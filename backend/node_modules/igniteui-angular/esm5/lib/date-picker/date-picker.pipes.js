import { __decorate, __param } from "tslib";
import { Pipe, Inject } from '@angular/core';
import { IGX_DATE_PICKER_COMPONENT } from './date-picker.common';
import { DatePickerUtil } from './date-picker.utils';
/**
 * @hidden
 */
var DatePickerDisplayValuePipe = /** @class */ (function () {
    function DatePickerDisplayValuePipe(_datePicker) {
        this._datePicker = _datePicker;
    }
    DatePickerDisplayValuePipe.prototype.transform = function (value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimEmptyPlaceholders(value);
        }
        return '';
    };
    DatePickerDisplayValuePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
    ]; };
    DatePickerDisplayValuePipe = __decorate([
        Pipe({
            name: 'displayValue'
        }),
        __param(0, Inject(IGX_DATE_PICKER_COMPONENT))
    ], DatePickerDisplayValuePipe);
    return DatePickerDisplayValuePipe;
}());
export { DatePickerDisplayValuePipe };
/**
 * @hidden
 */
var DatePickerInputValuePipe = /** @class */ (function () {
    function DatePickerInputValuePipe(_datePicker) {
        this._datePicker = _datePicker;
    }
    DatePickerInputValuePipe.prototype.transform = function (value, args) {
        /**
         * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
         * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
         */
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return this._datePicker._getEditorDate(this._datePicker.value);
                // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    };
    DatePickerInputValuePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
    ]; };
    DatePickerInputValuePipe = __decorate([
        Pipe({
            name: 'inputValue'
        }),
        __param(0, Inject(IGX_DATE_PICKER_COMPONENT))
    ], DatePickerInputValuePipe);
    return DatePickerInputValuePipe;
}());
export { DatePickerInputValuePipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIucGlwZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnBpcGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQWlCLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUQsT0FBTyxFQUFFLHlCQUF5QixFQUFlLE1BQU0sc0JBQXNCLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXJEOztHQUVHO0FBSUg7SUFDSSxvQ0FBdUQsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFBSSxDQUFDO0lBQ3BGLDhDQUFTLEdBQVQsVUFBVSxLQUFVLEVBQUUsSUFBVTtRQUM1QixJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7WUFDZCxJQUFJLEtBQUssS0FBSyxjQUFjLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDeEUsT0FBTyxFQUFFLENBQUM7YUFDYjtZQUNELElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztZQUN2QyxPQUFPLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0RDtRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQzs7Z0RBVlksTUFBTSxTQUFDLHlCQUF5Qjs7SUFEcEMsMEJBQTBCO1FBSHRDLElBQUksQ0FBQztZQUNGLElBQUksRUFBRSxjQUFjO1NBQ3ZCLENBQUM7UUFFZSxXQUFBLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFBO09BRHJDLDBCQUEwQixDQVl0QztJQUFELGlDQUFDO0NBQUEsQUFaRCxJQVlDO1NBWlksMEJBQTBCO0FBY3ZDOztHQUVHO0FBSUg7SUFDSSxrQ0FBdUQsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFBSSxDQUFDO0lBQ3BGLDRDQUFTLEdBQVQsVUFBVSxLQUFVLEVBQUUsSUFBVTtRQUM1Qjs7O1dBR0c7UUFDSCxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxLQUFLLEVBQUUsRUFBRTtZQUNyQyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDO1NBQ3ZDO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7Z0JBQ3pFLE9BQU8sY0FBYyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDdkU7aUJBQU07Z0JBQ0gsT0FBUSxJQUFJLENBQUMsV0FBbUIsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDeEUsaUhBQWlIO2FBQ3BIO1NBQ0o7SUFDTCxDQUFDOztnREFoQlksTUFBTSxTQUFDLHlCQUF5Qjs7SUFEcEMsd0JBQXdCO1FBSHBDLElBQUksQ0FBQztZQUNGLElBQUksRUFBRSxZQUFZO1NBQ3JCLENBQUM7UUFFZSxXQUFBLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFBO09BRHJDLHdCQUF3QixDQWtCcEM7SUFBRCwrQkFBQztDQUFBLEFBbEJELElBa0JDO1NBbEJZLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGVUcmFuc2Zvcm0sIFBpcGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSUdYX0RBVEVfUElDS0VSX0NPTVBPTkVOVCwgSURhdGVQaWNrZXIgfSBmcm9tICcuL2RhdGUtcGlja2VyLmNvbW1vbic7XG5pbXBvcnQgeyBEYXRlUGlja2VyVXRpbCB9IGZyb20gJy4vZGF0ZS1waWNrZXIudXRpbHMnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdkaXNwbGF5VmFsdWUnXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJEaXNwbGF5VmFsdWVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfREFURV9QSUNLRVJfQ09NUE9ORU5UKSBwcml2YXRlIF9kYXRlUGlja2VyOiBJRGF0ZVBpY2tlcikgeyB9XG4gICAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGFyZ3M/OiBhbnkpOiBhbnkge1xuICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IERhdGVQaWNrZXJVdGlsLm1hc2tUb1Byb21wdENoYXJzKHRoaXMuX2RhdGVQaWNrZXIuaW5wdXRNYXNrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGVQaWNrZXIucmF3RGF0ZVN0cmluZyA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnaW5wdXRWYWx1ZSdcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVBpY2tlcklucHV0VmFsdWVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoQEluamVjdChJR1hfREFURV9QSUNLRVJfQ09NUE9ORU5UKSBwcml2YXRlIF9kYXRlUGlja2VyOiBJRGF0ZVBpY2tlcikgeyB9XG4gICAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGFyZ3M/OiBhbnkpOiBhbnkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETyhELlAuKTogVGhpcyBwbHVncyBpbnRvIHRoZSBtYXNrLCBidXQgY29uc3RhbnRseSByZWNlaXZlZCBkaXNwbGF5IHN0cmluZ3MgaXQgY2FuJ3QgaGFuZGxlIGF0IGFsbFxuICAgICAgICAgKiBUaG9zZSBhcmUgYWxtb3N0IGltbWVkaWF0ZWx5IG92ZXJyaWRkZW4gYnkgdGhlIHBpY2tlcnMgb25Gb2N1cyBoYW5kbGluZyBhbnl3YXk7IFJlZmFjdG9yIEFTQVBcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl9kYXRlUGlja2VyLmludmFsaWREYXRlICE9PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVQaWNrZXIuaW52YWxpZERhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGF0ZVBpY2tlci52YWx1ZSA9PT0gbnVsbCB8fCB0aGlzLl9kYXRlUGlja2VyLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwubWFza1RvUHJvbXB0Q2hhcnModGhpcy5fZGF0ZVBpY2tlci5pbnB1dE1hc2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2RhdGVQaWNrZXIgYXMgYW55KS5fZ2V0RWRpdG9yRGF0ZSh0aGlzLl9kYXRlUGlja2VyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gRGF0ZVBpY2tlclV0aWwuYWRkUHJvbXB0Q2hhcnNFZGl0TW9kZSh0aGlzLl9kYXRlUGlja2VyLmRhdGVGb3JtYXRQYXJ0cywgdGhpcy5fZGF0ZVBpY2tlci52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19