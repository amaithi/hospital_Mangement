import { __decorate, __param } from "tslib";
import { InjectionToken, Input, Output, EventEmitter, Directive, NgModule, Optional, Inject } from '@angular/core';
/**
 * Defines the posible values of the components' display density.
 */
export var DisplayDensity;
(function (DisplayDensity) {
    DisplayDensity["comfortable"] = "comfortable";
    DisplayDensity["cosy"] = "cosy";
    DisplayDensity["compact"] = "compact";
})(DisplayDensity || (DisplayDensity = {}));
/**
 * Defines the DisplayDensity DI token.
 */
export const DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
let DisplayDensityBase = 
// tslint:disable-next-line: directive-class-suffix
class DisplayDensityBase {
    constructor(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     */
    get displayDensity() {
        return this._displayDensity ||
            ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     */
    set displayDensity(val) {
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = val;
        if (currentDisplayDensity !== this._displayDensity) {
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.initialDensity = this._displayDensity;
    }
    ngDoCheck() {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
};
DisplayDensityBase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    Input()
], DisplayDensityBase.prototype, "displayDensity", null);
__decorate([
    Output()
], DisplayDensityBase.prototype, "onDensityChanged", void 0);
DisplayDensityBase = __decorate([
    Directive({
        selector: '[igxDisplayDensityBase]'
    })
    // tslint:disable-next-line: directive-class-suffix
    ,
    __param(0, Optional()), __param(0, Inject(DisplayDensityToken))
], DisplayDensityBase);
export { DisplayDensityBase };
let IgxDisplayDensityModule = class IgxDisplayDensityModule {
};
IgxDisplayDensityModule = __decorate([
    NgModule({
        declarations: [
            DisplayDensityBase
        ],
        exports: [
            DisplayDensityBase
        ]
    })
], IgxDisplayDensityModule);
export { IgxDisplayDensityModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlzcGxheURlbnNpdHkuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvZGlzcGxheURlbnNpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQW1CLFNBQVMsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUlwSTs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLGNBSVg7QUFKRCxXQUFZLGNBQWM7SUFDdEIsNkNBQTJCLENBQUE7SUFDM0IsK0JBQWEsQ0FBQTtJQUNiLHFDQUFtQixDQUFBO0FBQ3ZCLENBQUMsRUFKVyxjQUFjLEtBQWQsY0FBYyxRQUl6QjtBQWNEOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxjQUFjLENBQXlCLGdCQUFnQixDQUFDLENBQUM7QUFFaEc7O0dBRUc7QUFLSCxJQUFhLGtCQUFrQjtBQUQvQixtREFBbUQ7QUFDbkQsTUFBYSxrQkFBa0I7SUE2QzNCLFlBQStELHFCQUE2QztRQUE3QywwQkFBcUIsR0FBckIscUJBQXFCLENBQXdCO1FBTHJHLHFCQUFnQixHQUFHLElBQUksWUFBWSxFQUE0QixDQUFDO1FBRTdELDZCQUF3QixHQUEyQixFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsV0FBVyxFQUFFLENBQUM7UUFJeEcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsd0JBQXdCLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUN4RSxDQUFDO0lBdkNEOzs7Ozs7O09BT0c7SUFFSCxJQUFXLGNBQWM7UUFDckIsT0FBTyxJQUFJLENBQUMsZUFBZTtZQUN2QixDQUFDLENBQUMsSUFBSSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjLENBQUMsSUFBSSxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDbEgsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxjQUFjLENBQUMsR0FBNEI7UUFDbEQsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQ25ELElBQUksQ0FBQyxlQUFlLEdBQUcsR0FBcUIsQ0FBQztRQUU3QyxJQUFJLHFCQUFxQixLQUFLLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDaEQsTUFBTSxrQkFBa0IsR0FBNkI7Z0JBQ2pELFVBQVUsRUFBRSxxQkFBcUI7Z0JBQ2pDLFVBQVUsRUFBRSxJQUFJLENBQUMsZUFBZTthQUNuQyxDQUFDO1lBRUYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ2xEO0lBQ0wsQ0FBQztJQVlEOztPQUVHO0lBQ0ksUUFBUTtRQUNYLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUMvQyxDQUFDO0lBRU0sU0FBUztRQUNaLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBQyxxQkFBcUI7WUFDL0MsSUFBSSxDQUFDLHdCQUF3QixDQUFDLGNBQWMsS0FBSyxJQUFJLENBQUMscUJBQXFCLENBQUMsY0FBYyxFQUFFO1lBQ2hHLE1BQU0sa0JBQWtCLEdBQTZCO2dCQUNqRCxVQUFVLEVBQUUsSUFBSSxDQUFDLHdCQUF3QixDQUFDLGNBQWM7Z0JBQ3hELFVBQVUsRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsY0FBYzthQUN4RCxDQUFDO1lBRUYsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQy9DLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUM1RztJQUNMLENBQUM7SUFFRDs7O09BR0c7SUFDTyx3QkFBd0IsQ0FBQyxjQUFzQjtRQUNyRCxRQUFRLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDekIsS0FBSyxjQUFjLENBQUMsSUFBSTtnQkFDcEIsT0FBTyxHQUFHLGNBQWMsS0FBSyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDdkQsS0FBSyxjQUFjLENBQUMsT0FBTztnQkFDdkIsT0FBTyxHQUFHLGNBQWMsS0FBSyxjQUFjLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDMUQ7Z0JBQ0ksT0FBTyxjQUFjLENBQUM7U0FDN0I7SUFDTCxDQUFDO0NBQ0osQ0FBQTs7NENBdENnQixRQUFRLFlBQUksTUFBTSxTQUFDLG1CQUFtQjs7QUE1Qm5EO0lBREMsS0FBSyxFQUFFO3dEQUlQO0FBb0JEO0lBREMsTUFBTSxFQUFFOzREQUM4RDtBQXhDOUQsa0JBQWtCO0lBSjlCLFNBQVMsQ0FBQztRQUNQLFFBQVEsRUFBRSx5QkFBeUI7S0FDdEMsQ0FBQztJQUNGLG1EQUFtRDs7SUE4Q2xDLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBO0dBN0MzQyxrQkFBa0IsQ0FtRjlCO1NBbkZZLGtCQUFrQjtBQTZGL0IsSUFBYSx1QkFBdUIsR0FBcEMsTUFBYSx1QkFBdUI7Q0FBRyxDQUFBO0FBQTFCLHVCQUF1QjtJQVJuQyxRQUFRLENBQUM7UUFDTixZQUFZLEVBQUU7WUFDVixrQkFBa0I7U0FDckI7UUFDRCxPQUFPLEVBQUU7WUFDTCxrQkFBa0I7U0FDckI7S0FDSixDQUFDO0dBQ1csdUJBQXVCLENBQUc7U0FBMUIsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgRG9DaGVjaywgT25Jbml0LCBEaXJlY3RpdmUsIE5nTW9kdWxlLCBPcHRpb25hbCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4vdXRpbHMnO1xuXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgcG9zaWJsZSB2YWx1ZXMgb2YgdGhlIGNvbXBvbmVudHMnIGRpc3BsYXkgZGVuc2l0eS5cbiAqL1xuZXhwb3J0IGVudW0gRGlzcGxheURlbnNpdHkge1xuICAgIGNvbWZvcnRhYmxlID0gJ2NvbWZvcnRhYmxlJyxcbiAgICBjb3N5ID0gJ2Nvc3knLFxuICAgIGNvbXBhY3QgPSAnY29tcGFjdCdcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIG9iamVjdCB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgRGlzcGxheURlbnNpdHkgaW4gQW5ndWxhciBESS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRGlzcGxheURlbnNpdHlPcHRpb25zIHtcbiAgICBkaXNwbGF5RGVuc2l0eTogRGlzcGxheURlbnNpdHk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURlbnNpdHlDaGFuZ2VkRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIG9sZERlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xuICAgIG5ld0RlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xufVxuXG4vKipcbiAqIERlZmluZXMgdGhlIERpc3BsYXlEZW5zaXR5IERJIHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgRGlzcGxheURlbnNpdHlUb2tlbiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxJRGlzcGxheURlbnNpdHlPcHRpb25zPignRGlzcGxheURlbnNpdHknKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGNvbnRhaW5pbmcgYWxsIGxvZ2ljIHJlcXVpcmVkIGZvciBpbXBsZW1lbnRpbmcgRGlzcGxheURlbnNpdHkuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneERpc3BsYXlEZW5zaXR5QmFzZV0nXG59KVxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBkaXJlY3RpdmUtY2xhc3Mtc3VmZml4XG5leHBvcnQgY2xhc3MgRGlzcGxheURlbnNpdHlCYXNlIGltcGxlbWVudHMgRG9DaGVjaywgT25Jbml0IHtcbiAgICBwcm90ZWN0ZWQgX2Rpc3BsYXlEZW5zaXR5OiBEaXNwbGF5RGVuc2l0eTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaW5pdGlhbERlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGhlbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgZGVmYXVsdCB0aGVtZSBpcyBgY29tZm9ydGFibGVgLlxuICAgICAqIEF2YWlsYWJsZSBvcHRpb25zIGFyZSBgY29tZm9ydGFibGVgLCBgY29zeWAsIGBjb21wYWN0YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGNvbXBvbmVudFRoZW1lID0gdGhpcy5jb21wb25lbnQuZGlzcGxheURlbnNpdHk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGRpc3BsYXlEZW5zaXR5KCk6IERpc3BsYXlEZW5zaXR5IHwgc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlEZW5zaXR5IHx8XG4gICAgICAgICAgICAoKHRoaXMuZGlzcGxheURlbnNpdHlPcHRpb25zICYmIHRoaXMuZGlzcGxheURlbnNpdHlPcHRpb25zLmRpc3BsYXlEZW5zaXR5KSB8fCBEaXNwbGF5RGVuc2l0eS5jb21mb3J0YWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGhlbWUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGRpc3BsYXlEZW5zaXR5KHZhbDogRGlzcGxheURlbnNpdHkgfCBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY3VycmVudERpc3BsYXlEZW5zaXR5ID0gdGhpcy5fZGlzcGxheURlbnNpdHk7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlEZW5zaXR5ID0gdmFsIGFzIERpc3BsYXlEZW5zaXR5O1xuXG4gICAgICAgIGlmIChjdXJyZW50RGlzcGxheURlbnNpdHkgIT09IHRoaXMuX2Rpc3BsYXlEZW5zaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBkZW5zaXR5Q2hhbmdlZEFyZ3M6IElEZW5zaXR5Q2hhbmdlZEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvbGREZW5zaXR5OiBjdXJyZW50RGlzcGxheURlbnNpdHksXG4gICAgICAgICAgICAgICAgbmV3RGVuc2l0eTogdGhpcy5fZGlzcGxheURlbnNpdHlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMub25EZW5zaXR5Q2hhbmdlZC5lbWl0KGRlbnNpdHlDaGFuZ2VkQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25EZW5zaXR5Q2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURlbnNpdHlDaGFuZ2VkRXZlbnRBcmdzPigpO1xuXG4gICAgcHJvdGVjdGVkIG9sZERpc3BsYXlEZW5zaXR5T3B0aW9uczogSURpc3BsYXlEZW5zaXR5T3B0aW9ucyA9IHsgZGlzcGxheURlbnNpdHk6IERpc3BsYXlEZW5zaXR5LmNvbWZvcnRhYmxlIH07XG5cblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoRGlzcGxheURlbnNpdHlUb2tlbikgcHJvdGVjdGVkIGRpc3BsYXlEZW5zaXR5T3B0aW9uczogSURpc3BsYXlEZW5zaXR5T3B0aW9ucykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub2xkRGlzcGxheURlbnNpdHlPcHRpb25zLCBkaXNwbGF5RGVuc2l0eU9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdGlhbERlbnNpdHkgPSB0aGlzLl9kaXNwbGF5RGVuc2l0eTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2Rpc3BsYXlEZW5zaXR5ICYmIHRoaXMuZGlzcGxheURlbnNpdHlPcHRpb25zICYmXG4gICAgICAgICAgICAgICAgdGhpcy5vbGREaXNwbGF5RGVuc2l0eU9wdGlvbnMuZGlzcGxheURlbnNpdHkgIT09IHRoaXMuZGlzcGxheURlbnNpdHlPcHRpb25zLmRpc3BsYXlEZW5zaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBkZW5zaXR5Q2hhbmdlZEFyZ3M6IElEZW5zaXR5Q2hhbmdlZEV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBvbGREZW5zaXR5OiB0aGlzLm9sZERpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eSxcbiAgICAgICAgICAgICAgICBuZXdEZW5zaXR5OiB0aGlzLmRpc3BsYXlEZW5zaXR5T3B0aW9ucy5kaXNwbGF5RGVuc2l0eVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5vbkRlbnNpdHlDaGFuZ2VkLmVtaXQoZGVuc2l0eUNoYW5nZWRBcmdzKTtcbiAgICAgICAgICAgIHRoaXMub2xkRGlzcGxheURlbnNpdHlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLm9sZERpc3BsYXlEZW5zaXR5T3B0aW9ucywgdGhpcy5kaXNwbGF5RGVuc2l0eU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzdHlsZSBjbGFzcyBvZiBhIGNvbXBvbmVudC9lbGVtZW50IHJldHVybnMgdGhlIG1vZGlmaWVkIHZlcnNpb24gb2YgaXQgYmFzZWRcbiAgICAgKiBvbiB0aGUgY3VycmVudCBkaXNwbGF5IGRlbnNpdHkuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldENvbXBvbmVudERlbnNpdHlDbGFzcyhiYXNlU3R5bGVDbGFzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmRpc3BsYXlEZW5zaXR5KSB7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvc3k6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VTdHlsZUNsYXNzfS0tJHtEaXNwbGF5RGVuc2l0eS5jb3N5fWA7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvbXBhY3Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VTdHlsZUNsYXNzfS0tJHtEaXNwbGF5RGVuc2l0eS5jb21wYWN0fWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlU3R5bGVDbGFzcztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRGlzcGxheURlbnNpdHlCYXNlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERpc3BsYXlEZW5zaXR5QmFzZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RGlzcGxheURlbnNpdHlNb2R1bGUge31cbiJdfQ==