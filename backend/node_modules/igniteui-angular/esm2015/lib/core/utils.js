import { __decorate, __param } from "tslib";
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Observable } from 'rxjs';
import ResizeObserver from 'resize-observer-polyfill';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export function cloneArray(array, deep) {
    const arr = [];
    if (!array) {
        return arr;
    }
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 */
export function cloneHierarchicalArray(array, childDataKey) {
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
export function mergeObjects(obj1, obj2) {
    if (!isObject(obj1)) {
        throw new Error(`Cannot merge into ${obj1}. First param must be an object.`);
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    for (const key of Object.keys(obj2)) {
        obj1[key] = cloneValue(obj2[key]);
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
export function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
export function getNodeSizeViaRange(range, node) {
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    const s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 */
export function isEdge() {
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 */
export function isFirefox() {
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
let PlatformUtil = class PlatformUtil {
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
};
PlatformUtil.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
PlatformUtil.ɵprov = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
PlatformUtil = __decorate([
    Injectable({ providedIn: 'root' }),
    __param(0, Inject(PLATFORM_ID))
], PlatformUtil);
export { PlatformUtil };
/**
 * @hidden
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/** @hidden */
export function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 */
export function flatten(arr) {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
export const HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
export const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
export const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
export const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
export const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);
export const HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l']);
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
export function resizeObservable(target) {
    return new Observable((observer) => {
        const instance = new ResizeObserver((entries) => {
            observer.next(entries);
        });
        instance.observe(target);
        const unsubscribe = () => instance.disconnect();
        return unsubscribe;
    });
}
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
export function compareMaps(map1, map2) {
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    let match = true;
    const keys = Array.from(map2.keys());
    for (const key of keys) {
        if (map1.has(key)) {
            match = map1.get(key) === map2.get(key);
        }
        else {
            match = false;
        }
        if (!match) {
            break;
        }
    }
    return match;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xDLE9BQU8sY0FBYyxNQUFNLDBCQUEwQixDQUFDOztBQUV0RDs7R0FFRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQUMsS0FBWSxFQUFFLElBQWM7SUFDbkQsTUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2YsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3JCLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDUixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuRDtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxLQUFZLEVBQUUsWUFBaUI7SUFDbEUsTUFBTSxNQUFNLEdBQVUsRUFBRSxDQUFDO0lBQ3pCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDUixPQUFPLE1BQU0sQ0FBQztLQUNqQjtJQUVELEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO1FBQ3RCLE1BQU0sVUFBVSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQyxJQUFJLEtBQUss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QUcsSUFBSSxDQUFDO0lBQ2pCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDckMsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDcEIsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2YsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMzQzthQUFNO1lBQ0gsS0FBSyxHQUFHLEtBQUssQ0FBQztTQUNqQjtRQUNELElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDUixNQUFNO1NBQ1Q7S0FDSjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBQTEFURk9STV9JRCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5OiBhbnlbXSwgZGVlcD86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGxldCBpID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gZGVlcCA/IGNsb25lVmFsdWUoYXJyYXlbaV0pIDogYXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogRG9lc24ndCBjbG9uZSBsZWFmIGl0ZW1zXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUhpZXJhcmNoaWNhbEFycmF5KGFycmF5OiBhbnlbXSwgY2hpbGREYXRhS2V5OiBhbnkpOiBhbnlbXSB7XG4gICAgY29uc3QgcmVzdWx0OiBhbnlbXSA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkSXRlbSA9IGNsb25lVmFsdWUoaXRlbSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1bY2hpbGREYXRhS2V5XSkpIHtcbiAgICAgICAgICAgIGNsb25lZEl0ZW1bY2hpbGREYXRhS2V5XSA9IGNsb25lSGllcmFyY2hpY2FsQXJyYXkoY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldLCBjaGlsZERhdGFLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGNsb25lZEl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERlZXAgY2xvbmVzIGFsbCBmaXJzdCBsZXZlbCBrZXlzIG9mIE9iajIgYW5kIG1lcmdlcyB0aGVtIHRvIE9iajFcbiAqIEBwYXJhbSBvYmoxIE9iamVjdCB0byBtZXJnZSBpbnRvXG4gKiBAcGFyYW0gb2JqMiBPYmplY3QgdG8gbWVyZ2UgZnJvbVxuICogQHJldHVybnMgT2JqMSB3aXRoIG1lcmdlZCBjbG9uZWQga2V5cyBmcm9tIE9iajJcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvYmoxOiB7fSwgb2JqMjoge30pOiBhbnkge1xuICAgIGlmICghaXNPYmplY3Qob2JqMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgbWVyZ2UgaW50byAke29iajF9LiBGaXJzdCBwYXJhbSBtdXN0IGJlIGFuIG9iamVjdC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzT2JqZWN0KG9iajIpKSB7XG4gICAgICAgIHJldHVybiBvYmoxO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iajIpKSB7XG4gICAgICAgIG9iajFba2V5XSA9IGNsb25lVmFsdWUob2JqMltrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqMTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGRlZXAgY2xvbmUgb2YgcHJvdmlkZWQgdmFsdWUuXG4gKiBTdXBwb3J0cyBwcmltaXRpdmUgdmFsdWVzLCBkYXRlcyBhbmQgb2JqZWN0cy5cbiAqIElmIHBhc3NlZCB2YWx1ZSBpcyBhcnJheSByZXR1cm5zIHNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY2xvbmVcbiAqIEByZXR1cm5zIERlZXAgY29weSBvZiBwcm92aWRlZCB2YWx1ZVxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZTogYW55KTogYW55IHtcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbLi4udmFsdWVdO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmVWYWx1ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIERhdGVcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZTogYW55KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHR3byBwYXNzZWQgYXJndW1lbnRzIGFyZSBlcXVhbFxuICogQ3VycmVudGx5IHN1cHBvcnRzIGRhdGUgb2JqZWN0c1xuICogQHBhcmFtIG9iajFcbiAqIEBwYXJhbSBvYmoyXG4gKiBAcmV0dXJuczogYGJvb2xlYW5gXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpOiBib29sZWFuIHtcbiAgICBpZiAoaXNEYXRlKG9iajEpICYmIGlzRGF0ZShvYmoyKSkge1xuICAgICAgICByZXR1cm4gb2JqMS5nZXRUaW1lKCkgPT09IG9iajIuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqMSA9PT0gb2JqMjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEtFWUNPREVTIHtcbiAgICBFTlRFUiA9IDEzLFxuICAgIFNQQUNFID0gMzIsXG4gICAgRVNDQVBFID0gMjcsXG4gICAgTEVGVF9BUlJPVyA9IDM3LFxuICAgIFVQX0FSUk9XID0gMzgsXG4gICAgUklHSFRfQVJST1cgPSAzOSxcbiAgICBET1dOX0FSUk9XID0gNDAsXG4gICAgRjIgPSAxMTMsXG4gICAgVEFCID0gOSxcbiAgICBDVFJMID0gMTcsXG4gICAgWiA9IDkwLFxuICAgIFkgPSA4OSxcbiAgICBYID0gODgsXG4gICAgQkFDS1NQQUNFID0gOCxcbiAgICBERUxFVEUgPSA0NixcbiAgICBJTlBVVF9NRVRIT0QgPSAyMjlcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEtFWVMge1xuICAgIEVOVEVSID0gJ0VudGVyJyxcbiAgICBTUEFDRSA9ICcgJyxcbiAgICBTUEFDRV9JRSA9ICdTcGFjZWJhcicsXG4gICAgRVNDQVBFID0gJ0VzY2FwZScsXG4gICAgRVNDQVBFX0lFID0gJ0VzYycsXG4gICAgTEVGVF9BUlJPVyA9ICdBcnJvd0xlZnQnLFxuICAgIExFRlRfQVJST1dfSUUgPSAnTGVmdCcsXG4gICAgVVBfQVJST1cgPSAnQXJyb3dVcCcsXG4gICAgVVBfQVJST1dfSUUgPSAnVXAnLFxuICAgIFJJR0hUX0FSUk9XID0gJ0Fycm93UmlnaHQnLFxuICAgIFJJR0hUX0FSUk9XX0lFID0gJ1JpZ2h0JyxcbiAgICBET1dOX0FSUk9XID0gJ0Fycm93RG93bicsXG4gICAgRE9XTl9BUlJPV19JRSA9ICdEb3duJyxcbiAgICBGMiA9ICdGMicsXG4gICAgVEFCID0gJ1RhYicsXG4gICAgU0VNSUNPTE9OID0gJzsnLFxuICAgIEhPTUUgPSAnSG9tZScsXG4gICAgRU5EID0gJ0VuZCdcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBSZXR1cm5zIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbm9kZSBjb250ZW50LCB1c2luZyBSYW5nZVxuICogYGBgdHlwZXNjcmlwdFxuICogbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAqXG4gKiBsZXQgc2l6ZSA9IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNvbHVtbi5jZWxsc1swXS5uYXRpdmVFbGVtZW50KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZTogUmFuZ2UsIG5vZGU6IGFueSk6IG51bWJlciB7XG4gICAgbGV0IG92ZXJmbG93ID0gbnVsbDtcbiAgICBpZiAoIWlzRmlyZWZveCgpKSB7XG4gICAgICAgIG92ZXJmbG93ID0gbm9kZS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGhhY2sgLSBvdGhlcndpc2UgY29udGVudCB3b24ndCBiZSBtZWFzdXJlZCBjb3JyZWN0bHkgaW4gSUUvRWRnZVxuICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICBjb25zdCB3aWR0aCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgaWYgKCFpc0ZpcmVmb3goKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRoYXQgaGFjayAtIG90aGVyd2lzZSBjb250ZW50IHdvbid0IGJlIG1lYXN1cmVkIGNvcnJlY3RseSBpbiBJRS9FZGdlXG4gICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqIFJldHVybnMgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBub2RlIGNvbnRlbnQsIHVzaW5nIENhbnZhc1xuICogYGBgdHlwZXNjcmlwdFxuICogbGV0IGN0eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gKlxuICogbGV0IHNpemUgPSB2YWxUb1B4bHNVc2luZ0NhbnZhcyhjdHgsIGNvbHVtbi5jZWxsc1swXS5uYXRpdmVFbGVtZW50KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFDYW52YXMoY2FudmFzMmRDdHg6IGFueSwgbm9kZTogYW55KTogbnVtYmVyIHtcbiAgICBjb25zdCBzID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAvLyBuZWVkIHRvIHNldCB0aGUgZm9udCB0byBnZXQgY29ycmVjdCB3aWR0aFxuICAgIGNhbnZhczJkQ3R4LmZvbnQgPSBzLmZvbnRTaXplICsgJyAnICsgcy5mb250RmFtaWx5O1xuXG4gICAgcmV0dXJuIGNhbnZhczJkQ3R4Lm1lYXN1cmVUZXh0KG5vZGUudGV4dENvbnRlbnQpLndpZHRoO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lFKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdUcmlkZW50LycpID4gMDtcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFZGdlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGVkZ2VCcm93c2VyID0gL0VkZ2VbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGVkZ2VCcm93c2VyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmlyZWZveCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBmaXJlZm94QnJvd3NlciA9IC9GaXJlZm94W1xcL1xcc10oXFxkK1xcLlxcZCspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHJldHVybiBmaXJlZm94QnJvd3Nlcjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgUGxhdGZvcm1VdGlsIHtcbiAgICBwdWJsaWMgaXNCcm93c2VyOiBib29sZWFuID0gaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKTtcblxuICAgIHB1YmxpYyBpc0lPUyA9IHRoaXMuaXNCcm93c2VyICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEoJ01TU3RyZWFtJyBpbiB3aW5kb3cpO1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMZWZ0Q2xpY2soZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYXZpZ2F0aW9uS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2Rvd24nLFxuICAgICAgICAndXAnLFxuICAgICAgICAnbGVmdCcsXG4gICAgICAgICdyaWdodCcsXG4gICAgICAgICdhcnJvd2Rvd24nLFxuICAgICAgICAnYXJyb3d1cCcsXG4gICAgICAgICdhcnJvd2xlZnQnLFxuICAgICAgICAnYXJyb3dyaWdodCcsXG4gICAgICAgICdob21lJyxcbiAgICAgICAgJ2VuZCcsXG4gICAgICAgICdzcGFjZScsXG4gICAgICAgICdzcGFjZWJhcicsXG4gICAgICAgICcgJ1xuICAgIF0uaW5kZXhPZihrZXkpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycjogYW55W10pIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICBhcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkoZWwuY2hpbGRyZW4pID8gZWwuY2hpbGRyZW4gOiBlbC5jaGlsZHJlbi50b0FycmF5KCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGZsYXR0ZW4oY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHJlZmVyZW5jZSB0byB0aGUgb3duZXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIG93bmVyPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzIGV4dGVuZHMgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqIEJyb3dzZXIgZXZlbnQgKi9cbiAgICBldmVudD86IEV2ZW50O1xufVxuXG5leHBvcnQgY29uc3QgSE9SSVpPTlRBTF9OQVZfS0VZUyA9IG5ldyBTZXQoWydhcnJvd2xlZnQnLCAnbGVmdCcsICdhcnJvd3JpZ2h0JywgJ3JpZ2h0JywgJ2hvbWUnLCAnZW5kJ10pO1xuXG5leHBvcnQgY29uc3QgTkFWSUdBVElPTl9LRVlTID0gbmV3IFNldChbXG4gICAgJ2Rvd24nLFxuICAgICd1cCcsXG4gICAgJ2xlZnQnLFxuICAgICdyaWdodCcsXG4gICAgJ2Fycm93ZG93bicsXG4gICAgJ2Fycm93dXAnLFxuICAgICdhcnJvd2xlZnQnLFxuICAgICdhcnJvd3JpZ2h0JyxcbiAgICAnaG9tZScsXG4gICAgJ2VuZCcsXG4gICAgJ3NwYWNlJyxcbiAgICAnc3BhY2ViYXInLFxuICAgICcgJ1xuXSk7XG5leHBvcnQgY29uc3QgUk9XX0VYUEFORF9LRVlTID0gbmV3IFNldCgncmlnaHQgZG93biBhcnJvd3JpZ2h0IGFycm93ZG93bicuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgUk9XX0NPTExBUFNFX0tFWVMgPSBuZXcgU2V0KCdsZWZ0IHVwIGFycm93bGVmdCBhcnJvd3VwJy5zcGxpdCgnICcpKTtcbmV4cG9ydCBjb25zdCBTVVBQT1JURURfS0VZUyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20oTkFWSUdBVElPTl9LRVlTKSwgJ2VudGVyJywgJ2YyJywgJ2VzY2FwZScsICdlc2MnLCAncGFnZWRvd24nLCAncGFnZXVwJ10pO1xuZXhwb3J0IGNvbnN0IEhFQURFUl9LRVlTID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShOQVZJR0FUSU9OX0tFWVMpLCAnZXNjYXBlJywgJ2VzYycgLCAnbCddKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBDcmVhdGVzIGEgbmV3IFJlc2l6ZU9ic2VydmVyIG9uIGB0YXJnZXRgIGFuZCByZXR1cm5zIGl0IGFzIGFuIE9ic2VydmFibGUuXG4gKiBSdW4gdGhlIHJlc2l6ZU9ic2VydmFibGUgb3V0c2lkZSBhbmd1bGFyIHpvbmUsIGJlY2F1c2UgaXQgcGF0Y2hlcyB0aGUgTXV0YXRpb25PYnNlcnZlciB3aGljaCBjYXVzZXMgYW4gaW5maW5pdGUgbG9vcC5cbiAqIFJlbGF0ZWQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMxNzEyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNpemVPYnNlcnZhYmxlKHRhcmdldDogSFRNTEVsZW1lbnQpOiBPYnNlcnZhYmxlPFJlc2l6ZU9ic2VydmVyRW50cnlbXT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXM6IFJlc2l6ZU9ic2VydmVyRW50cnlbXSkgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChlbnRyaWVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGluc3RhbmNlLm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSAoKSA9PiBpbnN0YW5jZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBDb21wYXJlcyB0d28gbWFwcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVNYXBzKG1hcDE6IE1hcDxhbnksIGFueT4sIG1hcDI6IE1hcDxhbnksIGFueT4pOiBib29sZWFuIHtcbiAgICBpZiAoIW1hcDIpIHtcbiAgICAgICAgcmV0dXJuICFtYXAxID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobWFwMS5zaXplICE9PSBtYXAyLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSB0cnVlO1xuICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKG1hcDIua2V5cygpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmIChtYXAxLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1hcDEuZ2V0KGtleSkgPT09IG1hcDIuZ2V0KGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRjaDtcbn1cbiJdfQ==