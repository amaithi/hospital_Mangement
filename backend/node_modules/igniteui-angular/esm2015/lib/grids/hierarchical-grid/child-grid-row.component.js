import { __decorate } from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, HostBinding, Input, OnInit, ViewChild, AfterViewInit, SimpleChanges, ComponentFactoryResolver } from '@angular/core';
import { GridBaseAPIService } from '.././api.service';
import { IgxGridComponent } from '../grid/grid.component';
import { takeUntil } from 'rxjs/operators';
let IgxChildGridRowComponent = class IgxChildGridRowComponent {
    constructor(gridAPI, element, resolver, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * @hidden
         */
        this.role = 'row';
        this.resolver = resolver;
    }
    /**
     * @hidden
     */
    get parentHasScroll() {
        return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    // TODO: Refactor
    get parentGrid() {
        return this.gridAPI.grid;
    }
    get level() {
        return this.layout.level;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.layout.onLayoutChange.subscribe((ch) => {
            this._handleLayoutChanges(ch);
        });
        const changes = this.layout.initialChanges;
        changes.forEach(change => {
            this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        // handler logic that re-emits hgrid events on the row island
        this.setupEventEmitters();
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.hGrid.childLayoutList = this.layout.children;
        const layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach((l) => this.hGrid.hgridAPI.registerChildRowIsland(l));
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.layout.onGridInitialized.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
        this.hGrid.cdr.detectChanges();
    }
    setupEventEmitters() {
        const destructor = takeUntil(this.hGrid.destroy$);
        const factory = this.resolver.resolveComponentFactory(IgxGridComponent);
        // exclude outputs related to two-way binding functionality
        const inputNames = factory.inputs.map(input => input.propName);
        const outputs = factory.outputs.filter(o => {
            const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
        });
        outputs.forEach(output => {
            if (this.hGrid[output.propName]) {
                this.hGrid[output.propName].pipe(destructor).subscribe((args) => {
                    if (!args) {
                        args = {};
                    }
                    args.owner = this.hGrid;
                    this.layout[output.propName].emit(args);
                });
            }
        });
    }
    _handleLayoutChanges(changes) {
        for (const change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    }
};
IgxChildGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "layout", void 0);
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "parentGridID", void 0);
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "rowData", void 0);
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "index", void 0);
__decorate([
    ViewChild('hgrid', { static: true })
], IgxChildGridRowComponent.prototype, "hGrid", void 0);
__decorate([
    HostBinding('attr.role')
], IgxChildGridRowComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.data-level')
], IgxChildGridRowComponent.prototype, "level", null);
IgxChildGridRowComponent = __decorate([
    Component({
        changeDetection: ChangeDetectionStrategy.OnPush,
        preserveWhitespaces: false,
        selector: 'igx-child-grid-row',
        template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
    })
], IgxChildGridRowComponent);
export { IgxChildGridRowComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hpbGQtZ3JpZC1yb3cuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9ncmlkcy9oaWVyYXJjaGljYWwtZ3JpZC9jaGlsZC1ncmlkLXJvdy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFDTCxNQUFNLEVBQ04sU0FBUyxFQUNULGFBQWEsRUFDYixhQUFhLEVBQ2Isd0JBQXdCLEVBQzNCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRXRELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzFELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQVEzQyxJQUFhLHdCQUF3QixHQUFyQyxNQUFhLHdCQUF3QjtJQWtHakMsWUFBbUIsT0FBdUUsRUFDL0UsT0FBbUIsRUFDMUIsUUFBa0MsRUFDM0IsR0FBc0I7UUFIZCxZQUFPLEdBQVAsT0FBTyxDQUFnRTtRQUMvRSxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBRW5CLFFBQUcsR0FBSCxHQUFHLENBQW1CO1FBbEdqQzs7Ozs7V0FLRztRQUNJLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFtQnhCOzs7Ozs7O1dBT0c7UUFFSSxZQUFPLEdBQVEsRUFBRSxDQUFDO1FBZ0J6Qjs7V0FFRztRQUVJLFNBQUksR0FBRyxLQUFLLENBQUM7UUE2Q1osSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDakMsQ0FBQztJQXpGRDs7T0FFRztJQUNILElBQVcsZUFBZTtRQUN0QixPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFVB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LEVBQUU7WUFDMUIsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUM7YUFDckQ7U0FDSjtJQUNMLENBQUM7Q0FDSixDQUFBOztZQWhGK0Isa0JBQWtCO1lBQzFCLFVBQVU7WUFDaEIsd0JBQXdCO1lBQ3RCLGlCQUFpQjs7QUF6RmpDO0lBREMsS0FBSyxFQUFFO3dEQUNzQjtBQWM5QjtJQURDLEtBQUssRUFBRTs4REFDb0I7QUFXNUI7SUFEQyxLQUFLLEVBQUU7eURBQ2lCO0FBV3pCO0lBREMsS0FBSyxFQUFFO3VEQUNhO0FBR3JCO0lBREMsU0FBUyxDQUFDLE9BQU8sRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQzt1REFDb0I7QUFNekQ7SUFEQyxXQUFXLENBQUMsV0FBVyxDQUFDO3NEQUNMO0FBeUJwQjtJQURDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQztxREFHOUI7QUFwRlEsd0JBQXdCO0lBTnBDLFNBQVMsQ0FBQztRQUNQLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1FBQy9DLG1CQUFtQixFQUFFLEtBQUs7UUFDMUIsUUFBUSxFQUFFLG9CQUFvQjtRQUM5QixvUEFBOEM7S0FDakQsQ0FBQztHQUNXLHdCQUF3QixDQWtMcEM7U0FsTFksd0JBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgVmlld0NoaWxkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi8uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneFJvd0lzbGFuZENvbXBvbmVudCB9IGZyb20gJy4vcm93LWlzbGFuZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4R3JpZENvbXBvbmVudCB9IGZyb20gJy4uL2dyaWQvZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBzZWxlY3RvcjogJ2lneC1jaGlsZC1ncmlkLXJvdycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NoaWxkLWdyaWQtcm93LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDaGlsZEdyaWRSb3dDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkluaXQge1xucHJpdmF0ZSByZXNvbHZlcjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcm93IGlzIGV4cGFuZGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBSb3dFeHBhbmRlZCA9IHRoaXMuZ3JpZDEucm93TGlzdC5maXJzdC5leHBhbmRlZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZXhwYW5kZWQgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgbGF5b3V0OiBJZ3hSb3dJc2xhbmRDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYXJlbnRIYXNTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wYXJlbnRHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmRjLmluc3RhbmNlLm5vdFZpcnR1YWw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcGFyZW50R3JpZElEOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgcGFzc2VkIHRvIHRoZSByb3cgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldCB0aGUgcm93IGRhdGEgZm9yIHRoZSBmaXJzdCBzZWxlY3RlZCByb3dcbiAgICAgKiBsZXQgc2VsZWN0ZWRSb3dEYXRhID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1swXS5yb3dEYXRhO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvd0RhdGE6IGFueSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSByb3cuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIHNlbGVjdGVkIHJvd1xuICAgICAqIGxldCBzZWxlY3RlZFJvd0luZGV4ID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1sxXS5pbmRleDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRleDogbnVtYmVyO1xuXG4gICAgQFZpZXdDaGlsZCgnaGdyaWQnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBoR3JpZDogYW55LyogVE9ETzogSWd4SGllcmFyY2hpY2FsR3JpZENvbXBvbmVudCovO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICdyb3cnO1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBncmlkIHRoYXQgY29udGFpbnMgdGhlIHNlbGVjdGVkIHJvdy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBoYW5kbGVSb3dTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgKiAgLy8gdGhlIGdyaWQgb24gd2hpY2ggdGhlIG9uUm93U2VsZWN0aW9uQ2hhbmdlIGV2ZW50IHdhcyB0cmlnZ2VyZWRcbiAgICAgKiAgY29uc3QgZ3JpZCA9IGV2ZW50LnJvdy5ncmlkO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1ncmlkXG4gICAgICogICAgW2RhdGFdPVwiZGF0YVwiXG4gICAgICogICAgKG9uUm93U2VsZWN0aW9uQ2hhbmdlKT1cImhhbmRsZVJvd1NlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICogIDwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgLy8gVE9ETzogUmVmYWN0b3JcbiAgICBnZXQgcGFyZW50R3JpZCgpOiBhbnkvKiBUT0RPOiBJZ3hIaWVyYXJjaGljYWxHcmlkQ29tcG9uZW50Ki8ge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkQVBJLmdyaWQ7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmRhdGEtbGV2ZWwnKVxuICAgIGdldCBsZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmxldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBuYXRpdmUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSByb3cuIENvdWxkIGJlIG51bGwgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0IHRoZSBuYXRpdmVFbGVtZW50IG9mIHRoZSBzZWNvbmQgc2VsZWN0ZWQgcm93XG4gICAgICogbGV0IHNlbGVjdGVkUm93TmF0aXZlRWxlbWVudCA9IHRoaXMuZ3JpZC5zZWxlY3RlZFJvd3NbMV0ubmF0aXZlRWxlbWVudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8YW55LyogVE9ETzogSWd4SGllcmFyY2hpY2FsR3JpZENvbXBvbmVudCovPixcbiAgICAgICAgcHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmxheW91dC5vbkxheW91dENoYW5nZS5zdWJzY3JpYmUoKGNoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVMYXlvdXRDaGFuZ2VzKGNoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmxheW91dC5pbml0aWFsQ2hhbmdlcztcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVMYXlvdXRDaGFuZ2VzKGNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhHcmlkLnBhcmVudCA9IHRoaXMucGFyZW50R3JpZDtcbiAgICAgICAgdGhpcy5oR3JpZC5wYXJlbnRJc2xhbmQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgdGhpcy5oR3JpZC5jaGlsZFJvdyA9ICB0aGlzO1xuICAgICAgICAvLyBoYW5kbGVyIGxvZ2ljIHRoYXQgcmUtZW1pdHMgaGdyaWQgZXZlbnRzIG9uIHRoZSByb3cgaXNsYW5kXG4gICAgICAgIHRoaXMuc2V0dXBFdmVudEVtaXR0ZXJzKCk7XG4gICAgICAgIHRoaXMubGF5b3V0Lm9uR3JpZENyZWF0ZWQuZW1pdCh7XG4gICAgICAgICAgICBvd25lcjogdGhpcy5sYXlvdXQsXG4gICAgICAgICAgICBwYXJlbnRJRDogdGhpcy5yb3dEYXRhLnJvd0lELFxuICAgICAgICAgICAgZ3JpZDogdGhpcy5oR3JpZFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmhHcmlkLmNoaWxkTGF5b3V0TGlzdCA9IHRoaXMubGF5b3V0LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBsYXlvdXRzID0gdGhpcy5oR3JpZC5jaGlsZExheW91dExpc3QudG9BcnJheSgpO1xuICAgICAgICBsYXlvdXRzLmZvckVhY2goKGwpID0+IHRoaXMuaEdyaWQuaGdyaWRBUEkucmVnaXN0ZXJDaGlsZFJvd0lzbGFuZChsKSk7XG4gICAgICAgIHRoaXMucGFyZW50R3JpZC5oZ3JpZEFQSS5yZWdpc3RlckNoaWxkR3JpZCh0aGlzLnJvd0RhdGEucm93SUQsIHRoaXMubGF5b3V0LmtleSwgdGhpcy5oR3JpZCk7XG4gICAgICAgIHRoaXMubGF5b3V0LnJvd0lzbGFuZEFQSS5yZWdpc3RlckNoaWxkR3JpZCh0aGlzLnJvd0RhdGEucm93SUQsIHRoaXMuaEdyaWQpO1xuXG4gICAgICAgIHRoaXMubGF5b3V0Lm9uR3JpZEluaXRpYWxpemVkLmVtaXQoe1xuICAgICAgICAgICAgb3duZXI6IHRoaXMubGF5b3V0LFxuICAgICAgICAgICAgcGFyZW50SUQ6IHRoaXMucm93RGF0YS5yb3dJRCxcbiAgICAgICAgICAgIGdyaWQ6IHRoaXMuaEdyaWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5oR3JpZC5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0dXBFdmVudEVtaXR0ZXJzKCkge1xuICAgICAgICBjb25zdCBkZXN0cnVjdG9yID0gdGFrZVVudGlsKHRoaXMuaEdyaWQuZGVzdHJveSQpO1xuXG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KElneEdyaWRDb21wb25lbnQpO1xuICAgICAgICAvLyBleGNsdWRlIG91dHB1dHMgcmVsYXRlZCB0byB0d28td2F5IGJpbmRpbmcgZnVuY3Rpb25hbGl0eVxuICAgICAgICBjb25zdCBpbnB1dE5hbWVzID0gZmFjdG9yeS5pbnB1dHMubWFwKGlucHV0ID0+IGlucHV0LnByb3BOYW1lKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IGZhY3Rvcnkub3V0cHV0cy5maWx0ZXIobyA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ0lucHV0UHJvcE5hbWUgPSBvLnByb3BOYW1lLnNsaWNlKDAsIG8ucHJvcE5hbWUuaW5kZXhPZignQ2hhbmdlJykpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0TmFtZXMuaW5kZXhPZihtYXRjaGluZ0lucHV0UHJvcE5hbWUpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dHMuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaEdyaWRbb3V0cHV0LnByb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaEdyaWRbb3V0cHV0LnByb3BOYW1lXS5waXBlKGRlc3RydWN0b3IpLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLm93bmVyID0gdGhpcy5oR3JpZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRbb3V0cHV0LnByb3BOYW1lXS5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgX2hhbmRsZUxheW91dENoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5nZSBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oR3JpZFtjaGFuZ2VdID0gY2hhbmdlc1tjaGFuZ2VdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==