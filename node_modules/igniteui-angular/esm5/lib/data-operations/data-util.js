import { __read, __spread, __values } from "tslib";
import { IgxSorting, IgxDataRecordSorting } from './sorting-strategy';
import { IgxGrouping } from './grouping-strategy';
import { PagingError } from './paging-state.interface';
import { FilteringStrategy } from './filtering-strategy';
import { cloneValue, mergeObjects } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
import { getHierarchy, isHierarchyMatch } from './operations';
/**
 * @hidden
 */
export var DataType;
(function (DataType) {
    DataType["String"] = "string";
    DataType["Number"] = "number";
    DataType["Boolean"] = "boolean";
    DataType["Date"] = "date";
})(DataType || (DataType = {}));
/**
 * @hidden
 */
var DataUtil = /** @class */ (function () {
    function DataUtil() {
    }
    DataUtil.sort = function (data, expressions, sorting) {
        if (sorting === void 0) { sorting = new IgxSorting(); }
        return sorting.sort(data, expressions);
    };
    DataUtil.treeGridSort = function (hierarchicalData, expressions, sorting, parent) {
        if (sorting === void 0) { sorting = new IgxDataRecordSorting(); }
        var res = [];
        hierarchicalData.forEach(function (hr) {
            var rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting);
        return res;
    };
    DataUtil.cloneTreeGridRecord = function (hierarchicalRecord) {
        var rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    };
    DataUtil.group = function (data, state, grid, groupsRecords, fullResult) {
        if (grid === void 0) { grid = null; }
        if (groupsRecords === void 0) { groupsRecords = []; }
        if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
        var grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    };
    DataUtil.page = function (data, state) {
        if (!state) {
            return data;
        }
        var len = data.length;
        var index = state.index;
        var res = [];
        var recordsPerPage = state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    };
    DataUtil.filter = function (data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    };
    DataUtil.correctPagingState = function (state, length) {
        var maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    };
    DataUtil.getHierarchy = function (gRow) {
        return getHierarchy(gRow);
    };
    DataUtil.isHierarchyMatch = function (h1, h2) {
        return isHierarchyMatch(h1, h2);
    };
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    DataUtil.mergeTransactions = function (data, transactions, primaryKey, deleteRows) {
        if (deleteRows === void 0) { deleteRows = false; }
        data.forEach(function (item, index) {
            var rowId = primaryKey ? item[primaryKey] : item;
            var transaction = transactions.find(function (t) { return t.id === rowId; });
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(function (t) { return t.type === TransactionType.DELETE; })
                .forEach(function (t) {
                var index = primaryKey ? data.findIndex(function (d) { return d[primaryKey] === t.id; }) : data.findIndex(function (d) { return d === t.id; });
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push.apply(data, __spread(transactions
            .filter(function (t) { return t.type === TransactionType.ADD; })
            .map(function (t) { return t.newValue; })));
        return data;
    };
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    DataUtil.mergeHierarchicalTransactions = function (data, transactions, childDataKey, primaryKey, deleteRows) {
        var e_1, _a;
        if (deleteRows === void 0) { deleteRows = false; }
        var _loop_1 = function (transaction) {
            if (transaction.path) {
                var parent_1 = this_1.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                var collection = parent_1 ? parent_1[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent_1 && !parent_1[childDataKey]) {
                            parent_1[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        var updateIndex = collection.findIndex(function (x) { return x[primaryKey] === transaction.id; });
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            var deleteIndex = collection.findIndex(function (r) { return r[primaryKey] === transaction.id; });
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        };
        var this_1 = this;
        try {
            for (var transactions_1 = __values(transactions), transactions_1_1 = transactions_1.next(); !transactions_1_1.done; transactions_1_1 = transactions_1.next()) {
                var transaction = transactions_1_1.value;
                _loop_1(transaction);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) _a.call(transactions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return data;
    };
    DataUtil.parseValue = function (dataType, value) {
        if (dataType === DataType.Number) {
            value = parseFloat(value);
        }
        return value;
    };
    DataUtil.findParentFromPath = function (data, primaryKey, childDataKey, path) {
        var e_2, _a;
        var collection = data;
        var result;
        var _loop_2 = function (id) {
            result = collection && collection.find(function (x) { return x[primaryKey] === id; });
            if (!result) {
                return "break";
            }
            collection = result[childDataKey];
        };
        try {
            for (var path_1 = __values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                var id = path_1_1.value;
                var state_1 = _loop_2(id);
                if (state_1 === "break")
                    break;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    };
    return DataUtil;
}());
export { DataUtil };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFFQSxPQUFPLEVBQUUsVUFBVSxFQUFFLG9CQUFvQixFQUF3QixNQUFNLG9CQUFvQixDQUFDO0FBQzVGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUdsRCxPQUFPLEVBQWdCLFdBQVcsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBTXJFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpELE9BQU8sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pELE9BQU8sRUFBZSxlQUFlLEVBQTJCLE1BQU0scUNBQXFDLENBQUM7QUFDNUcsT0FBTyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUU5RDs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFFBS1g7QUFMRCxXQUFZLFFBQVE7SUFDaEIsNkJBQWlCLENBQUE7SUFDakIsNkJBQWlCLENBQUE7SUFDakIsK0JBQW1CLENBQUE7SUFDbkIseUJBQWEsQ0FBQTtBQUNqQixDQUFDLEVBTFcsUUFBUSxLQUFSLFFBQVEsUUFLbkI7QUFFRDs7R0FFRztBQUNIO0lBQUE7SUE2TUEsQ0FBQztJQTVNaUIsYUFBSSxHQUFsQixVQUFzQixJQUFTLEVBQUUsV0FBaUMsRUFBRSxPQUFnRDtRQUFoRCx3QkFBQSxFQUFBLGNBQW9DLFVBQVUsRUFBRTtRQUNoSCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFYSxxQkFBWSxHQUExQixVQUEyQixnQkFBbUMsRUFDMUQsV0FBaUMsRUFDakMsT0FBMEQsRUFDMUQsTUFBd0I7UUFEeEIsd0JBQUEs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QUFNLFdBQVcseUJBQUE7d0JBQVgsV0FBVzthQStCckI7Ozs7Ozs7OztRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFYSxtQkFBVSxHQUF4QixVQUF5QixRQUFrQixFQUFFLEtBQVU7UUFDbkQsSUFBSSxRQUFRLEtBQUssUUFBUSxDQUFDLE1BQU0sRUFBRTtZQUM5QixLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdCO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVjLDJCQUFrQixHQUFqQyxVQUFrQyxJQUFXLEVBQUUsVUFBZSxFQUFFLFlBQWlCLEVBQUUsSUFBVzs7UUFDMUYsSUFBSSxVQUFVLEdBQVUsSUFBSSxDQUFDO1FBQzdCLElBQUksTUFBVyxDQUFDO2dDQUVMLEVBQUU7WUFDVCxNQUFNLEdBQUcsVUFBVSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxFQUFwQixDQUFvQixDQUFDLENBQUM7WUFDbEUsSUFBSSxDQUFDLE1BQU0sRUFBRTs7YUFFWjtZQUVELFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7OztZQU50QyxLQUFpQixJQUFBLFNBQUEsU0FBQSxJQUFJLENBQUEsMEJBQUE7Z0JBQWhCLElBQU0sRUFBRSxpQkFBQTtzQ0FBRixFQUFFOzs7YUFPWjs7Ozs7Ozs7O1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUNMLGVBQUM7QUFBRCxDQUFDLEFBN01ELElBNk1DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUZpbHRlcmluZ1N0YXRlIH0gZnJvbSAnLi9maWx0ZXJpbmctc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSWd4U29ydGluZywgSWd4RGF0YVJlY29yZFNvcnRpbmcsIElHcmlkU29ydGluZ1N0cmF0ZWd5IH0gZnJvbSAnLi9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElneEdyb3VwaW5nIH0gZnJvbSAnLi9ncm91cGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlc3VsdCB9IGZyb20gJy4vZ3JvdXBpbmctcmVzdWx0LmludGVyZmFjZSc7XG5cbmltcG9ydCB7IElQYWdpbmdTdGF0ZSwgUGFnaW5nRXJyb3IgfSBmcm9tICcuL3BhZ2luZy1zdGF0ZS5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJR3JvdXBCeUtleSB9IGZyb20gJy4vZ3JvdXBieS1leHBhbmQtc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cEJ5UmVjb3JkIH0gZnJvbSAnLi9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwaW5nU3RhdGUgfSBmcm9tICcuL2dyb3VwYnktc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4vc29ydGluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4vZmlsdGVyaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElUcmVlR3JpZFJlY29yZCB9IGZyb20gJy4uL2dyaWRzL3RyZWUtZ3JpZC9wdWJsaWNfYXBpJztcbmltcG9ydCB7IGNsb25lVmFsdWUsIG1lcmdlT2JqZWN0cyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSwgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBnZXRIaWVyYXJjaHksIGlzSGllcmFyY2h5TWF0Y2ggfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGVudW0gRGF0YVR5cGUge1xuICAgIFN0cmluZyA9ICdzdHJpbmcnLFxuICAgIE51bWJlciA9ICdudW1iZXInLFxuICAgIEJvb2xlYW4gPSAnYm9vbGVhbicsXG4gICAgRGF0ZSA9ICdkYXRlJ1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFVdGlsIHtcbiAgICBwdWJsaWMgc3RhdGljIHNvcnQ8VD4oZGF0YTogVFtdLCBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneFNvcnRpbmcoKSk6IFRbXSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nLnNvcnQoZGF0YSwgZXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgdHJlZUdyaWRTb3J0KGhpZXJhcmNoaWNhbERhdGE6IElUcmVlR3JpZFJlY29yZFtdLFxuICAgICAgICBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sXG4gICAgICAgIHNvcnRpbmc6IElHcmlkU29ydGluZ1N0cmF0ZWd5ID0gbmV3IElneERhdGFSZWNvcmRTb3J0aW5nKCksXG4gICAgICAgIHBhcmVudD86IElUcmVlR3JpZFJlY29yZCk6IElUcmVlR3JpZFJlY29yZFtdIHtcbiAgICAgICAgbGV0IHJlczogSVRyZWVHcmlkUmVjb3JkW10gPSBbXTtcbiAgICAgICAgaGllcmFyY2hpY2FsRGF0YS5mb3JFYWNoKChocjogSVRyZWVHcmlkUmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWM6IElUcmVlR3JpZFJlY29yZCA9IERhdGFVdGlsLmNsb25lVHJlZUdyaWRSZWNvcmQoaHIpO1xuICAgICAgICAgICAgcmVjLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChyZWMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZWMuY2hpbGRyZW4gPSBEYXRhVXRpbC50cmVlR3JpZFNvcnQocmVjLmNoaWxkcmVuLCBleHByZXNzaW9ucywgc29ydGluZywgcmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKHJlYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcyA9IERhdGFVdGlsLnNvcnQocmVzLCBleHByZXNzaW9ucywgc29ydGluZyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNsb25lVHJlZUdyaWRSZWNvcmQoaGllcmFyY2hpY2FsUmVjb3JkOiBJVHJlZUdyaWRSZWNvcmQpIHtcbiAgICAgICAgY29uc3QgcmVjOiBJVHJlZUdyaWRSZWNvcmQgPSB7XG4gICAgICAgICAgICByb3dJRDogaGllcmFyY2hpY2FsUmVjb3JkLnJvd0lELFxuICAgICAgICAgICAgZGF0YTogaGllcmFyY2hpY2FsUmVjb3JkLmRhdGEsXG4gICAgICAgICAgICBjaGlsZHJlbjogaGllcmFyY2hpY2FsUmVjb3JkLmNoaWxkcmVuLFxuICAgICAgICAgICAgaXNGaWx0ZXJlZE91dFBhcmVudDogaGllcmFyY2hpY2FsUmVjb3JkLmlzRmlsdGVyZWRPdXRQYXJlbnQsXG4gICAgICAgICAgICBsZXZlbDogaGllcmFyY2hpY2FsUmVjb3JkLmxldmVsLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGhpZXJhcmNoaWNhbFJlY29yZC5leHBhbmRlZFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVjO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ3JvdXA8VD4oZGF0YTogVFtdLCBzdGF0ZTogSUdyb3VwaW5nU3RhdGUsIGdyaWQ6IGFueSA9IG51bGwsXG4gICAgICAgIGdyb3Vwc1JlY29yZHM6IGFueVtdID0gW10sIGZ1bGxSZXN1bHQ6IElHcm91cEJ5UmVzdWx0ID0geyBkYXRhOiBbXSwgbWV0YWRhdGE6IFtdIH0pOiBJR3JvdXBCeVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IGdyb3VwaW5nID0gbmV3IElneEdyb3VwaW5nKCk7XG4gICAgICAgIGdyb3Vwc1JlY29yZHMuc3BsaWNlKDAsIGdyb3Vwc1JlY29yZHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwaW5nLmdyb3VwQnkoZGF0YSwgc3RhdGUsIGdyaWQsIGdyb3Vwc1JlY29yZHMsIGZ1bGxSZXN1bHQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgcGFnZTxUPihkYXRhOiBUW10sIHN0YXRlOiBJUGFnaW5nU3RhdGUpOiBUW10ge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGNvbnN0IHJlY29yZHNQZXJQYWdlID0gc3RhdGUucmVjb3Jkc1BlclBhZ2U7XG4gICAgICAgIHN0YXRlLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgY291bnRQYWdlczogMCxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkczogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBlcnJvcjogUGFnaW5nRXJyb3IuTm9uZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGlzTmFOKGluZGV4KSkge1xuICAgICAgICAgICAgc3RhdGUubWV0YWRhdGEuZXJyb3IgPSBQYWdpbmdFcnJvci5JbmNvcnJlY3RQYWdlSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNvcmRzUGVyUGFnZSA8PSAwIHx8IGlzTmFOKHJlY29yZHNQZXJQYWdlKSkge1xuICAgICAgICAgICAgc3RhdGUubWV0YWRhdGEuZXJyb3IgPSBQYWdpbmdFcnJvci5JbmNvcnJlY3RSZWNvcmRzUGVyUGFnZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubWV0YWRhdGEuY291bnRQYWdlcyA9IE1hdGguY2VpbChsZW4gLyByZWNvcmRzUGVyUGFnZSk7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gc3RhdGUubWV0YWRhdGEuY291bnRQYWdlcykge1xuICAgICAgICAgICAgc3RhdGUubWV0YWRhdGEuZXJyb3IgPSBQYWdpbmdFcnJvci5JbmNvcnJlY3RQYWdlSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKGluZGV4ICogcmVjb3Jkc1BlclBhZ2UsIChpbmRleCArIDEpICogcmVjb3Jkc1BlclBhZ2UpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZmlsdGVyPFQ+KGRhdGE6IFRbXSwgc3RhdGU6IElGaWx0ZXJpbmdTdGF0ZSk6IFRbXSB7XG4gICAgICAgIGlmICghc3RhdGUuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHN0YXRlLnN0cmF0ZWd5ID0gbmV3IEZpbHRlcmluZ1N0cmF0ZWd5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmF0ZWd5LmZpbHRlcihkYXRhLCBzdGF0ZS5leHByZXNzaW9uc1RyZWUsIHN0YXRlLmFkdmFuY2VkRXhwcmVzc2lvbnNUcmVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGNvcnJlY3RQYWdpbmdTdGF0ZShzdGF0ZTogSVBhZ2luZ1N0YXRlLCBsZW5ndGg6IG51bWJlcikge1xuICAgICAgICBjb25zdCBtYXhQYWdlID0gTWF0aC5jZWlsKGxlbmd0aCAvIHN0YXRlLnJlY29yZHNQZXJQYWdlKSAtIDE7XG4gICAgICAgIGlmICghaXNOYU4obWF4UGFnZSkgJiYgc3RhdGUuaW5kZXggPiBtYXhQYWdlKSB7XG4gICAgICAgICAgICBzdGF0ZS5pbmRleCA9IG1heFBhZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldEhpZXJhcmNoeShnUm93OiBJR3JvdXBCeVJlY29yZCk6IEFycmF5PElHcm91cEJ5S2V5PiB7XG4gICAgICAgIHJldHVybiBnZXRIaWVyYXJjaHkoZ1Jvdyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpc0hpZXJhcmNoeU1hdGNoKGgxOiBBcnJheTxJR3JvdXBCeUtleT4sIGgyOiBBcnJheTxJR3JvdXBCeUtleT4pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzSGllcmFyY2h5TWF0Y2goaDEsIGgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYWxsIGNoYW5nZXMgZnJvbSBwcm92aWRlZCB0cmFuc2FjdGlvbnMgaW50byBwcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZGF0YSBDb2xsZWN0aW9uIHRvIG1lcmdlXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgdG8gbWVyZ2UgaW50byBkYXRhXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgUHJpbWFyeSBrZXkgb2YgdGhlIGNvbGxlY3Rpb24sIGlmIGFueVxuICAgICAqIEBwYXJhbSBkZWxldGVSb3dzIFNob3VsZCBkZWxldGUgcm93cyB3aXRoIERFTEVURSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gZGF0YVxuICAgICAqIEByZXR1cm5zIFByb3ZpZGVkIGRhdGEgY29sbGVjdGlvbnMgdXBkYXRlZCB3aXRoIGFsbCBwcm92aWRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlVHJhbnNhY3Rpb25zPFQ+KGRhdGE6IFRbXSwgdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLCBwcmltYXJ5S2V5PzogYW55LCBkZWxldGVSb3dzOiBib29sZWFuID0gZmFsc2UpOiBUW10ge1xuICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93SWQgPSBwcmltYXJ5S2V5ID8gaXRlbVtwcmltYXJ5S2V5XSA6IGl0ZW07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9ucy5maW5kKHQgPT4gdC5pZCA9PT0gcm93SWQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5VUERBVEUpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHRyYW5zYWN0aW9uLm5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlUm93cykge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFTEVURSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmltYXJ5S2V5ID8gZGF0YS5maW5kSW5kZXgoZCA9PiBkW3ByaW1hcnlLZXldID09PSB0LmlkKSA6IGRhdGEuZmluZEluZGV4KGQgPT4gZCA9PT0gdC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5wdXNoKC4uLnRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFERClcbiAgICAgICAgICAgIC5tYXAodCA9PiB0Lm5ld1ZhbHVlKSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBjaGFuZ2VzIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb25zIGludG8gcHJvdmlkZWQgaGllcmFyY2hpY2FsIGRhdGEgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBkYXRhIENvbGxlY3Rpb24gdG8gbWVyZ2VcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRyYW5zYWN0aW9ucyB0byBtZXJnZSBpbnRvIGRhdGFcbiAgICAgKiBAcGFyYW0gY2hpbGREYXRhS2V5IERhdGEga2V5IG9mIGNoaWxkIGNvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgUHJpbWFyeSBrZXkgb2YgdGhlIGNvbGxlY3Rpb24sIGlmIGFueVxuICAgICAqIEBwYXJhbSBkZWxldGVSb3dzIFNob3VsZCBkZWxldGUgcm93cyB3aXRoIERFTEVURSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gZGF0YVxuICAgICAqIEByZXR1cm5zIFByb3ZpZGVkIGRhdGEgY29sbGVjdGlvbnMgdXBkYXRlZCB3aXRoIGFsbCBwcm92aWRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25zKFxuICAgICAgICBkYXRhOiBhbnlbXSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbltdLFxuICAgICAgICBjaGlsZERhdGFLZXk6IGFueSxcbiAgICAgICAgcHJpbWFyeUtleT86IGFueSxcbiAgICAgICAgZGVsZXRlUm93czogYm9vbGVhbiA9IGZhbHNlKTogYW55W10ge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnRGcm9tUGF0aChkYXRhLCBwcmltYXJ5S2V5LCBjaGlsZERhdGFLZXksIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IHBhcmVudCA/IHBhcmVudFtjaGlsZERhdGFLZXldIDogZGF0YTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQUREOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vIHBhcmVudCB0aGlzIGlzIEFERCByb3cgYXQgcm9vdCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50W2NoaWxkRGF0YUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbY2hpbGREYXRhS2V5XSA9IGNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaCh0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5kZXggPSBjb2xsZWN0aW9uLmZpbmRJbmRleCh4ID0+IHhbcHJpbWFyeUtleV0gPT09IHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW3VwZGF0ZUluZGV4XSA9IG1lcmdlT2JqZWN0cyhjbG9uZVZhbHVlKGNvbGxlY3Rpb25bdXBkYXRlSW5kZXhdKSwgdHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkRFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlSW5kZXggPSBjb2xsZWN0aW9uLmZpbmRJbmRleChyID0+IHJbcHJpbWFyeUtleV0gPT09IHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGRlbGV0ZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBwYXRoIHRoaXMgaXMgQUREIHJvdyBpbiByb290LiBQdXNoIHRoZSBuZXdWYWx1ZSB0byBkYXRhXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlVmFsdWUoZGF0YVR5cGU6IERhdGFUeXBlLCB2YWx1ZTogYW55KTogYW55IHtcbiAgICAgICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5OdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZmluZFBhcmVudEZyb21QYXRoKGRhdGE6IGFueVtdLCBwcmltYXJ5S2V5OiBhbnksIGNoaWxkRGF0YUtleTogYW55LCBwYXRoOiBhbnlbXSk6IGFueSB7XG4gICAgICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IGRhdGE7XG4gICAgICAgIGxldCByZXN1bHQ6IGFueTtcblxuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHBhdGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5maW5kKHggPT4geFtwcmltYXJ5S2V5XSA9PT0gaWQpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHJlc3VsdFtjaGlsZERhdGFLZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iXX0=