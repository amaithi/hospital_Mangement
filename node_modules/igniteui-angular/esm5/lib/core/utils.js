import { __decorate, __param, __read, __spread, __values } from "tslib";
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { Observable } from 'rxjs';
import ResizeObserver from 'resize-observer-polyfill';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export function cloneArray(array, deep) {
    var arr = [];
    if (!array) {
        return arr;
    }
    var i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 */
export function cloneHierarchicalArray(array, childDataKey) {
    var e_1, _a;
    var result = [];
    if (!array) {
        return result;
    }
    try {
        for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
            var item = array_1_1.value;
            var clonedItem = cloneValue(item);
            if (Array.isArray(item[childDataKey])) {
                clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
            }
            result.push(clonedItem);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
export function mergeObjects(obj1, obj2) {
    var e_2, _a;
    if (!isObject(obj1)) {
        throw new Error("Cannot merge into " + obj1 + ". First param must be an object.");
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    try {
        for (var _b = __values(Object.keys(obj2)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            obj1[key] = cloneValue(obj2[key]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
export function cloneValue(value) {
    var e_3, _a;
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return __spread(value);
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        var result = {};
        try {
            for (var _b = __values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                result[key] = cloneValue(value[key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
export function getNodeSizeViaRange(range, node) {
    var overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    var width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    var s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 */
export function isEdge() {
    var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 */
export function isFirefox() {
    var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
var PlatformUtil = /** @class */ (function () {
    function PlatformUtil(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
    PlatformUtil.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    PlatformUtil.ɵprov = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
    PlatformUtil = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(0, Inject(PLATFORM_ID))
    ], PlatformUtil);
    return PlatformUtil;
}());
export { PlatformUtil };
/**
 * @hidden
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/** @hidden */
export function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 */
export function flatten(arr) {
    var result = [];
    arr.forEach(function (el) {
        result.push(el);
        if (el.children) {
            var children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
export var HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
export var NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
export var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
export var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
export var SUPPORTED_KEYS = new Set(__spread(Array.from(NAVIGATION_KEYS), ['enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']));
export var HEADER_KEYS = new Set(__spread(Array.from(NAVIGATION_KEYS), ['escape', 'esc', 'l']));
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
export function resizeObservable(target) {
    return new Observable(function (observer) {
        var instance = new ResizeObserver(function (entries) {
            observer.next(entries);
        });
        instance.observe(target);
        var unsubscribe = function () { return instance.disconnect(); };
        return unsubscribe;
    });
}
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
export function compareMaps(map1, map2) {
    var e_4, _a;
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    var match = true;
    var keys = Array.from(map2.keys());
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            if (map1.has(key)) {
                match = map1.get(key) === map2.get(key);
            }
            else {
                match = false;
            }
            if (!match) {
                break;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return match;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xDLE9BQU8sY0FBYyxNQUFNLDBCQUEwQixDQUFDOztBQUV0RDs7R0FFRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQUMsS0FBWSxFQUFFLElBQWM7SUFDbkQsSUFBTSxHQUFHLEdBQUcsRUFBRSxDQUFDO0lBQ2YsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3JCLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDUixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuRDtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxLQUFZLEVBQUUsWUFBaUI7O0lBQ2xFLElBQU0sTUFBTSxHQUFVLEVBQUUsQ0FBQztJQUN6QixJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1IsT0FBTyxNQUFNLENBQUM7S0FDakI7O1FBRUQsS0FBbUIsSUFBQSxVQUFBLFNBQUEsS0FBSyxDQUFBLDRCQUFBLCtDQUFFO1lBQXJCLElBQU0sSUFBSSxrQkFBQTtZQUNYLElBQU0sVUFBVSxHQUFHLFVBQVUs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LENBQUMsSUFBSSxFQUFFO1FBQ3pCLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBQ0QsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ2pCLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7O1FBQ3JDLEtBQWtCLElBQUEsU0FBQSxTQUFBLElBQUksQ0FBQSwwQkFBQSw0Q0FBRTtZQUFuQixJQUFNLEdBQUcsaUJBQUE7WUFDVixJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2YsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMzQztpQkFBTTtnQkFDSCxLQUFLLEdBQUcsS0FBSyxDQUFDO2FBQ2pCO1lBQ0QsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDUixNQUFNO2FBQ1Q7U0FDSjs7Ozs7Ozs7O0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXk6IGFueVtdLCBkZWVwPzogYm9vbGVhbikge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBkZWVwID8gY2xvbmVWYWx1ZShhcnJheVtpXSkgOiBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lSGllcmFyY2hpY2FsQXJyYXkoYXJyYXk6IGFueVtdLCBjaGlsZERhdGFLZXk6IGFueSk6IGFueVtdIHtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtID0gY2xvbmVWYWx1ZShpdGVtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbVtjaGlsZERhdGFLZXldKSkge1xuICAgICAgICAgICAgY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldID0gY2xvbmVIaWVyYXJjaGljYWxBcnJheShjbG9uZWRJdGVtW2NoaWxkRGF0YUtleV0sIGNoaWxkRGF0YUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY2xvbmVkSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZXMgYWxsIGZpcnN0IGxldmVsIGtleXMgb2YgT2JqMiBhbmQgbWVyZ2VzIHRoZW0gdG8gT2JqMVxuICogQHBhcmFtIG9iajEgT2JqZWN0IHRvIG1lcmdlIGludG9cbiAqIEBwYXJhbSBvYmoyIE9iamVjdCB0byBtZXJnZSBmcm9tXG4gKiBAcmV0dXJucyBPYmoxIHdpdGggbWVyZ2VkIGNsb25lZCBrZXlzIGZyb20gT2JqMlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajE6IHt9LCBvYmoyOiB7fSk6IGFueSB7XG4gICAgaWYgKCFpc09iamVjdChvYmoxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtZXJnZSBpbnRvICR7b2JqMX0uIEZpcnN0IHBhcmFtIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgIH1cblxuICAgIGlmICghaXNPYmplY3Qob2JqMikpIHtcbiAgICAgICAgcmV0dXJuIG9iajE7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqMikpIHtcbiAgICAgICAgb2JqMVtrZXldID0gY2xvbmVWYWx1ZShvYmoyW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmoxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZGVlcCBjbG9uZSBvZiBwcm92aWRlZCB2YWx1ZS5cbiAqIFN1cHBvcnRzIHByaW1pdGl2ZSB2YWx1ZXMsIGRhdGVzIGFuZCBvYmplY3RzLlxuICogSWYgcGFzc2VkIHZhbHVlIGlzIGFycmF5IHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybnMgRGVlcCBjb3B5IG9mIHByb3ZpZGVkIHZhbHVlXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlOiBhbnkpOiBhbnkge1xuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi52YWx1ZV07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjbG9uZVZhbHVlKHZhbHVlW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgT2JqZWN0XG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgT2JqZWN0XG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdHdvIHBhc3NlZCBhcmd1bWVudHMgYXJlIGVxdWFsXG4gKiBDdXJyZW50bHkgc3VwcG9ydHMgZGF0ZSBvYmplY3RzXG4gKiBAcGFyYW0gb2JqMVxuICogQHBhcmFtIG9iajJcbiAqIEByZXR1cm5zOiBgYm9vbGVhbmBcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMik6IGJvb2xlYW4ge1xuICAgIGlmIChpc0RhdGUob2JqMSkgJiYgaXNEYXRlKG9iajIpKSB7XG4gICAgICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZQ09ERVMge1xuICAgIEVOVEVSID0gMTMsXG4gICAgU1BBQ0UgPSAzMixcbiAgICBFU0NBUEUgPSAyNyxcbiAgICBMRUZUX0FSUk9XID0gMzcsXG4gICAgVVBfQVJST1cgPSAzOCxcbiAgICBSSUdIVF9BUlJPVyA9IDM5LFxuICAgIERPV05fQVJST1cgPSA0MCxcbiAgICBGMiA9IDExMyxcbiAgICBUQUIgPSA5LFxuICAgIENUUkwgPSAxNyxcbiAgICBaID0gOTAsXG4gICAgWSA9IDg5LFxuICAgIFggPSA4OCxcbiAgICBCQUNLU1BBQ0UgPSA4LFxuICAgIERFTEVURSA9IDQ2LFxuICAgIElOUFVUX01FVEhPRCA9IDIyOVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZUyB7XG4gICAgRU5URVIgPSAnRW50ZXInLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFNQQUNFX0lFID0gJ1NwYWNlYmFyJyxcbiAgICBFU0NBUEUgPSAnRXNjYXBlJyxcbiAgICBFU0NBUEVfSUUgPSAnRXNjJyxcbiAgICBMRUZUX0FSUk9XID0gJ0Fycm93TGVmdCcsXG4gICAgTEVGVF9BUlJPV19JRSA9ICdMZWZ0JyxcbiAgICBVUF9BUlJPVyA9ICdBcnJvd1VwJyxcbiAgICBVUF9BUlJPV19JRSA9ICdVcCcsXG4gICAgUklHSFRfQVJST1cgPSAnQXJyb3dSaWdodCcsXG4gICAgUklHSFRfQVJST1dfSUUgPSAnUmlnaHQnLFxuICAgIERPV05fQVJST1cgPSAnQXJyb3dEb3duJyxcbiAgICBET1dOX0FSUk9XX0lFID0gJ0Rvd24nLFxuICAgIEYyID0gJ0YyJyxcbiAgICBUQUIgPSAnVGFiJyxcbiAgICBTRU1JQ09MT04gPSAnOycsXG4gICAgSE9NRSA9ICdIb21lJyxcbiAgICBFTkQgPSAnRW5kJ1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIFJldHVybnMgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBub2RlIGNvbnRlbnQsIHVzaW5nIFJhbmdlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuICpcbiAqIGxldCBzaXplID0gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZSwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlOiBSYW5nZSwgbm9kZTogYW55KTogbnVtYmVyIHtcbiAgICBsZXQgb3ZlcmZsb3cgPSBudWxsO1xuICAgIGlmICghaXNGaXJlZm94KCkpIHtcbiAgICAgICAgb3ZlcmZsb3cgPSBub2RlLnN0eWxlLm92ZXJmbG93O1xuICAgICAgICAvLyB3ZSBuZWVkIHRoYXQgaGFjayAtIG90aGVyd2lzZSBjb250ZW50IHdvbid0IGJlIG1lYXN1cmVkIGNvcnJlY3RseSBpbiBJRS9FZGdlXG4gICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgIGNvbnN0IHdpZHRoID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICBpZiAoIWlzRmlyZWZveCgpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICogQGhpZGRlblxuICogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgQ2FudmFzXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBsZXQgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAqXG4gKiBsZXQgc2l6ZSA9IHZhbFRvUHhsc1VzaW5nQ2FudmFzKGN0eCwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYUNhbnZhcyhjYW52YXMyZEN0eDogYW55LCBub2RlOiBhbnkpOiBudW1iZXIge1xuICAgIGNvbnN0IHMgPSB0aGlzLmdyaWQuZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAgIC8vIG5lZWQgdG8gc2V0IHRoZSBmb250IHRvIGdldCBjb3JyZWN0IHdpZHRoXG4gICAgY2FudmFzMmRDdHguZm9udCA9IHMuZm9udFNpemUgKyAnICcgKyBzLmZvbnRGYW1pbHk7XG5cbiAgICByZXR1cm4gY2FudmFzMmRDdHgubWVhc3VyZVRleHQobm9kZS50ZXh0Q29udGVudCkud2lkdGg7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSUUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ1RyaWRlbnQvJykgPiAwO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VkZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZWRnZUJyb3dzZXIgPSAvRWRnZVtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gZWRnZUJyb3dzZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlZm94KCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZpcmVmb3hCcm93c2VyID0gL0ZpcmVmb3hbXFwvXFxzXShcXGQrXFwuXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgcmV0dXJuIGZpcmVmb3hCcm93c2VyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBQbGF0Zm9ybVV0aWwge1xuICAgIHB1YmxpYyBpc0Jyb3dzZXI6IGJvb2xlYW4gPSBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpO1xuXG4gICAgcHVibGljIGlzSU9TID0gdGhpcy5pc0Jyb3dzZXIgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgISgnTVNTdHJlYW0nIGluIHdpbmRvdyk7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCkge1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xlZnRDbGljayhldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05hdmlnYXRpb25LZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnZG93bicsXG4gICAgICAgICd1cCcsXG4gICAgICAgICdsZWZ0JyxcbiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgJ2Fycm93ZG93bicsXG4gICAgICAgICdhcnJvd3VwJyxcbiAgICAgICAgJ2Fycm93bGVmdCcsXG4gICAgICAgICdhcnJvd3JpZ2h0JyxcbiAgICAgICAgJ2hvbWUnLFxuICAgICAgICAnZW5kJyxcbiAgICAgICAgJ3NwYWNlJyxcbiAgICAgICAgJ3NwYWNlYmFyJyxcbiAgICAgICAgJyAnXG4gICAgXS5pbmRleE9mKGtleSkgIT09IC0xO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyOiBhbnlbXSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgIGFyci5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgICBpZiAoZWwuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShlbC5jaGlsZHJlbikgPyBlbC5jaGlsZHJlbiA6IGVsLmNoaWxkcmVuLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdHRlbihjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgYWJpbGl0eSB0byBjYW5jZWwgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgcmVmZXJlbmNlIHRvIHRoZSBvd25lciBjb21wb25lbnQuXG4gICAgICovXG4gICAgb3duZXI/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKiogQnJvd3NlciBldmVudCAqL1xuICAgIGV2ZW50PzogRXZlbnQ7XG59XG5cbmV4cG9ydCBjb25zdCBIT1JJWk9OVEFMX05BVl9LRVlTID0gbmV3IFNldChbJ2Fycm93bGVmdCcsICdsZWZ0JywgJ2Fycm93cmlnaHQnLCAncmlnaHQnLCAnaG9tZScsICdlbmQnXSk7XG5cbmV4cG9ydCBjb25zdCBOQVZJR0FUSU9OX0tFWVMgPSBuZXcgU2V0KFtcbiAgICAnZG93bicsXG4gICAgJ3VwJyxcbiAgICAnbGVmdCcsXG4gICAgJ3JpZ2h0JyxcbiAgICAnYXJyb3dkb3duJyxcbiAgICAnYXJyb3d1cCcsXG4gICAgJ2Fycm93bGVmdCcsXG4gICAgJ2Fycm93cmlnaHQnLFxuICAgICdob21lJyxcbiAgICAnZW5kJyxcbiAgICAnc3BhY2UnLFxuICAgICdzcGFjZWJhcicsXG4gICAgJyAnXG5dKTtcbmV4cG9ydCBjb25zdCBST1dfRVhQQU5EX0tFWVMgPSBuZXcgU2V0KCdyaWdodCBkb3duIGFycm93cmlnaHQgYXJyb3dkb3duJy5zcGxpdCgnICcpKTtcbmV4cG9ydCBjb25zdCBST1dfQ09MTEFQU0VfS0VZUyA9IG5ldyBTZXQoJ2xlZnQgdXAgYXJyb3dsZWZ0IGFycm93dXAnLnNwbGl0KCcgJykpO1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9LRVlTID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShOQVZJR0FUSU9OX0tFWVMpLCAnZW50ZXInLCAnZjInLCAnZXNjYXBlJywgJ2VzYycsICdwYWdlZG93bicsICdwYWdldXAnXSk7XG5leHBvcnQgY29uc3QgSEVBREVSX0tFWVMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKE5BVklHQVRJT05fS0VZUyksICdlc2NhcGUnLCAnZXNjJyAsICdsJ10pO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICpcbiAqIENyZWF0ZXMgYSBuZXcgUmVzaXplT2JzZXJ2ZXIgb24gYHRhcmdldGAgYW5kIHJldHVybnMgaXQgYXMgYW4gT2JzZXJ2YWJsZS5cbiAqIFJ1biB0aGUgcmVzaXplT2JzZXJ2YWJsZSBvdXRzaWRlIGFuZ3VsYXIgem9uZSwgYmVjYXVzZSBpdCBwYXRjaGVzIHRoZSBNdXRhdGlvbk9ic2VydmVyIHdoaWNoIGNhdXNlcyBhbiBpbmZpbml0ZSBsb29wLlxuICogUmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzE3MTJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2l6ZU9ic2VydmFibGUodGFyZ2V0OiBIVE1MRWxlbWVudCk6IE9ic2VydmFibGU8UmVzaXplT2JzZXJ2ZXJFbnRyeVtdPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGVudHJpZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5zdGFuY2Uub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IGluc3RhbmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICpcbiAqIENvbXBhcmVzIHR3byBtYXBzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU1hcHMobWFwMTogTWFwPGFueSwgYW55PiwgbWFwMjogTWFwPGFueSwgYW55Pik6IGJvb2xlYW4ge1xuICAgIGlmICghbWFwMikge1xuICAgICAgICByZXR1cm4gIW1hcDEgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHRydWU7XG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20obWFwMi5rZXlzKCkpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKG1hcDEuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbWFwMS5nZXQoa2V5KSA9PT0gbWFwMi5nZXQoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufVxuIl19