import { __decorate, __extends, __read, __spread, __values } from "tslib";
import { ChangeDetectionStrategy, Component, HostBinding, Input, forwardRef, TemplateRef, ContentChild, ViewChild } from '@angular/core';
import { IgxTreeGridAPIService } from './tree-grid-api.service';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { GridBaseAPIService } from '../api.service';
import { TransactionType } from '../../services/transaction/transaction';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService, IgxGridCRUDService } from '../selection/selection.service';
import { mergeObjects } from '../../core/utils';
import { first, takeUntil } from 'rxjs/operators';
import { IgxRowLoadingIndicatorTemplateDirective } from './tree-grid.directives';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxRowIslandAPIService } from '../hierarchical-grid/row-island-api.service';
var NEXT_ID = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
var IgxTreeGridComponent = /** @class */ (function (_super) {
    __extends(IgxTreeGridComponent, _super);
    function IgxTreeGridComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._id = "igx-tree-grid-" + NEXT_ID++;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * @memberof IgxTreeGridComponent
         */
        _this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * @memberof IgxTreeGridComponent
         */
        _this.processedRecords = new Map();
        /**
         * An @Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        _this.cascadeOnDelete = true;
        _this._expansionDepth = Infinity;
        /**
         * @hidden
         */
        _this.loadingRows = new Set();
        _this._filteredData = null;
        return _this;
    }
    IgxTreeGridComponent_1 = IgxTreeGridComponent;
    Object.defineProperty(IgxTreeGridComponent.prototype, "id", {
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: function () {
            return this._id;
        },
        set: function (value) {
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "data", {
        /**
         * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
         * ```html
         * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: function () {
            return this._data;
        },
        set: function (value) {
            this._data = value || [];
            this.summaryService.clearSummaryCache();
            if (this.shouldGenerate) {
                this.setupColumns();
            }
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "filteredData", {
        /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: function () {
            return this._filteredData;
        },
        /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * @memberof IgxTreeGridComponent
         */
        set: function (value) {
            this._filteredData = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "transactions", {
        /**
         * Get transactions service for the grid.
         * @experimental @hidden
         */
        get: function () {
            return this._transactions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "expansionDepth", {
        /**
         * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
         * set to `Infinity` which means all levels would be expanded.
         * ```html
         * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: function () {
            return this._expansionDepth;
        },
        set: function (value) {
            this._expansionDepth = value;
            this.notifyChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", {
        /**
         * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
         * ```html
         * <ng-template #rowLoadingTemplate>
         *     <igx-icon fontSet="material">loop</igx-icon>
         * </ng-template>
         *
         * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
         *                [loadChildrenOnDemand]="loadChildren"
         *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
         * </igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: function () {
            return this._rowLoadingIndicatorTemplate;
        },
        set: function (value) {
            this._rowLoadingIndicatorTemplate = value;
            this.notifyChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "_gridAPI", {
        // Kind of stupid
        get: function () {
            return this.gridAPI;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    IgxTreeGridComponent.prototype.ngOnInit = function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.onRowToggle.pipe(takeUntil(this.destroy$)).subscribe(function (args) {
            _this.loadChildrenOnRowExpansion(args);
        });
    };
    IgxTreeGridComponent.prototype.ngDoCheck = function () {
        _super.prototype.ngDoCheck.call(this);
    };
    /**
     * @hidden
     */
    IgxTreeGridComponent.prototype.ngAfterContentInit = function () {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        _super.prototype.ngAfterContentInit.call(this);
    };
    IgxTreeGridComponent.prototype.loadChildrenOnRowExpansion = function (args) {
        var _this = this;
        if (this.loadChildrenOnDemand) {
            var parentID_1 = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID_1)) {
                this.loadingRows.add(parentID_1);
                this.loadChildrenOnDemand(parentID_1, function (children) {
                    _this.loadingRows.delete(parentID_1);
                    _this.addChildRows(children, parentID_1);
                    _this.notifyChanges();
                });
            }
        }
    };
    IgxTreeGridComponent.prototype.addChildRows = function (children, parentID) {
        var e_1, _a, _b;
        var _this = this;
        if (this.primaryKey && this.foreignKey) {
            try {
                for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                    var child = children_1_1.value;
                    child[this.foreignKey] = parentID;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_b = this.data).push.apply(_b, __spread(children));
        }
        else if (this.childDataKey) {
            var parent_1 = this.records.get(parentID);
            var parentData = parent_1.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                var path = [];
                while (parent_1) {
                    path.push(parent_1.rowID);
                    parent_1 = parent_1.parent;
                }
                var collection = this.data;
                var record = void 0;
                var _loop_1 = function (i) {
                    var pid = path[i];
                    record = collection.find(function (r) { return r[_this.primaryKey] === pid; });
                    if (!record) {
                        return "break";
                    }
                    collection = record[this_1.childDataKey];
                };
                var this_1 = this;
                for (var i = path.length - 1; i >= 0; i--) {
                    var state_1 = _loop_1(i);
                    if (state_1 === "break")
                        break;
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this._pipeTrigger++;
    };
    IgxTreeGridComponent.prototype.cloneMap = function (mapIn) {
        var mapCloned = new Map();
        mapIn.forEach(function (value, key, mapObj) {
            mapCloned.set(key, value);
        });
        return mapCloned;
    };
    IgxTreeGridComponent.prototype.getDefaultExpandState = function (record) {
        return record.children && record.children.length && record.level < this.expansionDepth;
    };
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    IgxTreeGridComponent.prototype.expandAll = function () {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    };
    /**
     * Collapses all rows.
     *
     * ```typescript
     * this.grid.collapseAll();
     *  ```
     * @memberof IgxTreeGridComponent
     */
    IgxTreeGridComponent.prototype.collapseAll = function () {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    };
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    IgxTreeGridComponent.prototype.addRow = function (data, parentRowID) {
        if (parentRowID !== undefined && parentRowID !== null) {
            _super.prototype.endEdit.call(this, true);
            var state = this.transactions.getState(parentRowID);
            // we should not allow adding of rows as child of deleted row
            if (state && state.type === TransactionType.DELETE) {
                throw Error("Cannot add child row to deleted parent row");
            }
            var parentRecord = this.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.primaryKey && this.foreignKey) {
                data[this.foreignKey] = parentRowID;
                _super.prototype.addRow.call(this, data);
            }
            else {
                var parentData = parentRecord.data;
                var childKey = this.childDataKey;
                if (this.transactions.enabled) {
                    var rowId = this.primaryKey ? data[this.primaryKey] : data;
                    var path = [];
                    path.push.apply(path, __spread(this.generateRowPath(parentRowID)));
                    path.push(parentRowID);
                    this.transactions.add({
                        id: rowId,
                        path: path,
                        newValue: data,
                        type: TransactionType.ADD
                    }, null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
                this.onRowAdded.emit({ data: data });
                this._pipeTrigger++;
                this.notifyChanges();
            }
        }
        else {
            if (this.primaryKey && this.foreignKey) {
                var rowID = data[this.foreignKey];
                this.summaryService.clearSummaryCache({ rowID: rowID });
            }
            _super.prototype.addRow.call(this, data);
        }
    };
    /** @hidden */
    IgxTreeGridComponent.prototype.deleteRowById = function (rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    };
    /** @hidden */
    IgxTreeGridComponent.prototype.generateRowPath = function (rowId) {
        var path = [];
        var record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    };
    /**
     * @hidden @internal
     */
    IgxTreeGridComponent.prototype.getDataBasedBodyHeight = function () {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    };
    /**
     * @hidden
     */
    IgxTreeGridComponent.prototype.scrollTo = function (row, column) {
        var _this = this;
        var delayScrolling = false;
        var record;
        if (typeof (row) !== 'number') {
            var rowData = row;
            var rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                var rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                var page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first()).subscribe(function () {
                _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.unpinnedDataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    };
    /**
     * @hidden
     */
    IgxTreeGridComponent.prototype.getContext = function (rowData, rowIndex, pinned) {
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false
        };
    };
    /**
     * @hidden
     * @internal
     */
    IgxTreeGridComponent.prototype.getInitialPinnedIndex = function (rec) {
        return this._pinnedRecordIDs.indexOf(rec.rowID);
    };
    /**
     * @inheritdoc
     */
    IgxTreeGridComponent.prototype.getSelectedData = function (formatters, headers) {
        if (formatters === void 0) { formatters = false; }
        if (headers === void 0) { headers = false; }
        var source = [];
        var process = function (record) {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.unpinnedDataView.forEach(process);
        source = this.isRowPinningToTop ? __spread(this.pinnedDataView, source) : __spread(source, this.pinnedDataView);
        return this.extractDataFromSelection(source, formatters, headers);
    };
    Object.defineProperty(IgxTreeGridComponent.prototype, "template", {
        /**
         * @hidden
         */
        get: function () {
            if (this.filteredData && this.filteredData.length === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
            }
            if (this.isLoading && (!this.data || this.dataLength === 0)) {
                return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
            }
            if (this.dataLength === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxTreeGridComponent.prototype.writeToData = function (rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    };
    /**
     * @hidden
     */
    IgxTreeGridComponent.prototype.initColumns = function (collection, cb) {
        if (cb === void 0) { cb = null; }
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !col.columnLayoutChild; });
            this.columnList.reset(nonColumnLayoutColumns);
        }
        _super.prototype.initColumns.call(this, collection, cb);
    };
    var IgxTreeGridComponent_1;
    __decorate([
        HostBinding('attr.id'),
        Input()
    ], IgxTreeGridComponent.prototype, "id", null);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "data", null);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "childDataKey", void 0);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "foreignKey", void 0);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "hasChildrenKey", void 0);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "cascadeOnDelete", void 0);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "expansionDepth", null);
    __decorate([
        ContentChild(IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective })
    ], IgxTreeGridComponent.prototype, "rowLoadingTemplate", void 0);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", null);
    __decorate([
        Input()
    ], IgxTreeGridComponent.prototype, "loadChildrenOnDemand", void 0);
    __decorate([
        ViewChild('dragIndicatorIconBase', { read: TemplateRef, static: true })
    ], IgxTreeGridComponent.prototype, "dragIndicatorIconBase", void 0);
    __decorate([
        ViewChild('record_template', { read: TemplateRef, static: true })
    ], IgxTreeGridComponent.prototype, "recordTemplate", void 0);
    __decorate([
        ViewChild('summary_template', { read: TemplateRef, static: true })
    ], IgxTreeGridComponent.prototype, "summaryTemplate", void 0);
    IgxTreeGridComponent = IgxTreeGridComponent_1 = __decorate([
        Component({
            changeDetection: ChangeDetectionStrategy.OnPush,
            preserveWhitespaces: false,
            selector: 'igx-tree-grid',
            template: "<igx-grid-toolbar role=\"toolbar\" [style.max-width.px]='outerWidth' [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (focus)=\"navigation.focusFirstCell()\" (keydown)=\"navigation.headerNavigation($event)\" #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollWidth\"></div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.handleNavigation($event)\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"processedExpandedFlatData.length\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
            providers: [
                IgxGridSelectionService,
                IgxGridCRUDService,
                IgxGridSummaryService,
                IgxGridNavigationService,
                { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                { provide: IgxGridBaseDirective, useExisting: forwardRef(function () { return IgxTreeGridComponent_1; }) },
                IgxFilteringService,
                IgxForOfSyncService,
                IgxForOfScrollSyncService,
                IgxRowIslandAPIService
            ]
        })
    ], IgxTreeGridComponent);
    return IgxTreeGridComponent;
}(IgxGridBaseDirective));
export { IgxTreeGridComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsVUFBVSxFQUVWLFdBQVcsRUFFWCxZQUFZLEVBRVosU0FBUyxFQUVaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzlELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR3BELE9BQU8sRUFBOEMsZUFBZSxFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFckgsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDMUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDMUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDN0YsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFFLHVDQUF1QyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDN0csT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFHdEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFFckYsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBRWhCOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQW1CSDtJQUEwQyx3Q0FBb0I7SUFBOUQ7UUFBQSxxRUFvbEJDO1FBbmxCVyxTQUFHLEdBQUcsbUJBQWlCLE9BQU8sRUFBSSxDQUFDO1FBK0YzQzs7Ozs7OztXQU9HO1FBQ0ksYUFBTyxHQUE4QixJQUFJLEdBQUcsRUFBd0IsQ0FBQztRQVk1RTs7Ozs7OztXQU9HO1FBQ0ksc0JBQWdCLEdBQThCLElBQUksR0FBRyxFQUF3QixDQUFDO1FBcUNyRjs7Ozs7Ozs7V0FRRztRQUVJLHFCQUFlLEdBQUcsSUFBSSxDQUFDO1FBRXRCLHFCQUFlLEdBQUcsUUFBUSxDQUFDO1FBa0VuQzs7V0FFRztRQUNJLGlCQUFXLEdBQUcsSUFBSSxHQUFHLEVBQU8sQ0FBQztRQU01QixtQkFBYSxHQUFHLElBQUksQ0FBQzs7SUE0VmpDLENBQUM7NkJBcGxCWSxvQkFBb0I7SUFlN0Isc0JBQVcsb0NBQUU7UUFUYjs7Ozs7O1dBTUc7YUFHSDtZQUNJLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUNwQixDQUFDO2FBQ0QsVUFBYyxLQUFhO1lBQ3ZCLElBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLENBQUM7OztPQUhBO0lBYUQsc0JBQVcsc0NBQUk7UUFSZjs7Ozs7O1dBTUc7YUFFSDtZQUNJLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN0QixDQUFDO2FBRUQsVUFBZ0IsS0FBWTtZQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDekIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1lBQ3hDLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDckIsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3ZCO1lBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUM1QixDQUFDOzs7T0FUQTtJQWtCRCxzQkFBSSw4Q0FBWTtRQVBoQjs7Ozs7O1dBTUc7YUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUM5QixDQUFDO1FBRUQ7Ozs7Ozs7OztXQVNHO2FBQ0gsVUFBaUIsS0FBSztZQUNsQixJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztRQUMvQixDQUFDOzs7T0FkQTtJQW9CRCxzQkFBSSw4Q0FBWTtRQUpoQjs7O1dBR0c7YUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUM5QixDQUFDOzs7T0FBQTtJQThHRCxzQkFBVyxnREFBYztRQVR6Qjs7Ozs7OztXQU9HO2FBRUg7WUFDSSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDaEMsQ0FBQzthQUVELFVBQTBCLEtBQWE7WUFDbkMsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7WUFDN0IsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3pCLENBQUM7OztPQUxBO0lBNEJELHNCQUFXLDZEQUEyQjtRQWZ0Qzs7Ozs7Ozs7Ozs7OztXQWFHO2FBRUg7WUFDSSxPQUFPLElBQUksQ0FBQyw0QkFBNEIsQ0FBQztRQUM3QyxDQUFDO2FBRUQsVUFBdUMsS0FBdUI7WUFDMUQsSUFBSSxDQUFDLDRCQUE0QixHQUFHLEtBQUssQ0FBQztZQUMxQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDekIsQ0FBQzs7O09BTEE7SUE2QkQsc0JBQVksMENBQVE7UUFEcEIsaUJBQWlCO2FBQ2pCO1lBQ0ksT0FBTyxJQUFJLENBQUMsT0FBZ0MsQ0FBQztRQUNqRCxDQUFDOzs7T0FBQTtJQXNCRDs7T0FFRztJQUNJLHVDQUFRLEdBQWY7UUFBQSxpQkFNQztRQUxHLGlCQUFNLFFBQVEsV0FBRSxDQUFDO1FBRWpCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBQyxJQUFJO1lBQzNELEtBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCx3Q0FBUyxHQUFUO1FBQ0ksaUJBQU0sU0FBUyxXQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksaURBQWtCLEdBQXpCO1FBQ0ksSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDekIsSUFBSSxDQUFDLDRCQUE0QixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUM7U0FDeEU7UUFDRCxpQkFBTSxrQkFBa0IsV0FBRSxDQUFDO0lBQy9CLENBQUM7SUFFTyx5REFBMEIsR0FBbEMsVUFBbUMsSUFBeUI7UUFBNUQsaUJBY0M7UUFiRyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUMzQixJQUFNLFVBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBRTVCLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsVUFBUSxDQUFDLEVBQUU7Z0JBQ3ZELElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFVBQVEsQ0FBQyxDQUFDO2dCQUUvQixJQUFJLENBQUMsb0JBQW9CLENBQUMsVUFBUSxFQUFFLFVBQUEsUUFBUTtvQkFDeEMsS0FBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBUSxDQUFDLENBQUM7b0JBQ2xDLEtBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLFVBQVEsQ0FBQyxDQUFDO29CQUN0QyxLQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7Z0JBQ3pCLENBQUMsQ0FBQyxDQUFDO2FBQ047U0FDSjtJQUNMLENBQUM7SUFFTywyQ0FBWSxHQUFwQixVQUFxQixRQUFlLEVBQUUsUUFBYTs7UUFBbkQsaUJBcUNDO1FBcENHLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFOztnQkFDcEMsS0FBb0IsSUFBQSxhQUFBLFNBQUEsUUFBUSxDQUFBLGtDQUFBLHdEQUFFO29CQUF6QixJQUFNLEtBQUsscUJBQUE7b0JBQ1osS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUM7aUJBQ3JDOzs7Ozs7Ozs7WUFDRCxDQUFBLEtBQUEsSUFBSSxDQUFDLElBQUksQ0FBQSxDQUFDLElBQUksb0JBQUksUUFBUSxHQUFFO1NBQy9CO2FBQU0sSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQzFCLElBQUksUUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hDLElBQUksVUFBVSxHQUFHLFFBQU0sQ0FBQyxJQUFJLENBQUM7WUFFN0IsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRTtnQkFDbEYsSUFBTSxJQUFJLEdBQUcsRUFBRSxDQUFDO2dCQUNoQixPQUFPLFFBQU0sRUFBRTtvQkFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDeEIsUUFBTSxHQUFHLFFBQU0sQ0FBQyxNQUFNLENBQUM7aUJBQzFCO2dCQUVELElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQzNCLElBQUksTUFBTSxTQUFLLENBQUM7d0NBQ1AsQ0FBQztvQkFDTixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3BCLE1BQU0sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLEtBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxHQUFHLEVBQTFCLENBQTBCLENBQUMsQ0FBQztvQkFFMUQsSUFBSSxDQUFDLE1BQU0sRUFBRTs7cUJBRVo7b0JBQ0QsVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFLLFlBQVksQ0FBQyxDQUFDOzs7Z0JBUDNDLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUU7MENBQWhDLENBQUM7OztpQkFRVDtnQkFDRCxJQUFJLE1BQU0sRUFBRTtvQkFDUixVQUFVLEdBQUcsTUFBTSxDQUFDO2lCQUN2QjthQUNKO1lBRUQsVUFBVSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxRQUFRLENBQUM7U0FDNUM7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUMzQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUVPLHVDQUFRLEdBQWhCLFVBQWlCLEtBQXdCO1FBQ3JDLElBQU0sU0FBUyxHQUFzQixJQUFJLEdBQUcsRUFBZ0IsQ0FBQztRQUU3RCxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBYyxFQUFFLEdBQVEsRUFBRSxNQUF5QjtZQUU5RCxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM5QixDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7SUFFTSxvREFBcUIsR0FBNUIsVUFBNkIsTUFBdUI7UUFDaEQsT0FBTyxNQUFNLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztJQUMzRixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksd0NBQVMsR0FBaEI7UUFDSSxJQUFJLENBQUMsZUFBZSxHQUFHLFFBQVEsQ0FBQztRQUNoQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxFQUFnQixDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksMENBQVcsR0FBbEI7UUFDSSxJQUFJLENBQUMsZUFBZSxHQUFHLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxFQUFnQixDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7T0FjRztJQUNJLHFDQUFNLEdBQWIsVUFBYyxJQUFTLEVBQUUsV0FBaUI7UUFDdEMsSUFBSSxXQUFXLEtBQUssU0FBUyxJQUFJLFdBQVcsS0FBSyxJQUFJLEVBQUU7WUFDbkQsaUJBQU0sT0FBTyxZQUFDLElBQUksQ0FBQyxDQUFDO1lBRXBCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3RELDZEQUE2RDtZQUM3RCxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLGVBQWUsQ0FBQyxNQUFNLEVBQUU7Z0JBQ2hELE1BQU0sS0FBSyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7YUFDN0Q7WUFFRCxJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUVuRCxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNmLE1BQU0sS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7YUFDekM7WUFDRCxJQUFJLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDLEVBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDO1lBQ25FLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFdBQVcsQ0FBQztnQkFDcEMsaUJBQU0sTUFBTSxZQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3RCO2lCQUFNO2dCQUNILElBQU0sVUFBVSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUM7Z0JBQ3JDLElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7Z0JBQ25DLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUU7b0JBQzNCLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztvQkFDN0QsSUFBTSxJQUFJLEdBQVUsRUFBRSxDQUFDO29CQUN2QixJQUFJLENBQUMsSUFBSSxPQUFULElBQUksV0FBUyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxHQUFFO29CQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUN2QixJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQzt3QkFDbEIsRUFBRSxFQUFFLEtBQUs7d0JBQ1QsSUFBSSxFQUFFLElBQUk7d0JBQ1YsUUFBUSxFQUFFLElBQUk7d0JBQ2QsSUFBSSxFQUFFLGVBQWUsQ0FBQyxHQUFHO3FCQUNELEVBQ3hCLElBQUksQ0FBQyxDQUFDO2lCQUNiO3FCQUFNO29CQUNILElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7d0JBQ3ZCLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7cUJBQzdCO29CQUNELFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ25DO2dCQUNELElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxNQUFBLEVBQUUsQ0FBQyxDQUFDO2dCQUMvQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7Z0JBQ3BCLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQzthQUN4QjtTQUNKO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDcEMsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDcEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUMsQ0FBQyxDQUFDO2FBQ3pEO1lBQ0QsaUJBQU0sTUFBTSxZQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3RCO0lBQ0wsQ0FBQztJQUVELGNBQWM7SUFDUCw0Q0FBYSxHQUFwQixVQUFxQixLQUFVO1FBQzNCLDZFQUE2RTtRQUM3RSxnRkFBZ0Y7UUFDaEYsOEVBQThFO1FBQzlFLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXZDLENBQUM7SUFFRCxjQUFjO0lBQ1AsOENBQWUsR0FBdEIsVUFBdUIsS0FBVTtRQUM3QixJQUFNLElBQUksR0FBVSxFQUFFLENBQUM7UUFDdkIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFckMsT0FBTyxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvQixNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUMxQjtRQUVELE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRDs7T0FFRztJQUNPLHFEQUFzQixHQUFoQztRQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQztZQUMvRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7O09BRUc7SUFDTyx1Q0FBUSxHQUFsQixVQUFtQixHQUFpQixFQUFFLE1BQW9CO1FBQTFELGlCQWdDQztRQS9CRyxJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUM7UUFDM0IsSUFBSSxNQUF1QixDQUFDO1FBRTVCLElBQUksT0FBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsRUFBRTtZQUMxQixJQUFNLE9BQU8sR0FBRyxHQUFHLENBQUM7WUFDcEIsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDaEQsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUU1QyxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2IsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDakUsSUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUVqRCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxFQUFFO29CQUNwQixjQUFjLEdBQUcsSUFBSSxDQUFDO29CQUN0QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztpQkFDcEI7YUFDSjtTQUNKO1FBRUQsSUFBSSxjQUFjLEVBQUU7WUFDaEIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUM7Z0JBQy9ELEtBQUksQ0FBQyxlQUFlLENBQUMsS0FBSSxDQUFDLHVCQUF1QixFQUM3QyxPQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUNoRixDQUFDLENBQUMsQ0FBQztTQUNOO2FBQU07WUFDSCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFDN0MsT0FBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7U0FDL0U7UUFFRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOztPQUVHO0lBQ0kseUNBQVUsR0FBakIsVUFBa0IsT0FBWSxFQUFFLFFBQWdCLEVBQUUsTUFBZ0I7UUFDOUQsT0FBTztZQUNILFNBQVMsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPO1lBQ3BFLEtBQUssRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQztZQUM5QyxVQUFVLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQ2pFLFFBQVEsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLG1CQUFtQixLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSztTQUN0RyxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7T0FHRztJQUNJLG9EQUFxQixHQUE1QixVQUE2QixHQUFHO1FBQzVCLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVEOztPQUVHO0lBQ0gsOENBQWUsR0FBZixVQUFnQixVQUFrQixFQUFFLE9BQWU7UUFBbkMsMkJBQUEsRUFBQSxrQkFBa0I7UUFBRSx3QkFBQSxFQUFBLGVBQWU7UUFDL0MsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBRWhCLElBQU0sT0FBTyxHQUFHLFVBQUMsTUFBTTtZQUNuQixJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7Z0JBQ2xCLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2xCLE9BQU87YUFDVjtZQUNELE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkMsTUFBTSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFVBQUssSUFBSSxDQUFDLGNBQWMsRUFBSyxNQUFNLEVBQUUsQ0FBQyxVQUFLLE1BQU0sRUFBSyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDNUcsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBS0Qsc0JBQVcsMENBQVE7UUFIbkI7O1dBRUc7YUFDSDtZQUNJLElBQUksSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ3JELE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQzthQUMzRjtZQUVELElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUN6RCxPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsMEJBQTBCLENBQUM7YUFDaEc7WUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUM7YUFDMUY7UUFDTCxDQUFDOzs7T0FBQTtJQUVTLDBDQUFXLEdBQXJCLFVBQXNCLFFBQWdCLEVBQUUsS0FBVTtRQUM5QyxZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7O09BRUc7SUFDTSwwQ0FBVyxHQUFyQixVQUFzQixVQUF5QyxFQUFFLEVBQW1CO1FBQW5CLG1CQUFBLEVBQUEsU0FBbUI7UUFDL0UsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDdkIsb0VBQW9FO1lBQ3BFLHdCQUF3QjtZQUN4QixJQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQUMsR0FBRyxJQUFLLE9BQUEsQ0FBQyxHQUFHLENBQUMsWUFBWSxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixFQUEzQyxDQUEyQyxDQUFDLENBQUM7WUFDNUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUNqRDtRQUNELGlCQUFNLFdBQVcsWUFBQyxVQUFVLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDdEMsQ0FBQzs7SUFwa0JEO1FBRkMsV0FBVyxDQUFDLFNBQVMsQ0FBQztRQUN0QixLQUFLLEVBQUU7a0RBR1A7SUFhRDtRQURDLEtBQUssRUFBRTtvREFHUDtJQXNHRDtRQURDLEtBQUssRUFBRTs4REFDWTtJQVdwQjtRQURDLEtBQUssRUFBRTs0REFDVTtJQWNsQjtRQURDLEtBQUssRUFBRTtnRUFDYztJQVl0QjtRQURDLEtBQUssRUFBRTtpRUFDc0I7SUFhOUI7UUFEQyxLQUFLLEVBQUU7OERBR1A7SUFXRDtRQURDLFlBQVksQ0FBQyx1Q0FBdUMsRUFBRSxFQUFFLElBQUksRUFBRSx1Q0FBdUMsRUFBRSxDQUFDO29FQUNuQztJQWlCdEU7UUFEQyxLQUFLLEVBQUU7MkVBR1A7SUFxQkQ7UUFEQyxLQUFLLEVBQUU7c0VBQzhFO0lBa0J0RjtRQURDLFNBQVMsQ0FBQyx1QkFBdUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDO3VFQUN6QjtJQU0vQztRQURDLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDO2dFQUN2QjtJQU0zQztRQURDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDO2lFQUN2QjtJQTNRbkMsb0JBQW9CO1FBbEJoQyxTQUFTLENBQUM7WUFDUCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtZQUMvQyxtQkFBbUIsRUFBRSxLQUFLO1lBQzFCLFFBQVEsRUFBRSxlQUFlO1lBQ3pCLHV0ZUFBdUM7WUFDdkMsU0FBUyxFQUFFO2dCQUNQLHVCQUF1QjtnQkFDdkIsa0JBQWtCO2dCQUNsQixxQkFBcUI7Z0JBQ3JCLHdCQUF3QjtnQkFDeEIsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLHFCQUFxQixFQUFFO2dCQUNoRSxFQUFFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLGNBQU0sT0FBQSxzQkFBb0IsRUFBcEIsQ0FBb0IsQ0FBQyxFQUFFO2dCQUN0RixtQkFBbUI7Z0JBQ25CLG1CQUFtQjtnQkFDbkIseUJBQXlCO2dCQUN6QixzQkFBc0I7YUFDekI7U0FDSixDQUFDO09BQ1csb0JBQW9CLENBb2xCaEM7SUFBRCwyQkFBQztDQUFBLEFBcGxCRCxDQUEwQyxvQkFBb0IsR0FvbEI3RDtTQXBsQlksb0JBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDb21wb25lbnQsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgZm9yd2FyZFJlZixcbiAgICBPbkluaXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgUXVlcnlMaXN0LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBEb0NoZWNrXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWdyaWQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VEaXJlY3RpdmUgfSBmcm9tICcuLi9ncmlkLWJhc2UuZGlyZWN0aXZlJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElUcmVlR3JpZFJlY29yZCB9IGZyb20gJy4vdHJlZS1ncmlkLmludGVyZmFjZXMnO1xuaW1wb3J0IHsgSVJvd1RvZ2dsZUV2ZW50QXJncyB9IGZyb20gJy4uL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IHsgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sIEhpZXJhcmNoaWNhbFN0YXRlLCBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wdWJsaWNfYXBpJztcbmltcG9ydCB7IElneEZpbHRlcmluZ1NlcnZpY2UgfSBmcm9tICcuLi9maWx0ZXJpbmcvZ3JpZC1maWx0ZXJpbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU3VtbWFyeVNlcnZpY2UgfSBmcm9tICcuLi9zdW1tYXJpZXMvZ3JpZC1zdW1tYXJ5LnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsIElneEdyaWRDUlVEU2VydmljZSB9IGZyb20gJy4uL3NlbGVjdGlvbi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBtZXJnZU9iamVjdHMgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IGZpcnN0LCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL3RyZWUtZ3JpZC5kaXJlY3RpdmVzJztcbmltcG9ydCB7IElneEZvck9mU3luY1NlcnZpY2UsIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2Yuc3luYy5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2dyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSb3dJc2xhbmRBUElTZXJ2aWNlIH0gZnJvbSAnLi4vaGllcmFyY2hpY2FsLWdyaWQvcm93LWlzbGFuZC1hcGkuc2VydmljZSc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBUcmVlIEdyaWQqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvZ3JpZC5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgVHJlZSBHcmlkIGRpc3BsYXlzIGFuZCBtYW5pcHVsYXRlcyBoaWVyYXJjaGljYWwgZGF0YSB3aXRoIGNvbnNpc3RlbnQgc2NoZW1hIGZvcm1hdHRlZCBhcyBhIHRhYmxlIGFuZFxuICogcHJvdmlkZXMgZmVhdHVyZXMgc3VjaCBhcyBzb3J0aW5nLCBmaWx0ZXJpbmcsIGVkaXRpbmcsIGNvbHVtbiBwaW5uaW5nLCBwYWdpbmcsIGNvbHVtbiBtb3ZpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgcHJpbWFyeUtleT1cImVtcGxveWVlSURcIiBmb3JlaWduS2V5PVwiUElEXCIgYXV0b0dlbmVyYXRlPVwiZmFsc2VcIj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJmaXJzdFwiIGhlYWRlcj1cIkZpcnN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwibGFzdFwiIGhlYWRlcj1cIkxhc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJyb2xlXCIgaGVhZGVyPVwiUm9sZVwiPjwvaWd4LWNvbHVtbj5cbiAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlLWdyaWQnLFxuICAgIHRlbXBsYXRlVXJsOiAndHJlZS1ncmlkLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRDUlVEU2VydmljZSxcbiAgICAgICAgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlLFxuICAgICAgICBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHsgcHJvdmlkZTogR3JpZEJhc2VBUElTZXJ2aWNlLCB1c2VDbGFzczogSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSWd4R3JpZEJhc2VEaXJlY3RpdmUsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneFRyZWVHcmlkQ29tcG9uZW50KSB9LFxuICAgICAgICBJZ3hGaWx0ZXJpbmdTZXJ2aWNlLFxuICAgICAgICBJZ3hGb3JPZlN5bmNTZXJ2aWNlLFxuICAgICAgICBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBJZ3hSb3dJc2xhbmRBUElTZXJ2aWNlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlR3JpZENvbXBvbmVudCBleHRlbmRzIElneEdyaWRCYXNlRGlyZWN0aXZlIGltcGxlbWVudHMgR3JpZFR5cGUsIE9uSW5pdCwgRG9DaGVjaywgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgcHJpdmF0ZSBfaWQgPSBgaWd4LXRyZWUtZ3JpZC0ke05FWFRfSUQrK31gO1xuICAgIHByaXZhdGUgX2RhdGE7XG4gICAgcHJpdmF0ZSBfcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIHByb3RlY3RlZCBfdHJhbnNhY3Rpb25zOiBJZ3hIaWVyYXJjaGljYWxUcmFuc2FjdGlvblNlcnZpY2U8SGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sIEhpZXJhcmNoaWNhbFN0YXRlPjtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtpZF09XCInaWd4LXRyZWUtZ3JpZC0xJ1wiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGxldHMgeW91IGZpbGwgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAgd2l0aCBhbiBhcnJheSBvZiBkYXRhLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBkYXRhKCk6IGFueVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBkYXRhKHZhbHVlOiBhbnlbXSkge1xuICAgICAgICB0aGlzLl9kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgIHRoaXMuc3VtbWFyeVNlcnZpY2UuY2xlYXJTdW1tYXJ5Q2FjaGUoKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkR2VuZXJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBDb2x1bW5zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIGRhdGEgaW4gdGhlIGBJZ3hHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmVkRGF0YSA9IHRoaXMuZ3JpZC5maWx0ZXJlZERhdGE7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmVkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgZGF0YSBpbiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZmlsdGVyZWREYXRhID0gW3tcbiAgICAgKiAgICAgICBJRDogMSxcbiAgICAgKiAgICAgICBOYW1lOiBcIkFcIlxuICAgICAqIH1dO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBmaWx0ZXJlZERhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWREYXRhID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRyYW5zYWN0aW9ucyBzZXJ2aWNlIGZvciB0aGUgZ3JpZC5cbiAgICAgKiBAZXhwZXJpbWVudGFsIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZmxhdERhdGE6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBwcm9jZXNzZWRFeHBhbmRlZEZsYXREYXRhOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJvb3QgbGV2ZWwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByb290IHJlY29yZCB3aXRoIGluZGV4PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucm9vdFJlY29yZHNbMl07XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHJvb3RSZWNvcmRzOiBJVHJlZUdyaWRSZWNvcmRbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgYWxsIGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcmVjb3JkIHdpdGggcHJpbWFyeUtleT0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnJlY29yZHMuZ2V0KDIpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyByZWNvcmRzOiBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+ID0gbmV3IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4oKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcHJvY2Vzc2VkIChmaWx0ZXJlZCBhbmQgc29ydGVkKSByb290IGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcHJvY2Vzc2VkIHJvb3QgcmVjb3JkIHdpdGggaW5kZXg9MlxuICAgICAqIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ3JpZC5wcm9jZXNzZWRSb290UmVjb3Jkc1syXTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkUm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgcHJvY2Vzc2VkIChmaWx0ZXJlZCBhbmQgc29ydGVkKSBgSVRyZWVHcmlkUmVjb3JkYHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldHMgdGhlIHByb2Nlc3NlZCByZWNvcmQgd2l0aCBwcmltYXJ5S2V5PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucHJvY2Vzc2VkUmVjb3Jkcy5nZXQoMik7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHByb2Nlc3NlZFJlY29yZHM6IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4gPSBuZXcgTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPigpO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgY2hpbGQgZGF0YSBrZXkgb2YgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtjaGlsZERhdGFLZXldPVwiJ2VtcGxveWVlcydcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2hpbGREYXRhS2V5O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZm9yZWlnbiBrZXkgb2YgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZm9yZWlnbktleTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGtleSBpbmRpY2F0aW5nIHdoZXRoZXIgYSByb3cgaGFzIGNoaWxkcmVuLlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSB1c2VkIGZvciBsb2FkIG9uIGRlbWFuZCBzY2VuYXJpb3MuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIlxuICAgICAqICAgICAgICAgICAgICAgIFtsb2FkQ2hpbGRyZW5PbkRlbWFuZF09XCJsb2FkQ2hpbGRyZW5cIlxuICAgICAqICAgICAgICAgICAgICAgIFtoYXNDaGlsZHJlbktleV09XCInaGFzRW1wbG95ZWVzJ1wiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoYXNDaGlsZHJlbktleTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSBpbmRpY2F0aW5nIHdoZXRoZXIgY2hpbGQgcmVjb3JkcyBzaG91bGQgYmUgZGVsZXRlZCB3aGVuIHRoZWlyIHBhcmVudCBnZXRzIGRlbGV0ZWQuXG4gICAgICogQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZSBhbmQgZGVsZXRlcyBhbGwgY2hpbGRyZW4gYWxvbmcgd2l0aCB0aGUgcGFyZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCIgY2FzY2FkZU9uRGVsZXRlPVwiZmFsc2VcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2FzY2FkZU9uRGVsZXRlID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjb3VudCBvZiBsZXZlbHMgdG8gYmUgZXhwYW5kZWQgaW4gdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYEluZmluaXR5YCB3aGljaCBtZWFucyBhbGwgbGV2ZWxzIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgZXhwYW5zaW9uRGVwdGg9XCIxXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBleHBhbnNpb25EZXB0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uRGVwdGg7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBleHBhbnNpb25EZXB0aCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gdmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFJvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUgfSlcbiAgICBwcm90ZWN0ZWQgcm93TG9hZGluZ1RlbXBsYXRlOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlcyBhIHRlbXBsYXRlIGZvciB0aGUgcm93IGxvYWRpbmcgaW5kaWNhdG9yIHdoZW4gbG9hZCBvbiBkZW1hbmQgaXMgZW5hYmxlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNyb3dMb2FkaW5nVGVtcGxhdGU+XG4gICAgICogICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5sb29wPC9pZ3gtaWNvbj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqXG4gICAgICogPGlneC10cmVlLWdyaWQgI2dyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW3ByaW1hcnlLZXldPVwiJ0lEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIlxuICAgICAqICAgICAgICAgICAgICAgIFtsb2FkQ2hpbGRyZW5PbkRlbWFuZF09XCJsb2FkQ2hpbGRyZW5cIlxuICAgICAqICAgICAgICAgICAgICAgIFtyb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVdPVwicm93TG9hZGluZ1RlbXBsYXRlXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCByb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCByb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUodmFsdWU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHByb3ZpZGVzIGEgY2FsbGJhY2sgZm9yIGxvYWRpbmcgY2hpbGQgcm93cyBvbiBkZW1hbmQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIiBbbG9hZENoaWxkcmVuT25EZW1hbmRdPVwibG9hZENoaWxkcmVuXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgbG9hZENoaWxkcmVuID0gKHBhcmVudElEOiBhbnksIGRvbmU6IChjaGlsZHJlbjogYW55W10pID0+IHZvaWQpID0+IHtcbiAgICAgKiAgICAgdGhpcy5kYXRhU2VydmljZS5nZXREYXRhKHBhcmVudElELCBjaGlsZHJlbiA9PiBkb25lKGNoaWxkcmVuKSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGxvYWRDaGlsZHJlbk9uRGVtYW5kOiAocGFyZW50SUQ6IGFueSwgZG9uZTogKGNoaWxkcmVuOiBhbnlbXSkgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZGluZ1Jvd3MgPSBuZXcgU2V0PGFueT4oKTtcblxuICAgIC8vIEtpbmQgb2Ygc3R1cGlkXG4gICAgcHJpdmF0ZSBnZXQgX2dyaWRBUEkoKTogSWd4VHJlZUdyaWRBUElTZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSSBhcyBJZ3hUcmVlR3JpZEFQSVNlcnZpY2U7XG4gICAgfVxuICAgIHByaXZhdGUgX2ZpbHRlcmVkRGF0YSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZHJhZ0luZGljYXRvckljb25CYXNlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGRyYWdJbmRpY2F0b3JJY29uQmFzZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncmVjb3JkX3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHJlY29yZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdzdW1tYXJ5X3RlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJvdGVjdGVkIHN1bW1hcnlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5vblJvd1RvZ2dsZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRDaGlsZHJlbk9uUm93RXhwYW5zaW9uKGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIHN1cGVyLm5nRG9DaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5yb3dMb2FkaW5nVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZSA9IHRoaXMucm93TG9hZGluZ1RlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJDb250ZW50SW5pdCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9hZENoaWxkcmVuT25Sb3dFeHBhbnNpb24oYXJnczogSVJvd1RvZ2dsZUV2ZW50QXJncykge1xuICAgICAgICBpZiAodGhpcy5sb2FkQ2hpbGRyZW5PbkRlbWFuZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SUQgPSBhcmdzLnJvd0lEO1xuXG4gICAgICAgICAgICBpZiAoYXJncy5leHBhbmRlZCAmJiAhdGhpcy5fZXhwYW5zaW9uU3RhdGVzLmhhcyhwYXJlbnRJRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdSb3dzLmFkZChwYXJlbnRJRCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRDaGlsZHJlbk9uRGVtYW5kKHBhcmVudElELCBjaGlsZHJlbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1Jvd3MuZGVsZXRlKHBhcmVudElEKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZFJvd3MoY2hpbGRyZW4sIHBhcmVudElEKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZENoaWxkUm93cyhjaGlsZHJlbjogYW55W10sIHBhcmVudElEOiBhbnkpIHtcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeUtleSAmJiB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjaGlsZFt0aGlzLmZvcmVpZ25LZXldID0gcGFyZW50SUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCguLi5jaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZERhdGFLZXkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnJlY29yZHMuZ2V0KHBhcmVudElEKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnREYXRhID0gcGFyZW50LmRhdGE7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9ucy5lbmFibGVkICYmIHRoaXMudHJhbnNhY3Rpb25zLmdldEFnZ3JlZ2F0ZWRDaGFuZ2VzKHRydWUpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChwYXJlbnQucm93SUQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGxldCByZWNvcmQ6IGFueTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWQgPSBwYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICByZWNvcmQgPSBjb2xsZWN0aW9uLmZpbmQociA9PiByW3RoaXMucHJpbWFyeUtleV0gPT09IHBpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSByZWNvcmRbdGhpcy5jaGlsZERhdGFLZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERhdGEgPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJlbnREYXRhW3RoaXMuY2hpbGREYXRhS2V5XSA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5jbGVhckhlYWRlckNCU3RhdGUoKTtcbiAgICAgICAgdGhpcy5fcGlwZVRyaWdnZXIrKztcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb25lTWFwKG1hcEluOiBNYXA8YW55LCBib29sZWFuPik6IE1hcDxhbnksIGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgbWFwQ2xvbmVkOiBNYXA8YW55LCBib29sZWFuPiA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuXG4gICAgICAgIG1hcEluLmZvckVhY2goKHZhbHVlOiBib29sZWFuLCBrZXk6IGFueSwgbWFwT2JqOiBNYXA8YW55LCBib29sZWFuPikgPT4ge1xuXG4gICAgICAgICAgICBtYXBDbG9uZWQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbWFwQ2xvbmVkO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXREZWZhdWx0RXhwYW5kU3RhdGUocmVjb3JkOiBJVHJlZUdyaWRSZWNvcmQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC5jaGlsZHJlbiAmJiByZWNvcmQuY2hpbGRyZW4ubGVuZ3RoICYmIHJlY29yZC5sZXZlbCA8IHRoaXMuZXhwYW5zaW9uRGVwdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyBhbGwgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmV4cGFuZEFsbCgpO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBleHBhbmRBbGwoKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCByb3dzLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jb2xsYXBzZUFsbCgpO1xuICAgICAqICBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sbGFwc2VBbGwoKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gZGF0YS4gSWYgYSBwYXJlbnRSb3dJRCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbmV3bHkgY3JlYXRlZFxuICAgICAqIHJvdyB3b3VsZCBiZSBhZGRlZCBhdCB0aGUgcm9vdCBsZXZlbC4gT3RoZXJ3aXNlLCBpdCB3b3VsZCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIHRoZSByb3cgd2hvc2UgcHJpbWFyeUtleSBtYXRjaGVzXG4gICAgICogdGhlIHNwZWNpZmllZCBwYXJlbnRSb3dJRC4gSWYgdGhlIHBhcmVudFJvd0lEIGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3b3VsZCBiZSB0aHJvd24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgKiAgICAgSUQ6IHRoaXMuZ3JpZC5kYXRhW3RoaXMuZ3JpZDEuZGF0YS5sZW5ndGggLSAxXS5JRCArIDEsXG4gICAgICogICAgIE5hbWU6IHRoaXMubmV3UmVjb3JkXG4gICAgICogfTtcbiAgICAgKiB0aGlzLmdyaWQuYWRkUm93KHJlY29yZCwgMSk7IC8vIEFkZHMgYSBuZXcgY2hpbGQgcm93IHRvIHRoZSByb3cgd2l0aCBJRD0xLlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIHBhcmVudFJvd0lEXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGFkZFJvdyhkYXRhOiBhbnksIHBhcmVudFJvd0lEPzogYW55KSB7XG4gICAgICAgIGlmIChwYXJlbnRSb3dJRCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFJvd0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlci5lbmRFZGl0KHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMudHJhbnNhY3Rpb25zLmdldFN0YXRlKHBhcmVudFJvd0lEKTtcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBub3QgYWxsb3cgYWRkaW5nIG9mIHJvd3MgYXMgY2hpbGQgb2YgZGVsZXRlZCByb3dcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCBhZGQgY2hpbGQgcm93IHRvIGRlbGV0ZWQgcGFyZW50IHJvd2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSZWNvcmQgPSB0aGlzLnJlY29yZHMuZ2V0KHBhcmVudFJvd0lEKTtcblxuICAgICAgICAgICAgaWYgKCFwYXJlbnRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBwYXJlbnQgcm93IElEIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdW1tYXJ5U2VydmljZS5jbGVhclN1bW1hcnlDYWNoZSh7cm93SUQ6IHBhcmVudFJlY29yZC5yb3dJRH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeUtleSAmJiB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW3RoaXMuZm9yZWlnbktleV0gPSBwYXJlbnRSb3dJRDtcbiAgICAgICAgICAgICAgICBzdXBlci5hZGRSb3coZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudERhdGEgPSBwYXJlbnRSZWNvcmQuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHRoaXMuY2hpbGREYXRhS2V5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0lkID0gdGhpcy5wcmltYXJ5S2V5ID8gZGF0YVt0aGlzLnByaW1hcnlLZXldIDogZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aDogYW55W10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKC4uLnRoaXMuZ2VuZXJhdGVSb3dQYXRoKHBhcmVudFJvd0lEKSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChwYXJlbnRSb3dJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcm93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUcmFuc2FjdGlvblR5cGUuQUREXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudERhdGFbY2hpbGRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREYXRhW2NoaWxkS2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERhdGFbY2hpbGRLZXldLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25Sb3dBZGRlZC5lbWl0KHsgZGF0YSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9waXBlVHJpZ2dlcisrO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeUtleSAmJiB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dJRCA9IGRhdGFbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLmNsZWFyU3VtbWFyeUNhY2hlKHtyb3dJRDogcm93SUR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyLmFkZFJvdyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGRlbGV0ZVJvd0J5SWQocm93SWQ6IGFueSkge1xuICAgICAgICAvLyAgaWYgdGhpcyBpcyBmbGF0IHNlbGYtcmVmZXJlbmNpbmcgZGF0YSwgYW5kIENhc2NhZGVPbkRlbGV0ZSBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAvLyAgYW5kIGlmIHdlIGhhdmUgdHJhbnNhY3Rpb25zIHdlIHNob3VsZCBzdGFydCBwZW5kaW5nIHRyYW5zYWN0aW9uLiBUaGlzIGFsbG93c1xuICAgICAgICAvLyAgdXMgaW4gY2FzZSBvZiBkZWxldGUgYWN0aW9uIHRvIGRlbGV0ZSBhbGwgY2hpbGQgcm93cyBhcyBzaW5nbGUgdW5kbyBhY3Rpb25cbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5kZWxldGVSb3dCeUlkKHJvd0lkKTtcblxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdlbmVyYXRlUm93UGF0aChyb3dJZDogYW55KTogYW55W10ge1xuICAgICAgICBjb25zdCBwYXRoOiBhbnlbXSA9IFtdO1xuICAgICAgICBsZXQgcmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldChyb3dJZCk7XG5cbiAgICAgICAgd2hpbGUgKHJlY29yZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWNvcmQucGFyZW50LnJvd0lEKTtcbiAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RGF0YUJhc2VkQm9keUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gIXRoaXMuZmxhdERhdGEgfHwgKHRoaXMuZmxhdERhdGEubGVuZ3RoIDwgdGhpcy5fZGVmYXVsdFRhcmdldFJlY29yZE51bWJlcikgP1xuICAgICAgICAgICAgMCA6IHRoaXMuZGVmYXVsdFRhcmdldEJvZHlIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzY3JvbGxUbyhyb3c6IGFueSB8IG51bWJlciwgY29sdW1uOiBhbnkgfCBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGRlbGF5U2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZWNvcmQ6IElUcmVlR3JpZFJlY29yZDtcblxuICAgICAgICBpZiAodHlwZW9mKHJvdykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCByb3dEYXRhID0gcm93O1xuICAgICAgICAgICAgY29uc3Qgcm93SUQgPSB0aGlzLl9ncmlkQVBJLmdldF9yb3dfaWQocm93RGF0YSk7XG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLnByb2Nlc3NlZFJlY29yZHMuZ2V0KHJvd0lEKTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkuZXhwYW5kX3BhdGhfdG9fcmVjb3JkKHJlY29yZCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2luZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gdGhpcy5wcm9jZXNzZWRFeHBhbmRlZEZsYXREYXRhLmluZGV4T2Yocm93RGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IE1hdGguZmxvb3Iocm93SW5kZXggLyB0aGlzLnBlclBhZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFnZSAhPT0gcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheVNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGF5U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLm9uRGF0YUNoYW5nZWQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aXZlKHRoaXMudmVydGljYWxTY3JvbGxDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZihyb3cpID09PSAnbnVtYmVyJyA/IHJvdyA6IHRoaXMudW5waW5uZWREYXRhVmlldy5pbmRleE9mKHJlY29yZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERpcmVjdGl2ZSh0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHR5cGVvZihyb3cpID09PSAnbnVtYmVyJyA/IHJvdyA6IHRoaXMudW5waW5uZWREYXRhVmlldy5pbmRleE9mKHJlY29yZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY3JvbGxUb0hvcml6b250YWxseShjb2x1bW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29udGV4dChyb3dEYXRhOiBhbnksIHJvd0luZGV4OiBudW1iZXIsIHBpbm5lZD86IGJvb2xlYW4pOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB0aGlzLmlzR2hvc3RSZWNvcmQocm93RGF0YSkgPyByb3dEYXRhLnJlY29yZFJlZiA6IHJvd0RhdGEsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5nZXREYXRhVmlld0luZGV4KHJvd0luZGV4LCBwaW5uZWQpLFxuICAgICAgICAgICAgdGVtcGxhdGVJRDogdGhpcy5pc1N1bW1hcnlSb3cocm93RGF0YSkgPyAnc3VtbWFyeVJvdycgOiAnZGF0YVJvdycsXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5pc0dob3N0UmVjb3JkKHJvd0RhdGEpID8gcm93RGF0YS5yZWNvcmRSZWYuaXNGaWx0ZXJlZE91dFBhcmVudCA9PT0gdW5kZWZpbmVkIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldEluaXRpYWxQaW5uZWRJbmRleChyZWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpbm5lZFJlY29yZElEcy5pbmRleE9mKHJlYy5yb3dJRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZERhdGEoZm9ybWF0dGVycyA9IGZhbHNlLCBoZWFkZXJzID0gZmFsc2UpOiBhbnlbXSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBbXTtcblxuICAgICAgICBjb25zdCBwcm9jZXNzID0gKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlY29yZC5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2UucHVzaChyZWNvcmQuZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51bnBpbm5lZERhdGFWaWV3LmZvckVhY2gocHJvY2Vzcyk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuaXNSb3dQaW5uaW5nVG9Ub3AgPyBbLi4udGhpcy5waW5uZWREYXRhVmlldywgLi4uc291cmNlXSA6IFsuLi5zb3VyY2UsIC4uLnRoaXMucGlubmVkRGF0YVZpZXddO1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0RGF0YUZyb21TZWxlY3Rpb24oc291cmNlLCBmb3JtYXR0ZXJzLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0ZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyZWREYXRhICYmIHRoaXMuZmlsdGVyZWREYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgPyB0aGlzLmVtcHR5R3JpZFRlbXBsYXRlIDogdGhpcy5lbXB0eUZpbHRlcmVkR3JpZFRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nICYmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YUxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmdHcmlkVGVtcGxhdGUgPyB0aGlzLmxvYWRpbmdHcmlkVGVtcGxhdGUgOiB0aGlzLmxvYWRpbmdHcmlkRGVmYXVsdFRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgPyB0aGlzLmVtcHR5R3JpZFRlbXBsYXRlIDogdGhpcy5lbXB0eUdyaWREZWZhdWx0VGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgd3JpdGVUb0RhdGEocm93SW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkge1xuICAgICAgICBtZXJnZU9iamVjdHModGhpcy5mbGF0RGF0YVtyb3dJbmRleF0sIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICBwcm90ZWN0ZWQgaW5pdENvbHVtbnMoY29sbGVjdGlvbjogUXVlcnlMaXN0PElneENvbHVtbkNvbXBvbmVudD4sIGNiOiBGdW5jdGlvbiA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgLy8gaW52YWxpZCBjb25maWd1cmF0aW9uIC0gdHJlZSBncmlkIHNob3VsZCBub3QgYWxsb3cgY29sdW1uIGxheW91dHNcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjb2x1bW4gbGF5b3V0c1xuICAgICAgICAgICAgY29uc3Qgbm9uQ29sdW1uTGF5b3V0Q29sdW1ucyA9IHRoaXMuY29sdW1uTGlzdC5maWx0ZXIoKGNvbCkgPT4gIWNvbC5jb2x1bW5MYXlvdXQgJiYgIWNvbC5jb2x1bW5MYXlvdXRDaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkxpc3QucmVzZXQobm9uQ29sdW1uTGF5b3V0Q29sdW1ucyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuaW5pdENvbHVtbnMoY29sbGVjdGlvbiwgY2IpO1xuICAgIH1cbn1cbiJdfQ==