import { __values } from "tslib";
import { DateRangeType } from '../core/dates';
/**
 * @hidden
 */
var TimeDeltaInterval;
(function (TimeDeltaInterval) {
    TimeDeltaInterval["Month"] = "month";
    TimeDeltaInterval["Year"] = "year";
})(TimeDeltaInterval || (TimeDeltaInterval = {}));
var MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var FEBRUARY = 1;
export function range(start, stop, step) {
    if (start === void 0) { start = 0; }
    if (step === void 0) { step = 1; }
    var res = [];
    var cur = (stop === undefined) ? 0 : start;
    var max = (stop === undefined) ? start : stop;
    for (var i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param year
 * @returns
 */
export function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}
export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param year
 * @param month
 * @returns
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    var day = weekDay(year, month, 1);
    var nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}
export function isDateInRanges(date, ranges) {
    var e_1, _a, e_2, _b;
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    var dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    try {
        for (var ranges_1 = __values(ranges), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
            var descriptor = ranges_1_1.value;
            var dRanges = descriptor.dateRange ? descriptor.dateRange.map(function (r) { return new Date(r.getFullYear(), r.getMonth(), r.getDate()); }) : undefined;
            switch (descriptor.type) {
                case (DateRangeType.After):
                    if (dateInMs > dRanges[0].getTime()) {
                        return true;
                    }
                    break;
                case (DateRangeType.Before):
                    if (dateInMs < dRanges[0].getTime()) {
                        return true;
                    }
                    break;
                case (DateRangeType.Between):
                    var dRange = dRanges.map(function (d) { return d.getTime(); });
                    var min = Math.min(dRange[0], dRange[1]);
                    var max = Math.max(dRange[0], dRange[1]);
                    if (dateInMs >= min && dateInMs <= max) {
                        return true;
                    }
                    break;
                case (DateRangeType.Specific):
                    var datesInMs = dRanges.map(function (d) { return d.getTime(); });
                    try {
                        for (var datesInMs_1 = (e_2 = void 0, __values(datesInMs)), datesInMs_1_1 = datesInMs_1.next(); !datesInMs_1_1.done; datesInMs_1_1 = datesInMs_1.next()) {
                            var specificDateInMs = datesInMs_1_1.value;
                            if (dateInMs === specificDateInMs) {
                                return true;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (datesInMs_1_1 && !datesInMs_1_1.done && (_b = datesInMs_1.return)) _b.call(datesInMs_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    break;
                case (DateRangeType.Weekdays):
                    var day = date.getDay();
                    if (day % 6 !== 0) {
                        return true;
                    }
                    break;
                case (DateRangeType.Weekends):
                    var weekday = date.getDay();
                    if (weekday % 6 === 0) {
                        return true;
                    }
                    break;
                default:
                    return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ranges_1_1 && !ranges_1_1.done && (_a = ranges_1.return)) _a.call(ranges_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
export var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
var Calendar = /** @class */ (function () {
    function Calendar(firstWeekDay) {
        if (firstWeekDay === void 0) { firstWeekDay = WEEKDAYS.SUNDAY; }
        this._firstWeekDay = firstWeekDay;
    }
    Object.defineProperty(Calendar.prototype, "firstWeekDay", {
        get: function () {
            return this._firstWeekDay % 7;
        },
        set: function (value) {
            this._firstWeekDay = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    Calendar.prototype.weekdays = function () {
        var e_3, _a;
        var res = [];
        try {
            for (var _b = __values(range(this.firstWeekDay, this.firstWeekDay + 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var i = _c.value;
                res.push(i % 7);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
    };
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    Calendar.prototype.monthdates = function (year, month, extraWeek) {
        var e_4, _a;
        if (extraWeek === void 0) { extraWeek = false; }
        var date = new Date(year, month, 1);
        var days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        var res = [];
        var value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    try {
                        for (var _b = (e_4 = void 0, __values(range(0, 7))), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var _ = _c.value;
                            value = this.generateICalendarDate(date, year, month);
                            res.push(value);
                            date = this.timedelta(date, 'day', 1);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
                break;
            }
        }
        return res;
    };
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    Calendar.prototype.monthdatescalendar = function (year, month, extraWeek) {
        var e_5, _a;
        if (extraWeek === void 0) { extraWeek = false; }
        var dates = this.monthdates(year, month, extraWeek);
        var res = [];
        try {
            for (var _b = __values(range(0, dates.length, 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var i = _c.value;
                res.push(dates.slice(i, i + 7));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return res;
    };
    Calendar.prototype.timedelta = function (date, interval, units) {
        var ret = new Date(date);
        var checkRollover = function () {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    };
    Calendar.prototype.formatToParts = function (date, locale, options, parts) {
        var e_6, _a, e_7, _b;
        var formatter = new Intl.DateTimeFormat(locale, options);
        var result = {
            date: date,
            full: formatter.format(date)
        };
        if (formatter.formatToParts) {
            var formattedParts_1 = formatter.formatToParts(date);
            var toType = function (partType) {
                var index = formattedParts_1.findIndex(function (_a) {
                    var type = _a.type;
                    return type === partType;
                });
                var o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts_1[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts_1[index].value;
                o.literal = formattedParts_1[index + 1] ? formattedParts_1[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            try {
                for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                    var each = parts_1_1.value;
                    result[each] = toType(each);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        else {
            try {
                for (var parts_2 = __values(parts), parts_2_1 = parts_2.next(); !parts_2_1.done; parts_2_1 = parts_2.next()) {
                    var each = parts_2_1.value;
                    result[each] = { value: '', literal: '', combined: '' };
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (parts_2_1 && !parts_2_1.done && (_b = parts_2.return)) _b.call(parts_2);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
        return result;
    };
    Calendar.prototype.getFirstViewDate = function (date, interval, activeViewIdx) {
        return this.timedelta(date, interval, -activeViewIdx);
    };
    Calendar.prototype.getNextMonth = function (date) {
        return this.timedelta(date, TimeDeltaInterval.Month, 1);
    };
    Calendar.prototype.getPrevMonth = function (date) {
        return this.timedelta(date, TimeDeltaInterval.Month, -1);
    };
    Calendar.prototype.getNextYear = function (date) {
        return this.timedelta(date, TimeDeltaInterval.Year, 1);
    };
    Calendar.prototype.getPrevYear = function (date) {
        return this.timedelta(date, TimeDeltaInterval.Year, -1);
    };
    Calendar.prototype.generateICalendarDate = function (date, year, month) {
        return {
            date: date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    };
    Calendar.prototype.isPreviousMonth = function (date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    };
    Calendar.prototype.isNextMonth = function (date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    };
    return Calendar;
}());
export { Calendar };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NhbGVuZGFyL2NhbGVuZGFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQXVCLGFBQWEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVuRTs7R0FFRztBQUNILElBQUssaUJBR0o7QUFIRCxXQUFLLGlCQUFpQjtJQUNsQixvQ0FBZSxDQUFBO0lBQ2Ysa0NBQWEsQ0FBQTtBQUNqQixDQUFDLEVBSEksaUJBQWlCLEtBQWpCLGlCQUFpQixRQUdyQjtBQUVELElBQU0sS0FBSyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMvRCxJQUFNLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFFbkIsTUFBTSxVQUFVLEtBQUssQ0FBQyxLQUFTLEVBQUUsSUFBSSxFQUFFLElBQVE7SUFBekIsc0JBQUEsRUFBQSxTQUFTO0lBQVEscUJBQUEsRUFBQSxRQUFRO0lBQzNDLElBQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQztJQUNmLElBQU0sR0FBRyxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUM3QyxJQUFNLEdBQUcsR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDaEQsS0FBSyxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxD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QUFDLFFBQVEsRUFBRSxHQUFHLEtBQUssQ0FBQztTQUNsQztRQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQztJQUNyQyxDQUFDO0lBRU8sOEJBQVcsR0FBbkIsVUFBb0IsSUFBVSxFQUFFLElBQVksRUFBRSxLQUFhO1FBQ3ZELElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM3QixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUM7U0FDbEM7UUFFRCxPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUM7SUFDckMsQ0FBQztJQUNMLGVBQUM7QUFBRCxDQUFDLEFBNU5ELElBNE5DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0ZVJhbmdlRGVzY3JpcHRvciwgRGF0ZVJhbmdlVHlwZSB9IGZyb20gJy4uL2NvcmUvZGF0ZXMnO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZW51bSBUaW1lRGVsdGFJbnRlcnZhbCB7XG4gICAgTW9udGggPSAnbW9udGgnLFxuICAgIFllYXIgPSAneWVhcidcbn1cblxuY29uc3QgTURBWVMgPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5jb25zdCBGRUJSVUFSWSA9IDE7XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShzdGFydCA9IDAsIHN0b3AsIHN0ZXAgPSAxKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgY3VyID0gKHN0b3AgPT09IHVuZGVmaW5lZCkgPyAwIDogc3RhcnQ7XG4gICAgY29uc3QgbWF4ID0gKHN0b3AgPT09IHVuZGVmaW5lZCkgPyBzdGFydCA6IHN0b3A7XG4gICAgZm9yIChsZXQgaSA9IGN1cjsgc3RlcCA8IDAgPyBpID4gbWF4IDogaSA8IG1heDsgaSArPSBzdGVwKSB7XG4gICAgICAgIHJlcy5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBmb3IgbGVhcCB5ZWFycywgZmFsc2UgZm9yIG5vbi1sZWFwIHllYXJzLlxuICpcbiAqIEBleHBvcnRcbiAqIEBwYXJhbSB5ZWFyXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMZWFwKHllYXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDApICYmICgoeWVhciAlIDEwMCAhPT0gMCkgfHwgKHllYXIgJSA0MDAgPT09IDApKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtEYXkoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXkpLmdldERheSgpO1xufVxuXG4vKipcbiAqIFJldHVybiB3ZWVrZGF5IGFuZCBudW1iZXIgb2YgZGF5cyBmb3IgeWVhciwgbW9udGguXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHllYXJcbiAqIEBwYXJhbSBtb250aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vbnRoUmFuZ2UoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIGlmICgobW9udGggPCAwKSB8fCAobW9udGggPiAxMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vbnRoIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBjb25zdCBkYXkgPSB3ZWVrRGF5KHllYXIsIG1vbnRoLCAxKTtcbiAgICBsZXQgbkRheXMgPSBNREFZU1ttb250aF07XG4gICAgaWYgKChtb250aCA9PT0gRkVCUlVBUlkpICYmIChpc0xlYXAoeWVhcikpKSB7XG4gICAgICAgIG5EYXlzKys7XG4gICAgfVxuICAgIHJldHVybiBbZGF5LCBuRGF5c107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGVJblJhbmdlcyhkYXRlOiBEYXRlLCByYW5nZXM6IERhdGVSYW5nZURlc2NyaXB0b3JbXSk6IGJvb2xlYW4ge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgIGNvbnN0IGRhdGVJbk1zID0gZGF0ZS5nZXRUaW1lKCk7XG5cbiAgICBpZiAoIXJhbmdlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIHJhbmdlcykge1xuICAgICAgICBjb25zdCBkUmFuZ2VzID0gZGVzY3JpcHRvci5kYXRlUmFuZ2UgPyBkZXNjcmlwdG9yLmRhdGVSYW5nZS5tYXAoXG4gICAgICAgICAgICByID0+IG5ldyBEYXRlKHIuZ2V0RnVsbFllYXIoKSwgci5nZXRNb250aCgpLCByLmdldERhdGUoKSkpIDogdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKGRlc2NyaXB0b3IudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAoRGF0ZVJhbmdlVHlwZS5BZnRlcik6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVJbk1zID4gZFJhbmdlc1swXS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChEYXRlUmFuZ2VUeXBlLkJlZm9yZSk6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVJbk1zIDwgZFJhbmdlc1swXS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChEYXRlUmFuZ2VUeXBlLkJldHdlZW4pOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRSYW5nZSA9IGRSYW5nZXMubWFwKGQgPT4gZC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKGRSYW5nZVswXSwgZFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChkUmFuZ2VbMF0sIGRSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVJbk1zID49IG1pbiAmJiBkYXRlSW5NcyA8PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChEYXRlUmFuZ2VUeXBlLlNwZWNpZmljKTpcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlc0luTXMgPSBkUmFuZ2VzLm1hcChkID0+IGQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmljRGF0ZUluTXMgb2YgZGF0ZXNJbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlSW5NcyA9PT0gc3BlY2lmaWNEYXRlSW5Ncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKERhdGVSYW5nZVR5cGUuV2Vla2RheXMpOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRheSA9IGRhdGUuZ2V0RGF5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGRheSAlIDYgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIChEYXRlUmFuZ2VUeXBlLldlZWtlbmRzKTpcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWVrZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSAlIDYgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ2FsZW5kYXJEYXRlIHtcbiAgICBkYXRlOiBEYXRlO1xuICAgIGlzQ3VycmVudE1vbnRoOiBib29sZWFuO1xuICAgIGlzUHJldk1vbnRoOiBib29sZWFuO1xuICAgIGlzTmV4dE1vbnRoOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGb3JtYXR0ZWRQYXJ0cyB7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgICBsaXRlcmFsPzogc3RyaW5nO1xuICAgIGNvbWJpbmVkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvcm1hdHRpbmdPcHRpb25zIHtcbiAgICBkYXk/OiBzdHJpbmc7XG4gICAgbW9udGg/OiBzdHJpbmc7XG4gICAgd2Vla2RheT86IHN0cmluZztcbiAgICB5ZWFyPzogc3RyaW5nO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgSUZvcm1hdHRpbmdWaWV3cyB7XG4gICAgZGF5PzogYm9vbGVhbjtcbiAgICBtb250aD86IGJvb2xlYW47XG4gICAgeWVhcj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIFdFRUtEQVlTIHtcbiAgICBTVU5EQVkgPSAwLFxuICAgIE1PTkRBWSA9IDEsXG4gICAgVFVFU0RBWSA9IDIsXG4gICAgV0VETkVTREFZID0gMyxcbiAgICBUSFVSU0RBWSA9IDQsXG4gICAgRlJJREFZID0gNSxcbiAgICBTQVRVUkRBWSA9IDZcbn1cblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyIHtcblxuICAgIHByaXZhdGUgX2ZpcnN0V2Vla0RheTogbnVtYmVyIHwgV0VFS0RBWVM7XG5cbiAgICBjb25zdHJ1Y3RvcihmaXJzdFdlZWtEYXk6IG51bWJlciB8IFdFRUtEQVlTID0gV0VFS0RBWVMuU1VOREFZKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0V2Vla0RheSA9IGZpcnN0V2Vla0RheTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGZpcnN0V2Vla0RheSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3RXZWVrRGF5ICUgNztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGZpcnN0V2Vla0RheSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0V2Vla0RheSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygd2Vla2RheXMgZm9yIG9uZSB3ZWVrIHN0YXJ0aW5nXG4gICAgICogd2l0aCB0aGUgY3VycmVudGx5IHNldCBgZmlyc3RXZWVrRGF5YFxuICAgICAqXG4gICAgICogdGhpcy5maXJzdFdlZWtEYXkgPSAwIChTdW5kYXkpIC0tPiBbMCwgMSwgMiwgMywgNCwgNSwgNl1cbiAgICAgKiB0aGlzLmZpcnN0V2Vla0RheSA9IDEgKE1vbmRheSkgLS0+IFsxLCAyLCAzLCA0LCA1LCA2LCAwXVxuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBDYWxlbmRhclxuICAgICAqL1xuICAgIHB1YmxpYyB3ZWVrZGF5cygpOiBudW1iZXJbXSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5maXJzdFdlZWtEYXksIHRoaXMuZmlyc3RXZWVrRGF5ICsgNykpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGkgJSA3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgdmFsdWVzIGZvciBvbmUgbW9udGguIEl0IHdpbGwgYWx3YXlzIGl0ZXJhdGUgdGhyb3VnaHRcbiAgICAgKiBjb21wbGV0ZSB3ZWVrcywgc28gaXQgd2lsbCBjb250YWluIGRhdGVzIG91dHNpZGUgdGhlIHNwZWNpZmllZCBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHBhcmFtIGJvb2xlYW5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENhbGVuZGFyXG4gICAgICovXG4gICAgcHVibGljIG1vbnRoZGF0ZXMoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBleHRyYVdlZWs6IGJvb2xlYW4gPSBmYWxzZSk6IElDYWxlbmRhckRhdGVbXSB7XG4gICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xuICAgICAgICBsZXQgZGF5cyA9IChkYXRlLmdldERheSgpIC0gdGhpcy5maXJzdFdlZWtEYXkpICUgNztcbiAgICAgICAgaWYgKGRheXMgPCAwKSB7XG4gICAgICAgICAgICBkYXlzID0gNyAtIE1hdGguYWJzKGRheXMpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGUgPSB0aGlzLnRpbWVkZWx0YShkYXRlLCAnZGF5JywgLWRheXMpO1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgbGV0IHZhbHVlOiBJQ2FsZW5kYXJEYXRlO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZW5lcmF0ZUlDYWxlbmRhckRhdGUoZGF0ZSwgeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgcmVzLnB1c2godmFsdWUpO1xuXG4gICAgICAgICAgICBkYXRlID0gdGhpcy50aW1lZGVsdGEoZGF0ZSwgJ2RheScsIDEpO1xuXG4gICAgICAgICAgICBpZiAoKGRhdGUuZ2V0TW9udGgoKSAhPT0gbW9udGgpICYmIChkYXRlLmdldERheSgpID09PSB0aGlzLmZpcnN0V2Vla0RheSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFXZWVrICYmIHJlcy5sZW5ndGggPD0gMzUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBfIG9mIHJhbmdlKDAsIDcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2VuZXJhdGVJQ2FsZW5kYXJEYXRlKGRhdGUsIHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLnRpbWVkZWx0YShkYXRlLCAnZGF5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWF0cml4IChhcnJheSBvZiBhcnJheXMpIHJlcHJlc2VudGluZyBhIG1vbnRoJ3MgY2FsZW5kYXIuXG4gICAgICogRWFjaCByb3cgcmVwcmVzZW50cyBhIGZ1bGwgd2Vlazsgd2VlayBlbnRyaWVzIGFyZSBJQ2FsZW5kYXJEYXRlIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aFxuICAgICAqIEByZXR1cm5zXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgQ2FsZW5kYXJcbiAgICAgKi9cbiAgICBwdWJsaWMgbW9udGhkYXRlc2NhbGVuZGFyKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZXh0cmFXZWVrOiBib29sZWFuID0gZmFsc2UpOiBJQ2FsZW5kYXJEYXRlW11bXSB7XG4gICAgICAgIGNvbnN0IGRhdGVzID0gdGhpcy5tb250aGRhdGVzKHllYXIsIG1vbnRoLCBleHRyYVdlZWspO1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKDAsIGRhdGVzLmxlbmd0aCwgNykpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGRhdGVzLnNsaWNlKGksIGkgKyA3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgdGltZWRlbHRhKGRhdGU6IERhdGUsIGludGVydmFsOiBzdHJpbmcsIHVuaXRzOiBudW1iZXIpOiBEYXRlIHtcbiAgICAgICAgY29uc3QgcmV0ID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICAgICAgY29uc3QgY2hlY2tSb2xsb3ZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXQuZ2V0RGF0ZSgpICE9PSBkYXRlLmdldERhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldC5zZXREYXRlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAoaW50ZXJ2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgcmV0LnNldEZ1bGxZZWFyKHJldC5nZXRGdWxsWWVhcigpICsgdW5pdHMpO1xuICAgICAgICAgICAgICAgIGNoZWNrUm9sbG92ZXIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIDMgKiB1bml0cyk7XG4gICAgICAgICAgICAgICAgY2hlY2tSb2xsb3ZlcigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRNb250aChyZXQuZ2V0TW9udGgoKSArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBjaGVja1JvbGxvdmVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0RGF0ZShyZXQuZ2V0RGF0ZSgpICsgNyAqIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgcmV0LnNldERhdGUocmV0LmdldERhdGUoKSArIHVuaXRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDM2MDAwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICByZXQuc2V0VGltZShyZXQuZ2V0VGltZSgpICsgdW5pdHMgKiA2MDAwMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHJldC5zZXRUaW1lKHJldC5nZXRUaW1lKCkgKyB1bml0cyAqIDEwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZXJ2YWwgc3BlY2lmaWVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZm9ybWF0VG9QYXJ0cyhkYXRlOiBEYXRlLCBsb2NhbGU6IHN0cmluZywgb3B0aW9uczogYW55LCBwYXJ0czogc3RyaW5nW10pIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGZ1bGw6IGZvcm1hdHRlci5mb3JtYXQoZGF0ZSlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoKGZvcm1hdHRlciBhcyBhbnkpLmZvcm1hdFRvUGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFBhcnRzID0gKGZvcm1hdHRlciBhcyBhbnkpLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvVHlwZSA9IChwYXJ0VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBmb3JtYXR0ZWRQYXJ0cy5maW5kSW5kZXgoKHsgdHlwZSB9KSA9PiB0eXBlID09PSBwYXJ0VHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbzogSUZvcm1hdHRlZFBhcnRzID0geyB2YWx1ZTogJycsIGxpdGVyYWw6ICcnLCBjb21iaW5lZDogJycgfTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJ0VHlwZSA9PT0gJ2VyYScgJiYgaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvLnZhbHVlID0gZm9ybWF0dGVkUGFydHNbaW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRUeXBlID09PSAnZXJhJyAmJiBpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgby52YWx1ZSA9IGZvcm1hdHRlZFBhcnRzW2luZGV4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICBvLmxpdGVyYWwgPSBmb3JtYXR0ZWRQYXJ0c1tpbmRleCArIDFdID8gZm9ybWF0dGVkUGFydHNbaW5kZXggKyAxXS52YWx1ZSA6ICcnO1xuICAgICAgICAgICAgICAgIG8uY29tYmluZWQgPSBbby52YWx1ZSwgby5saXRlcmFsXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZWFjaCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlYWNoXSA9IHRvVHlwZShlYWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWFjaCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlYWNoXSA9IHsgdmFsdWU6ICcnLCBsaXRlcmFsOiAnJywgY29tYmluZWQ6ICcnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Rmlyc3RWaWV3RGF0ZShkYXRlOiBEYXRlLCBpbnRlcnZhbDogc3RyaW5nLCBhY3RpdmVWaWV3SWR4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZWRlbHRhKGRhdGUsIGludGVydmFsLCAtYWN0aXZlVmlld0lkeCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldE5leHRNb250aChkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5Nb250aCwgMSk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFByZXZNb250aChkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5Nb250aCwgLTEpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXROZXh0WWVhcihkYXRlOiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVkZWx0YShkYXRlLCBUaW1lRGVsdGFJbnRlcnZhbC5ZZWFyLCAxKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UHJldlllYXIoZGF0ZTogRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lZGVsdGEoZGF0ZSwgVGltZURlbHRhSW50ZXJ2YWwuWWVhciwgLTEpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVJQ2FsZW5kYXJEYXRlKGRhdGU6IERhdGUsIHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IElDYWxlbmRhckRhdGUge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGlzQ3VycmVudE1vbnRoOiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSBtb250aCxcbiAgICAgICAgICAgIGlzTmV4dE1vbnRoOiB0aGlzLmlzTmV4dE1vbnRoKGRhdGUsIHllYXIsIG1vbnRoKSxcbiAgICAgICAgICAgIGlzUHJldk1vbnRoOiB0aGlzLmlzUHJldmlvdXNNb250aChkYXRlLCB5ZWFyLCBtb250aClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzUHJldmlvdXNNb250aChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0geWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSA8IG1vbnRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgPCB5ZWFyO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNOZXh0TW9udGgoZGF0ZTogRGF0ZSwgeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLmdldE1vbnRoKCkgPiBtb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgPiB5ZWFyO1xuICAgIH1cbn1cbiJdfQ==