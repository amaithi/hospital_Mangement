import { __decorate, __extends } from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, ContentChild, AfterViewInit, AfterContentInit } from '@angular/core';
import { IgxProcessBarTextTemplateDirective, IgxProgressBarGradientDirective, } from './progressbar.common';
import { IgxDirectionality } from '../services/direction/directionality';
var ONE_PERCENT = 0.01;
var MIN_VALUE = 0;
export var IgxTextAlign;
(function (IgxTextAlign) {
    IgxTextAlign["START"] = "start";
    IgxTextAlign["CENTER"] = "center";
    IgxTextAlign["END"] = "end";
})(IgxTextAlign || (IgxTextAlign = {}));
export var IgxProgressType;
(function (IgxProgressType) {
    IgxProgressType["ERROR"] = "error";
    IgxProgressType["INFO"] = "info";
    IgxProgressType["WARNING"] = "warning";
    IgxProgressType["SUCCESS"] = "success";
})(IgxProgressType || (IgxProgressType = {}));
/**
 * @hidden
 */
var BaseProgress = /** @class */ (function () {
    function BaseProgress() {
        this.requestAnimationId = undefined;
        this._initValue = 0;
        this._contentInit = false;
        this._valueInPercent = MIN_VALUE;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
    }
    Object.defineProperty(BaseProgress.prototype, "step", {
        /**
         * Returns the value which update the progress indicator of the `progress bar`.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
         * public stepValue(event) {
         *     let step = this.progressBar.step;
         *     alert(step);
         * }
         * ```
         */
        get: function () {
            if (this._step) {
                return this._step;
            }
            return this._max * ONE_PERCENT;
        },
        /**
         * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         * ```html
         * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
         * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
         * ```
         */
        set: function (val) {
            this._step = Number(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseProgress.prototype, "animate", {
        /**
         * Returns whether the `progress bar` has animation true/false.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
         * public animationStatus(event) {
         *     let animationStatus = this.progressBar.animate;
         *     alert(animationStatus);
         * }
         * ```
         */
        get: function () {
            return this._animate;
        },
        /**
         * Animating the progress. By default it is set to true.
         * ```html
         * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
         * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
         * ```
         */
        set: function (animate) {
            this._animate = animate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseProgress.prototype, "max", {
        /**
         * Returns the the maximum progress value of the `progress bar`.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
         * public maxValue(event) {
         *     let max = this.progressBar.max;
         *     alert(max);
         * }
         * ```
         */
        get: function () {
            return this._max;
        },
        /**
         * Set maximum value that can be passed. By default it is set to 100.
         * ```html
         * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
         * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
         * ```
         */
        set: function (maxNum) {
            this._max = maxNum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseProgress.prototype, "valueInPercent", {
        /**
         * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         * public valuePercent(event){
         *     let percentValue = this.progressBar.valueInPercent;
         *     alert(percentValue);
         * }
         * ```
         */
        get: function () {
            return this._valueInPercent;
        },
        /**
         * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *     public setValue(event){
         *     this.progressBar.valueInPercent = 56;
         * }
         * ```
         */
        set: function (value) {
            this._valueInPercent = value;
        },
        enumerable: true,
        configurable: true
    });
    BaseProgress.prototype.triggerProgressTransition = function (oldVal, newVal) {
        if (oldVal === newVal) {
            return;
        }
        var changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        var stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            this.runAnimation(newVal, stepDirection);
        }
        else {
            this.updateProgressDirectly(newVal);
        }
        this.onProgressChanged.emit(changedValues);
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.runAnimation = function (val, step) {
        var _this = this;
        this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.updateProgressSmoothly = function (val, step) {
        var _this = this;
        this._value = valueInRange(this._value, this._max) + step;
        var passedValue = toPercent(val, this._max);
        var progressValue = toPercent(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
        }
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.updateProgressDirectly = function (val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.directionFlow = function (currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    };
    /**
     * @hidden
     */
    BaseProgress.prototype.isInLimitRange = function (val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    };
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    BaseProgress.prototype.isExceedingUpperLimit = function (val, comparator, step) {
        return val > comparator && step > 0;
    };
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    BaseProgress.prototype.isExceedingLowerLimit = function (val, comparator, step) {
        return val < comparator && step < 0;
    };
    /**
     * @hidden
     * @param step
     */
    BaseProgress.prototype.updateProgress = function (val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    };
    __decorate([
        Output()
    ], BaseProgress.prototype, "onProgressChanged", void 0);
    __decorate([
        Input()
    ], BaseProgress.prototype, "step", null);
    __decorate([
        Input()
    ], BaseProgress.prototype, "animate", null);
    __decorate([
        HostBinding('attr.aria-valuemax'),
        Input()
    ], BaseProgress.prototype, "max", null);
    return BaseProgress;
}());
export { BaseProgress };
var NEXT_LINEAR_ID = 0;
var NEXT_CIRCULAR_ID = 0;
var NEXT_GRADIENT_ID = 0;
var IgxLinearProgressBarComponent = /** @class */ (function (_super) {
    __extends(IgxLinearProgressBarComponent, _super);
    function IgxLinearProgressBarComponent() {
        var _this = _super.call(this) || this;
        _this.valueMin = 0;
        _this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        _this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        _this.indeterminate = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        _this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        _this.id = "igx-linear-bar-" + NEXT_LINEAR_ID++;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        _this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        _this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        _this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        _this.type = 'default';
        return _this;
    }
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "value", {
        /**
         * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public getValue(event) {
         *     let value = this.progressBar.value;
         *     alert(value);
         * }
         * ```
         */
        get: function () {
            return this._value;
        },
        /**
         * Set value that indicates the current `IgxLinearProgressBarComponent` position.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        set: function (val) {
            var valInRange = valueInRange(val, this.max);
            if (isNaN(valInRange) || this._value === val || this.indeterminate) {
                return;
            }
            if (this._contentInit) {
                this.triggerProgressTransition(this._value, valInRange);
            }
            else {
                this._initValue = valInRange;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "error", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.ERROR;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "info", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.INFO;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "warning", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.WARNING;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "success", {
        /**
         * @hidden
         */
        get: function () {
            return this.type === IgxProgressType.SUCCESS;
        },
        enumerable: true,
        configurable: true
    });
    IgxLinearProgressBarComponent.prototype.ngAfterContentInit = function () {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    };
    __decorate([
        HostBinding('attr.aria-valuemin')
    ], IgxLinearProgressBarComponent.prototype, "valueMin", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar')
    ], IgxLinearProgressBarComponent.prototype, "cssClass", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar--striped'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "striped", void 0);
    __decorate([
        HostBinding('class.igx-linear-bar--indeterminate'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "indeterminate", void 0);
    __decorate([
        HostBinding('attr.role'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "role", void 0);
    __decorate([
        HostBinding('attr.id'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "id", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "textAlign", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "textVisibility", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "textTop", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "text", void 0);
    __decorate([
        Input()
    ], IgxLinearProgressBarComponent.prototype, "type", void 0);
    __decorate([
        HostBinding('attr.aria-valuenow'),
        Input()
    ], IgxLinearProgressBarComponent.prototype, "value", null);
    __decorate([
        HostBinding('class.igx-linear-bar--danger')
    ], IgxLinearProgressBarComponent.prototype, "error", null);
    __decorate([
        HostBinding('class.igx-linear-bar--info')
    ], IgxLinearProgressBarComponent.prototype, "info", null);
    __decorate([
        HostBinding('class.igx-linear-bar--warning')
    ], IgxLinearProgressBarComponent.prototype, "warning", null);
    __decorate([
        HostBinding('class.igx-linear-bar--success')
    ], IgxLinearProgressBarComponent.prototype, "success", null);
    IgxLinearProgressBarComponent = __decorate([
        Component({
            selector: 'igx-linear-bar',
            template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
        })
    ], IgxLinearProgressBarComponent);
    return IgxLinearProgressBarComponent;
}(BaseProgress));
export { IgxLinearProgressBarComponent };
var IgxCircularProgressBarComponent = /** @class */ (function (_super) {
    __extends(IgxCircularProgressBarComponent, _super);
    function IgxCircularProgressBarComponent(renderer, _directionality) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this._directionality = _directionality;
        _this.STROKE_OPACITY_DVIDER = 100;
        _this.STROKE_OPACITY_ADDITION = .2;
        /** @hidden */
        _this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        _this.id = "igx-circular-bar-" + NEXT_CIRCULAR_ID++;
        /**
         * @hidden
         */
        _this.gradientId = "igx-circular-gradient-" + NEXT_GRADIENT_ID++;
        /**
         * An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        _this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        _this.textVisibility = true;
        _this._circleRadius = 46;
        _this._circumference = 2 * Math.PI * _this._circleRadius;
        return _this;
    }
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "context", {
        /**
         * @hidden
         */
        get: function () {
            return {
                $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "value", {
        /**
         * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
         * ```typescript
         *  @ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public getValue(event) {
         *     let value = this.progressBar.value;
         *     alert(value);
         * }
         * ```
         * ```html
         * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
         * ```
         */
        get: function () {
            return this._value;
        },
        /**
         * Set value that indicates the current `IgxCircularProgressBarComponent` position.
         * ```html
         * <igx-circular-bar [value]="50"></igx-circular-bar>
         * ```
         */
        set: function (val) {
            var valInRange = valueInRange(val, this.max);
            if (isNaN(valInRange) || this._value === val || this.indeterminate) {
                return;
            }
            if (this._contentInit) {
                this.triggerProgressTransition(this._value, valInRange);
            }
            else {
                this._initValue = valInRange;
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxCircularProgressBarComponent.prototype.ngAfterContentInit = function () {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    };
    IgxCircularProgressBarComponent.prototype.ngAfterViewInit = function () {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', "url(#" + this.gradientId + ")");
    };
    /**
     * @hidden
     */
    IgxCircularProgressBarComponent.prototype.updateProgressSmoothly = function (val, step) {
        // Set frames for the animation
        var FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        _super.prototype.updateProgressSmoothly.call(this, val, step);
    };
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "textContent", {
        /**
         * @hidden
         */
        get: function () {
            return this.text;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    IgxCircularProgressBarComponent.prototype.updateProgressDirectly = function (val) {
        _super.prototype.updateProgressDirectly.call(this, val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    };
    IgxCircularProgressBarComponent.prototype.getProgress = function (percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    };
    IgxCircularProgressBarComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: IgxDirectionality }
    ]; };
    __decorate([
        HostBinding('class.igx-circular-bar')
    ], IgxCircularProgressBarComponent.prototype, "cssClass", void 0);
    __decorate([
        HostBinding('attr.id'),
        Input()
    ], IgxCircularProgressBarComponent.prototype, "id", void 0);
    __decorate([
        HostBinding('class.igx-circular-bar--indeterminate'),
        Input()
    ], IgxCircularProgressBarComponent.prototype, "indeterminate", void 0);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "textVisibility", void 0);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "text", void 0);
    __decorate([
        ContentChild(IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective })
    ], IgxCircularProgressBarComponent.prototype, "textTemplate", void 0);
    __decorate([
        ContentChild(IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective })
    ], IgxCircularProgressBarComponent.prototype, "gradientTemplate", void 0);
    __decorate([
        Input()
    ], IgxCircularProgressBarComponent.prototype, "value", null);
    __decorate([
        ViewChild('circle', { static: true })
    ], IgxCircularProgressBarComponent.prototype, "_svgCircle", void 0);
    IgxCircularProgressBarComponent = __decorate([
        Component({
            selector: 'igx-circular-bar',
            template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
        })
    ], IgxCircularProgressBarComponent);
    return IgxCircularProgressBarComponent;
}(BaseProgress));
export { IgxCircularProgressBarComponent };
export function valueInRange(value, max, min) {
    if (min === void 0) { min = 0; }
    return Math.max(Math.min(value, max), min);
}
export function toPercent(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
var IgxProgressBarModule = /** @class */ (function () {
    function IgxProgressBarModule() {
    }
    IgxProgressBarModule = __decorate([
        NgModule({
            declarations: [
                IgxLinearProgressBarComponent,
                IgxCircularProgressBarComponent,
                IgxProcessBarTextTemplateDirective,
                IgxProgressBarGradientDirective,
            ],
            exports: [
                IgxLinearProgressBarComponent,
                IgxCircularProgressBarComponent,
                IgxProcessBarTextTemplateDirective,
                IgxProgressBarGradientDirective,
            ],
            imports: [CommonModule]
        })
    ], IgxProgressBarModule);
    return IgxProgressBarModule;
}());
export { IgxProgressBarModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUNaLGFBQWEsRUFDYixnQkFBZ0IsRUFDbkIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNILGtDQUFrQyxFQUNsQywrQkFBK0IsR0FDbEMsTUFBTSxzQkFBc0IsQ0FBQztBQUU5QixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUV6RSxJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDekIsSUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFDO0FBRXBCLE1BQU0sQ0FBTixJQUFZLFlBSVg7QUFKRCxXQUFZLFlBQVk7SUFDcEIsK0JBQWUsQ0FBQTtJQUNmLGlDQUFpQixDQUFBO0lBQ2pCLDJCQUFXLENBQUE7QUFDZixDQUFDLEVBSlcsWUFBWSxLQUFaLFlBQVksUUFJdkI7QUFFRCxNQUFNLENBQU4sSUFBWSxlQUtYO0FBTEQsV0FBWSxlQUFlO0lBQ3ZCLGtDQUFlLENBQUE7SUFDZixnQ0FBYSxDQUFBO0lBQ2Isc0NBQW1CLENBQUE7SUFDbkIsc0NBQW1CLENBQUE7QUFDdkIsQ0FBQyxFQUxXLGVBQWUsS0FBZixlQUFlLFFBSzFCO0FBT0Q7O0dBRUc7QUFDSDtJQUFBO1FBQ1ksdUJBQWtCLEdBQVcsU0FBUyxDQUFDO1FBRXJDLGVBQVUsR0FBRyxDQUFDLENBQUM7UUFDZixpQkFBWSxHQUFHLEtBQUssQ0FBQztRQUNyQixvQkFBZSxHQUFHLFNBQVMsQ0FBQztRQUM1QixTQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ1gsV0FBTSxHQUFHLFNBQVMsQ0FBQztRQUNuQixZQUFPLEdBQUcsU0FBUyxDQUFDO1FBQ3BCLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFHMUI7Ozs7Ozs7Ozs7OztXQVlHO1FBRUksc0JBQWlCLEdBQUcsSUFBSSxZQUFZLEVBQTRCLENBQUM7SUF5TjVFLENBQUM7SUEzTUcsc0JBQUksOEJBQUk7UUFaUjs7Ozs7Ozs7OztXQVVHO2FBRUg7WUFDSSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO2FBQ3JCO1lBRUQsT0FBTyxJQUFJLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQztRQUNuQyxDQUFDO1FBRUQ7Ozs7OztXQU1HO2FBQ0gsVUFBUyxHQUFXO1lBQ2hCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLENBQUM7OztPQVhBO0lBcUJELHNCQUFXLGlDQUFPO1FBSWxCOzs7Ozs7Ozs7O1dBVUc7YUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN6QixDQUFDO1FBekJEOzs7Ozs7V0FNRzthQUVILFVBQW1CLE9BQWdCO1lBQy9CLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBMEJELHNCQUFJLDZCQUFHO1FBSVA7Ozs7Ozs7Ozs7V0FVRzthQUNIO1lBQ0ksT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ3JCLENBQUM7UUExQkQ7Ozs7OztXQU1HO2FBR0gsVUFBUSxNQUFjO1lBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7OztPQUFBO0lBMkJELHNCQUFXLHdDQUFjO1FBSXpCOzs7Ozs7Ozs7O1dBVUc7YUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUNoQyxDQUFDO1FBM0JEOzs7Ozs7Ozs7V0FTRzthQUNILFVBQTBCLEtBQWE7WUFDbkMsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7UUFDakMsQ0FBQzs7O09BQUE7SUFpQlMsZ0RBQXlCLEdBQW5DLFVBQW9DLE1BQU0sRUFBRSxNQUFNO1FBQzlDLElBQUksTUFBTSxLQUFLLE1BQU0sRUFBRTtZQUNuQixPQUFPO1NBQ1Y7UUFFRCxJQUFNLGFBQWEsR0FBRztZQUNsQixZQUFZLEVBQUUsTUFBTTtZQUNwQixhQUFhLEVBQUUsTUFBTTtTQUN4QixDQUFDO1FBRUYsSUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDekQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7U0FDNUM7YUFBTTtZQUNILElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN2QztRQUVELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOztPQUVHO0lBQ08sbUNBQVksR0FBdEIsVUFBdUIsR0FBVyxFQUFFLElBQVk7UUFBaEQsaUJBR0M7UUFGRyxJQUFJLENBQUMsa0JBQWtCLEdBQUcscUJBQXFCLENBQzNDLGNBQU0sT0FBQSxLQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLEtBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQWpELENBQWlELENBQUMsQ0FBQztJQUNqRSxDQUFDO0lBRUQ7O09BRUc7SUFDTyw2Q0FBc0IsR0FBaEMsVUFBaUMsR0FBVyxFQUFFLElBQVk7UUFBMUQsaUJBY0M7UUFiRyxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7UUFDMUQsSUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3hELElBQUksSUFBSSxDQUFDLGNBQWMsS0FBSyxXQUFXLEVBQUU7WUFDckMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN6QixvQkFBb0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztTQUNqRDthQUFNLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxhQUFhLEVBQUUsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFO1lBQzlELElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDekIsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDakQ7YUFBTTtZQUNILElBQUksQ0FBQyxjQUFjLEdBQUcsYUFBYSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxxQkFBcUIsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxLQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxFQUFqRCxDQUFpRCxDQUFDLENBQUM7U0FDNUc7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDTyw2Q0FBc0IsR0FBaEMsVUFBaUMsR0FBVztRQUN4QyxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNDLElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRDs7T0FFRztJQUNPLG9DQUFhLEdBQXZCLFVBQXdCLFlBQW9CLEVBQUUsU0FBaUI7UUFDM0QsT0FBTyxZQUFZLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDN0QsQ0FBQztJQUVEOztPQUVHO0lBQ0sscUNBQWMsR0FBdEIsVUFBdUIsR0FBVyxFQUFFLFVBQWtCLEVBQUUsSUFBWTtRQUNoRSxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2xILENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ssNENBQXFCLEdBQTdCLFVBQThCLEdBQVcsRUFBRSxVQUFrQixFQUFFLElBQVk7UUFDdkUsT0FBTyxHQUFHLEdBQUcsVUFBVSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLDRDQUFxQixHQUE3QixVQUE4QixHQUFXLEVBQUUsVUFBa0IsRUFBRSxJQUFZO1FBQ3ZFLE9BQU8sR0FBRyxHQUFHLFVBQVUsSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7O09BR0c7SUFDSyxxQ0FBYyxHQUF0QixVQUF1QixHQUFXO1FBQzlCLElBQUksQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLGNBQWMsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQXhORDtRQURDLE1BQU0sRUFBRTsyREFDK0Q7SUFjeEU7UUFEQyxLQUFLLEVBQUU7NENBT1A7SUFxQkQ7UUFEQyxLQUFLLEVBQUU7K0NBR1A7SUEwQkQ7UUFGQyxXQUFXLENBQUMsb0JBQW9CLENBQUM7UUFDakMsS0FBSyxFQUFFOzJDQUdQO0lBa0pMLG1CQUFDO0NBQUEsQUFuUEQsSUFtUEM7U0FuUHFCLFlBQVk7QUFvUGxDLElBQUksY0FBYyxHQUFHLENBQUMsQ0FBQztBQUN2QixJQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQUN6QixJQUFJLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQUt6QjtJQUFtRCxpREFBWTtJQUUzRDtRQUFBLFlBQ0ksaUJBQU8sU0FDVjtRQUdNLGNBQVEsR0FBRyxDQUFDLENBQUM7UUFHYixjQUFRLEdBQUcsZ0JBQWdCLENBQUM7UUFFbkM7Ozs7O1dBS0c7UUFHSSxhQUFPLEdBQUcsS0FBSyxDQUFDO1FBRXZCOzs7OztXQUtHO1FBR0ksbUJBQWEsR0FBRyxLQUFLLENBQUM7UUFFN0I7Ozs7O1dBS0c7UUFHSSxVQUFJLEdBQUcsYUFBYSxDQUFDO1FBRTVCOzs7OztXQUtHO1FBR0ksUUFBRSxHQUFHLG9CQUFrQixjQUFjLEVBQUksQ0FBQztRQUVqRDs7Ozs7Ozs7Ozs7OztXQWFHO1FBRUksZUFBUyxHQUFpQixZQUFZLENBQUMsS0FBSyxDQUFDO1FBRXBEOzs7OztXQUtHO1FBRUksb0JBQWMsR0FBRyxJQUFJLENBQUM7UUFFN0I7Ozs7O1dBS0c7UUFFSSxhQUFPLEdBQUcsS0FBSyxDQUFDO1FBV3ZCOzs7OztXQUtHO1FBRUksVUFBSSxHQUFHLFNBQVMsQ0FBQzs7SUFuR3hCLENBQUM7SUFrSEQsc0JBQUksZ0RBQUs7UUFiVjs7Ozs7Ozs7OztXQVVHO2FBR0Y7WUFDSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDdkIsQ0FBQztRQUVEOzs7OztXQUtHO2FBQ0gsVUFBVSxHQUFHO1lBQ1QsSUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDL0MsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxHQUFHLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDaEUsT0FBTzthQUNWO1lBRUQsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNuQixJQUFJLENBQUMseUJBQXlCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQzthQUMzRDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQzthQUNoQztRQUVMLENBQUM7OztPQXBCQTtJQTBCRCxzQkFBVyxnREFBSztRQUpoQjs7V0FFRzthQUVIO1lBQ0ksT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsQ0FBQyxLQUFLLENBQUM7UUFDL0MsQ0FBQzs7O09BQUE7SUFNRCxzQkFBVywrQ0FBSTtRQUpmOztXQUVHO2FBRUg7WUFDSSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssZUFBZSxDQUFDLElBQUksQ0FBQztRQUM5QyxDQUFDOzs7T0FBQTtJQU1ELHNCQUFXLGtEQUFPO1FBSmxCOztXQUVHO2FBRUg7WUFDSSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssZUFBZSxDQUFDLE9BQU8sQ0FBQztRQUNqRCxDQUFDOzs7T0FBQTtJQU1ELHNCQUFXLGtEQUFPO1FBSmxCOztXQUVHO2FBRUg7WUFDSSxPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssZUFBZSxDQUFDLE9BQU8sQ0FBQztRQUNqRCxDQUFDOzs7T0FBQTtJQUVNLDBEQUFrQixHQUF6QjtRQUNJLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0lBQzdCLENBQUM7SUExS0Q7UUFEQyxXQUFXLENBQUMsb0JBQW9CLENBQUM7bUVBQ2Q7SUFHcEI7UUFEQyxXQUFXLENBQUMsc0JBQXNCLENBQUM7bUVBQ0Q7SUFVbkM7UUFGQyxXQUFXLENBQUMsK0JBQStCLENBQUM7UUFDNUMsS0FBSyxFQUFFO2tFQUNlO0lBVXZCO1FBRkMsV0FBVyxDQUFDLHFDQUFxQyxDQUFDO1FBQ2xELEtBQUssRUFBRTt3RUFDcUI7SUFVN0I7UUFGQyxXQUFXLENBQUMsV0FBVyxDQUFDO1FBQ3hCLEtBQUssRUFBRTsrREFDb0I7SUFVNUI7UUFGQyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBQ3RCLEtBQUssRUFBRTs2REFDeUM7SUFpQmpEO1FBREMsS0FBSyxFQUFFO29FQUM0QztJQVNwRDtRQURDLEtBQUssRUFBRTt5RUFDcUI7SUFTN0I7UUFEQyxLQUFLLEVBQUU7a0VBQ2U7SUFTdkI7UUFEQyxLQUFLLEVBQUU7K0RBQ1k7SUFTcEI7UUFEQyxLQUFLLEVBQUU7K0RBQ2dCO0lBZXhCO1FBRkMsV0FBVyxDQUFDLG9CQUFvQixDQUFDO1FBQ2pDLEtBQUssRUFBRTs4REFHUDtJQTBCRDtRQURDLFdBQVcsQ0FBQyw4QkFBOEIsQ0FBQzs4REFHM0M7SUFNRDtRQURDLFdBQVcsQ0FBQyw0QkFBNEIsQ0FBQzs2REFHekM7SUFNRDtRQURDLFdBQVcsQ0FBQywrQkFBK0IsQ0FBQztnRUFHNUM7SUFNRDtRQURDLFdBQVcsQ0FBQywrQkFBK0IsQ0FBQztnRUFHNUM7SUE1S1EsNkJBQTZCO1FBSnpDLFNBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSxnQkFBZ0I7WUFDMUIsOGpCQUFrRDtTQUNyRCxDQUFDO09BQ1csNkJBQTZCLENBa0x6QztJQUFELG9DQUFDO0NBQUEsQUFsTEQsQ0FBbUQsWUFBWSxHQWtMOUQ7U0FsTFksNkJBQTZCO0FBd0wxQztJQUFxRCxtREFBWTtJQW1IN0QseUNBQW9CLFFBQW1CLEVBQVUsZUFBa0M7UUFBbkYsWUFDSSxpQkFBTyxTQUNWO1FBRm1CLGNBQVEsR0FBUixRQUFRLENBQVc7UUFBVSxxQkFBZSxHQUFmLGVBQWUsQ0FBbUI7UUFqSGxFLDJCQUFxQixHQUFHLEdBQUcsQ0FBQztRQUM1Qiw2QkFBdUIsR0FBRyxFQUFFLENBQUM7UUFFOUMsY0FBYztRQUVQLGNBQVEsR0FBRyxrQkFBa0IsQ0FBQztRQUVyQzs7Ozs7V0FLRztRQUdJLFFBQUUsR0FBRyxzQkFBb0IsZ0JBQWdCLEVBQUksQ0FBQztRQUVyRDs7V0FFRztRQUNJLGdCQUFVLEdBQUcsMkJBQXlCLGdCQUFnQixFQUFJLENBQUM7UUFFbEU7Ozs7O1dBS0c7UUFHSSxtQkFBYSxHQUFHLEtBQUssQ0FBQztRQUU3Qjs7Ozs7V0FLRztRQUVJLG9CQUFjLEdBQUcsSUFBSSxDQUFDO1FBb0VyQixtQkFBYSxHQUFHLEVBQUUsQ0FBQztRQUNuQixvQkFBYyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUksQ0FBQyxhQUFhLENBQUM7O0lBTzFELENBQUM7SUFyREQsc0JBQVcsb0RBQU87UUFIbEI7O1dBRUc7YUFDSDtZQUNJLE9BQU87Z0JBQ0gsU0FBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsY0FBYyxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUU7YUFDdkYsQ0FBQztRQUNOLENBQUM7OztPQUFBO0lBaUJELHNCQUFJLGtEQUFLO1FBZlQ7Ozs7Ozs7Ozs7Ozs7V0FhRzthQUVIO1lBQ0ksT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ3ZCLENBQUM7UUFFRDs7Ozs7V0FLRzthQUNILFVBQVUsR0FBVztZQUNqQixJQUFNLFVBQVUsR0FBRyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMvQyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLEdBQUcsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUNoRSxPQUFPO2FBQ1Y7WUFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQzNEO2lCQUFNO2dCQUNILElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO2FBQ2hDO1FBRUwsQ0FBQzs7O09BcEJBO0lBZ0NNLDREQUFrQixHQUF6QjtRQUNJLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzNELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0lBQzdCLENBQUM7SUFFTSx5REFBZSxHQUF0QjtRQUNJLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUNsQixJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFDN0IsUUFBUSxFQUNSLFVBQVEsSUFBSSxDQUFDLFVBQVUsTUFBRyxDQUM3QixDQUFDO0lBQ04sQ0FBQztJQUVEOztPQUVHO0lBQ0ksZ0VBQXNCLEdBQTdCLFVBQThCLEdBQVcsRUFBRSxJQUFZO1FBQ25ELCtCQUErQjtRQUMvQixJQUFNLE1BQU0sR0FBRyxDQUFDO2dCQUNaLGdCQUFnQixFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztnQkFDL0MsYUFBYSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsR0FBRyxJQUFJLENBQUMsdUJBQXVCO2FBQzNGLEVBQUU7Z0JBQ0MsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDO2dCQUN2RCxhQUFhLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLElBQUksQ0FBQyx1QkFBdUI7YUFDbkcsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtZQUMxQyxNQUFNLEVBQUUsVUFBVTtZQUNsQixJQUFJLEVBQUUsVUFBVTtTQUNuQixDQUFDLENBQUM7UUFFSCxpQkFBTSxzQkFBc0IsWUFBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUtELHNCQUFXLHdEQUFXO1FBSHRCOztXQUVHO2FBQ0g7WUFDSSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDckIsQ0FBQzs7O09BQUE7SUFFRDs7T0FFRztJQUNJLGdFQUFzQixHQUE3QixVQUE4QixHQUFXO1FBQ3JDLGlCQUFNLHNCQUFzQixZQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUNsQixJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsRUFDN0IsbUJBQW1CLEVBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFFM0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQ2xCLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUM3QixnQkFBZ0IsRUFDaEIsQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0lBQzNGLENBQUM7SUFFTyxxREFBVyxHQUFuQixVQUFvQixVQUFrQjtRQUNsQyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsY0FBYyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDaEUsSUFBSSxDQUFDLGNBQWMsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsY0FBYyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7O2dCQWpFNkIsU0FBUztnQkFBMkIsaUJBQWlCOztJQTVHbkY7UUFEQyxXQUFXLENBQUMsd0JBQXdCLENBQUM7cUVBQ0Q7SUFVckM7UUFGQyxXQUFXLENBQUMsU0FBUyxDQUFDO1FBQ3RCLEtBQUssRUFBRTsrREFDNkM7SUFlckQ7UUFGQyxXQUFXLENBQUMsdUNBQXVDLENBQUM7UUFDcEQsS0FBSyxFQUFFOzBFQUNxQjtJQVM3QjtRQURDLEtBQUssRUFBRTsyRUFDcUI7SUFZN0I7UUFEQyxLQUFLLEVBQUU7aUVBQ1k7SUFHcEI7UUFEQyxZQUFZLENBQUMsa0NBQWtDLEVBQUUsRUFBRSxJQUFJLEVBQUUsa0NBQWtDLEVBQUUsQ0FBQzt5RUFDdkM7SUFHeEQ7UUFEQyxZQUFZLENBQUMsK0JBQStCLEVBQUUsRUFBRSxJQUFJLEVBQUUsK0JBQStCLEVBQUUsQ0FBQzs2RUFDaEM7SUEwQnpEO1FBREMsS0FBSyxFQUFFO2dFQUdQO0lBMEJEO1FBREMsU0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQzt1RUFDUDtJQWpIdEIsK0JBQStCO1FBSjNDLFNBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSxrQkFBa0I7WUFDNUIsaWdEQUFvRDtTQUN2RCxDQUFDO09BQ1csK0JBQStCLENBcUwzQztJQUFELHNDQUFDO0NBQUEsQUFyTEQsQ0FBcUQsWUFBWSxHQXFMaEU7U0FyTFksK0JBQStCO0FBdUw1QyxNQUFNLFVBQVUsWUFBWSxDQUFDLEtBQWEsRUFBRSxHQUFXLEVBQUUsR0FBTztJQUFQLG9CQUFBLEVBQUEsT0FBTztJQUM1RCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELE1BQU0sVUFBVSxTQUFTLENBQUMsS0FBYSxFQUFFLEdBQVc7SUFDaEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUVEOztHQUVHO0FBZ0JIO0lBQUE7SUFBb0MsQ0FBQztJQUF4QixvQkFBb0I7UUFmaEMsUUFBUSxDQUFDO1lBQ04sWUFBWSxFQUFFO2dCQUNWLDZCQUE2QjtnQkFDN0IsK0JBQStCO2dCQUMvQixrQ0FBa0M7Z0JBQ2xDLCtCQUErQjthQUNsQztZQUNELE9BQU8sRUFBRTtnQkFDTCw2QkFBNkI7Z0JBQzdCLCtCQUErQjtnQkFDL0Isa0NBQWtDO2dCQUNsQywrQkFBK0I7YUFDbEM7WUFDRCxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7U0FDMUIsQ0FBQztPQUNXLG9CQUFvQixDQUFJO0lBQUQsMkJBQUM7Q0FBQSxBQUFyQyxJQUFxQztTQUF4QixvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQWZ0ZXJDb250ZW50SW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxufSBmcm9tICcuL3Byb2dyZXNzYmFyLmNvbW1vbic7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4RGlyZWN0aW9uYWxpdHkgfSBmcm9tICcuLi9zZXJ2aWNlcy9kaXJlY3Rpb24vZGlyZWN0aW9uYWxpdHknO1xuXG5jb25zdCBPTkVfUEVSQ0VOVCA9IDAuMDE7XG5jb25zdCBNSU5fVkFMVUUgPSAwO1xuXG5leHBvcnQgZW51bSBJZ3hUZXh0QWxpZ24ge1xuICAgIFNUQVJUID0gJ3N0YXJ0JyxcbiAgICBDRU5URVIgPSAnY2VudGVyJyxcbiAgICBFTkQgPSAnZW5kJ1xufVxuXG5leHBvcnQgZW51bSBJZ3hQcm9ncmVzc1R5cGUge1xuICAgIEVSUk9SID0gJ2Vycm9yJyxcbiAgICBJTkZPID0gJ2luZm8nLFxuICAgIFdBUk5JTkcgPSAnd2FybmluZycsXG4gICAgU1VDQ0VTUyA9ICdzdWNjZXNzJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBwcmV2aW91c1ZhbHVlOiBudW1iZXI7XG4gICAgY3VycmVudFZhbHVlOiBudW1iZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVByb2dyZXNzIHtcbiAgICBwcml2YXRlIHJlcXVlc3RBbmltYXRpb25JZDogbnVtYmVyID0gdW5kZWZpbmVkO1xuXG4gICAgcHJvdGVjdGVkIF9pbml0VmFsdWUgPSAwO1xuICAgIHByb3RlY3RlZCBfY29udGVudEluaXQgPSBmYWxzZTtcbiAgICBwcm90ZWN0ZWQgX3ZhbHVlSW5QZXJjZW50ID0gTUlOX1ZBTFVFO1xuICAgIHByb3RlY3RlZCBfbWF4ID0gMTAwO1xuICAgIHByb3RlY3RlZCBfdmFsdWUgPSBNSU5fVkFMVUU7XG4gICAgcHJvdGVjdGVkIF9uZXdWYWwgPSBNSU5fVkFMVUU7XG4gICAgcHJvdGVjdGVkIF9hbmltYXRlID0gdHJ1ZTtcbiAgICBwcm90ZWN0ZWQgX3N0ZXA7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCwgd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIGEgcHJvZ3Jlc3MgaXMgY2hhbmdlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIHByb2dyZXNzQ2hhbmdlKGV2ZW50KSB7XG4gICAgICogICAgIGFsZXJ0KFwiUHJvZ3Jlc3MgbWFkZSFcIik7XG4gICAgICogfVxuICAgICAqICAvLy4uLlxuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbdmFsdWVdPVwiY3VycmVudFZhbHVlXCIgKG9uUHJvZ3Jlc3NDaGFuZ2VkKT1cInByb2dyZXNzQ2hhbmdlKCRldmVudClcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogPGlneC1saW5lYXItYmFyIFt2YWx1ZV09XCJjdXJyZW50VmFsdWVcIiAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uUHJvZ3Jlc3NDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSB3aGljaCB1cGRhdGUgdGhlIHByb2dyZXNzIGluZGljYXRvciBvZiB0aGUgYHByb2dyZXNzIGJhcmAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfCBJZ3hDaXJjdWxhckJhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgc3RlcFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5wcm9ncmVzc0Jhci5zdGVwO1xuICAgICAqICAgICBhbGVydChzdGVwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RlcCgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5fc3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWF4ICogT05FX1BFUkNFTlQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYnkgd2hpY2ggcHJvZ3Jlc3MgaW5kaWNhdG9yIGlzIHVwZGF0ZWQuIEJ5IGRlZmF1bHQgaXQgaXMgMSUgb2YgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCIgW3N0ZXBdPVwiMVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiMFwiIFtzdGVwXT1cIjFcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IHN0ZXAodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IE51bWJlcih2YWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGluZyB0aGUgcHJvZ3Jlc3MuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbYW5pbWF0ZV09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBhbmltYXRlKGFuaW1hdGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGFuaW1hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBgcHJvZ3Jlc3MgYmFyYCBoYXMgYW5pbWF0aW9uIHRydWUvZmFsc2UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgfCBJZ3hDaXJjdWxhckJhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgYW5pbWF0aW9uU3RhdHVzKGV2ZW50KSB7XG4gICAgICogICAgIGxldCBhbmltYXRpb25TdGF0dXMgPSB0aGlzLnByb2dyZXNzQmFyLmFuaW1hdGU7XG4gICAgICogICAgIGFsZXJ0KGFuaW1hdGlvblN0YXR1cyk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgYW5pbWF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG1heGltdW0gdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byAxMDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiA8aWd4LWNpcmN1bGFyLWJhciBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbWF4JylcbiAgICBASW5wdXQoKVxuICAgIHNldCBtYXgobWF4TnVtOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4TnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRoZSBtYXhpbXVtIHByb2dyZXNzIHZhbHVlIG9mIHRoZSBgcHJvZ3Jlc3MgYmFyYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCB8IElneENpcmN1bGFyQmFyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBtYXhWYWx1ZShldmVudCkge1xuICAgICAqICAgICBsZXQgbWF4ID0gdGhpcy5wcm9ncmVzc0Jhci5tYXg7XG4gICAgICogICAgIGFsZXJ0KG1heCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBtYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC9gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdmFsdWUgaW4gcGVyY2VudGFnZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIEBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICogcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqICAgICBwdWJsaWMgc2V0VmFsdWUoZXZlbnQpe1xuICAgICAqICAgICB0aGlzLnByb2dyZXNzQmFyLnZhbHVlSW5QZXJjZW50ID0gNTY7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdmFsdWVJblBlcmNlbnQodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZUluUGVyY2VudCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7IC8vIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRcbiAgICAgKiBwdWJsaWMgdmFsdWVQZXJjZW50KGV2ZW50KXtcbiAgICAgKiAgICAgbGV0IHBlcmNlbnRWYWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWVJblBlcmNlbnQ7XG4gICAgICogICAgIGFsZXJ0KHBlcmNlbnRWYWx1ZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdmFsdWVJblBlcmNlbnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlSW5QZXJjZW50O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCB0cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmIChvbGRWYWwgPT09IG5ld1ZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hhbmdlZFZhbHVlcyA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZTogbmV3VmFsLFxuICAgICAgICAgICAgcHJldmlvdXNWYWx1ZTogb2xkVmFsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc3RlcERpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uRmxvdyhvbGRWYWwsIG5ld1ZhbCk7XG4gICAgICAgIGlmICh0aGlzLl9hbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bkFuaW1hdGlvbihuZXdWYWwsIHN0ZXBEaXJlY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzc0RpcmVjdGx5KG5ld1ZhbCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NDaGFuZ2VkLmVtaXQoY2hhbmdlZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBydW5BbmltYXRpb24odmFsOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgICAgICgpID0+IHRoaXMudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseS5jYWxsKHRoaXMsIHZhbCwgc3RlcCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWVJblJhbmdlKHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpICsgc3RlcDtcbiAgICAgICAgY29uc3QgcGFzc2VkVmFsdWUgPSB0b1BlcmNlbnQodmFsLCB0aGlzLl9tYXgpO1xuICAgICAgICBjb25zdCBwcm9ncmVzc1ZhbHVlID0gdG9QZXJjZW50KHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZUluUGVyY2VudCA9PT0gcGFzc2VkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3ModmFsKTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdEFuaW1hdGlvbklkKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSW5MaW1pdFJhbmdlKHByb2dyZXNzVmFsdWUsIHBhc3NlZFZhbHVlLCBzdGVwKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyh2YWwpO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0QW5pbWF0aW9uSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUluUGVyY2VudCA9IHByb2dyZXNzVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnVwZGF0ZVByb2dyZXNzU21vb3RobHkuY2FsbCh0aGlzLCB2YWwsIHN0ZXApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlSW5SYW5nZSh2YWwsIHRoaXMuX21heCk7XG4gICAgICAgIHRoaXMudmFsdWVJblBlcmNlbnQgPSB0b1BlcmNlbnQodGhpcy5fdmFsdWUsIHRoaXMuX21heCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXJlY3Rpb25GbG93KGN1cnJlbnRWYWx1ZTogbnVtYmVyLCBwcmV2VmFsdWU6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWUgPCBwcmV2VmFsdWUgPyB0aGlzLnN0ZXAgOiAtdGhpcy5zdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIGlzSW5MaW1pdFJhbmdlKHZhbDogbnVtYmVyLCBjb21wYXJhdG9yOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0V4Y2VlZGluZ1VwcGVyTGltaXQodmFsLCBjb21wYXJhdG9yLCBzdGVwKSB8fCB0aGlzLmlzRXhjZWVkaW5nTG93ZXJMaW1pdCh2YWwsIGNvbXBhcmF0b3IsIHN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzRXhjZWVkaW5nVXBwZXJMaW1pdCh2YWw6IG51bWJlciwgY29tcGFyYXRvcjogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IGNvbXBhcmF0b3IgJiYgc3RlcCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXG4gICAgICogQHBhcmFtIHN0ZXBcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzRXhjZWVkaW5nTG93ZXJMaW1pdCh2YWw6IG51bWJlciwgY29tcGFyYXRvcjogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA8IGNvbXBhcmF0b3IgJiYgc3RlcCA8IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVQcm9ncmVzcyh2YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlSW5SYW5nZSh2YWwsIHRoaXMuX21heCk7XG4gICAgICAgIHRoaXMudmFsdWVJblBlcmNlbnQgPSB0b1BlcmNlbnQodGhpcy5fdmFsdWUsIHRoaXMuX21heCk7XG4gICAgfVxufVxubGV0IE5FWFRfTElORUFSX0lEID0gMDtcbmxldCBORVhUX0NJUkNVTEFSX0lEID0gMDtcbmxldCBORVhUX0dSQURJRU5UX0lEID0gMDtcbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LWxpbmVhci1iYXInLFxuICAgIHRlbXBsYXRlVXJsOiAndGVtcGxhdGVzL2xpbmVhci1iYXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50IGV4dGVuZHMgQmFzZVByb2dyZXNzIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW1pbicpXG4gICAgcHVibGljIHZhbHVlTWluID0gMDtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtbGluZWFyLWJhcic7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIHN0cmlwZWQgc3R5bGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdHJpcGVkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzdHJpcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIGluZGV0ZXJtaW5hdGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0taW5kZXRlcm1pbmF0ZScpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGByb2xlYCBhdHRyaWJ1dGUuIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBwcm9ncmVzc2JhcmAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbGluZWFyLWJhciByb2xlPVwicHJvZ3Jlc3NiYXJcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyByb2xlID0gJ3Byb2dyZXNzYmFyJztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtpZF09XCInaWd4LWxpbmVhci1iYXItNTUnXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1saW5lYXItYmFyLSR7TkVYVF9MSU5FQVJfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwb3NpdGlvbiB0aGF0IGRlZmluZXMgd2hlcmUgdGhlIHRleHQgaXMgYWxpZ25lZC5cbiAgICAgKiBQb3NzaWJsZSBvcHRpb25zIC0gYElneFRleHRBbGlnbi5TVEFSVGAgKGRlZmF1bHQpLCBgSWd4VGV4dEFsaWduLkNFTlRFUmAsIGBJZ3hUZXh0QWxpZ24uRU5EYC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIHBvc2l0aW9uQ2VudGVyOiBJZ3hUZXh0QWxpZ247XG4gICAgICogcHVibGljIG5nT25Jbml0KCkge1xuICAgICAqICAgICB0aGlzLnBvc2l0aW9uQ2VudGVyID0gSWd4VGV4dEFsaWduLkNFTlRFUjtcbiAgICAgKiB9XG4gICAgICogIC8vLi4uXG4gICAgICogYGBgXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRBbGlnbjogSWd4VGV4dEFsaWduID0gSWd4VGV4dEFsaWduLlNUQVJUO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB0ZXh0IHRvIGJlIHZpc2libGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWxpbmVhci1iYXIgdHlwZT1cImRlZmF1bHRcIiBbdGV4dFZpc2liaWxpdHldPVwiZmFsc2VcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHRWaXNpYmlsaXR5ID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIGlmIHRoZSB0ZXh0IHNob3VsZCBiZSBhbGlnbmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBsaW5lLiBCeSBkZWZhdWx0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogIDxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZXJyb3JcIiBbdGV4dFRvcF09XCJ0cnVlXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBjdXN0b20gdGV4dCB0aGF0IGlzIGRpc3BsYXllZCBhY2NvcmRpbmcgdG8gdGhlIGRlZmluZWQgcG9zaXRpb24uXG4gICAgICogIGBgYGh0bWxcbiAgICAgKiA8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHRleHQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCB0eXBlIG9mIHRoZSBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLiBQb3NzaWJsZSBvcHRpb25zIC0gYGRlZmF1bHRgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBhbmQgYGVycm9yYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIxMDBcIiBbdmFsdWVdPVwiMFwiIHR5cGU9XCJlcnJvclwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZSA9ICdkZWZhdWx0JztcblxuICAgLyoqXG4gICAgKiBSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiAgQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgKiBwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAqICAgICBsZXQgdmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlO1xuICAgICogICAgIGFsZXJ0KHZhbHVlKTtcbiAgICAqIH1cbiAgICAqIGBgYFxuICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVub3cnKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIyMDBcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWwpIHtcbiAgICAgICAgY29uc3QgdmFsSW5SYW5nZSA9IHZhbHVlSW5SYW5nZSh2YWwsIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbEluUmFuZ2UpIHx8IHRoaXMuX3ZhbHVlID09PSB2YWwgfHwgdGhpcy5pbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29udGVudEluaXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbih0aGlzLl92YWx1ZSwgdmFsSW5SYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0VmFsdWUgPSB2YWxJblJhbmdlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtbGluZWFyLWJhci0tZGFuZ2VyJylcbiAgICBwdWJsaWMgZ2V0IGVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hQcm9ncmVzc1R5cGUuRVJST1I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLWluZm8nKVxuICAgIHB1YmxpYyBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLklORk87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLXdhcm5pbmcnKVxuICAgIHB1YmxpYyBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLldBUk5JTkc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWxpbmVhci1iYXItLXN1Y2Nlc3MnKVxuICAgIHB1YmxpYyBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4UHJvZ3Jlc3NUeXBlLlNVQ0NFU1M7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKE1JTl9WQUxVRSwgdGhpcy5faW5pdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fY29udGVudEluaXQgPSB0cnVlO1xuICAgIH1cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtY2lyY3VsYXItYmFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9jaXJjdWxhci1iYXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3MgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgU1RST0tFX09QQUNJVFlfRFZJREVSID0gMTAwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgU1RST0tFX09QQUNJVFlfQURESVRJT04gPSAuMjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtY2lyY3VsYXItYmFyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LWNpcmN1bGFyLWJhcic7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFtpZF09XCInaWd4LWNpcmN1bGFyLWJhci01NSdcIiBbdmFsdWVdPVwiNTBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtY2lyY3VsYXItYmFyLSR7TkVYVF9DSVJDVUxBUl9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdyYWRpZW50SWQgPSBgaWd4LWNpcmN1bGFyLWdyYWRpZW50LSR7TkVYVF9HUkFESUVOVF9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGluZGV0ZXJtaW5hdGVgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtY2lyY3VsYXItYmFyLS1pbmRldGVybWluYXRlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZXh0IHZpc2liaWxpdHkuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIHRydWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFt0ZXh0VmlzaWJpbGl0eV09XCJmYWxzZVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VmlzaWJpbGl0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIHRleHQgdG8gYmUgZGlzcGxheWVkIGluc2lkZSB0aGUgYGlneENpcmN1bGFyQmFyYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1jaXJjdWxhci1iYXIgdGV4dD1cIlByb2dyZXNzXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgdGV4dCA9IHRoaXMuY2lyY3VsYXJCYXIudGV4dDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0OiBzdHJpbmc7XG5cbiAgICBAQ29udGVudENoaWxkKElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUsIHsgcmVhZDogSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyB0ZXh0VGVtcGxhdGU6IElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICBAQ29udGVudENoaWxkKElneFByb2dyZXNzQmFyR3JhZGllbnREaXJlY3RpdmUsIHsgcmVhZDogSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSB9KVxuICAgIHB1YmxpYyBncmFkaWVudFRlbXBsYXRlOiBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29udGV4dCgpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiB7IHZhbHVlOiB0aGlzLnZhbHVlLCB2YWx1ZUluUGVyY2VudDogdGhpcy52YWx1ZUluUGVyY2VudCwgbWF4OiB0aGlzLm1heCB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICBAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqIHB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICAgbGV0IHZhbHVlID0gdGhpcy5wcm9ncmVzc0Jhci52YWx1ZTtcbiAgICAgKiAgICAgYWxlcnQodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGJ1dHRvbiBpZ3hCdXR0b249XCJmYWJcIiBpZ3hSaXBwbGU9XCJcIiAoY2xpY2spPVwiZ2V0VmFsdWUoKVwiPkNsaWNrPC9idXR0b24+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB2YWx1ZSB0aGF0IGluZGljYXRlcyB0aGUgY3VycmVudCBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgdmFsSW5SYW5nZSA9IHZhbHVlSW5SYW5nZSh2YWwsIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbEluUmFuZ2UpIHx8IHRoaXMuX3ZhbHVlID09PSB2YWwgfHwgdGhpcy5pbmRldGVybWluYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29udGVudEluaXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlclByb2dyZXNzVHJhbnNpdGlvbih0aGlzLl92YWx1ZSwgdmFsSW5SYW5nZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0VmFsdWUgPSB2YWxJblJhbmdlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIF9jaXJjbGVSYWRpdXMgPSA0NjtcbiAgICBwcml2YXRlIF9jaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiB0aGlzLl9jaXJjbGVSYWRpdXM7XG5cbiAgICBAVmlld0NoaWxkKCdjaXJjbGUnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByaXZhdGUgX3N2Z0NpcmNsZTogRWxlbWVudFJlZjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfZGlyZWN0aW9uYWxpdHk6IElneERpcmVjdGlvbmFsaXR5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyUHJvZ3Jlc3NUcmFuc2l0aW9uKE1JTl9WQUxVRSwgdGhpcy5faW5pdFZhbHVlKTtcbiAgICAgICAgdGhpcy5fY29udGVudEluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UnLFxuICAgICAgICAgICAgYHVybCgjJHt0aGlzLmdyYWRpZW50SWR9KWBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZVByb2dyZXNzU21vb3RobHkodmFsOiBudW1iZXIsIHN0ZXA6IG51bWJlcikge1xuICAgICAgICAvLyBTZXQgZnJhbWVzIGZvciB0aGUgYW5pbWF0aW9uXG4gICAgICAgIGNvbnN0IEZSQU1FUyA9IFt7XG4gICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiB0aGlzLmdldFByb2dyZXNzKHRoaXMuX3ZhbHVlKSxcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6ICh0aGlzLl92YWx1ZSAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSKSArIHRoaXMuU1RST0tFX09QQUNJVFlfQURESVRJT05cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogdGhpcy5nZXRQcm9ncmVzcyh0aGlzLnZhbHVlSW5QZXJjZW50KSxcbiAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6ICh0aGlzLnZhbHVlSW5QZXJjZW50IC8gdGhpcy5TVFJPS0VfT1BBQ0lUWV9EVklERVIpICsgdGhpcy5TVFJPS0VfT1BBQ0lUWV9BRERJVElPTlxuICAgICAgICB9XTtcbiAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZShGUkFNRVMsIHtcbiAgICAgICAgICAgIGVhc2luZzogJ2Vhc2Utb3V0JyxcbiAgICAgICAgICAgIGZpbGw6ICdmb3J3YXJkcydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseSh2YWwsIHN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICAgICAgICAgICAgdGhpcy5nZXRQcm9ncmVzcyh0aGlzLnZhbHVlSW5QZXJjZW50KSk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShcbiAgICAgICAgICAgIHRoaXMuX3N2Z0NpcmNsZS5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICAgICAgICAgICh0aGlzLnZhbHVlSW5QZXJjZW50IC8gdGhpcy5TVFJPS0VfT1BBQ0lUWV9EVklERVIpICsgdGhpcy5TVFJPS0VfT1BBQ0lUWV9BRERJVElPTik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRQcm9ncmVzcyhwZXJjZW50YWdlOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbmFsaXR5LnJ0bCA/XG4gICAgICAgICAgICB0aGlzLl9jaXJjdW1mZXJlbmNlICsgKHBlcmNlbnRhZ2UgKiB0aGlzLl9jaXJjdW1mZXJlbmNlIC8gMTAwKSA6XG4gICAgICAgICAgICB0aGlzLl9jaXJjdW1mZXJlbmNlIC0gKHBlcmNlbnRhZ2UgKiB0aGlzLl9jaXJjdW1mZXJlbmNlIC8gMTAwKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZUluUmFuZ2UodmFsdWU6IG51bWJlciwgbWF4OiBudW1iZXIsIG1pbiA9IDApOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUGVyY2VudCh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKDEwMCAqIHZhbHVlIC8gbWF4KTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50LFxuICAgICAgICBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hQcm9ncmVzc0JhckdyYWRpZW50RGlyZWN0aXZlLFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCxcbiAgICAgICAgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4UHJvZ3Jlc3NCYXJHcmFkaWVudERpcmVjdGl2ZSxcbiAgICBdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdXG59KVxuZXhwb3J0IGNsYXNzIElneFByb2dyZXNzQmFyTW9kdWxlIHsgfVxuXG4iXX0=