import { __extends } from "tslib";
import { VerticalAlignment, HorizontalAlignment } from './../utilities';
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
var AutoPositionStrategy = /** @class */ (function (_super) {
    __extends(AutoPositionStrategy, _super);
    function AutoPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    AutoPositionStrategy.prototype.fitInViewport = function (element, connectedFit) {
        var transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                var horizontalPush = this.horizontalPush(connectedFit);
                transformString.push("translateX(" + horizontalPush + "px)");
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                var verticalPush = this.verticalPush(connectedFit);
                transformString.push("translateY(" + verticalPush + "px)");
            }
        }
        element.style.transform = transformString.join(' ').trim();
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipHorizontal = function (connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        var flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        var flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        var rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipVertical = function (connectedFit) {
        var flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        var flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        var bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    };
    /**
     * Flips direction and start point of the position settings
     */
    AutoPositionStrategy.prototype.flipHorizontal = function () {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    };
    /**
     * Flips direction and start point of the position settings
     */
    AutoPositionStrategy.prototype.flipVertical = function () {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    };
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.horizontalPush = function (connectedFit) {
        var leftExtend = connectedFit.left;
        var rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    };
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.verticalPush = function (connectedFit) {
        var topExtend = connectedFit.top;
        var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    };
    return AutoPositionStrategy;
}(BaseFitPositionStrategy));
export { AutoPositionStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9hdXRvLXBvc2l0aW9uLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsbUJBQW1CLEVBQWdCLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEYsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFFdkU7OztHQUdHO0FBQ0g7SUFBMEMsd0NBQXVCO0lBQWpFOztJQWlKQSxDQUFDO0lBL0lHLGtCQUFrQjtJQUNSLDRDQUFhLEdBQXZCLFVBQXdCLE9BQW9CLEVBQUUsWUFBMEI7UUFDcEUsSUFBTSxlQUFlLEdBQWEsRUFBRSxDQUFDO1FBQ3JDLElBQUksWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRTtZQUMvRSxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdEMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQ3pCO2lCQUFNO2dCQUNILElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3pELGVBQWUsQ0FBQyxJQUFJLENBQUMsZ0JBQWMsY0FBYyxRQUFLLENBQUMsQ0FBQzthQUMzRDtTQUNKO1FBRUQsSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFO1lBQzNFLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDcEMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3ZCO2lCQUFNO2dC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QUksV0FBVyxHQUFHLENBQUMsRUFBRTtZQUN4QixPQUFPLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDOUM7YUFBTTtZQUNILE9BQU8sQ0FBQyxDQUFDO1NBQ1o7SUFDTCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLDJDQUFZLEdBQXBCLFVBQXFCLFlBQTBCO1FBQzNDLElBQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUM7UUFDbkMsSUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLE1BQU0sR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztRQUM1RSxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDZixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDOUI7YUFBTSxJQUFJLFlBQVksR0FBRyxDQUFDLEVBQUU7WUFDekIsT0FBTyxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQzlDO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUNMLDJCQUFDO0FBQUQsQ0FBQyxBQWpKRCxDQUEwQyx1QkFBdUIsR0FpSmhFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVydGljYWxBbGlnbm1lbnQsIEhvcml6b250YWxBbGlnbm1lbnQsIENvbm5lY3RlZEZpdCB9IGZyb20gJy4vLi4vdXRpbGl0aWVzJztcbmltcG9ydCB7IEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9iYXNlLWZpdC1wb3NpdGlvbi1zdHJhdGVneSc7XG5cbi8qKlxuICogUG9zaXRpb25zIHRoZSBlbGVtZW50IGFzIGluICoqQ29ubmVjdGVkKiogcG9zaXRpb25pbmcgc3RyYXRlZ3kgYW5kIHJlLXBvc2l0aW9ucyB0aGUgZWxlbWVudCBpblxuICogdGhlIHZpZXcgcG9ydCAoY2FsY3VsYXRpbmcgYSBkaWZmZXJlbnQgc3RhcnQgcG9pbnQpIGluIGNhc2UgdGhlIGVsZW1lbnQgaXMgcGFydGlhbGx5IGdldHRpbmcgb3V0IG9mIHZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Qb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQmFzZUZpdFBvc2l0aW9uU3RyYXRlZ3kge1xuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgcHJvdGVjdGVkIGZpdEluVmlld3BvcnQoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmluZzogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsLmJhY2sgPCAwIHx8IGNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsLmZvcndhcmQgPCAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5GbGlwSG9yaXpvbnRhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsUHVzaCA9IHRoaXMuaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWCgke2hvcml6b250YWxQdXNofXB4KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbm5lY3RlZEZpdC5maXRWZXJ0aWNhbC5iYWNrIDwgMCB8fCBjb25uZWN0ZWRGaXQuZml0VmVydGljYWwuZm9yd2FyZCA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljYWxQdXNoID0gdGhpcy52ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWSgke3ZlcnRpY2FsUHVzaH1weClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtU3RyaW5nLmpvaW4oJyAnKS50cmltKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBIb3Jpem9udGFsKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogYm9vbGVhbiB7XG4gICAgICAgIC8vICBIb3Jpem9udGFsQWxpZ25tZW50IGNhbiBiZSBMZWZ0ID0gLTE7IENlbnRlciA9IC0wLjUgb3IgUmlnaHQgPSAwLlxuICAgICAgICAvLyAgVG8gdmlydHVhbGx5IGZsaXAgZGlyZWN0aW9uIGFuZCBzdGFydCBwb2ludCAoYm90aCBhcmUgSG9yaXpvbnRhbEFsaWdubWVudCkgd2UgY2FuIGRvIHRoaXM6XG4gICAgICAgIC8vICBmbGlwcGVkQWxpZ25tZW50ID0gKC0xKSAqIChIb3Jpem9udGFsQWxpZ25tZW50ICsgMSlcbiAgICAgICAgLy8gIHRoaXMgd2F5OlxuICAgICAgICAvLyAgKC0xKSAqIChMZWZ0ICsgMSkgPSAwID0gUmlnaHRcbiAgICAgICAgLy8gICgtMSkgKiAoQ2VudGVyICsgMSkgPSAtMC41ID0gQ2VudGVyXG4gICAgICAgIC8vICAoLTEpICogKFJpZ2h0ICsgMSkgPSAtMSA9IExlZnRcbiAgICAgICAgY29uc3QgZmxpcHBlZFN0YXJ0UG9pbnQgPSAoLTEpICogKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uICsgMSk7XG5cbiAgICAgICAgY29uc3QgbGVmdEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlTGVmdChcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC50YXJnZXRSZWN0LCBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LCBmbGlwcGVkU3RhcnRQb2ludCwgZmxpcHBlZERpcmVjdGlvbiwgMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyID0gbGVmdEJvcmRlciArIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHJldHVybiAwIDwgbGVmdEJvcmRlciAmJiByaWdodEJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmbGlwcGVkU3RhcnRQb2ludCA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IHRvcEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlVG9wKFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnRhcmdldFJlY3QsIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsIGZsaXBwZWRTdGFydFBvaW50LCBmbGlwcGVkRGlyZWN0aW9uLCAwKTtcbiAgICAgICAgY29uc3QgYm90dG9tQm9yZGVyID0gdG9wQm9yZGVyICsgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAwIDwgdG9wQm9yZGVyICYmIGJvdHRvbUJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uID0gSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwVmVydGljYWwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiA9IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24gPSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCA9IFZlcnRpY2FsQWxpZ25tZW50LlRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgbmVjZXNzYXJ5IGhvcml6b250YWwgcHVzaCBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgY29ubmVjdGVkRml0XG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgYW1vdW50IG9mIG5lY2Vzc2FyeSB0cmFuc2xhdGlvbiB3aGljaCB3aWxsIHB1c2ggdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBsZWZ0RXh0ZW5kID0gY29ubmVjdGVkRml0LmxlZnQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXh0ZW5kID0gY29ubmVjdGVkRml0LnJpZ2h0IC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5yaWdodDtcbiAgICAgICAgLy8gIGlmIGxlZnRFeHRlbmQgPCAwIG92ZXJsYXkgZ29lcyBiZXlvbmQgbGVmdCBlbmQgb2YgdGhlIHNjcmVlbi4gV2Ugc2hvdWxkIHB1c2ggaXQgYmFjayB3aXRoIGV4YWN0bHlcbiAgICAgICAgLy8gIGFzIG11Y2ggYXMgaXQgaXMgYmV5b25kIHRoZSBzY3JlZW4uXG4gICAgICAgIC8vICBpZiByaWdodEV4dGVuZCA+IDAgb3ZlcmxheSBnb2VzIGJleW9uZCByaWdodCBlbmQgb2YgdGhlIHNjcmVlbi4gV2Ugc2hvdWxkIHB1c2ggaXQgYmFjayB3aXRoIHRoZVxuICAgICAgICAvLyAgZXh0ZW5kIGJ1dCB3aXRoIGFtb3VudCBub3QgYmlnZ2VyIHRoYW4gd2hhdCBsZWZ0IGJldHdlZW4gbGVmdCBib3JkZXIgb2Ygc2NyZWVuIGFuZCBsZWZ0IGJvcmRlciBvZlxuICAgICAgICAvLyAgb3ZlcmxheSwgZS5nLiBsZWZ0RXh0ZW5kXG4gICAgICAgIGlmIChsZWZ0RXh0ZW5kIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGxlZnRFeHRlbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RXh0ZW5kID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0gTWF0aC5taW4ocmlnaHRFeHRlbmQsIGxlZnRFeHRlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG5lY2Vzc2FyeSB2ZXJ0aWNhbCBwdXNoIGFjY29yZGluZyB0byBwcm92aWRlZCBjb25uZWN0ZWRGaXRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBhbW91bnQgb2YgbmVjZXNzYXJ5IHRyYW5zbGF0aW9uIHdoaWNoIHdpbGwgcHVzaCB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSB2ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB0b3BFeHRlbmQgPSBjb25uZWN0ZWRGaXQudG9wO1xuICAgICAgICBjb25zdCBib3R0b21FeHRlbmQgPSBjb25uZWN0ZWRGaXQuYm90dG9tIC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5ib3R0b207XG4gICAgICAgIGlmICh0b3BFeHRlbmQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModG9wRXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21FeHRlbmQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLSBNYXRoLm1pbihib3R0b21FeHRlbmQsIHRvcEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==