import { __decorate, __extends } from "tslib";
import { CommonModule } from '@angular/common';
import { ChangeDetectorRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, Directive, DoCheck, EmbeddedViewRef, EventEmitter, Input, IterableChanges, IterableDiffer, IterableDiffers, NgModule, NgZone, OnChanges, OnDestroy, OnInit, Output, SimpleChanges, TemplateRef, TrackByFunction, ViewContainerRef, AfterViewInit } from '@angular/core';
import { DisplayContainerComponent } from './display.container';
import { HVirtualHelperComponent } from './horizontal.virtual.helper.component';
import { VirtualHelperComponent } from './virtual.helper.component';
import { IgxScrollInertiaModule } from './../scroll-inertia/scroll_inertia.directive';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from './for_of.sync.service';
import { Subject } from 'rxjs';
import { takeUntil, filter, throttleTime, first } from 'rxjs/operators';
import ResizeObserver from 'resize-observer-polyfill';
import { VirtualHelperBaseDirective } from './base.helper.component';
/**
 *  @publicApi
 */
var IgxForOfContext = /** @class */ (function () {
    function IgxForOfContext($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    Object.defineProperty(IgxForOfContext.prototype, "first", {
        /**
         * A function that returns whether the element is the first or not
         */
        get: function () { return this.index === 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfContext.prototype, "last", {
        /**
         * A function that returns whether the element is the last or not
         */
        get: function () { return this.index === this.count - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfContext.prototype, "even", {
        /**
         * A function that returns whether the element is even or not
         */
        get: function () { return this.index % 2 === 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfContext.prototype, "odd", {
        /**
         * A function that returns whether the element is odd or not
         */
        get: function () { return !this.even; },
        enumerable: true,
        configurable: true
    });
    return IgxForOfContext;
}());
export { IgxForOfContext };
var IgxForOfDirective = /** @class */ (function () {
    function IgxForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        /**
         * An @Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */
        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.onScrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.onContentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /** Height that is being virtualized. */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollTop = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    Object.defineProperty(IgxForOfDirective.prototype, "igxForTotalItemCount", {
        /**
         * The total count of the virtual data items, when using remote service.
         * Similar to the property totalItemCount, but this will allow setting the data count into the template.
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
         *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
         * ```
         */
        get: function () {
            return this.totalItemCount;
        },
        set: function (value) {
            this.totalItemCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "displayContainer", {
        get: function () {
            return this.dc.instance._viewContainer.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "virtualHelper", {
        get: function () {
            return this.scrollComponent.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "sizesCache", {
        get: function () {
            return this._sizesCache;
        },
        set: function (value) {
            this._sizesCache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "_isScrolledToBottom", {
        get: function () {
            if (!this.getScroll()) {
                return true;
            }
            var scrollHeight = this.getScroll().scrollHeight;
            // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
            // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
            return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "_isAtBottomIndex", {
        get: function () {
            return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "isRemote", {
        /**
         * @hidden
         */
        get: function () {
            return this.totalItemCount !== null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "scrollPosition", {
        /**
         *
         * Gets/Sets the scroll position.
         * ```typescript
         * const position = directive.scrollPosition;
         * directive.scrollPosition = value;
         * ```
         */
        get: function () {
            return this.scrollComponent.scrollAmount;
        },
        set: function (val) {
            if (val === this.scrollComponent.scrollAmount) {
                return;
            }
            if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
                this.scrollComponent.nativeElement.scrollLeft = val;
            }
            else if (this.scrollComponent) {
                this.scrollComponent.nativeElement.scrollTop = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.removeScrollEventListeners = function () {
        var _this = this;
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(function () {
                return _this.scrollComponent.nativeElement.removeEventListener('scroll', _this.func);
            });
        }
        else {
            this._zone.runOutsideAngular(function () {
                return _this.scrollComponent.nativeElement.removeEventListener('scroll', _this.verticalScrollHandler);
            });
        }
    };
    IgxForOfDirective.prototype.verticalScrollHandler = function (event) {
        this.onScroll(event);
    };
    IgxForOfDirective.prototype.isScrollable = function () {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.ngOnInit = function () {
        var _this = this;
        var totalSize = 0;
        var vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        var dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
            }
            for (var i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                var input = this.igxForOf[i];
                var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            var factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(function () {
                _this.verticalScrollHandler = _this.verticalScrollHandler.bind(_this);
                _this.scrollComponent.nativeElement.addEventListener('scroll', _this.verticalScrollHandler);
                _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
            });
            var destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(destructor, filter(function () { return _this.igxForContainerSize && _this.igxForOf && _this.igxForOf.length > 0; }), throttleTime(40, undefined, { leading: true, trailing: true }))
                .subscribe(function () {
                _this._zone.runTask(function () {
                    _this.updateSizes();
                });
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = function (evt) { _this.onHScroll(evt); };
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                var hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.scrollComponent = vc.createComponent(hvFactory).instance;
                this.scrollComponent.size = totalSize;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(function () {
                    _this.scrollComponent.nativeElement.addEventListener('scroll', _this.func);
                    _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(function () {
                    _this.scrollComponent.nativeElement.addEventListener('scroll', _this.func);
                    _this.dc.instance.scrollContainer = _this.scrollComponent.nativeElement;
                });
            }
            this._updateHScrollOffset();
        }
    };
    IgxForOfDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(function () {
                _this.contentObserver = new ResizeObserver(function () { return _this.contentResizeNotify.next(); });
                _this.contentObserver.observe(_this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.ngOnDestroy = function () {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.ngOnChanges = function (changes) {
        var forOf = 'igxForOf';
        if (forOf in changes) {
            var value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
        var defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        var containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.ngDoCheck = function () {
        var _this = this;
        if (this._differ) {
            var changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(function () {
                    _this._applyChanges();
                    _this.cdr.markForCheck();
                    _this._updateScrollOffset();
                    _this.onDataChanged.emit();
                });
            }
        }
    };
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    IgxForOfDirective.prototype.addScrollTop = function (addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        var originalVirtScrollTop = this._virtScrollTop;
        var containerSize = parseInt(this.igxForContainerSize, 10);
        var maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.scrollPosition += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        var maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    };
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param index
     */
    IgxForOfDirective.prototype.scrollTo = function (index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        var containerSize = parseInt(this.igxForContainerSize, 10);
        var isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        var nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
        }
        else {
            var maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    };
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    IgxForOfDirective.prototype.scrollNext = function () {
        var scr = Math.ceil(this.scrollPosition);
        var endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    };
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    IgxForOfDirective.prototype.scrollPrev = function () {
        this.scrollTo(this.state.startIndex - 1);
    };
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    IgxForOfDirective.prototype.scrollNextPage = function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    };
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    IgxForOfDirective.prototype.scrollPrevPage = function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            var containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.getColumnScrollLeft = function (colIndex) {
        return this.sizesCache[colIndex];
    };
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    IgxForOfDirective.prototype.getItemCountInView = function () {
        var startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        var endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    };
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    IgxForOfDirective.prototype.getScroll = function () {
        return this.scrollComponent.nativeElement;
    };
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    IgxForOfDirective.prototype.getSizeAt = function (index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    };
    IgxForOfDirective.prototype.getScrollbarWidth = function () {
        return this.scrollComponent ? this.scrollComponent.scrollWidth : 0;
    };
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    IgxForOfDirective.prototype.getScrollForIndex = function (index, bottom) {
        var containerSize = parseInt(this.igxForContainerSize, 10);
        var scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    };
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    IgxForOfDirective.prototype.onScroll = function (event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        var prevStartIndex = this.state.startIndex;
        var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    };
    IgxForOfDirective.prototype.updateSizes = function () {
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        this.onContentSizeChange.emit();
    };
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    IgxForOfDirective.prototype.recalcUpdateSizes = function () {
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        var diffs = [];
        var totalDiff = 0;
        var l = this._embeddedViews.length;
        var rNodes = this._embeddedViews.map(function (view) {
            return view.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; }) || view.rootNodes[0].nextElementSibling;
        });
        for (var i = 0; i < l; i++) {
            var rNode = rNodes[i];
            if (rNode) {
                var h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                var index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                var oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                var newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                var currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (var j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                var totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            var reducer = function (acc, val) { return acc + val; };
            if (this.igxForScrollOrientation === 'vertical') {
                var scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                var hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.scrollComponent.destroyed) {
                    this.scrollComponent.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    var containerSize = parseInt(this.igxForContainerSize, 10);
                    var maxVirtScrollTop = this._virtHeight - containerSize;
                    this._bScrollInternal = true;
                    this._virtScrollTop = maxVirtScrollTop;
                    this.scrollPosition = maxVirtScrollTop;
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    var updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    var sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    if (sumDiffs !== 0) {
                        this.addScrollTop(sumDiffs);
                    }
                    this._adjustToIndex = null;
                }
            }
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.fixedUpdateAllElements = function (inScrollTop) {
        var count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        var newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        var prevStart = this.state.startIndex;
        var diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                // recalculate and apply page size.
                if (diff && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    diff > 0 ? this.moveApplyScrollNext(prevStart) : this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    };
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    IgxForOfDirective.prototype.moveApplyScrollNext = function (prevIndex) {
        var start = prevIndex + this.state.chunkSize;
        var end = start + this.state.startIndex - prevIndex;
        var container = this.dc.instance._vcr;
        for (var i = start; i < end && this.igxForOf[i] !== undefined; i++) {
            var embView = this._embeddedViews.shift();
            this.scrollFocus(embView.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; })
                || embView.rootNodes[0].nextElementSibling);
            var view = container.detach(0);
            this.updateTemplateContext(embView.context, i);
            container.insert(view);
            this._embeddedViews.push(embView);
        }
    };
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    IgxForOfDirective.prototype.moveApplyScrollPrev = function (prevIndex) {
        var container = this.dc.instance._vcr;
        for (var i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            var embView = this._embeddedViews.pop();
            this.scrollFocus(embView.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; })
                || embView.rootNodes[0].nextElementSibling);
            var view = container.detach(container.length - 1);
            this.updateTemplateContext(embView.context, i);
            container.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.getContextIndex = function (input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    };
    /**
     * @hidden
     * Function which updates the passed context of an embedded view with the provided index
     * from the view container.
     * Often, called while handling a scroll event.
     */
    IgxForOfDirective.prototype.updateTemplateContext = function (context, index) {
        if (index === void 0) { index = 0; }
        context.$implicit = this.igxForOf[index];
        context.index = this.getContextIndex(this.igxForOf[index]);
        context.count = this.igxForOf.length;
    };
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    IgxForOfDirective.prototype.fixedApplyScroll = function () {
        var j = 0;
        var endIndex = this.state.startIndex + this.state.chunkSize;
        for (var i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            var embView = this._embeddedViews[j++];
            this.updateTemplateContext(embView.context, i);
        }
    };
    /**
     * @hidden
     * @internal
     *
     * Clears focus inside the virtualized container on small scroll swaps.
     */
    IgxForOfDirective.prototype.scrollFocus = function (node) {
        var activeElement = document.activeElement;
        // Remove focus in case the the active element is inside the view container.
        // Otherwise we hit an exception while doing the 'small' scrolls swapping.
        // For more information:
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
        if (node && node.contains(document.activeElement)) {
            activeElement.blur();
        }
    };
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    IgxForOfDirective.prototype.onHScroll = function (event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        var prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        var scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    };
    Object.defineProperty(IgxForOfDirective.prototype, "igxForTrackBy", {
        /**
         * Gets the function used to track changes in the items collection.
         * By default the object references are compared. However this can be optimized if you have unique identifier
         * value that can be used for the comparison instead of the object ref or if you have some other property values
         * in the item object that should be tracked for changes.
         * This option is similar to ngForTrackBy.
         * ```typescript
         * const trackFunc = this.parentVirtDir.igxForTrackBy;
         * ```
         */
        get: function () { return this._trackByFn; },
        /**
         * Sets the function used to track changes in the items collection.
         * This function can be set in scenarios where you want to optimize or
         * customize the tracking of changes for the items in the collection.
         * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
         * ```typescript
         * this.parentVirtDir.igxForTrackBy = (index, item) => {
         *      return item.id + item.width;
         * };
         * ```
         */
        set: function (fn) { this._trackByFn = fn; },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    IgxForOfDirective.prototype._applyChanges = function () {
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            var startIndex = this.state.startIndex;
            var endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                var embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype._calcMaxBrowserHeight = function () {
        var div = document.createElement('div');
        var style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        document.body.appendChild(div);
        var size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    };
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    IgxForOfDirective.prototype._calculateChunkSize = function () {
        var chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.getElement = function (viewref, nodeName) {
        var elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.initSizesCache = function (items) {
        var totalSize = 0;
        var size = 0;
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        var i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        var count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    };
    IgxForOfDirective.prototype._updateSizeCache = function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
        var newHeight = this.initSizesCache(this.igxForOf);
        var diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            var offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
        }
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype._calcMaxChunkSize = function () {
        var _this = this;
        var i = 0;
        var length = 0;
        var maxLength = 0;
        var arr = [];
        var sum = 0;
        var availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        var reducer = function (accumulator, currentItem) { return accumulator + _this._getItemSize(currentItem, dimension); };
        for (i; i < this.igxForOf.length; i++) {
            var item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            var size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    var curItem = dimension === 'height' ? arr[0].value : arr[0];
                    var prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        var prevItem = this.igxForOf[prevIndex];
                        var prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    };
    /**
     * @hidden
     */
    IgxForOfDirective.prototype.getIndexAt = function (left, set, index) {
        var start = 0;
        var end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            var midIdx = Math.floor((start + end) / 2);
            var midLeft = set[midIdx];
            var cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    };
    IgxForOfDirective.prototype._recalcScrollBarSize = function () {
        var count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        var scrollable = this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            var totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
                // Need to reset the scrollAmount value here, because horizontalScrollBar is hidden, therefore
                // onScroll event handler for VirtualHelperBaseDirective will not be called
                this.scrollComponent.scrollAmount = 0;
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();
            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
                // Need to reset the scrollAmount value here, because verticalScrollBar is hidden, therefore
                // onScroll event handler for VirtualHelperBaseDirective will not be called
                this.scrollComponent.scrollAmount = 0;
            }
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.onScrollbarVisibilityChanged.emit();
        }
    };
    IgxForOfDirective.prototype._calcHeight = function () {
        var height;
        if (this.heightCache) {
            height = this.heightCache.reduce(function (acc, val) { return acc + val; }, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    };
    IgxForOfDirective.prototype._recalcOnContainerChange = function (changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            var scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    };
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    IgxForOfDirective.prototype.removeLastElem = function () {
        var oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    };
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    IgxForOfDirective.prototype.addLastElem = function () {
        var _this = this;
        var elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        var input = this.igxForOf[elemIndex];
        var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(function () {
            _this.cdr.markForCheck();
        });
    };
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    IgxForOfDirective.prototype.applyChunkSizeChange = function () {
        var chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            var diff = chunkSize - this.state.chunkSize;
            for (var i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            var diff = this.state.chunkSize - chunkSize;
            for (var i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    };
    IgxForOfDirective.prototype._updateScrollOffset = function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    };
    IgxForOfDirective.prototype._updateVScrollOffset = function () {
        var scrollOffset = 0;
        var currentScrollTop = this.scrollPosition;
        if (this._virtHeightRatio !== 1) {
            this._calcVirtualScrollTop(this.scrollPosition);
            currentScrollTop = this._virtScrollTop;
        }
        var vScroll = this.scrollComponent.nativeElement;
        scrollOffset = vScroll && this.scrollComponent.size ?
            currentScrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    };
    IgxForOfDirective.prototype._calcVirtualScrollTop = function (scrollTop) {
        var containerSize = parseInt(this.igxForContainerSize, 10);
        var maxRealScrollTop = this.scrollComponent.size - containerSize;
        var realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;
        var maxVirtScrollTop = this._virtHeight - containerSize;
        this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
    };
    IgxForOfDirective.prototype._updateHScrollOffset = function () {
        var scrollOffset = 0;
        scrollOffset = this.scrollComponent.nativeElement &&
            this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    };
    IgxForOfDirective.prototype._getItemSize = function (item, dimension) {
        var dim = item[dimension];
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    };
    IgxForOfDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: NgZone },
        { type: IgxForOfScrollSyncService }
    ]; };
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForOf", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForSizePropName", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForScrollOrientation", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForScrollContainer", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForContainerSize", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForItemSize", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForTotalItemCount", null);
    __decorate([
        Output()
    ], IgxForOfDirective.prototype, "onChunkLoad", void 0);
    __decorate([
        Output()
    ], IgxForOfDirective.prototype, "onScrollbarVisibilityChanged", void 0);
    __decorate([
        Output()
    ], IgxForOfDirective.prototype, "onContentSizeChange", void 0);
    __decorate([
        Output()
    ], IgxForOfDirective.prototype, "onDataChanged", void 0);
    __decorate([
        Output()
    ], IgxForOfDirective.prototype, "onBeforeViewDestroyed", void 0);
    __decorate([
        Output()
    ], IgxForOfDirective.prototype, "onChunkPreload", void 0);
    __decorate([
        Input()
    ], IgxForOfDirective.prototype, "igxForTrackBy", null);
    IgxForOfDirective = __decorate([
        Directive({ selector: '[igxFor][igxForOf]' })
    ], IgxForOfDirective);
    return IgxForOfDirective;
}());
export { IgxForOfDirective };
export function getTypeNameForDebugging(type) {
    var name = 'name';
    return type[name] || typeof type;
}
var IgxGridForOfDirective = /** @class */ (function (_super) {
    __extends(IgxGridForOfDirective, _super);
    function IgxGridForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
        var _this = _super.call(this, _viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) || this;
        _this.syncScrollService = syncScrollService;
        _this.syncService = syncService;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        _this.onDataChanging = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxGridForOfDirective.prototype, "igxGridForOf", {
        get: function () {
            return this.igxForOf;
        },
        set: function (value) {
            this.igxForOf = value;
        },
        enumerable: true,
        configurable: true
    });
    IgxGridForOfDirective.prototype.ngOnInit = function () {
        this.syncService.setMaster(this);
        _super.prototype.ngOnInit.call(this);
        this.removeScrollEventListeners();
    };
    IgxGridForOfDirective.prototype.ngOnChanges = function (changes) {
        var forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            var value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
        var defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        var containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    };
    Object.defineProperty(IgxGridForOfDirective.prototype, "sizesCache", {
        /**
         * @hidden
         * @internal
         */
        get: function () {
            if (this.syncService.isMaster(this)) {
                return this._sizesCache;
            }
            return this.syncService.sizesCache(this.igxForScrollOrientation);
        },
        /**
         * @hidden
         * @internal
         */
        set: function (value) {
            this._sizesCache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridForOfDirective.prototype, "itemsDimension", {
        get: function () {
            return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
        },
        enumerable: true,
        configurable: true
    });
    IgxGridForOfDirective.prototype.getItemSize = function (item) {
        var size = 0;
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    };
    IgxGridForOfDirective.prototype.initSizesCache = function (items) {
        if (!this.syncService.isMaster(this)) {
            var masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        var totalSize = 0;
        var size = 0;
        var i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        var count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    };
    IgxGridForOfDirective.prototype._updateSizeCache = function (changes) {
        var _this = this;
        if (changes === void 0) { changes = null; }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
        var newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            newHeight = this.initSizesCache(this.igxForOf);
        }
        var diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(function () {
                _this.recalcUpdateSizes();
                var offset = parseInt(_this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (_this.scrollPosition !== 0) {
                    _this.scrollPosition = _this.sizesCache[_this.state.startIndex] - offset;
                }
                else {
                    _this._updateScrollOffset();
                }
            });
        }
    };
    IgxGridForOfDirective.prototype.handleCacheChanges = function (changes) {
        var _this = this;
        var identityChanges = [];
        var newHeightCache = [];
        var newSizesCache = [];
        newSizesCache.push(0);
        var newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        var numRemovedItems = 0;
        changes.forEachRemovedItem(function () { return numRemovedItems++; });
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange(function (item) {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem(function (item) {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = _this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = _this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    };
    /**
     * @hidden
     * @internal
     */
    IgxGridForOfDirective.prototype.assumeMaster = function () {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    };
    IgxGridForOfDirective.prototype.ngDoCheck = function () {
        if (this._differ) {
            var changes = this._differ.diff(this.igxForOf);
            if (changes) {
                var args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    };
    IgxGridForOfDirective.prototype.onScroll = function (event) {
        var _this = this;
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first()).subscribe(function () {
            _this.recalcUpdateSizes();
        });
        this.cdr.markForCheck();
    };
    IgxGridForOfDirective.prototype.onHScroll = function (scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        var scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    };
    IgxGridForOfDirective.prototype.addLastElem = function () {
        var elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        var input = this.igxForOf[elemIndex];
        var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    };
    IgxGridForOfDirective.prototype._updateViews = function (prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            var startIndex = void 0;
            var endIndex = void 0;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                var embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    };
    IgxGridForOfDirective.prototype._applyChanges = function () {
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    };
    /**
     * @hidden
     */
    IgxGridForOfDirective.prototype._calcMaxChunkSize = function () {
        if (this.syncService.isMaster(this)) {
            return _super.prototype._calcMaxChunkSize.call(this);
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    };
    IgxGridForOfDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: NgZone },
        { type: IgxForOfScrollSyncService },
        { type: IgxForOfSyncService }
    ]; };
    __decorate([
        Input()
    ], IgxGridForOfDirective.prototype, "igxGridForOf", null);
    __decorate([
        Output()
    ], IgxGridForOfDirective.prototype, "onDataChanging", void 0);
    IgxGridForOfDirective = __decorate([
        Directive({
            selector: '[igxGridFor][igxGridForOf]'
        })
    ], IgxGridForOfDirective);
    return IgxGridForOfDirective;
}(IgxForOfDirective));
export { IgxGridForOfDirective };
/**
 * @hidden
 */
var IgxForOfModule = /** @class */ (function () {
    function IgxForOfModule() {
    }
    IgxForOfModule = __decorate([
        NgModule({
            declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                HVirtualHelperComponent, VirtualHelperBaseDirective],
            entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
            exports: [IgxForOfDirective, IgxGridForOfDirective],
            imports: [IgxScrollInertiaModule, CommonModule]
        })
    ], IgxForOfModule);
    return IgxForOfModule;
}());
export { IgxForOfModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yX29mLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFlBQVksRUFBa0IsTUFBTSxpQkFBaUIsQ0FBQztBQUMvRCxPQUFPLEVBQ0gsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUNoQix3QkFBd0IsRUFDeEIsWUFBWSxFQUNaLFNBQVMsRUFDVCxPQUFPLEVBQ1AsZUFBZSxFQUNmLFlBQVksRUFDWixLQUFLLEVBQ0wsZUFBZSxFQUNmLGNBQWMsRUFDZCxlQUFlLEVBQ2YsUUFBUSxFQUNSLE1BQU0sRUFDTixTQUFTLEVBQ1QsU0FBUyxFQUNULE1BQU0sRUFDTixNQUFNLEVBQ04sYUFBYSxFQUNiLFdBQVcsRUFDWCxlQUFlLEVBQ2YsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDaEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDaEUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDaEYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDcEUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sOENBQThDLENBQUM7QUFDdEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxjQUFjLE1BQU0sMEJBQTBCLENBQUM7QUFFdEQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0seUJBQXlC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QUNwRSxDQUFDOztnQkFyVW1CLGdCQUFnQjtnQkFDckIsV0FBVztnQkFDWixlQUFlO2dCQUNmLHdCQUF3QjtnQkFDN0IsaUJBQWlCO2dCQUNmLE1BQU07Z0JBQ2dCLHlCQUF5QjtnQkFDL0IsbUJBQW1COztJQUs5QztRQURDLEtBQUssRUFBRTs2REFHUDtJQVdEO1FBREMsTUFBTSxFQUFFO2lFQUMrRDtJQTVCL0QscUJBQXFCO1FBSGpDLFNBQVMsQ0FBQztZQUNQLFFBQVEsRUFBRSw0QkFBNEI7U0FDekMsQ0FBQztPQUNXLHFCQUFxQixDQXlVakM7SUFBRCw0QkFBQztDQUFBLEFBelVELENBQThDLGlCQUFpQixHQXlVOUQ7U0F6VVkscUJBQXFCO0FBMlVsQzs7R0FFRztBQVNIO0lBQUE7SUFDQSxDQUFDO0lBRFksY0FBYztRQVIxQixRQUFRLENBQUM7WUFDTixZQUFZLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxxQkFBcUIsRUFBRSx5QkFBeUIsRUFBRSxzQkFBc0I7Z0JBQ3JHLHVCQUF1QixFQUFFLDBCQUEwQixDQUFDO1lBQ3pELGVBQWUsRUFBRSxDQUFDLHlCQUF5QixFQUFFLHNCQUFzQixFQUFFLHVCQUF1QixDQUFDO1lBQzdGLE9BQU8sRUFBRSxDQUFDLGlCQUFpQixFQUFFLHFCQUFxQixDQUFDO1lBQ25ELE9BQU8sRUFBRSxDQUFDLHNCQUFzQixFQUFFLFlBQVksQ0FBQztTQUNsRCxDQUFDO09BRVcsY0FBYyxDQUMxQjtJQUFELHFCQUFDO0NBQUEsQUFERCxJQUNDO1NBRFksY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSwgTmdGb3JPZkNvbnRleHQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIERvQ2hlY2ssXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBJdGVyYWJsZUNoYW5nZXMsXG4gICAgSXRlcmFibGVEaWZmZXIsXG4gICAgSXRlcmFibGVEaWZmZXJzLFxuICAgIE5nTW9kdWxlLFxuICAgIE5nWm9uZSxcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBUcmFja0J5RnVuY3Rpb24sXG4gICAgVmlld0NvbnRhaW5lclJlZixcbiAgICBBZnRlclZpZXdJbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9kaXNwbGF5LmNvbnRhaW5lcic7XG5pbXBvcnQgeyBIVmlydHVhbEhlbHBlckNvbXBvbmVudCB9IGZyb20gJy4vaG9yaXpvbnRhbC52aXJ0dWFsLmhlbHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgVmlydHVhbEhlbHBlckNvbXBvbmVudCB9IGZyb20gJy4vdmlydHVhbC5oZWxwZXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneFNjcm9sbEluZXJ0aWFNb2R1bGUgfSBmcm9tICcuLy4uL3Njcm9sbC1pbmVydGlhL3Njcm9sbF9pbmVydGlhLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlLCBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSAnLi9mb3Jfb2Yuc3luYy5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgZmlsdGVyLCB0aHJvdHRsZVRpbWUsIGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IFJlc2l6ZU9ic2VydmVyIGZyb20gJ3Jlc2l6ZS1vYnNlcnZlci1wb2x5ZmlsbCc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmUgfSBmcm9tICcuL2Jhc2UuaGVscGVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICogIEBwdWJsaWNBcGlcbiAqL1xuZXhwb3J0IGNsYXNzIElneEZvck9mQ29udGV4dDxUPiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgcHVibGljICRpbXBsaWNpdDogVCxcbiAgICAgICBwdWJsaWMgaW5kZXg6IG51bWJlcixcbiAgICAgICBwdWJsaWMgY291bnQ6IG51bWJlclxuICAgICkge31cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGhlIGZpcnN0IG9yIG5vdFxuICAgICAqL1xuICAgIGdldCBmaXJzdCgpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuaW5kZXggPT09IDA7IH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGhlIGxhc3Qgb3Igbm90XG4gICAgICovXG4gICAgZ2V0IGxhc3QoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLmluZGV4ID09PSB0aGlzLmNvdW50IC0gMTsgfVxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyBldmVuIG9yIG5vdFxuICAgICAqL1xuICAgIGdldCBldmVuKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5pbmRleCAlIDIgPT09IDA7IH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgb2RkIG9yIG5vdFxuICAgICAqL1xuICAgIGdldCBvZGQoKTogYm9vbGVhbiB7IHJldHVybiAhdGhpcy5ldmVuOyB9XG5cbn1cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2lneEZvcl1baWd4Rm9yT2ZdJyB9KVxuZXhwb3J0IGNsYXNzIElneEZvck9mRGlyZWN0aXZlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2ssIE9uRGVzdHJveSwgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBkYXRhIHRvIGJlIHJlbmRlcmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yT2Y6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgcHJvcGVydHkgbmFtZSBmcm9tIHdoaWNoIHRvIHJlYWQgdGhlIHNpemUgaW4gdGhlIGRhdGEgb2JqZWN0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNpemVQcm9wTmFtZTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgc2Nyb2xsIG9yaWVudGF0aW9uLlxuICAgICAqIFNjcm9sbCBvcmllbnRhdGlvbiBjYW4gYmUgXCJ2ZXJ0aWNhbFwiIG9yIFwiaG9yaXpvbnRhbFwiLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPSAndmVydGljYWwnO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWxseSBwYXNzIHRoZSBwYXJlbnQgYGlneEZvcmAgaW5zdGFuY2UgdG8gY3JlYXRlIGEgdmlydHVhbCB0ZW1wbGF0ZSBzY3JvbGxpbmcgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSAjc2Nyb2xsQ29udGFpbmVyIGlneEZvciBsZXQtcm93RGF0YSBbaWd4Rm9yT2ZdPVwiZGF0YVwiXG4gICAgICogICAgICAgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIid2ZXJ0aWNhbCdcIlxuICAgICAqICAgICAgIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIlxuICAgICAqICAgICAgIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIlxuICAgICAqICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCI+XG4gICAgICogICAgICAgPGRpdiBbc3R5bGUuZGlzcGxheV09XCInZmxleCdcIiBbc3R5bGUuaGVpZ2h0XT1cIic1MHB4J1wiPlxuICAgICAqICAgICAgICAgICA8bmctdGVtcGxhdGUgI2NoaWxkQ29udGFpbmVyIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCJcbiAgICAgKiAgICAgICAgICAgICAgIFtpZ3hGb3JTY3JvbGxDb250YWluZXJdPVwicGFyZW50VmlydERpclwiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCI+XG4gICAgICogICAgICAgICAgICAgICAgICAgPGRpdiBbc3R5bGUubWluLXdpZHRoXT1cIic1MHB4J1wiPnt7cm93SW5kZXh9fSA6IHt7aXRlbS50ZXh0fX08L2Rpdj5cbiAgICAgKiAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNjcm9sbENvbnRhaW5lcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgcHgtYWZmaXhlZCBzaXplIG9mIHRoZSBjb250YWluZXIgYWxvbmcgdGhlIGF4aXMgb2Ygc2Nyb2xsaW5nLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGlzIHZhbHVlIGlzIHRoZSB3aWR0aCBvZiB0aGUgY29udGFpbmVyIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIGlzIHRoZSBoZWlnaHQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgbGV0LWl0ZW0gW2lneEZvck9mXT1cImRhdGFcIiBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCJcbiAgICAgKiAgICAgIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvckNvbnRhaW5lclNpemU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHB4LWFmZml4ZWQgc2l6ZSBvZiB0aGUgaXRlbSBhbG9uZyB0aGUgYXhpcyBvZiBzY3JvbGxpbmcuXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoaXMgdmFsdWUgaXMgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gYW5kIGZvciBcInZlcnRpY2FsXCIgaXMgdGhlIGhlaWdodCBvciB0aGUgcm93LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvckl0ZW1TaXplOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY291bnQgb2YgdGhlIHZpcnR1YWwgZGF0YSBpdGVtcywgd2hlbiB1c2luZyByZW1vdGUgc2VydmljZS5cbiAgICAgKiBTaW1pbGFyIHRvIHRoZSBwcm9wZXJ0eSB0b3RhbEl0ZW1Db3VudCwgYnV0IHRoaXMgd2lsbCBhbGxvdyBzZXR0aW5nIHRoZSBkYXRhIGNvdW50IGludG8gdGhlIHRlbXBsYXRlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhIHwgYXN5bmNcIiBbaWd4Rm9yVG90YWxJdGVtQ291bnRdPVwiY291bnQgfCBhc3luY1wiXG4gICAgICogIFtpZ3hGb3JDb250YWluZXJTaXplXT1cIic1MDBweCdcIiBbaWd4Rm9ySXRlbVNpemVdPVwiJzUwcHgnXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBpZ3hGb3JUb3RhbEl0ZW1Db3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1Db3VudDtcbiAgICB9XG4gICAgc2V0IGlneEZvclRvdGFsSXRlbUNvdW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy50b3RhbEl0ZW1Db3VudCA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRjOiBDb21wb25lbnRSZWY8RGlzcGxheUNvbnRhaW5lckNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGlyZWN0aXZlLiBJdCBjb250YWlucyBgc3RhcnRJbmRleGAgYW5kIGBjaHVua1NpemVgLlxuICAgICAqIHN0YXRlLnN0YXJ0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gYXQgd2hpY2ggdGhlIGN1cnJlbnQgdmlzaWJsZSBjaHVuayBiZWdpbnMuXG4gICAgICogc3RhdGUuY2h1bmtTaXplIC0gVGhlIG51bWJlciBvZiBpdGVtcyB0aGUgY3VycmVudCB2aXNpYmxlIGNodW5rIGhvbGRzLlxuICAgICAqIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgcmVtb3RlIHZpcnR1YWxpemF0aW9uIGFzIHRoZXkgcHJvdmlkZSB0aGUgbmVjZXNzYXJ5IHN0YXRlIGluZm9ybWF0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncmlkU3RhdGUgPSB0aGlzLnBhcmVudFZpcnREaXIuc3RhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHN0YXRlOiBJRm9yT2ZTdGF0ZSA9IHtcbiAgICAgICAgc3RhcnRJbmRleDogMCxcbiAgICAgICAgY2h1bmtTaXplOiAwXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY291bnQgb2YgdGhlIHZpcnR1YWwgZGF0YSBpdGVtcywgd2hlbiB1c2luZyByZW1vdGUgc2VydmljZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnRvdGFsSXRlbUNvdW50ID0gZGF0YS5Db3VudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG90YWxJdGVtQ291bnQ6IG51bWJlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgYSBuZXcgY2h1bmsgaGFzIGJlZW4gbG9hZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChvbkNodW5rTG9hZCk9XCJjaHVua0xvYWQoJGV2ZW50KVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNodW5rTG9hZChlKXtcbiAgICAgKiBhbGVydChcImNodW5rIGxvYWRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkNodW5rTG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHNjcm9sbGJhciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgdGhlIHJlbmRlcmVkIGNvbnRlbnQgc2l6ZSBvZiB0aGUgaWd4Rm9yT2YgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Db250ZW50U2l6ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIGRhdGEgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiAob25EYXRhQ2hhbmdlZCk9XCJkYXRhQ2hhbmdlZCgkZXZlbnQpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZGF0YUNoYW5nZWQoZSl7XG4gICAgICogYWxlcnQoXCJkYXRhIGNoYW5nZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25EYXRhQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQmVmb3JlVmlld0Rlc3Ryb3llZCA9IG5ldyBFdmVudEVtaXR0ZXI8RW1iZWRkZWRWaWV3UmVmPGFueT4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgb24gY2h1bmsgbG9hZGluZyB0byBlbWl0IHRoZSBjdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIC0gc3RhcnRJbmRleCwgZW5kSW5kZXgsIHRvdGFsQ291bnQuXG4gICAgICogQ2FuIGJlIHVzZWQgZm9yIGltcGxlbWVudGluZyByZW1vdGUgbG9hZCBvbiBkZW1hbmQgZm9yIHRoZSBpZ3hGb3IgZGF0YS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiAob25DaHVua1ByZWxvYWQpPVwiY2h1bmtQcmVsb2FkKCRldmVudClcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjaHVua1ByZWxvYWQoZSl7XG4gICAgICogYWxlcnQoXCJjaHVuayBpcyBsb2FkaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2h1bmtQcmVsb2FkID0gbmV3IEV2ZW50RW1pdHRlcjxJRm9yT2ZTdGF0ZT4oKTtcbiAgICBwcm90ZWN0ZWQgZnVuYztcbiAgICBwcm90ZWN0ZWQgX3NpemVzQ2FjaGU6IG51bWJlcltdID0gW107XG4gICAgcHJvdGVjdGVkIHNjcm9sbENvbXBvbmVudDogVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmU7XG4gICAgcHJvdGVjdGVkIF9kaWZmZXI6IEl0ZXJhYmxlRGlmZmVyPFQ+IHwgbnVsbCA9IG51bGw7XG4gICAgcHJvdGVjdGVkIF90cmFja0J5Rm46IFRyYWNrQnlGdW5jdGlvbjxUPjtcbiAgICBwcm90ZWN0ZWQgaGVpZ2h0Q2FjaGUgPSBbXTtcbiAgICBwcml2YXRlIF9hZGp1c3RUb0luZGV4O1xuICAgIHByaXZhdGUgTUFYX1BFUkZfU0NST0xMX0RJRkYgPSA0O1xuXG5cbiAgICBwdWJsaWMgZ2V0IGRpc3BsYXlDb250YWluZXIoKTogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCB2aXJ0dWFsSGVscGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHNpemVzQ2FjaGUoKTogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZXNDYWNoZTtcbiAgICB9XG4gICAgcHJvdGVjdGVkIHNldCBzaXplc0NhY2hlKHZhbHVlOiBudW1iZXJbXSkge1xuICAgICAgICB0aGlzLl9zaXplc0NhY2hlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgX2lzU2Nyb2xsZWRUb0JvdHRvbSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFNjcm9sbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLmdldFNjcm9sbCgpLnNjcm9sbEhlaWdodDtcbiAgICAgICAgLy8gVXNlID09PSBhbmQgbm90ID49IGJlY2F1c2UgYHNjcm9sbFRvcCArIGNvbnRhaW5lciBzaXplYCBjYW4ndCBiZSBiaWdnZXIgdGhhbiBgc2Nyb2xsSGVpZ2h0YCwgdW5sZXNzIHNvbWV0aGluZyBpc24ndCB1cGRhdGVkLlxuICAgICAgICAvLyBBbHNvIHVzZSBNYXRoLnJvdW5kIGJlY2F1c2UgQ2hyb21lIGhhcyBzb21lIGluY29uc2lzdGVuY2llcyBhbmQgYHNjcm9sbFRvcCArIGNvbnRhaW5lcmAgY2FuIGJlIGZsb2F0IHdoZW4gem9vbWluZyB0aGUgcGFnZS5cbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5nZXRTY3JvbGwoKS5zY3JvbGxUb3AgKyB0aGlzLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXQgX2lzQXRCb3R0b21JbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgPiB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gdmlydHVhbCBoZWlnaHQgaGFuZGxpbmcgZHVlIHRvIGJyb3dzZXIgbGltaXRhdGlvblxuICAgIC8qKiBNYXhpbXVtIGhlaWdodCBmb3IgYW4gZWxlbWVudCBvZiB0aGUgYnJvd3Nlci4gKi9cbiAgICBwcml2YXRlIF9tYXhIZWlnaHQ7XG5cbiAgICAvKiogSGVpZ2h0IHRoYXQgaXMgYmVpbmcgdmlydHVhbGl6ZWQuICovXG4gICAgcHJvdGVjdGVkIF92aXJ0SGVpZ2h0ID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJhdGlvIGZvciBoZWlnaHQgdGhhdCdzIGJlaW5nIHZpcnR1YWxpemFlZCBhbmQgdGhlIG9uZSB2aXNpYmxlXG4gICAgICogSWYgX3ZpcnRIZWlnaHRSYXRpbyA9IDEsIHRoZSB2aXNpYmxlIGhlaWdodCBhbmQgdGhlIHZpcnR1YWxpemVkIGFyZSB0aGUgc2FtZSwgYWxzbyBfbWF4SGVpZ2h0ID4gX3ZpcnRIZWlnaHQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdmlydEhlaWdodFJhdGlvID0gMTtcblxuICAgIC8qKiBJbnRlcm5hbCB0cmFjayBmb3Igc2Nyb2xsIHRvcCB0aGF0IGlzIGJlaW5nIHZpcnR1YWxpemVkICovXG4gICAgcHJvdGVjdGVkIF92aXJ0U2Nyb2xsVG9wID0gMDtcblxuICAgIC8qKiBJZiB0aGUgbmV4dCBvblNjcm9sbCBldmVudCBpcyB0cmlnZ2VyZWQgZHVlIHRvIGludGVybmFsIHNldHRpbmcgb2Ygc2Nyb2xsVG9wICovXG4gICAgcHJvdGVjdGVkIF9iU2Nyb2xsSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAvLyBFbmQgcHJvcGVydGllcyByZWxhdGVkIHRvIHZpcnR1YWwgaGVpZ2h0IGhhbmRsaW5nXG5cbiAgICBwcm90ZWN0ZWQgX2VtYmVkZGVkVmlld3M6IEFycmF5PEVtYmVkZGVkVmlld1JlZjxhbnk+PiA9IFtdO1xuXG4gICAgcHJvdGVjdGVkIGNvbnRlbnRSZXNpemVOb3RpZnkgPSBuZXcgU3ViamVjdCgpO1xuICAgIHByb3RlY3RlZCBjb250ZW50T2JzZXJ2ZXI6IFJlc2l6ZU9ic2VydmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4sXG4gICAgICAgIHByb3RlY3RlZCBfZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICBwcml2YXRlIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJvdGVjdGVkIHN5bmNTY3JvbGxTZXJ2aWNlOiBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0IGlzUmVtb3RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1Db3VudCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwb3NpdGlvbiA9IGRpcmVjdGl2ZS5zY3JvbGxQb3NpdGlvbjtcbiAgICAgKiBkaXJlY3RpdmUuc2Nyb2xsUG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNjcm9sbFBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc2Nyb2xsUG9zaXRpb24odmFsOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy5zY3JvbGxDb21wb25lbnQuc2Nyb2xsQW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiB0aGlzLnNjcm9sbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gdmFsO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2Nyb2xsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuZnVuYylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlcilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgdmVydGljYWxTY3JvbGxIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHRoaXMub25TY3JvbGwoZXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpc1Njcm9sbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID4gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IHZjID0gdGhpcy5pZ3hGb3JTY3JvbGxDb250YWluZXIgPyB0aGlzLmlneEZvclNjcm9sbENvbnRhaW5lci5fdmlld0NvbnRhaW5lciA6IHRoaXMuX3ZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lID0gdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgfHwgJ3dpZHRoJztcblxuICAgICAgICBjb25zdCBkY0ZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8RGlzcGxheUNvbnRhaW5lckNvbXBvbmVudD4gPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERpc3BsYXlDb250YWluZXJDb21wb25lbnQpO1xuICAgICAgICB0aGlzLmRjID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVDb21wb25lbnQoZGNGYWN0b3J5LCAwKTtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5zY3JvbGxEaXJlY3Rpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gRWRnZSBhbmQgSUUgd2hlbiBzY3JvbGxpbmcgb24gdG91Y2ggdGhlIHBhZ2Ugc2Nyb2xsIGluc3RlYWQgb2YgdGhlIGdyaWQuXG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgdG90YWxTaXplID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID0gdGhpcy5zeW5jU2Nyb2xsU2VydmljZS5nZXRTY3JvbGxNYXN0ZXIodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUNodW5rU2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5ub3RWaXJ0dWFsID0gISh0aGlzLmlneEZvckNvbnRhaW5lclNpemUgJiYgdGhpcy5zdGF0ZS5jaHVua1NpemUgPCB0aGlzLmlneEZvck9mLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxDb21wb25lbnQgJiYgIXRoaXMuc2Nyb2xsQ29tcG9uZW50LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhcnRJbmRleCA9IE1hdGgubWluKHRoaXMuZ2V0SW5kZXhBdCh0aGlzLnNjcm9sbFBvc2l0aW9uLCB0aGlzLnNpemVzQ2FjaGUsIDApLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7IGkgPCB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IElneEZvck9mQ29udGV4dDxUPihpbnB1dCwgdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpLCB0aGlzLmlneEZvck9mLmxlbmd0aClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxWaXJ0dWFsSGVscGVyQ29tcG9uZW50PiA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoVmlydHVhbEhlbHBlckNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudCA9IHZjLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5KS5pbnN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMuX21heEhlaWdodCA9IHRoaXMuX2NhbGNNYXhCcm93c2VySGVpZ2h0KCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID0gdGhpcy5pZ3hGb3JPZiA/IHRoaXMuX2NhbGNIZWlnaHQoKSA6IDA7XG4gICAgICAgICAgICB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLnNldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uLCB0aGlzLnNjcm9sbENvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlciA9IHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5zY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0cnVjdG9yID0gdGFrZVVudGlsPGFueT4odGhpcy5kZXN0cm95JCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRSZXNpemVOb3RpZnkucGlwZShkZXN0cnVjdG9yLFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAmJiB0aGlzLmlneEZvck9mICYmIHRoaXMuaWd4Rm9yT2YubGVuZ3RoID4gMCksXG4gICAgICAgICAgICB0aHJvdHRsZVRpbWUoNDAsIHVuZGVmaW5lZCwge2xlYWRpbmc6IHRydWUsIHRyYWlsaW5nOiB0cnVlfSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1blRhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemVzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuZnVuYyA9IChldnQpID0+IHsgdGhpcy5vbkhTY3JvbGwoZXZ0KTsgfTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID0gdGhpcy5zeW5jU2Nyb2xsU2VydmljZS5nZXRTY3JvbGxNYXN0ZXIodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHZGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PEhWaXJ0dWFsSGVscGVyQ29tcG9uZW50PiA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoSFZpcnR1YWxIZWxwZXJDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID0gdmMuY3JlYXRlQ29tcG9uZW50KGh2RmFjdG9yeSkuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IHRvdGFsU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLnNldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uLCB0aGlzLnNjcm9sbENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5mdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5zY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVIU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLmNvbnRlbnRSZXNpemVOb3RpZnkubmV4dCgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRPYnNlcnZlci5vYnNlcnZlKHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZm9yT2YgPSAnaWd4Rm9yT2YnO1xuICAgICAgICBpZiAoZm9yT2YgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzW2Zvck9mXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKHRoaXMuaWd4Rm9yVHJhY2tCeSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgQ2Fubm90IGZpbmQgYSBkaWZmZXIgc3VwcG9ydGluZyBvYmplY3QgXCIke3ZhbHVlfVwiIG9mIHR5cGUgXCIke2dldFR5cGVOYW1lRm9yRGVidWdnaW5nKHZhbHVlKX1cIi5cbiAgICAgICAgICAgICAgICAgICAgIE5nRm9yIG9ubHkgc3VwcG9ydHMgYmluZGluZyB0byBJdGVyYWJsZXMgc3VjaCBhcyBBcnJheXMuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRJdGVtU2l6ZSA9ICdpZ3hGb3JJdGVtU2l6ZSc7XG4gICAgICAgIGlmIChkZWZhdWx0SXRlbVNpemUgaW4gY2hhbmdlcyAmJiAhY2hhbmdlc1tkZWZhdWx0SXRlbVNpemVdLmZpcnN0Q2hhbmdlICYmXG4gICAgICAgICAgICB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWZhdWx0IGl0ZW0gc2l6ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAnaWd4Rm9yQ29udGFpbmVyU2l6ZSc7XG4gICAgICAgIGlmIChjb250YWluZXJTaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbY29udGFpbmVyU2l6ZV0uZmlyc3RDaGFuZ2UgJiYgdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgdGhpcy5fcmVjYWxjT25Db250YWluZXJDaGFuZ2UoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpZmZlcikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2RpZmZlci5kaWZmKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvLyAgcmUtaW5pdCBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JPZiA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaXplQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EYXRhQ2hhbmdlZC5lbWl0KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIHNjcm9sbCB0aHVtYiBwb3NpdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmFkZFNjcm9sbFRvcCg1KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gYWRkVG9wIG5lZ2F0aXZlIHZhbHVlIHRvIHNjcm9sbCB1cCBhbmQgcG9zaXRpdmUgdG8gc2Nyb2xsIGRvd247XG4gICAgICovXG4gICAgcHVibGljIGFkZFNjcm9sbFRvcChhZGRUb3A6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoYWRkVG9wID09PSAwICYmIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRTY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRIZWlnaHQgLSBjb250YWluZXJTaXplO1xuXG4gICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxUb3AgKz0gYWRkVG9wO1xuICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydFNjcm9sbFRvcCA+IDAgP1xuICAgICAgICAgICAgKHRoaXMuX3ZpcnRTY3JvbGxUb3AgPCBtYXhWaXJ0U2Nyb2xsVG9wID8gdGhpcy5fdmlydFNjcm9sbFRvcCA6IG1heFZpcnRTY3JvbGxUb3ApIDpcbiAgICAgICAgICAgIDA7XG5cbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiArPSBhZGRUb3AgLyB0aGlzLl92aXJ0SGVpZ2h0UmF0aW87XG4gICAgICAgIGlmIChNYXRoLmFicyhhZGRUb3AgLyB0aGlzLl92aXJ0SGVpZ2h0UmF0aW8pIDwgMSkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBkZWx0YSB0aGF0IHdhcyBhZGRlZCBpcyBzbWFsbGVyIHRoYW4gMSBhbmQgb25TY3JvbGwgaGFuZGxlciBkb2Vzbid0IHRyaWdnZXIgd2hlbiBzY3JvbGxpbmcgPCAxcHhcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyh0aGlzLl92aXJ0U2Nyb2xsVG9wKTtcbiAgICAgICAgICAgIC8vIHNjcm9sbE9mZnNldCA9IHNjcm9sbE9mZnNldCAhPT0gcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApID8gc2Nyb2xsT2Zmc2V0IDogMDtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXhSZWFsU2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICBpZiAoKHRoaXMuX3ZpcnRTY3JvbGxUb3AgPiAwICYmIHRoaXMuc2Nyb2xsUG9zaXRpb24gPT09IDApIHx8XG4gICAgICAgICAgICAodGhpcy5fdmlydFNjcm9sbFRvcCA8IG1heFZpcnRTY3JvbGxUb3AgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA9PT0gbWF4UmVhbFNjcm9sbFRvcCkpIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBzY3JvbGwgcG9zaXRpb24gaXMgYXQgdGhlIHRvcCBvciBib3R0b20sIGJ1dCB2aXJ0dWFsIG9uZSBpcyBub3QgYXQgdGhlIHRvcCBvciBib3R0b20gKHRoZXJlJ3MgbW9yZSB0byBzY3JvbGwpXG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBhY3R1YWwgc2Nyb2xsIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSB2aXJ0dWFsIHNjcm9sbC5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl92aXJ0U2Nyb2xsVG9wIC8gdGhpcy5fdmlydEhlaWdodFJhdGlvO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpcnRTY3JvbGxUb3AgPT09IDAgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBzY3JvbGwgcG9zaXRpb24gaXMgbm90IGF0IHRoZSB0b3AsIGJ1dCB2aXJ0dWFsIHNjcm9sbCBpcy4gSnVzdCB1cGRhdGUgdGhlIGFjdHVhbCBzY3JvbGxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpcnRTY3JvbGxUb3AgPT09IG1heFZpcnRTY3JvbGxUb3AgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA8IG1heFJlYWxTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBzY3JvbGwgcG9zaXRpb24gaXMgbm90IGF0IHRoZSBib3R0b20sIGJ1dCB2aXJ0dWFsIHNjcm9sbCBpcy4gSnVzdCB1cGRhdGUgdGhlIGFjdWFsIHNjcm9sbFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG1heFJlYWxTY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpcnRTY3JvbGxUb3AgIT09IG9yaWdpbmFsVmlydFNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxUbyg1KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsVG8oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+ICh0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IGlzUHJldkl0ZW0gPSBpbmRleCA8IHRoaXMuc3RhdGUuc3RhcnRJbmRleCB8fCB0aGlzLnNjcm9sbFBvc2l0aW9uID4gdGhpcy5zaXplc0NhY2hlW2luZGV4XTtcbiAgICAgICAgbGV0IG5leHRTY3JvbGwgPSBpc1ByZXZJdGVtID8gdGhpcy5zaXplc0NhY2hlW2luZGV4XSA6IHRoaXMuc2l6ZXNDYWNoZVtpbmRleCArIDFdIC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgaWYgKG5leHRTY3JvbGwgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG5leHRTY3JvbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXhWaXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydEhlaWdodCAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgICAgICBpZiAobmV4dFNjcm9sbCA+IG1heFZpcnRTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICBuZXh0U2Nyb2xsID0gbWF4VmlydFNjcm9sbFRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsVG9wID0gbmV4dFNjcm9sbDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl92aXJ0U2Nyb2xsVG9wIC8gdGhpcy5fdmlydEhlaWdodFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5fYWRqdXN0VG9JbmRleCA9ICFpc1ByZXZJdGVtID8gaW5kZXggOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBieSBvbmUgaXRlbSBpbnRvIHRoZSBhcHByb3ByaWF0ZSBuZXh0IGRpcmVjdGlvbi5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhhdCB3aWxsIGJlIHRoZSByaWdodCBjb2x1bW4gYW5kIGZvciBcInZlcnRpY2FsXCIgdGhhdCBpcyB0aGUgbG93ZXIgcm93LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsTmV4dCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxOZXh0KCkge1xuICAgICAgICBjb25zdCBzY3IgPSBNYXRoLmNlaWwodGhpcy5zY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgc2NyICsgcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCksXG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAwXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8oZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIGl0ZW0gaW50byB0aGUgYXBwcm9wcmlhdGUgcHJldmlvdXMgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgdGhlIGxlZnQgY29sdW1uIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgdGhlIHVwcGVyIHJvdy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbFByZXYoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUHJldigpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUbyh0aGlzLnN0YXRlLnN0YXJ0SW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBwYWdlIGludG8gdGhlIGFwcHJvcHJpYXRlIG5leHQgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgb25lIHZpZXcgdG8gdGhlIHJpZ2h0IGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIHRoYXQgaXMgb25lIHZpZXcgdG8gdGhlIGJvdHRvbS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnNjcm9sbE5leHRQYWdlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbE5leHRQYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uICs9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRTY3JvbGxUb3AocGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBieSBvbmUgcGFnZSBpbnRvIHRoZSBhcHByb3ByaWF0ZSBwcmV2aW91cyBkaXJlY3Rpb24uXG4gICAgICogRm9yIFwiaG9yaXpvbnRhbFwiIG9yaWVudGF0aW9uIHRoYXQgd2lsbCBiZSBvbmUgdmlldyB0byB0aGUgbGVmdCBhbmQgZm9yIFwidmVydGljYWxcIiB0aGF0IGlzIG9uZSB2aWV3IHRvIHRoZSB0b3AuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxQcmV2UGFnZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxQcmV2UGFnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiAtPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAocGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpO1xuICAgICAgICAgICAgdGhpcy5hZGRTY3JvbGxUb3AoLWNvbnRhaW5lclNpemUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb2x1bW5TY3JvbGxMZWZ0KGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVzQ2FjaGVbY29sSW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyB0aGF0IGFyZSBmdWxseSB2aXNpYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuZ2V0SXRlbUNvdW50SW5WaWV3KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldEl0ZW1Db3VudEluVmlldygpIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLmdldEluZGV4QXQoXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uLFxuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxQb3NpdGlvbiAtIHRoaXMuc2l6ZXNDYWNoZVtzdGFydEluZGV4XSA+IDApIHtcbiAgICAgICAgICAgIC8vIGZpc3J0IGl0ZW0gaXMgbm90IGZ1bGx5IGluIHZpZXdcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuZ2V0SW5kZXhBdChcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gKyBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSxcbiAgICAgICAgICAgIHRoaXMuc2l6ZXNDYWNoZSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVuZEluZGV4IC0gc3RhcnRJbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBzY3JvbGxiYXIgRE9NIGVsZW1lbnQuXG4gICAgICogVGhpcyBpcyBlaXRoZXIgYSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIHNjcm9sbGJhciBkZXBlbmRpbmcgb24gdGhlIHNwZWNpZmllZCBpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZGlyLmdldFNjcm9sbCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRTaXplQXQoMSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldFNpemVBdChpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVzQ2FjaGVbaW5kZXggKyAxXSAtIHRoaXMuc2l6ZXNDYWNoZVtpbmRleF07XG4gICAgfVxuXG4gICAgcHVibGljIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb21wb25lbnQgPyAodGhpcy5zY3JvbGxDb21wb25lbnQgYXMgVmlydHVhbEhlbHBlckNvbXBvbmVudCkuc2Nyb2xsV2lkdGggOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmdldFNjcm9sbEZvckluZGV4KDEpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTY3JvbGxGb3JJbmRleChpbmRleDogbnVtYmVyLCBib3R0b20/OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gYm90dG9tID8gTWF0aC5tYXgoMCwgdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gLSBjb250YWluZXJTaXplKSA6IHRoaXMuc2l6ZXNDYWNoZVtpbmRleF07XG4gICAgICAgIHJldHVybiBzY3JvbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gc2Nyb2xsaW5nIHZlcnRpY2FsbHlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgLyogaW4gY2VydGFpbiBzaXR1YXRpb25zIHRoaXMgbWF5IGJlIGNhbGxlZCB3aGVuIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlICovXG4gICAgICAgIGlmICghcGFyc2VJbnQodGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fYlNjcm9sbEludGVybmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjVmlydHVhbFNjcm9sbFRvcChldmVudC50YXJnZXQuc2Nyb2xsVG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZTdGFydEluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHModGhpcy5fdmlydFNjcm9sbFRvcCk7XG5cbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gLShzY3JvbGxPZmZzZXQpICsgJ3B4JztcblxuICAgICAgICB0aGlzLmRjLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHByZXZTdGFydEluZGV4ICE9PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMub25DaHVua0xvYWQuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB1cGRhdGVTaXplcygpIHtcbiAgICAgICAgdGhpcy5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIHRoaXMub25Db250ZW50U2l6ZUNoYW5nZS5lbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgcmVjYWN1bGF0ZXMgYW5kIHVwZGF0ZXMgY2FjaGUgc2l6ZXMuXG4gICAgICovXG4gICAgcHVibGljIHJlY2FsY1VwZGF0ZVNpemVzKCkge1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgZGlmZnMgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsRGlmZiA9IDA7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLl9lbWJlZGRlZFZpZXdzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgck5vZGVzID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5tYXAodmlldyA9PlxuICAgICAgICAgICAgdmlldy5yb290Tm9kZXMuZmluZChub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB8fCB2aWV3LnJvb3ROb2Rlc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgck5vZGUgPSByTm9kZXNbaV07XG4gICAgICAgICAgICBpZiAock5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gck5vZGUub2Zmc2V0SGVpZ2h0IHx8IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIGk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IHRoaXMuaGVpZ2h0Q2FjaGVbaW5kZXhdIDogdGhpcy5pZ3hGb3JPZltpbmRleF1bZGltZW5zaW9uXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID8gaCA6IHJOb2RlLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGVbaW5kZXhdID0gbmV3VmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2ZbaW5kZXhdW2RpbWVuc2lvbl0gPSBuZXdWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJEaWZmID0gbmV3VmFsIC0gb2xkVmFsO1xuICAgICAgICAgICAgICAgIGRpZmZzLnB1c2goY3VyckRpZmYpO1xuICAgICAgICAgICAgICAgIHRvdGFsRGlmZiArPSBjdXJyRGlmZjtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGVbaW5kZXggKyAxXSArPSB0b3RhbERpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdXBkYXRlIGNhY2hlXG4gICAgICAgIGlmIChNYXRoLmFicyh0b3RhbERpZmYpID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplICsgMTsgaiA8IHRoaXMuc2l6ZXNDYWNoZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZXNDYWNoZVtqXSArPSB0b3RhbERpZmY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBzY3JCYXIgaGVpZ2h0cy93aWR0aHNcbiAgICAgICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gcGFyc2VJbnQodGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5jaGlsZHJlblswXS5zdHlsZS53aWR0aCwgMTApICsgdG90YWxEaWZmO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGggPSB0b3RhbFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlZHVjZXIgPSAoYWNjLCB2YWwpID0+IGFjYyArIHZhbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyVG9Cb3R0b20gPSB0aGlzLl9pc1Njcm9sbGVkVG9Cb3R0b20gJiYgIXRoaXMuZGMuaW5zdGFuY2Uubm90VmlydHVhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBoU3VtID0gdGhpcy5oZWlnaHRDYWNoZS5yZWR1Y2UocmVkdWNlcik7XG4gICAgICAgICAgICAgICAgaWYgKGhTdW0gPiB0aGlzLl9tYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlydEhlaWdodFJhdGlvID0gaFN1bSAvIHRoaXMuX21heEhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IE1hdGgubWluKHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgKyB0b3RhbERpZmYsIHRoaXMuX21heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlydEhlaWdodCA9IGhTdW07XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNjcm9sbENvbXBvbmVudC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjclRvQm90dG9tICYmICF0aGlzLl9pc0F0Qm90dG9tSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhWaXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydEhlaWdodCAtIGNvbnRhaW5lclNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxUb3AgPSBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gbWF4VmlydFNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWRqdXN0VG9JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHNjcm9sbGVkIHRvIHNwZWNpZmljIGluZGV4IHdoZXJlIGFmdGVyIHNjcm9sbCBoZWlnaHRzIGFyZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYWRqdXN0IHRoZSBvZmZzZXRzIHNvIHRoYXQgaXRlbSBpcyBsYXN0IGluIHZpZXcuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXNUb0luZGV4ID0gdGhpcy5fYWRqdXN0VG9JbmRleCAtIHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bURpZmZzID0gZGlmZnMuc2xpY2UoMCwgdXBkYXRlc1RvSW5kZXgpLnJlZHVjZShyZWR1Y2VyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1bURpZmZzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNjcm9sbFRvcChzdW1EaWZmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRqdXN0VG9JbmRleCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaXhlZFVwZGF0ZUFsbEVsZW1lbnRzKGluU2Nyb2xsVG9wOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgICAgIGxldCBuZXdTdGFydCA9IHRoaXMuZ2V0SW5kZXhBdChcbiAgICAgICAgICAgIGluU2Nyb2xsVG9wLFxuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLFxuICAgICAgICAgICAgMFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChuZXdTdGFydCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gY291bnQpIHtcbiAgICAgICAgICAgIG5ld1N0YXJ0ID0gY291bnQgLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ld1N0YXJ0IC0gdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggPSBuZXdTdGFydDtcblxuICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgdGhpcy5vbkNodW5rUHJlbG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBhbmQgYXBwbHkgcGFnZSBzaXplLlxuICAgICAgICAgICAgICAgIGlmIChkaWZmICYmIE1hdGguYWJzKGRpZmYpIDw9IHRoaXMuTUFYX1BFUkZfU0NST0xMX0RJRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA+IDAgPyB0aGlzLm1vdmVBcHBseVNjcm9sbE5leHQocHJldlN0YXJ0KSA6IHRoaXMubW92ZUFwcGx5U2Nyb2xsUHJldihwcmV2U3RhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRBcHBseVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpblNjcm9sbFRvcCAtIHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBUaGUgZnVuY3Rpb24gYXBwbGllcyBhbiBvcHRpbWl6ZWQgc3RhdGUgY2hhbmdlIGZvciBzY3JvbGxpbmcgZG93bi9yaWdodCBlbXBsb3lpbmcgY29udGV4dCBjaGFuZ2Ugd2l0aCB2aWV3IHJlYXJyYW5nZW1lbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgbW92ZUFwcGx5U2Nyb2xsTmV4dChwcmV2SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGFydCA9IHByZXZJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHRoaXMuc3RhdGUuc3RhcnRJbmRleCAtIHByZXZJbmRleDtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyIGFzIFZpZXdDb250YWluZXJSZWY7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxGb2N1cyhlbWJWaWV3LnJvb3ROb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpXG4gICAgICAgICAgICAgICAgfHwgZW1iVmlldy5yb290Tm9kZXNbMF0ubmV4dEVsZW1lbnRTaWJsaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjb250YWluZXIuZGV0YWNoKDApO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydCh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJWaWV3KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBUaGUgZnVuY3Rpb24gYXBwbGllcyBhbiBvcHRpbWl6ZWQgc3RhdGUgY2hhbmdlIGZvciBzY3JvbGxpbmcgdXAvbGVmdCBlbXBsb3lpbmcgY29udGV4dCBjaGFuZ2Ugd2l0aCB2aWV3IHJlYXJyYW5nZW1lbnRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgbW92ZUFwcGx5U2Nyb2xsUHJldihwcmV2SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IgYXMgVmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHByZXZJbmRleCAtIDE7IGkgPj0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRm9jdXMoZW1iVmlldy5yb290Tm9kZXMuZmluZChub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKVxuICAgICAgICAgICAgICAgIHx8IGVtYlZpZXcucm9vdE5vZGVzWzBdLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gY29udGFpbmVyLmRldGFjaChjb250YWluZXIubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGVtcGxhdGVDb250ZXh0KGVtYlZpZXcuY29udGV4dCwgaSk7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0KHZpZXcsIDApO1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy51bnNoaWZ0KGVtYlZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRDb250ZXh0SW5kZXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSZW1vdGUgPyB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLmlneEZvck9mLmluZGV4T2YoaW5wdXQpIDogdGhpcy5pZ3hGb3JPZi5pbmRleE9mKGlucHV0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRnVuY3Rpb24gd2hpY2ggdXBkYXRlcyB0aGUgcGFzc2VkIGNvbnRleHQgb2YgYW4gZW1iZWRkZWQgdmlldyB3aXRoIHRoZSBwcm92aWRlZCBpbmRleFxuICAgICAqIGZyb20gdGhlIHZpZXcgY29udGFpbmVyLlxuICAgICAqIE9mdGVuLCBjYWxsZWQgd2hpbGUgaGFuZGxpbmcgYSBzY3JvbGwgZXZlbnQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHVwZGF0ZVRlbXBsYXRlQ29udGV4dChjb250ZXh0OiBhbnksIGluZGV4OiBudW1iZXIgPSAwKTogdm9pZCB7XG4gICAgICAgIGNvbnRleHQuJGltcGxpY2l0ID0gdGhpcy5pZ3hGb3JPZltpbmRleF07XG4gICAgICAgIGNvbnRleHQuaW5kZXggPSB0aGlzLmdldENvbnRleHRJbmRleCh0aGlzLmlneEZvck9mW2luZGV4XSk7XG4gICAgICAgIGNvbnRleHQuY291bnQgPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVGhlIGZ1bmN0aW9uIGFwcGxpZXMgYW4gb3B0aW1pemVkIHN0YXRlIGNoYW5nZSB0aHJvdWdoIGNvbnRleHQgY2hhbmdlIGZvciBlYWNoIHZpZXdcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZml4ZWRBcHBseVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSB0aGlzLl9lbWJlZGRlZFZpZXdzW2orK107XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqXG4gICAgICogQ2xlYXJzIGZvY3VzIGluc2lkZSB0aGUgdmlydHVhbGl6ZWQgY29udGFpbmVyIG9uIHNtYWxsIHNjcm9sbCBzd2Fwcy5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsRm9jdXMobm9kZT86IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIC8vIFJlbW92ZSBmb2N1cyBpbiBjYXNlIHRoZSB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgaW5zaWRlIHRoZSB2aWV3IGNvbnRhaW5lci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGhpdCBhbiBleGNlcHRpb24gd2hpbGUgZG9pbmcgdGhlICdzbWFsbCcgc2Nyb2xscyBzd2FwcGluZy5cbiAgICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb246XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL3JlbW92ZUNoaWxkXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQzMjM5MlxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyBob3Jpem9udGFsbHlcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgb25IU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMF0uc3R5bGUud2lkdGgsIDEwKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZTdGFydEluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICAvLyBVcGRhdGluZyBob3Jpem9udGFsIGNodW5rc1xuICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHMoZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQpO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gLXNjcm9sbE9mZnNldCArICdweCc7XG5cbiAgICAgICAgdGhpcy5kYy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChwcmV2U3RhcnRJbmRleCAhPT0gdGhpcy5zdGF0ZS5zdGFydEluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGNoYW5nZXMgaW4gdGhlIGl0ZW1zIGNvbGxlY3Rpb24uXG4gICAgICogQnkgZGVmYXVsdCB0aGUgb2JqZWN0IHJlZmVyZW5jZXMgYXJlIGNvbXBhcmVkLiBIb3dldmVyIHRoaXMgY2FuIGJlIG9wdGltaXplZCBpZiB5b3UgaGF2ZSB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2YgdGhlIG9iamVjdCByZWYgb3IgaWYgeW91IGhhdmUgc29tZSBvdGhlciBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgKiBpbiB0aGUgaXRlbSBvYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhY2tlZCBmb3IgY2hhbmdlcy5cbiAgICAgKiBUaGlzIG9wdGlvbiBpcyBzaW1pbGFyIHRvIG5nRm9yVHJhY2tCeS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdHJhY2tGdW5jID0gdGhpcy5wYXJlbnRWaXJ0RGlyLmlneEZvclRyYWNrQnk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgaWd4Rm9yVHJhY2tCeSgpOiBUcmFja0J5RnVuY3Rpb248VD4geyByZXR1cm4gdGhpcy5fdHJhY2tCeUZuOyB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGNoYW5nZXMgaW4gdGhlIGl0ZW1zIGNvbGxlY3Rpb24uXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgc2V0IGluIHNjZW5hcmlvcyB3aGVyZSB5b3Ugd2FudCB0byBvcHRpbWl6ZSBvclxuICAgICAqIGN1c3RvbWl6ZSB0aGUgdHJhY2tpbmcgb2YgY2hhbmdlcyBmb3IgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIFRoZSBpZ3hGb3JUcmFja0J5IGZ1bmN0aW9uIHRha2VzIHRoZSBpbmRleCBhbmQgdGhlIGN1cnJlbnQgaXRlbSBhcyBhcmd1bWVudHMgYW5kIG5lZWRzIHRvIHJldHVybiB0aGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgaXRlbS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmlneEZvclRyYWNrQnkgPSAoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgKiAgICAgIHJldHVybiBpdGVtLmlkICsgaXRlbS53aWR0aDtcbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCBpZ3hGb3JUcmFja0J5KGZuOiBUcmFja0J5RnVuY3Rpb248VD4pIHsgdGhpcy5fdHJhY2tCeUZuID0gZm47IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2FwcGx5Q2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGggJiYgdGhpcy5kYykge1xuICAgICAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3Q29weSA9IE9iamVjdC5hc3NpZ24oW10sIHRoaXMuX2VtYmVkZGVkVmlld3MpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gZW1iZWRkZWRWaWV3Q29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGVtcGxhdGVDb250ZXh0KGVtYlZpZXcuY29udGV4dCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNodW5rU2l6ZSAhPT0gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4QnJvd3NlckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc3R5bGUudG9wID0gJzk5OTk5OTk5OTk5OTk5OTlweCc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsndG9wJ10pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGNodW5rU2l6ZSBiYXNlZCBvbiBjdXJyZW50IHN0YXJ0SW5kZXggYW5kIHJldHVybnMgdGhlIG5ldyBzaXplLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggaXMgdXBkYXRlZCwgbm90IGJlZm9yZS5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZUNodW5rU2l6ZSgpOiBudW1iZXIge1xuICAgICAgICBsZXQgY2h1bmtTaXplID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAhPT0gbnVsbCAmJiB0aGlzLmlneEZvckNvbnRhaW5lclNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNpemVzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2h1bmtTaXplID0gdGhpcy5fY2FsY01heENodW5rU2l6ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWd4Rm9yT2YgJiYgY2h1bmtTaXplID4gdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjaHVua1NpemUgPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtTaXplID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEVsZW1lbnQodmlld3JlZiwgbm9kZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbSA9IHZpZXdyZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUobm9kZU5hbWUpO1xuICAgICAgICByZXR1cm4gZWxlbS5sZW5ndGggPiAwID8gZWxlbVswXSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0U2l6ZXNDYWNoZShpdGVtczogYW55W10pOiBudW1iZXIge1xuICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUucHVzaCgwKTtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgICAgICAvLyBjb2xzW2ldW2RpbWVuc2lvbl0gPSBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICBzaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRDYWNoZS5wdXNoKHNpemUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5fZ2V0SXRlbVNpemUoaXRlbXNbaV0sIGRpbWVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3RhbFNpemUgKz0gc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKHRvdGFsU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsU2l6ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZVNpemVDYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSB0aGlzLmhlaWdodENhY2hlLmxlbmd0aCA+IDAgPyB0aGlzLmhlaWdodENhY2hlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkgOiAwO1xuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBvbGRIZWlnaHQgLSBuZXdIZWlnaHQ7XG5cbiAgICAgICAgLy8gaWYgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIHdoaWxlIGNvbnRhaW5lciBpcyBzY3JvbGxlZFxuICAgICAgICAvLyBzaG91bGQgdXBkYXRlIHNjcm9sbCB0b3AvbGVmdCBhY2NvcmRpbmcgdG8gY2hhbmdlIHNvIHRoYXQgc2FtZSBzdGFydEluZGV4IGlzIGluIHZpZXdcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wLCAxMCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF0gLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBtYXhMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgaWYgKCFhdmFpbGFibGVTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChhY2N1bXVsYXRvciwgY3VycmVudEl0ZW0pID0+IGFjY3VtdWxhdG9yICsgdGhpcy5fZ2V0SXRlbVNpemUoY3VycmVudEl0ZW0sIGRpbWVuc2lvbik7XG4gICAgICAgIGZvciAoaTsgaSA8IHRoaXMuaWd4Rm9yT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHsgdmFsdWU6IHRoaXMuaWd4Rm9yT2ZbaV0sIGhlaWdodDogdGhpcy5oZWlnaHRDYWNoZVtpXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgP1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGVbaV0gOlxuICAgICAgICAgICAgICAgIHRoaXMuX2dldEl0ZW1TaXplKGl0ZW0sIGRpbWVuc2lvbik7XG4gICAgICAgICAgICBzdW0gPSBhcnIucmVkdWNlKHJlZHVjZXIsIHNpemUpO1xuICAgICAgICAgICAgaWYgKHN1bSA8IGF2YWlsYWJsZVNpemUpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBlbmQgd2l0aG91dCBleGNlZWRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBwcmV2IGl0ZW1zIHVudGlsIHNpemUgaXMgZmlsbGVkIG9yIGZpcnN0IGl0ZW0gaXMgcmVhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1ckl0ZW0gPSBkaW1lbnNpb24gPT09ICdoZWlnaHQnID8gYXJyWzBdLnZhbHVlIDogYXJyWzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldkluZGV4ID0gdGhpcy5pZ3hGb3JPZi5pbmRleE9mKGN1ckl0ZW0pIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHByZXZJbmRleCA+PSAwICYmIHN1bSA8PSBhdmFpbGFibGVTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJJdGVtID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGFyclswXS52YWx1ZSA6IGFyclswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJbmRleCA9IHRoaXMuaWd4Rm9yT2YuaW5kZXhPZihjdXJJdGVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SXRlbSA9IHRoaXMuaWd4Rm9yT2ZbcHJldkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZTaXplID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRDYWNoZVtwcmV2SW5kZXhdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChwcmV2SXRlbVtkaW1lbnNpb25dLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBhcnIucmVkdWNlKHJlZHVjZXIsIHByZXZTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KHByZXZJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGFyci5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4TGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0SW5kZXhBdChsZWZ0LCBzZXQsIGluZGV4KSB7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSBzZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZElkeCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgICAgICAgICAgY29uc3QgbWlkTGVmdCA9IHNldFttaWRJZHhdO1xuICAgICAgICAgICAgY29uc3QgY21wID0gbGVmdCAtIG1pZExlZnQ7XG4gICAgICAgICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWlkSWR4ICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IG1pZElkeCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWRJZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3JlY2FsY1Njcm9sbEJhclNpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiAodGhpcy5pZ3hGb3JPZiA/IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIDogMCk7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uubm90VmlydHVhbCA9ICEodGhpcy5pZ3hGb3JDb250YWluZXJTaXplICYmIHRoaXMuZGMgJiYgdGhpcy5zdGF0ZS5jaHVua1NpemUgPCBjb3VudCk7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGUgPSB0aGlzLmlzU2Nyb2xsYWJsZSgpO1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFdpZHRoID0gdGhpcy5pZ3hGb3JDb250YWluZXJTaXplID8gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKSA6IDA7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy5pZ3hGb3JDb250YWluZXJTaXplICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPD0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHJlc2V0IHRoZSBzY3JvbGxBbW91bnQgdmFsdWUgaGVyZSwgYmVjYXVzZSBob3Jpem9udGFsU2Nyb2xsQmFyIGlzIGhpZGRlbiwgdGhlcmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gb25TY3JvbGwgZXZlbnQgaGFuZGxlciBmb3IgVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmUgd2lsbCBub3QgYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2Nyb2xsQW1vdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID0gdGhpcy5fY2FsY0hlaWdodCgpO1xuICAgICAgICAgICAgaWYgKCB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplIDw9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byByZXNldCB0aGUgc2Nyb2xsQW1vdW50IHZhbHVlIGhlcmUsIGJlY2F1c2UgdmVydGljYWxTY3JvbGxCYXIgaXMgaGlkZGVuLCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAgICAvLyBvblNjcm9sbCBldmVudCBoYW5kbGVyIGZvciBWaXJ0dWFsSGVscGVyQmFzZURpcmVjdGl2ZSB3aWxsIG5vdCBiZSBjYWxsZWRcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JvbGxhYmxlICE9PSB0aGlzLmlzU2Nyb2xsYWJsZSgpKSB7XG4gICAgICAgICAgICAvLyBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgdGhpcy5vblNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2FsY0hlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRDYWNoZSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5oZWlnaHRDYWNoZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXJ0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAoaGVpZ2h0ID4gdGhpcy5fbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl92aXJ0SGVpZ2h0UmF0aW8gPSBoZWlnaHQgLyB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9tYXhIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3JlY2FsY09uQ29udGFpbmVyQ2hhbmdlKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgY29uc3QgcHJldkNodW5rU2l6ZSA9IHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB0aGlzLmFwcGx5Q2h1bmtTaXplQ2hhbmdlKCk7XG4gICAgICAgIHRoaXMuX3JlY2FsY1Njcm9sbEJhclNpemUoKTtcbiAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2l6ZXNDYWNoZSAmJiB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIGhvcml6b250YWwgY2h1bmtzIGFuZCBvZmZzZXRzIGJhc2VkIG9uIHRoZSBuZXcgc2Nyb2xsTGVmdFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuc2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IC1zY3JvbGxPZmZzZXQgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJlbW92ZXMgYW4gZWxlbWVuZXQgZnJvbSB0aGUgZW1iZWRkZWQgdmlld3MgYW5kIHVwZGF0ZXMgY2h1bmtTaXplLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW1vdmVMYXN0RWxlbSgpIHtcbiAgICAgICAgY29uc3Qgb2xkRWxlbSA9IHRoaXMuX2VtYmVkZGVkVmlld3MucG9wKCk7XG4gICAgICAgIHRoaXMub25CZWZvcmVWaWV3RGVzdHJveWVkLmVtaXQob2xkRWxlbSk7XG4gICAgICAgIC8vIGFsc28gZGV0YWNoIGZyb20gVmlld0NvbnRhaW5lclJlZiB0byBtYWtlIGFic29sdXRlbHkgc3VyZSB0aGlzIGlzIHJlbW92ZWQgZnJvbSB0aGUgdmlldyBjb250YWluZXIuXG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5kZXRhY2godGhpcy5kYy5pbnN0YW5jZS5fdmNyLmxlbmd0aCAtIDEpO1xuICAgICAgICBvbGRFbGVtLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZS0tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBJZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCB0aGF0IHdlIGNhbiBjcmVhdGUgZW1iZWRkZWQgdmlldyBmb3IgY3JlYXRlcyBpdCwgYXBwZW5kcyBpdCBhbmQgdXBkYXRlcyBjaHVua1NpemVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWRkTGFzdEVsZW0oKSB7XG4gICAgICAgIGxldCBlbGVtSW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbUluZGV4ID49IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltlbGVtSW5kZXhdO1xuICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICBuZXcgSWd4Rm9yT2ZDb250ZXh0PFQ+KGlucHV0LCB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCksIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSsrO1xuXG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgY2h1bmtTaXplIGFuZCBhZGRzL3JlbW92ZXMgZWxlbWVudHMgaWYgbmVlZCBkdWUgdG8gdGhlIGNoYW5nZS5cbiAgICAgKiB0aGlzLnN0YXRlLmNodW5rU2l6ZSBpcyB1cGRhdGVkIGluIEBhZGRMYXN0RWxlbSgpIG9yIEByZW1vdmVMYXN0RWxlbSgpXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFwcGx5Q2h1bmtTaXplQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSB0aGlzLmlzUmVtb3RlID8gKHRoaXMuaWd4Rm9yT2YgPyB0aGlzLmlneEZvck9mLmxlbmd0aCA6IDApIDogdGhpcy5fY2FsY3VsYXRlQ2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChjaHVua1NpemUgPiB0aGlzLnN0YXRlLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNodW5rU2l6ZSAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExhc3RFbGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmtTaXplIDwgdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSAtIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXN0RWxlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVTY3JvbGxPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZTY3JvbGxPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF91cGRhdGVWU2Nyb2xsT2Zmc2V0KCkge1xuICAgICAgICBsZXQgc2Nyb2xsT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRTY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5fdmlydEhlaWdodFJhdGlvICE9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjVmlydHVhbFNjcm9sbFRvcCh0aGlzLnNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZTY3JvbGwgPSAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gdlNjcm9sbCAmJiB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID9cbiAgICAgICAgY3VycmVudFNjcm9sbFRvcCAtIHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIDogMDtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gLShzY3JvbGxPZmZzZXQpICsgJ3B4JztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NhbGNWaXJ0dWFsU2Nyb2xsVG9wKHNjcm9sbFRvcDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgbWF4UmVhbFNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgLSBjb250YWluZXJTaXplO1xuICAgICAgICBjb25zdCByZWFsUGVyY2VudFNjcm9sbGVkID0gbWF4UmVhbFNjcm9sbFRvcCAhPT0gMCA/ICBzY3JvbGxUb3AgLyBtYXhSZWFsU2Nyb2xsVG9wIDogMDtcbiAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRIZWlnaHQgLSBjb250YWluZXJTaXplO1xuICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsVG9wID0gcmVhbFBlcmNlbnRTY3JvbGxlZCAqIG1heFZpcnRTY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdXBkYXRlSFNjcm9sbE9mZnNldCgpIHtcbiAgICAgICAgbGV0IHNjcm9sbE9mZnNldCA9IDA7XG4gICAgICAgIHNjcm9sbE9mZnNldCA9ICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID9cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gLSB0aGlzLnNpemVzQ2FjaGVbdGhpcy5zdGF0ZS5zdGFydEluZGV4XSA6IDA7XG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSAtc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXRJdGVtU2l6ZShpdGVtLCBkaW1lbnNpb246IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGl0ZW1bZGltZW5zaW9uXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkaW0gPT09ICdudW1iZXInID8gZGltIDogcGFyc2VJbnQodGhpcy5pZ3hGb3JJdGVtU2l6ZSwgMTApIHx8IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodHlwZTogYW55KTogc3RyaW5nIHtcbiAgICBjb25zdCBuYW1lID0gJ25hbWUnO1xuICAgIHJldHVybiB0eXBlW25hbWVdIHx8IHR5cGVvZiB0eXBlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGb3JPZlN0YXRlIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIHN0YXJ0SW5kZXg/OiBudW1iZXI7XG4gICAgY2h1bmtTaXplPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBjb250YWluZXJTaXplOiBudW1iZXI7XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneEdyaWRGb3JdW2lneEdyaWRGb3JPZl0nXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRGb3JPZkRpcmVjdGl2ZTxUPiBleHRlbmRzIElneEZvck9mRGlyZWN0aXZlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2sge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPE5nRm9yT2ZDb250ZXh0PFQ+PixcbiAgICAgICAgX2RpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJvdGVjdGVkIHN5bmNTY3JvbGxTZXJ2aWNlOiBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgc3luY1NlcnZpY2U6IElneEZvck9mU3luY1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSwgX2RpZmZlcnMsIHJlc29sdmVyLCBjZHIsIF96b25lLCBzeW5jU2Nyb2xsU2VydmljZSk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgaWd4R3JpZEZvck9mKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaWd4Rm9yT2YgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgaWd4R3JpZEZvck9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZ3hGb3JPZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBhZnRlciBkYXRhIGhhcyBiZWVuIGNoYW5nZWQgYnV0IGJlZm9yZSB0aGUgdmlldyBpcyByZWZyZXNoZWRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25EYXRhQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncz4oKTtcblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnNldE1hc3Rlcih0aGlzKTtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgZm9yT2YgPSAnaWd4R3JpZEZvck9mJztcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgIGlmIChmb3JPZiBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbZm9yT2ZdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZGlmZmVyICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHZhbHVlKS5jcmVhdGUodGhpcy5pZ3hGb3JUcmFja0J5KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBDYW5ub3QgZmluZCBhIGRpZmZlciBzdXBwb3J0aW5nIG9iamVjdCBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7Z2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcodmFsdWUpfVwiLlxuICAgICAgICAgICAgICAgICAgICAgTmdGb3Igb25seSBzdXBwb3J0cyBiaW5kaW5nIHRvIEl0ZXJhYmxlcyBzdWNoIGFzIEFycmF5cy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdEl0ZW1TaXplID0gJ2lneEZvckl0ZW1TaXplJztcbiAgICAgICAgaWYgKGRlZmF1bHRJdGVtU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2RlZmF1bHRJdGVtU2l6ZV0uZmlyc3RDaGFuZ2UgJiZcbiAgICAgICAgICAgICB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBkZWZhdWx0IGl0ZW0gc2l6ZSBjaGFuZ2VkLlxuICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gJ2lneEZvckNvbnRhaW5lclNpemUnO1xuICAgICAgICBpZiAoY29udGFpbmVyU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2NvbnRhaW5lclNpemVdLmZpcnN0Q2hhbmdlICYmIHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY09uQ29udGFpbmVyQ2hhbmdlKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgc2l6ZXNDYWNoZSgpOiBudW1iZXJbXSB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZXNDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jU2VydmljZS5zaXplc0NhY2hlKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHNldCBzaXplc0NhY2hlKHZhbHVlOiBudW1iZXJbXSkge1xuICAgICAgICB0aGlzLl9zaXplc0NhY2hlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBpdGVtc0RpbWVuc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIDogJ2hlaWdodCc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEl0ZW1TaXplKGl0ZW0pIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgP1xuICAgICAgICAgICAgdGhpcy5pZ3hGb3JTaXplUHJvcE5hbWUgOiAnaGVpZ2h0JztcbiAgICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcpIHtcbiAgICAgICAgICAgIHNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uc3VtbWFyaWVzKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGl0ZW0ubWF4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0uZ3JvdXBzICYmIGl0ZW0uaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGl0ZW0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZSA9IHBhcnNlSW50KGl0ZW1bZGltZW5zaW9uXSwgMTApIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGluaXRTaXplc0NhY2hlKGl0ZW1zOiBhbnlbXSk6IG51bWJlciB7XG4gICAgICAgIGlmICghdGhpcy5zeW5jU2VydmljZS5pc01hc3Rlcih0aGlzKSkge1xuICAgICAgICAgICAgY29uc3QgbWFzdGVyU2l6ZXNDYWNoZSA9IHRoaXMuc3luY1NlcnZpY2Uuc2l6ZXNDYWNoZSh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXN0ZXJTaXplc0NhY2hlW21hc3RlclNpemVzQ2FjaGUubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5oZWlnaHRDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUucHVzaCgwKTtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuZ2V0SXRlbVNpemUoaXRlbXNbaV0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNEaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRDYWNoZS5wdXNoKHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG90YWxTaXplICs9IHNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUucHVzaCh0b3RhbFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbFNpemU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVTaXplQ2FjaGUoY2hhbmdlczogSXRlcmFibGVDaGFuZ2VzPFQ+ID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gdGhpcy5oZWlnaHRDYWNoZS5sZW5ndGggPiAwID8gdGhpcy5oZWlnaHRDYWNoZS5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MgKyB2YWwpIDogMDtcbiAgICAgICAgbGV0IG5ld0hlaWdodCA9IG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGNoYW5nZXMgJiYgIXRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IHRoaXMuaGFuZGxlQ2FjaGVDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBvbGRIZWlnaHQgLSBuZXdIZWlnaHQ7XG5cbiAgICAgICAgLy8gaWYgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkIHdoaWxlIGNvbnRhaW5lciBpcyBzY3JvbGxlZFxuICAgICAgICAvLyBzaG91bGQgdXBkYXRlIHNjcm9sbCB0b3AvbGVmdCBhY2NvcmRpbmcgdG8gY2hhbmdlIHNvIHRoYXQgc2FtZSBzdGFydEluZGV4IGlzIGluIHZpZXdcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMCkge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBjb2RlIGNhbiBiZSByZW1vdmVkLiBIb3dldmVyIHRlc3RzIG5lZWQgdG8gYmUgcmV3cml0dGVuIGluIGEgd2F5IHRoYXQgdGhleSB3YWl0IGZvciBSZXNpemVPYnNlcnZlZCB0byBjb21wbGV0ZS5cbiAgICAgICAgICAgIC8vIFNvIGxlYXZpbmcgYXMgaXMgZm9yIHRoZSBtb21lbnQuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZUludCh0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxQb3NpdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF0gLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaGFuZGxlQ2FjaGVDaGFuZ2VzKGNoYW5nZXM6IEl0ZXJhYmxlQ2hhbmdlczxUPikge1xuICAgICAgICBjb25zdCBpZGVudGl0eUNoYW5nZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0Q2FjaGUgPSBbXTtcbiAgICAgICAgY29uc3QgbmV3U2l6ZXNDYWNoZSA9IFtdO1xuICAgICAgICBuZXdTaXplc0NhY2hlLnB1c2goMCk7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSAwO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcmVtb3ZlZCBpdGVtcyB0aGUgY2hhbmdlcyBhcmUgbm90IHJlbGlhYmxlIHNvIHRob3NlIHdpdGggaWRlbnRpdHkgY2hhbmdlIHNob3VsZCBiZSBkZWZhdWx0IHNpemUuXG4gICAgICAgIGxldCBudW1SZW1vdmVkSXRlbXMgPSAwO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbSgoKSA9PiBudW1SZW1vdmVkSXRlbXMrKyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBpZGVudGl0eSBjaGFuZ2VzIHRvIGRldGVybWluZSBsYXRlciBpZiB0aG9zZSB0aGF0IGhhdmUgY2hhbmdlZCB0aGVpciBpbmRleGVzIHNob3VsZCBiZSBhc3NpZ25lZCBkZWZhdWx0IGl0ZW0gc2l6ZS5cbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmN1cnJlbnRJbmRleCAhPT0gaXRlbS5wcmV2aW91c0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBvbmVzIHRoYXQgaGF2ZSBub3QgY2hhbmdlZCB0aGVpciBpbmRleC5cbiAgICAgICAgICAgICAgICBpZGVudGl0eUNoYW5nZXNbaXRlbS5jdXJyZW50SW5kZXhdID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUHJvY2Vzc2luZyBlYWNoIGl0ZW0gdGhhdCBpcyBwYXNzZWQgdG8gdGhlIGlneEZvck9mIHNvIGZhciBzZWVtIHRvIGJlIG1vc3QgcmVsaWFibGUuIFdlIHBhcnNlIHRoZSB1cGRhdGVkIGxpc3Qgb2YgaXRlbXMuXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaEl0ZW0oKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzSW5kZXggIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAobnVtUmVtb3ZlZEl0ZW1zIDwgMiB8fCAhaWRlbnRpdHlDaGFuZ2VzLmxlbmd0aCB8fCBpZGVudGl0eUNoYW5nZXNbaXRlbS5jdXJyZW50SW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIC8vIFJldXNlIGNhY2hlIG9uIHRob3NlIHdobyBoYXZlIHByZXZpb3VzSW5kZXguXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSByZW1vdmVkIGl0ZW1zIGN1cnJlbnRseSB0aGUgY2hhbmdlcyBhcmUgbm90IHJlYWRhYmxlIHNvIG9uZXMgd2l0aCBpZGVudGl0eSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmFjYWxjdWxhdGVkLlxuICAgICAgICAgICAgICAgIG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XSA9IHRoaXMuaGVpZ2h0Q2FjaGVbaXRlbS5wcmV2aW91c0luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIGRlZmF1bHQgaXRlbSBzaXplLlxuICAgICAgICAgICAgICAgIG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XSA9IHRoaXMuZ2V0SXRlbVNpemUoaXRlbS5pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1NpemVzQ2FjaGVbaXRlbS5jdXJyZW50SW5kZXggKyAxXSA9IG5ld1NpemVzQ2FjaGVbaXRlbS5jdXJyZW50SW5kZXhdICsgbmV3SGVpZ2h0Q2FjaGVbaXRlbS5jdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgbmV3SGVpZ2h0ICs9IG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGVpZ2h0Q2FjaGUgPSBuZXdIZWlnaHRDYWNoZTtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlID0gbmV3U2l6ZXNDYWNoZTtcbiAgICAgICAgcmV0dXJuIG5ld0hlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGFzc3VtZU1hc3RlcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2l6ZXNDYWNoZSA9IHRoaXMuc3luY1NlcnZpY2Uuc2l6ZXNDYWNoZSh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyU2l6ZTogdGhpcy5pZ3hGb3JDb250YWluZXJTaXplXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YUNoYW5naW5nLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gIHJlLWluaXQgY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2YgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogd2UgbmVlZCB0byByZXNldCB0aGUgbWFzdGVyIGRpciBpZiBhbGwgcm93cyBhcmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIChlLmcuIGJlY2F1c2Ugb2YgZmlsdGVyaW5nKTsgaWYgYWxsIGNvbHVtbnMgYXJlIGhpZGRlbiwgcm93cyBhcmVcbiAgICAgICAgICAgICAgICBzdGlsbCByZW5kZXJlZCBlbXB0eSwgc28gd2Ugc2hvdWxkIG5vdCByZXNldCBtYXN0ZXIgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWd4Rm9yT2YubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jU2VydmljZS5yZXNldE1hc3RlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnNldE1hc3Rlcih0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlneEZvckNvbnRhaW5lclNpemUgPSBhcmdzLmNvbnRhaW5lclNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2l6ZUNhY2hlKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhQ2hhbmdlZC5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNjcm9sbChldmVudCkge1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0LCAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2JTY3JvbGxJbnRlcm5hbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1ZpcnR1YWxTY3JvbGxUb3AoZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHModGhpcy5fdmlydFNjcm9sbFRvcCk7XG5cbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudG9wID0gLShzY3JvbGxPZmZzZXQpICsgJ3B4JztcblxuICAgICAgICB0aGlzLl96b25lLm9uU3RhYmxlLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY1VwZGF0ZVNpemVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBvbkhTY3JvbGwoc2Nyb2xsQW1vdW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29tcG9uZW50IHx8ICFwYXJzZUludCh0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuWzBdLnN0eWxlLndpZHRoLCAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGluZyBob3Jpem9udGFsIGNodW5rc1xuICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHMoc2Nyb2xsQW1vdW50KTtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IC1zY3JvbGxPZmZzZXQgKyAncHgnO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBhZGRMYXN0RWxlbSgpIHtcbiAgICAgICAgbGV0IGVsZW1JbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZW1vdGUgJiYgIXRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGVtSW5kZXggPj0gdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1JbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoIC0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlneEZvck9mW2VsZW1JbmRleF07XG4gICAgICAgIGNvbnN0IGVtYmVkZGVkVmlldyA9IHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5jcmVhdGVFbWJlZGRlZFZpZXcoXG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSxcbiAgICAgICAgICAgIG5ldyBJZ3hGb3JPZkNvbnRleHQ8VD4oaW5wdXQsIHRoaXMuZ2V0Q29udGV4dEluZGV4KGlucHV0KSwgdGhpcy5pZ3hGb3JPZi5sZW5ndGgpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYmVkZGVkVmlldyk7XG4gICAgICAgIHRoaXMuc3RhdGUuY2h1bmtTaXplKys7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVWaWV3cyhwcmV2Q2h1bmtTaXplKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvck9mICYmIHRoaXMuaWd4Rm9yT2YubGVuZ3RoICYmIHRoaXMuZGMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkVmlld0NvcHkgPSBPYmplY3QuYXNzaWduKFtdLCB0aGlzLl9lbWJlZGRlZFZpZXdzKTtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4O1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgPiB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuc3RhdGUuY2h1bmtTaXplICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4ICYmIHRoaXMuaWd4Rm9yT2ZbaV0gIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1iVmlldyA9IGVtYmVkZGVkVmlld0NvcHkuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBfYXBwbHlDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBwcmV2Q2h1bmtTaXplID0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuYXBwbHlDaHVua1NpemVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjU2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVWaWV3cyhwcmV2Q2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2NhbGNNYXhDaHVua1NpemUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zeW5jU2VydmljZS5jaHVua1NpemUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hGb3JPZkRpcmVjdGl2ZSwgSWd4R3JpZEZvck9mRGlyZWN0aXZlLCBEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50LCBWaXJ0dWFsSGVscGVyQ29tcG9uZW50LFxuICAgICAgICAgSFZpcnR1YWxIZWxwZXJDb21wb25lbnQsIFZpcnR1YWxIZWxwZXJCYXNlRGlyZWN0aXZlXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50LCBWaXJ0dWFsSGVscGVyQ29tcG9uZW50LCBIVmlydHVhbEhlbHBlckNvbXBvbmVudF0sXG4gICAgZXhwb3J0czogW0lneEZvck9mRGlyZWN0aXZlLCBJZ3hHcmlkRm9yT2ZEaXJlY3RpdmVdLFxuICAgIGltcG9ydHM6IFtJZ3hTY3JvbGxJbmVydGlhTW9kdWxlLCBDb21tb25Nb2R1bGVdXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4Rm9yT2ZNb2R1bGUge1xufVxuIl19