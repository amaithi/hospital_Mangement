import { __decorate } from "tslib";
import { Directive, HostBinding, NgModule, Input } from '@angular/core';
export var IgxDividerType;
(function (IgxDividerType) {
    IgxDividerType["SOLID"] = "solid";
    IgxDividerType["DASHED"] = "dashed";
})(IgxDividerType || (IgxDividerType = {}));
var NEXT_ID = 0;
var IgxDividerDirective = /** @class */ (function () {
    function IgxDividerDirective() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = "igx-divider-" + NEXT_ID++;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    Object.defineProperty(IgxDividerDirective.prototype, "isDashed", {
        get: function () {
            return this.type === IgxDividerType.DASHED;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDividerDirective.prototype, "isSolid", {
        /**
         * A getter that returns `true` if the type of the divider is `default`;
         * ```typescript
         * const isDefault = this.divider.isDefault;
         * ```
         */
        get: function () {
            return this.type === IgxDividerType.SOLID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDividerDirective.prototype, "inset", {
        /**
         * Gets the current divider inset in terms of
         * margin representation as applied to the divider.
         * ```typescript
         * const inset = this.divider.inset;
         * ```
         */
        get: function () {
            var baseMargin = '0';
            if (this.middle) {
                if (this.vertical) {
                    return this._inset + " " + baseMargin;
                }
                return baseMargin + " " + this._inset;
            }
            else {
                if (this.vertical) {
                    return this._inset + " " + baseMargin + " 0 " + baseMargin;
                }
                return baseMargin + " 0 " + baseMargin + " " + this._inset;
            }
        },
        /**
         * Sets the inset of the divider from the side(s).
         * If the divider attribute `middle` is set to `true`,
         * it will inset the divider on both sides.
         * ```typescript
         * this.divider.inset = '32px';
         * ```
         */
        set: function (value) {
            this._inset = value;
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('attr.id'),
        Input()
    ], IgxDividerDirective.prototype, "id", void 0);
    __decorate([
        Input('inset')
    ], IgxDividerDirective.prototype, "_inset", void 0);
    __decorate([
        HostBinding('attr.role'),
        Input()
    ], IgxDividerDirective.prototype, "role", void 0);
    __decorate([
        HostBinding('class.igx-divider'),
        Input()
    ], IgxDividerDirective.prototype, "type", void 0);
    __decorate([
        HostBinding('class.igx-divider--dashed')
    ], IgxDividerDirective.prototype, "isDashed", null);
    __decorate([
        HostBinding('class.igx-divider--inset'),
        Input()
    ], IgxDividerDirective.prototype, "middle", void 0);
    __decorate([
        HostBinding('class.igx-divider--vertical'),
        Input()
    ], IgxDividerDirective.prototype, "vertical", void 0);
    __decorate([
        HostBinding('style.margin')
    ], IgxDividerDirective.prototype, "inset", null);
    IgxDividerDirective = __decorate([
        Directive({
            // tslint:disable-next-line:directive-selector
            selector: 'igx-divider'
        })
    ], IgxDividerDirective);
    return IgxDividerDirective;
}());
export { IgxDividerDirective };
var IgxDividerModule = /** @class */ (function () {
    function IgxDividerModule() {
    }
    IgxDividerModule = __decorate([
        NgModule({
            declarations: [IgxDividerDirective],
            exports: [IgxDividerDirective]
        })
    ], IgxDividerModule);
    return IgxDividerModule;
}());
export { IgxDividerModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGl2aWRlci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZGl2aWRlci9kaXZpZGVyLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV4RSxNQUFNLENBQU4sSUFBWSxjQUdYO0FBSEQsV0FBWSxjQUFjO0lBQ3RCLGlDQUFlLENBQUE7SUFDZixtQ0FBaUIsQ0FBQTtBQUNyQixDQUFDLEVBSFcsY0FBYyxLQUFkLGNBQWMsUUFHekI7QUFFRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFNaEI7SUFBQTtRQUNJOzs7Ozs7Ozs7V0FTRztRQUdJLE9BQUUsR0FBRyxpQkFBZSxPQUFPLEVBQUksQ0FBQztRQUd2Qzs7Ozs7O1dBTUc7UUFFSyxXQUFNLEdBQUcsR0FBRyxDQUFDO1FBRXJCOzs7V0FHRztRQUdJLFNBQUksR0FBRyxXQUFXLENBQUM7UUFFMUI7Ozs7OztXQU1HO1FBR0ksU0FBSSxHQUE0QixjQUFjLENBQUMsS0FBSyxDQUFDO1FBTzVEOzs7Ozs7O1dBT0c7UUFHSSxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBWXRCOzs7OztXQUtHO1FBR0ksYUFBUSxHQUFHLEtBQUssQ0FBQztJQXFDNUIsQ0FBQztJQXZFRyxzQkFBSSx5Q0FBUTthQUFaO1lBQ0ksT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxNQUFNLENBQUM7UUFDL0MsQ0FBQzs7O09BQUE7SUFvQkQsc0JBQUksd0NBQU87UUFOWDs7Ozs7V0FLRzthQUNIO1lBQ0ksT0FBTyxJQUFJLENBQUMsSUFBSSxLQUFLLGNBQWMsQ0FBQyxLQUFLLENBQUM7UUFDOUMsQ0FBQzs7O09BQUE7SUFxQkQsc0JBQUksc0NBQUs7UUFJVDs7Ozs7O1dBTUc7YUFDSDtZQUNJLElBQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQztZQUV2QixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2IsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNmLE9BQVUsSUFBSSxDQUFDLE1BQU0sU0FBSSxVQUFZLENBQUM7aUJBQ3pDO2dCQUNELE9BQVUsVUFBVSxTQUFJLElBQUksQ0FBQyxNQUFRLENBQUM7YUFDekM7aUJBQU07Z0JBQ0gsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUNmLE9BQVUsSUFBSSxDQUFDLE1BQU0sU0FBSSxVQUFVLFdBQU0sVUFBWSxDQUFDO2lCQUN6RDtnQkFDRCxPQUFVLFVBQVUsV0FBTSxVQUFVLFNBQUksSUFBSSxDQUFDLE1BQVEsQ0FBQzthQUN6RDtRQUNMLENBQUM7UUFsQ0Q7Ozs7Ozs7V0FPRzthQUVILFVBQVUsS0FBYTtZQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUN4QixDQUFDOzs7T0FBQTtJQWhGRDtRQUZDLFdBQVcsQ0FBQyxTQUFTLENBQUM7UUFDdEIsS0FBSyxFQUFFO21EQUMrQjtJQVd2QztRQURDLEtBQUssQ0FBQyxPQUFPLENBQUM7dURBQ007SUFRckI7UUFGQyxXQUFXLENBQUMsV0FBVyxDQUFDO1FBQ3hCLEtBQUssRUFBRTtxREFDa0I7SUFXMUI7UUFGQyxXQUFXLENBQUMsbUJBQW1CLENBQUM7UUFDaEMsS0FBSyxFQUFFO3FEQUNvRDtJQUc1RDtRQURDLFdBQVcsQ0FBQywyQkFBMkIsQ0FBQzt1REFHeEM7SUFZRDtRQUZDLFdBQVcsQ0FBQywwQkFBMEIsQ0FBQztRQUN2QyxLQUFLLEVBQUU7dURBQ2M7SUFvQnRCO1FBRkMsV0FBVyxDQUFDLDZCQUE2QixDQUFDO1FBQzFDLEtBQUssRUFBRTt5REFDZ0I7SUFXeEI7UUFEQyxXQUFXLENBQUMsY0FBYyxDQUFDO29EQUczQjtJQTdGUSxtQkFBbUI7UUFKL0IsU0FBUyxDQUFDO1lBQ1AsOENBQThDO1lBQzlDLFFBQVEsRUFBRSxhQUFhO1NBQzFCLENBQUM7T0FDVyxtQkFBbUIsQ0FxSC9CO0lBQUQsMEJBQUM7Q0FBQSxBQXJIRCxJQXFIQztTQXJIWSxtQkFBbUI7QUEySGhDO0lBQUE7SUFBZ0MsQ0FBQztJQUFwQixnQkFBZ0I7UUFKNUIsUUFBUSxDQUFDO1lBQ04sWUFBWSxFQUFFLENBQUMsbUJBQW1CLENBQUM7WUFDbkMsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUM7U0FDakMsQ0FBQztPQUNXLGdCQUFnQixDQUFJO0lBQUQsdUJBQUM7Q0FBQSxBQUFqQyxJQUFpQztTQUFwQixnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBOZ01vZHVsZSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGVudW0gSWd4RGl2aWRlclR5cGUge1xuICAgIFNPTElEID0gJ3NvbGlkJyxcbiAgICBEQVNIRUQgPSAnZGFzaGVkJ1xufVxuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbkBEaXJlY3RpdmUoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgICBzZWxlY3RvcjogJ2lneC1kaXZpZGVyJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hEaXZpZGVyRGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBpZGAgb2YgdGhlIGRpdmlkZXIuXG4gICAgICogSWYgbm90IHNldCwgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LWRpdmlkZXItMFwiYDtcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIGlkPVwibXktZGl2aWRlclwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBkaXZpZGVySWQgPSAgdGhpcy5kaXZpZGVyLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LWRpdmlkZXItJHtORVhUX0lEKyt9YDtcblxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpbnNldGAgYXR0cmlidXRlLlxuICAgICAqIElmIG5vdCBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCB0byBgJzAnYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIGluc2V0PVwiMTZweFwiPjwvaWd4LWRpdmlkZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpbnNldCcpXG4gICAgcHJpdmF0ZSBfaW5zZXQgPSAnMCc7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgcm9sZWAgYXR0cmlidXRlLlxuICAgICAqIElmIG5vdCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgc2VwYXJhdG9yYCB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvbGUgPSAnc2VwYXJhdG9yJztcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHR5cGUgb2YgdGhlIGRpdmlkZXIuIFRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICogaXMgYGRlZmF1bHRgLiBUaGUgZGl2aWRlciBjYW4gYWxzbyBiZSBgZGFzaGVkYDtcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1kaXZpZGVyIHR5cGU9XCJkYXNoZWRcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXInKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHR5cGU6IElneERpdmlkZXJUeXBlIHwgc3RyaW5nID0gSWd4RGl2aWRlclR5cGUuU09MSUQ7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS1kYXNoZWQnKVxuICAgIGdldCBpc0Rhc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4RGl2aWRlclR5cGUuREFTSEVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCB0aGF0IHNldHMgdGhlIGBtaWRkbGVgIGF0dHJpYnV0ZSBvZiB0aGUgZGl2aWRlci5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgIGFuZCBhbiBgaW5zZXRgIHZhbHVlIGhhcyBiZWVuIHByb3ZpZGVkLFxuICAgICAqIHRoZSBkaXZpZGVyIHdpbGwgc3RhcnQgc2hyaW5raW5nIGZyb20gYm90aCBlbmRzLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgW21pZGRsZV09XCJ0cnVlXCI+PC9pZ3gtZGl2aWRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kaXZpZGVyLS1pbnNldCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbWlkZGxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgYHRydWVgIGlmIHRoZSB0eXBlIG9mIHRoZSBkaXZpZGVyIGlzIGBkZWZhdWx0YDtcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaXNEZWZhdWx0ID0gdGhpcy5kaXZpZGVyLmlzRGVmYXVsdDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgaXNTb2xpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gSWd4RGl2aWRlclR5cGUuU09MSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHRoYXQgc2V0cyB0aGUgdmVydGljYWwgYXR0cmlidXRlIG9mIHRoZSBkaXZpZGVyLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWRpdmlkZXIgW3ZlcnRpY2FsXT1cInRydWVcIj48L2lneC1kaXZpZGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWRpdmlkZXItLXZlcnRpY2FsJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB2ZXJ0aWNhbCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5zZXQgb2YgdGhlIGRpdmlkZXIgZnJvbSB0aGUgc2lkZShzKS5cbiAgICAgKiBJZiB0aGUgZGl2aWRlciBhdHRyaWJ1dGUgYG1pZGRsZWAgaXMgc2V0IHRvIGB0cnVlYCxcbiAgICAgKiBpdCB3aWxsIGluc2V0IHRoZSBkaXZpZGVyIG9uIGJvdGggc2lkZXMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZGl2aWRlci5pbnNldCA9ICczMnB4JztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm1hcmdpbicpXG4gICAgc2V0IGluc2V0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5faW5zZXQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGRpdmlkZXIgaW5zZXQgaW4gdGVybXMgb2ZcbiAgICAgKiBtYXJnaW4gcmVwcmVzZW50YXRpb24gYXMgYXBwbGllZCB0byB0aGUgZGl2aWRlci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaW5zZXQgPSB0aGlzLmRpdmlkZXIuaW5zZXQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGluc2V0KCkge1xuICAgICAgICBjb25zdCBiYXNlTWFyZ2luID0gJzAnO1xuXG4gICAgICAgIGlmICh0aGlzLm1pZGRsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVydGljYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5faW5zZXR9ICR7YmFzZU1hcmdpbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VNYXJnaW59ICR7dGhpcy5faW5zZXR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuX2luc2V0fSAke2Jhc2VNYXJnaW59IDAgJHtiYXNlTWFyZ2lufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYCR7YmFzZU1hcmdpbn0gMCAke2Jhc2VNYXJnaW59ICR7dGhpcy5faW5zZXR9YDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hEaXZpZGVyRGlyZWN0aXZlXSxcbiAgICBleHBvcnRzOiBbSWd4RGl2aWRlckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RGl2aWRlck1vZHVsZSB7IH1cbiJdfQ==