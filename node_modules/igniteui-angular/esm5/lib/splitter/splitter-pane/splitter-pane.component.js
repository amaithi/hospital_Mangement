import { __decorate } from "tslib";
import { Component, HostBinding, Input, ElementRef, Output, EventEmitter } from '@angular/core';
/**
 * Represents individual resizable/collapsible panes.
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
var IgxSplitterPaneComponent = /** @class */ (function () {
    function IgxSplitterPaneComponent(el) {
        this.el = el;
        this._size = 'auto';
        this._collapsed = false;
        /**
         * Gets/Sets whether pane is resizable.
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (onToggle)='onPaneToggle($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.onToggle = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.
         */
        this.minHeight = 0;
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
    }
    Object.defineProperty(IgxSplitterPaneComponent.prototype, "size", {
        /**
         * Gets/Sets the size of the current pane.
         *  * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        get: function () {
            return this._size;
        },
        set: function (value) {
            this._size = value;
            this.el.nativeElement.style.flex = this.flex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSplitterPaneComponent.prototype, "element", {
        /**
         *
         * @hidden @internal
         * Gets the host native element.
         */
        get: function () {
            return this.el.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSplitterPaneComponent.prototype, "flex", {
        /**
         * @hidden @internal
         * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
         */
        get: function () {
            var grow = this.size !== 'auto' ? 0 : 1;
            var shrink = this.size !== 'auto' ? 0 : 1;
            return grow + " " + shrink + " " + this.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSplitterPaneComponent.prototype, "collapsed", {
        get: function () {
            return this._collapsed;
        },
        /**
         * Gets/Sets whether current pane is collapsed.
         * @example
         * ```typescript
         * const isCollapsed = pane.collapsed;
         * ```
         */
        set: function (value) {
            this._collapsed = value;
            this.display = this._collapsed ? 'none' : 'flex';
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden @internal */
    IgxSplitterPaneComponent.prototype._getSiblings = function () {
        var panes = this.owner.panes.toArray();
        var index = panes.indexOf(this);
        var siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    };
    /**
     * Toggles the collapsed state of the pane.
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    IgxSplitterPaneComponent.prototype.toggle = function () {
        // reset sibling sizes when pane collapse state changes.
        this._getSiblings().forEach(function (sibling) { return sibling.size = 'auto'; });
        this.collapsed = !this.collapsed;
        this.onToggle.emit(this);
    };
    IgxSplitterPaneComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input()
    ], IgxSplitterPaneComponent.prototype, "size", null);
    __decorate([
        Input()
    ], IgxSplitterPaneComponent.prototype, "minSize", void 0);
    __decorate([
        Input()
    ], IgxSplitterPaneComponent.prototype, "maxSize", void 0);
    __decorate([
        Input()
    ], IgxSplitterPaneComponent.prototype, "resizable", void 0);
    __decorate([
        Output()
    ], IgxSplitterPaneComponent.prototype, "onToggle", void 0);
    __decorate([
        HostBinding('style.order')
    ], IgxSplitterPaneComponent.prototype, "order", void 0);
    __decorate([
        HostBinding('style.overflow')
    ], IgxSplitterPaneComponent.prototype, "overflow", void 0);
    __decorate([
        HostBinding('style.min-height'),
        HostBinding('style.min-width')
    ], IgxSplitterPaneComponent.prototype, "minHeight", void 0);
    __decorate([
        HostBinding('style.max-height'),
        HostBinding('style.max-width')
    ], IgxSplitterPaneComponent.prototype, "maxHeight", void 0);
    __decorate([
        HostBinding('style.flex')
    ], IgxSplitterPaneComponent.prototype, "flex", null);
    __decorate([
        HostBinding('style.display')
    ], IgxSplitterPaneComponent.prototype, "display", void 0);
    __decorate([
        Input()
    ], IgxSplitterPaneComponent.prototype, "collapsed", null);
    IgxSplitterPaneComponent = __decorate([
        Component({
            selector: 'igx-splitter-pane',
            template: "<ng-content></ng-content>"
        })
    ], IgxSplitterPaneComponent);
    return IgxSplitterPaneComponent;
}());
export { IgxSplitterPaneComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXItcGFuZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3NwbGl0dGVyL3NwbGl0dGVyLXBhbmUvc3BsaXR0ZXItcGFuZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVoRzs7Ozs7Ozs7Ozs7O0dBWUc7QUFLSDtJQWtMSSxrQ0FBb0IsRUFBYztRQUFkLE9BQUUsR0FBRixFQUFFLENBQVk7UUFoTDFCLFVBQUssR0FBRyxNQUFNLENBQUM7UUFDZixlQUFVLEdBQUcsS0FBSyxDQUFDO1FBZ0QzQjs7Ozs7Ozs7OztXQVVHO1FBRUksY0FBUyxHQUFHLElBQUksQ0FBQztRQUV4Qjs7Ozs7Ozs7V0FRRztRQUVJLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBNEIsQ0FBQztRQWdCL0Q7OztXQUdHO1FBRUksYUFBUSxHQUFHLE1BQU0sQ0FBQztRQUV6Qjs7O1dBR0c7UUFHSSxjQUFTLEdBQUcsQ0FBQyxDQUFDO1FBRXJCOzs7V0FHRztRQUdJLGNBQVMsR0FBRyxNQUFNLENBQUM7UUFjMUI7OztXQUdHO1FBRUksWUFBTyxHQUFHLE1BQU0sQ0FBQztJQStDYyxDQUFDO0lBaEt2QyxzQkFBSSwwQ0FBSTtRQVZSOzs7Ozs7OztXQVFHO2FBRUg7WUFDSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDdEIsQ0FBQzthQUVELFVBQVMsS0FBSztZQUNWLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUNqRCxDQUFDOzs7T0FMQTtJQW1FRCxzQkFBVyw2Q0FBTztR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QVEsRUFBRSxtQkFBbUI7WUFDN0IscUNBQTZDO1NBQ2hELENBQUM7T0FDVyx3QkFBd0IsQ0FtTHBDO0lBQUQsK0JBQUM7Q0FBQSxBQW5MRCxJQW1MQztTQW5MWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgRWxlbWVudFJlZiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGluZGl2aWR1YWwgcmVzaXphYmxlL2NvbGxhcHNpYmxlIHBhbmVzLlxuICogQGlneE1vZHVsZSBJZ3hTcGxpdHRlck1vZHVsZVxuICpcbiAqIEBpZ3hQYXJlbnQgSWd4U3BsaXR0ZXJDb21wb25lbnRcbiAqXG4gKiBAaWd4S2V5d29yZHMgcGFuZVxuICpcbiAqIEBpZ3hHcm91cCBwcmVzZW50YXRpb25cbiAqXG4gKiBAcmVtYXJrc1xuICogIFVzZXJzIGNhbiBjb250cm9sIHRoZSByZXNpemUgYmVoYXZpb3IgdmlhIHRoZSBtaW4gYW5kIG1heCBzaXplIHByb3BlcnRpZXMuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXNwbGl0dGVyLXBhbmUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci1wYW5lLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQge1xuXG4gICAgcHJpdmF0ZSBfc2l6ZSA9ICdhdXRvJztcbiAgICBwcml2YXRlIF9jb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvd25lcjtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbc2l6ZV09J3NpemUnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuXG4gICAgc2V0IHNpemUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuc3R5bGUuZmxleCA9IHRoaXMuZmxleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgdGhlIG1pbmltdW0gYWxsb3dlZCBzaXplIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFttaW5TaXplXT0nbWluU2l6ZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtaW5TaXplITogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXQgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFttYXhTaXplXT0nbWF4U2l6ZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBtYXhTaXplITogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHdoZXRoZXIgcGFuZSBpcyByZXNpemFibGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zcGxpdHRlcj5cbiAgICAgKiAgPGlneC1zcGxpdHRlci1wYW5lIFtyZXNpemFibGVdPSdmYWxzZSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHBhbmUgaXMgbm90IHJlc2l6YWJsZSBpdHMgcmVsYXRlZCBzcGxpdHRlciBiYXIgY2Fubm90IGJlIGRyYWdnZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcmVzaXphYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gY29sbGFwc2VkIHN0YXRlIG9mIHBhbmUgaXMgY2hhbmdlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyPlxuICAgICAqICA8aWd4LXNwbGl0dGVyLXBhbmUgKG9uVG9nZ2xlKT0nb25QYW5lVG9nZ2xlKCRldmVudCknPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uVG9nZ2xlID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+KCk7XG5cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3JkZXInKVxuICAgIHB1YmxpYyBvcmRlciE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBob3N0IG5hdGl2ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZWxlbWVudCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgb3ZlcmZsb3dgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3ZlcmZsb3cnKVxuICAgIHB1YmxpYyBvdmVyZmxvdyA9ICdhdXRvJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgbWluSGVpZ2h0YCBhbmQgYG1pbldpZHRoYCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5taW4taGVpZ2h0JylcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm1pbi13aWR0aCcpXG4gICAgcHVibGljIG1pbkhlaWdodCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG1heEhlaWdodGAgYW5kIGBtYXhXaWR0aGAgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLm1heC1oZWlnaHQnKVxuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4LXdpZHRoJylcbiAgICBwdWJsaWMgbWF4SGVpZ2h0ID0gJzEwMCUnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBgZmxleGAgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYElneFNwbGl0dGVyUGFuZUNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4JylcbiAgICBwdWJsaWMgZ2V0IGZsZXgoKSB7XG4gICAgICAgIGNvbnN0IGdyb3cgPSB0aGlzLnNpemUgIT09ICdhdXRvJyA/IDAgOiAxO1xuICAgICAgICBjb25zdCBzaHJpbmsgPSB0aGlzLnNpemUgIT09ICdhdXRvJyA/IDAgOiAxO1xuXG4gICAgICAgIHJldHVybiBgJHtncm93fSAke3Nocmlua30gJHt0aGlzLnNpemV9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgJ2Rpc3BsYXknIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB3aGV0aGVyIGN1cnJlbnQgcGFuZSBpcyBjb2xsYXBzZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaXNDb2xsYXBzZWQgPSBwYW5lLmNvbGxhcHNlZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgY29sbGFwc2VkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSB0aGlzLl9jb2xsYXBzZWQgPyAnbm9uZScgOiAnZmxleCcgO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgY29sbGFwc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHByaXZhdGUgX2dldFNpYmxpbmdzKCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMub3duZXIucGFuZXMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhbmVzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgc2libGluZ3MucHVzaChwYW5lc1tpbmRleCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggIT09IHBhbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNpYmxpbmdzLnB1c2gocGFuZXNbaW5kZXggKyAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGNvbGxhcHNlZCBzdGF0ZSBvZiB0aGUgcGFuZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwYW5lLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgICAgIC8vIHJlc2V0IHNpYmxpbmcgc2l6ZXMgd2hlbiBwYW5lIGNvbGxhcHNlIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgIHRoaXMuX2dldFNpYmxpbmdzKCkuZm9yRWFjaChzaWJsaW5nID0+IHNpYmxpbmcuc2l6ZSA9ICdhdXRvJyk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gIXRoaXMuY29sbGFwc2VkO1xuICAgICAgICB0aGlzLm9uVG9nZ2xlLmVtaXQodGhpcyk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikgeyB9XG59XG4iXX0=