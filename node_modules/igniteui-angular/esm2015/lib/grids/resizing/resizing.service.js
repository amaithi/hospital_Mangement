import { __decorate } from "tslib";
import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 * @internal
 */
let IgxColumnResizingService = class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualMinWidth = parseFloat(this.column.minWidth);
        const minWidth = actualMinWidth < parseFloat(this.column.width) ? actualMinWidth : parseFloat(this.column.width);
        return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        if (this.column.maxWidth) {
            return parseFloat(this.column.maxWidth) - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const size = this.column.getLargestCellWidth();
        if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.minWidth)) {
            this.column.width = parseFloat(this.column.minWidth) + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        let currentColWidth = parseFloat(this.column.width);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const colMinWidth = this.getColMinWidth(this.column);
        const colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    getColMaxWidth(column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const minWidth = this.getColMinWidth(col.target);
                const maxWidth = this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const currentResizeWidth = parseFloat(col.target.calcWidth);
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    }
};
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
IgxColumnResizingService = __decorate([
    Injectable()
], IgxColumnResizingService);
export { IgxColumnResizingService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvcmVzaXppbmcvcmVzaXppbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHbkQ7OztHQUdHO0FBRUgsSUFBYSx3QkFBd0IsR0FBckMsTUFBYSx3QkFBd0I7SUF5QmpDLFlBQW9CLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBYmhDOztXQUVHO1FBQ0ksaUJBQVksR0FBVyxJQUFJLENBQUM7UUFDbkM7O1dBRUc7UUFDSSxnQkFBVyxHQUFHLEtBQUssQ0FBQztJQU1TLENBQUM7SUFFckM7O09BRUc7SUFDSCxJQUFJLGFBQWE7UUFDYixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1FBRXhELG9IQUFvSDtRQUNwSCxJQUFJLHNCQUFzQixHQUFHLENBQUMsQ0FBQztRQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUU7WUFDL0Isc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1NBQzlGO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLHNCQUFzQixDQUFDO1NBQ3JIO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBSSxp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QkFBTSxJQUFJLFFBQVEsSUFBSSxDQUFDLGtCQUFrQixHQUFHLFlBQVksR0FBRyxRQUFRLENBQUMsRUFBRTtvQkFDbkUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDbkMsV0FBVyxJQUFJLENBQUMsUUFBUSxHQUFHLGtCQUFrQixDQUFDLENBQUM7b0JBQy9DLGVBQWUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDO29CQUNoQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2lCQUN4QjtxQkFBTTtvQkFDSCxvQ0FBb0M7b0JBQ3BDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzdCO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxtQkFBbUIsR0FBRyxlQUFlLENBQUM7WUFDdEMsZUFBZSxHQUFHLGVBQWUsQ0FBQztTQUNyQyxRQUFRLGFBQWEsRUFBRTtRQUV4QixpRUFBaUU7UUFDakUsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQzVCLE1BQU0sa0JBQWtCLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDNUQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxXQUFXLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQztZQUNyRixHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLGtCQUFrQixHQUFHLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQztRQUNsRSxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSixDQUFBOztZQTNLNkIsTUFBTTs7QUF6QnZCLHdCQUF3QjtJQURwQyxVQUFVLEVBQUU7R0FDQSx3QkFBd0IsQ0FvTXBDO1NBcE1ZLHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1ucy9jb2x1bW4uY29tcG9uZW50JztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneENvbHVtblJlc2l6aW5nU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHBpbm5lZE1heFdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0UmVzaXplUG9zOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb2x1bW4gaXMgY3VycmVudGx5IGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGlzQ29sdW1uUmVzaXppbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZXNpemVDdXJzb3I6IHN0cmluZyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzaG93UmVzaXplciA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2x1bW4gYmVpbmcgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHpvbmU6IE5nWm9uZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHJlc2l6ZXJIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuY29sdW1uLmdyaWQuZ2V0VmlzaWJsZUNvbnRlbnRIZWlnaHQoKTtcblxuICAgICAgICAvLyBDb2x1bW4gaGVpZ2h0IG11bHRpcGxpZXIgaW4gY2FzZSB0aGVyZSBhcmUgQ29sdW1uIExheW91dHMuIFRoZSByZXNpemVyIGhlaWdodCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHJvd1N0YXJ0LlxuICAgICAgICBsZXQgY29sdW1uSGVpZ2h0TXVsdGlwbGllciA9IDE7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5jb2x1bW5MYXlvdXRDaGlsZCkge1xuICAgICAgICAgICAgY29sdW1uSGVpZ2h0TXVsdGlwbGllciA9IHRoaXMuY29sdW1uLmdyaWQubXVsdGlSb3dMYXlvdXRSb3dTaXplIC0gdGhpcy5jb2x1bW4ucm93U3RhcnQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmxldmVsICE9PSAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgLT0gdGhpcy5jb2x1bW4udG9wTGV2ZWxQYXJlbnQuaGVhZGVyR3JvdXAuaGVpZ2h0IC0gdGhpcy5jb2x1bW4uaGVhZGVyR3JvdXAuaGVpZ2h0ICogY29sdW1uSGVpZ2h0TXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWluaW1hbCBwb3NzaWJsZSB3aWR0aCB0byB3aGljaCB0aGUgY29sdW1uIGNhbiBiZSByZXNpemVkLlxuICAgICAqL1xuICAgIGdldCByZXN0cmljdFJlc2l6ZU1pbigpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhY3R1YWxNaW5XaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWluV2lkdGgpO1xuICAgICAgICBjb25zdCBtaW5XaWR0aCA9IGFjdHVhbE1pbldpZHRoIDwgcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkgPyBhY3R1YWxNaW5XaWR0aCA6IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIG1pbldpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNYXgoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9zaXplcyB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogSWYgdGhlIGNvbHVtbiBoYXMgYSBwcmVkaWZpbmVkIG1heFdpZHRoIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGJlY29tZSBiaWdnZXIgdGhhbiBpdCxcbiAgICAgKiB0aGVuIHRoZSBjb2x1bW4gaXMgc2l6ZWQgdG8gaXRzIG1heFdpZHRoLlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgcGlubmVkIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGNhdXNlIHRoZSBwaW5uZWQgYXJlYSB0byBiZWNvbWUgYmlnZ2VyXG4gICAgICogdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHBpbm5lZCBhcmVhIHdpZHRoICg4MCUgb2YgdGhlIHRvdGFsIGdyaWQgd2lkdGgpLCBhdXRvc2l6aW5nIHdpbGwgYmUgZGVpc21pc3NlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXV0b3NpemVDb2x1bW5PbkRibENsaWNrKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5jb2x1bW4uZ2V0TGFyZ2VzdENlbGxXaWR0aCgpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGggJiYgKHBhcnNlRmxvYXQoc2l6ZSkgPiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnNlRmxvYXQoc2l6ZSkgPCBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1pbldpZHRoKSkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1pbldpZHRoKSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHt9KTtcblxuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNvbHVtbiByZWdhcmlkbmcgdG8gdGhlIGNvbHVtbiBtaW5XaWR0aCBhbmQgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFJlc2l6ZVBvcztcblxuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE51bWJlci5pc05hTihjdXJyZW50Q29sV2lkdGgpIHx8IChjdXJyZW50Q29sV2lkdGggPCBhY3R1YWxXaWR0aCkgPyBhY3R1YWxXaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcblxuICAgICAgICBjb25zdCBjb2xNaW5XaWR0aCA9IHRoaXMuZ2V0Q29sTWluV2lkdGgodGhpcy5jb2x1bW4pO1xuICAgICAgICBjb25zdCBjb2xNYXhXaWR0aCA9IHRoaXMuZ2V0Q29sTWF4V2lkdGgodGhpcy5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4uZ3JpZC5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNvbHVtbkxheW91dEZvcih0aGlzLmNvbHVtbiwgZGlmZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbFdpZHRoICsgZGlmZiA8IGNvbE1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBjb2xNaW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbE1heFdpZHRoICYmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmID4gY29sTWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBjb2xNYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggIT09IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgIHByZXZXaWR0aDogY3VycmVudENvbFdpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNDb2x1bW5SZXNpemluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2xNaW5XaWR0aChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ud2lkdGgpO1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IGNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gTnVtYmVyLmlzTmFOKGN1cnJlbnRDb2xXaWR0aCkgfHwgKGN1cnJlbnRDb2xXaWR0aCA8IGFjdHVhbFdpZHRoKSA/IGFjdHVhbFdpZHRoIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGNvbnN0IGFjdHVhbE1pbldpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ubWluV2lkdGgpO1xuICAgICAgICByZXR1cm4gYWN0dWFsTWluV2lkdGggPCBjdXJyZW50Q29sV2lkdGggPyBhY3R1YWxNaW5XaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q29sTWF4V2lkdGgoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5waW5uZWQgPyBwYXJzZUZsb2F0KHRoaXMucGlubmVkTWF4V2lkdGgpIDogcGFyc2VGbG9hdChjb2x1bW4ubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZXNpemVDb2x1bW5MYXlvdXRGb3IoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQsIGRpZmY6IG51bWJlcikge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbHVtbnMgPSBjb2x1bW4uZ2V0UmVzaXphYmxlQ29sVW5kZXJFbmQoKTtcbiAgICAgICAgY29uc3QgY29tYmluZWRTcGFuID0gcmVsYXRpdmVDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2wpID0+ICBhY2MgKyBjb2wuc3BhblVzZWQsIDApO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBmaXJzdCB0aG9zZSB3aG8gbWlnaHQgcmVhY2ggbWluL21heCB3aWR0aFxuICAgICAgICBsZXQgY29sdW1uc1RvUmVzaXplID0gWy4uLnJlbGF0aXZlQ29sdW1uc107XG4gICAgICAgIGxldCB1cGRhdGVkRGlmZiA9IGRpZmY7XG4gICAgICAgIGxldCB1cGRhdGVkQ29tYmluZWRTcGFuID0gY29tYmluZWRTcGFuO1xuICAgICAgICBsZXQgc2V0TWluTWF4Q29scyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBDeWNsZSB0aGVtIHVudGlsIHRoZXJlIGFyZSBub3Qgb25lcyB0aGF0IHJlYWNoIG1pbi9tYXggc2l6ZSwgYmVjYXVzZSB0aGUgZGlmZiBhY2N1bXVsYXRlcyBhZnRlciBlYWNoIGN5Y2xlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGNhbiBoYXZlIGF0IGZpcnN0IDIgY29scyByZWFjaGluZyBtaW4gd2lkdGggYW5kIHRoZW4gYWZ0ZXJcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRpbmcgdGhlIGRpZmYgdGhlcmUgbWlnaHQgYmUgMSBtb3JlIHRoYXQgcmVhY2hlcyBtaW4gd2lkdGguXG4gICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV3Q29tYmluZWRTcGFuID0gdXBkYXRlZENvbWJpbmVkU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbHNUb1Jlc2l6ZSA9IFtdO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNpemVXaWR0aCA9IHBhcnNlRmxvYXQoY29sLnRhcmdldC5jYWxjV2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9IChkaWZmIC8gdXBkYXRlZENvbWJpbmVkU3BhbikgKiBjb2wudGFyZ2V0LmdyaWRDb2x1bW5TcGFuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWluV2lkdGggPSB0aGlzLmdldENvbE1pbldpZHRoKGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gdGhpcy5nZXRDb2xNYXhXaWR0aChjb2wudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkIDwgbWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnRhcmdldC53aWR0aCA9IG1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgKz0gKGN1cnJlbnRSZXNpemVXaWR0aCAtIG1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhXaWR0aCAmJiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkID4gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSBtYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWREaWZmIC09IChtYXhXaWR0aCAtIGN1cnJlbnRSZXNpemVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbWJpbmVkU3BhbiAtPSBjb2wuc3BhblVzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgbmV3IG9uZXMgdGhhdCBjYW4gYmUgcmVzaXplZFxuICAgICAgICAgICAgICAgICAgICBuZXdDb2xzVG9SZXNpemUucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1cGRhdGVkQ29tYmluZWRTcGFuID0gbmV3Q29tYmluZWRTcGFuO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplID0gbmV3Q29sc1RvUmVzaXplO1xuICAgICAgICB9IHdoaWxlIChzZXRNaW5NYXhDb2xzKTtcblxuICAgICAgICAvLyBUaG9zZSBsZWZ0IHRoYXQgZG9uJ3QgcmVhY2ggbWluL21heCBzaXplIHJlc2l6ZSB0aGVtIG5vcm1hbGx5LlxuICAgICAgICBjb2x1bW5zVG9SZXNpemUuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzaXplV2lkdGggPSBwYXJzZUZsb2F0KGNvbC50YXJnZXQuY2FsY1dpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9ICh1cGRhdGVkRGlmZiAvIHVwZGF0ZWRDb21iaW5lZFNwYW4pICogY29sLnRhcmdldC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkKSArICdweCc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==