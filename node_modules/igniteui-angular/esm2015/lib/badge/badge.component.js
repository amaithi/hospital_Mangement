import { __decorate } from "tslib";
import { CommonModule } from '@angular/common';
import { Component, HostBinding, Input, NgModule } from '@angular/core';
import { IgxIconModule } from '../icon/public_api';
let NEXT_ID = 0;
/**
 * Determines the igxBadge type
 */
export var IgxBadgeType;
(function (IgxBadgeType) {
    IgxBadgeType["PRIMARY"] = "primary";
    IgxBadgeType["INFO"] = "info";
    IgxBadgeType["SUCCESS"] = "success";
    IgxBadgeType["WARNING"] = "warning";
    IgxBadgeType["ERROR"] = "error";
})(IgxBadgeType || (IgxBadgeType = {}));
/**
 * Badge provides visual notifications used to decorate avatars, menus, etc.
 *
 * @igxModule IgxBadgeModule
 *
 * @igxTheme igx-badge-theme
 *
 * @igxKeywords badge, icon, notification
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * @example
 * ```html
 * <igx-avatar>
 *   <igx-badge icon="check" type="success"></igx-badge>
 * </igx-avatar>
 */
let IgxBadgeComponent = class IgxBadgeComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the badge.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-badge-0"`.
         *
         * @example
         * ```html
         * <igx-badge id="igx-badge-2"></igx-badge>
         * ```
         */
        this.id = `igx-badge-${NEXT_ID++}`;
        /**
         * Sets/gets the type of the badge.
         *
         * @remarks
         * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         *
         * @example
         * ```html
         * <igx-badge type="success"></igx-badge>
         * ```
         */
        this.type = IgxBadgeType.PRIMARY;
        /**
         * Sets/gets the value to be displayed inside the badge.
         *
         * @remarks
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the content of the badge will be empty.
         *
         * @example
         * ```html
         * <igx-badge value="11"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * Sets/gets the role attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.role = 'status';
         * ```
         */
        this.role = 'status';
        /**
         * Sets/gets the the css class to use on the badge.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.cssClass = 'my-badge-class';
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * Sets/gets the aria-label attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.label = 'badge';
         * ```
         */
        this.label = 'badge';
    }
    /**
     * Defines a human-readable, accessor, author-localized description for
     * the `type` and the `icon` or `value` of the element.
     * @hidden
     * @internal
     */
    get roleDescription() {
        let message;
        // tslint:disable-next-line:prefer-conditional-expression
        if (this.icon) {
            message = this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value) {
            message = this.type + ' badge type with value ' + this.value;
        }
        else {
            message = this.type + ' badge type without value';
        }
        return message;
    }
    /**
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @hidden
     * @internal
     */
    setClasses() {
        let classes = {};
        switch (IgxBadgeType[this.type.toUpperCase()]) {
            case IgxBadgeType.INFO:
                classes = {
                    [`${this.cssClass}__circle--info`]: true
                };
                break;
            case IgxBadgeType.SUCCESS:
                classes = {
                    [`${this.cssClass}__circle--success`]: true
                };
                break;
            case IgxBadgeType.WARNING:
                classes = {
                    [`${this.cssClass}__circle--warning`]: true
                };
                break;
            case IgxBadgeType.ERROR:
                classes = {
                    [`${this.cssClass}__circle--error`]: true
                };
                break;
            default:
                classes = {
                    [`${this.cssClass}__circle--default`]: true
                };
        }
        return classes;
    }
};
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxBadgeComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "icon", void 0);
__decorate([
    HostBinding('attr.role')
], IgxBadgeComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-badge')
], IgxBadgeComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxBadgeComponent.prototype, "label", void 0);
IgxBadgeComponent = __decorate([
    Component({
        selector: 'igx-badge',
        template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
    })
], IgxBadgeComponent);
export { IgxBadgeComponent };
/**
 * @hidden
 */
let IgxBadgeModule = class IgxBadgeModule {
};
IgxBadgeModule = __decorate([
    NgModule({
        declarations: [IgxBadgeComponent],
        exports: [IgxBadgeComponent],
        imports: [CommonModule, IgxIconModule]
    })
], IgxBadgeModule);
export { IgxBadgeModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFkZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9iYWRnZS9iYWRnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFFaEI7O0dBRUc7QUFDSCxNQUFNLENBQU4sSUFBWSxZQU1YO0FBTkQsV0FBWSxZQUFZO0lBQ3BCLG1DQUFtQixDQUFBO0lBQ25CLDZCQUFhLENBQUE7SUFDYixtQ0FBbUIsQ0FBQTtJQUNuQixtQ0FBbUIsQ0FBQTtJQUNuQiwrQkFBZSxDQUFBO0FBQ25CLENBQUMsRUFOVyxZQUFZLEtBQVosWUFBWSxRQU12QjtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQkc7QUFLSCxJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFpQjtJQUE5QjtRQUVHOzs7Ozs7Ozs7O1dBVUc7UUFHSyxPQUFFLEdBQUcsYUFBYSxPQUFPLEVBQUUsRUFBRSxDQUFDO1FBRXRDOzs7Ozs7Ozs7OztXQVdHO1FBRUssU0FBSSxHQUEwQixZQUFZLENBQUMsT0FBTyxDQUFDO1FBRTNEOzs7Ozs7Ozs7OztXQVdHO1FBRUssVUFBSyxHQUFHLEVBQUUsQ0FBQztRQWtCbEI7Ozs7Ozs7Ozs7V0FVRztRQUVJLFNBQUksR0FBRyxRQUFRLENBQUM7UUFFdkI7Ozs7Ozs7Ozs7V0FVRztRQUVJLGFBQVEsR0FBRyxXQUFXLENBQUM7UUFFOUI7Ozs7Ozs7Ozs7V0FVRztRQUVJLFVBQUssR0FBRyxPQUFPLENBQUM7SUE4RDNCLENBQUM7SUE1REc7Ozs7O09BS0c7SUFDSCxJQUFJLGVBQWU7UUFDZixJQUFJLE9BQWUsQ0FBQztRQUVwQix5REFBeUQ7UUFDekQsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1gsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsNkJBQTZCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztTQUNuRTthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNuQixPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyx5QkFBeUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1NBQ2hFO2FBQU07WUFDSCxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRywyQkFBMkIsQ0FBQztTQUNyRDtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFVBQVU7UUFDYixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFakIsUUFBUSxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFO1lBQzNDLEtBQUssWUFBWSxDQUFDLElBQUk7Z0JBQ2xCLE9BQU8sR0FBRztvQkFDTixDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsZ0JBQWdCLENBQUMsRUFBRSxJQUFJO2lCQUMzQyxDQUFDO2dCQUNGLE1BQU07WUFDVixLQUFLLFlBQVksQ0FBQyxPQUFPO2dCQUNyQixPQUFPLEdBQUc7b0JBQ04sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLG1CQUFtQixDQUFDLEVBQUUsSUFBSTtpQkFDOUMsQ0FBQztnQkFDRixNQUFNO1lBQ1YsS0FBSyxZQUFZLENBQUMsT0FBTztnQkFDckIsT0FBTyxHQUFHO29CQUNOLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxtQkFBbUIsQ0FBQyxFQUFFLElBQUk7aUJBQzlDLENBQUM7Z0JBQ0YsTUFBTTtZQUNWLEtBQUssWUFBWSxDQUFDLEtBQUs7Z0JBQ25CLE9BQU8sR0FBRztvQkFDTixDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsaUJBQWlCLENBQUMsRUFBRSxJQUFJO2lCQUM1QyxDQUFDO2dCQUNGLE1BQU07WUFDVjtnQkFDSSxPQUFPLEdBQUc7b0JBQ04sQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLG1CQUFtQixDQUFDLEVBQUUsSUFBSTtpQkFDOUMsQ0FBQztTQUNUO1FBRUQsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztDQUVKLENBQUE7QUF0Skc7SUFGQyxXQUFXLENBQUMsU0FBUyxDQUFDO0lBQ3RCLEtBQUssRUFBRTs2Q0FDNkI7QUFlckM7SUFEQyxLQUFLLEVBQUU7K0NBQ2tEO0FBZTFEO0lBREMsS0FBSyxFQUFFO2dEQUNVO0FBZ0JsQjtJQURDLEtBQUssRUFBRTsrQ0FDWTtBQWNwQjtJQURDLFdBQVcsQ0FBQyxXQUFXLENBQUM7K0NBQ0Y7QUFjdkI7SUFEQyxXQUFXLENBQUMsaUJBQWlCLENBQUM7bURBQ0Q7QUFjOUI7SUFEQyxXQUFXLENBQUMsaUJBQWlCLENBQUM7Z0RBQ1I7QUF2R2QsaUJBQWlCO0lBSjdCLFNBQVMsQ0FBQztRQUNQLFFBQVEsRUFBRSxXQUFXO1FBQ3JCLHVSQUFtQztLQUN0QyxDQUFDO0dBQ1csaUJBQWlCLENBcUs3QjtTQXJLWSxpQkFBaUI7QUF1SzlCOztHQUVHO0FBTUgsSUFBYSxjQUFjLEdBQTNCLE1BQWEsY0FBYztDQUFJLENBQUE7QUFBbEIsY0FBYztJQUwxQixRQUFRLENBQUM7UUFDTixZQUFZLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztRQUNqQyxPQUFPLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztRQUM1QixPQUFPLEVBQUUsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDO0tBQ3pDLENBQUM7R0FDVyxjQUFjLENBQUk7U0FBbEIsY0FBYyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneEljb25Nb2R1bGUgfSBmcm9tICcuLi9pY29uL3B1YmxpY19hcGknO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgaWd4QmFkZ2UgdHlwZVxuICovXG5leHBvcnQgZW51bSBJZ3hCYWRnZVR5cGUge1xuICAgIFBSSU1BUlkgPSAncHJpbWFyeScsXG4gICAgSU5GTyA9ICdpbmZvJyxcbiAgICBTVUNDRVNTID0gJ3N1Y2Nlc3MnLFxuICAgIFdBUk5JTkcgPSAnd2FybmluZycsXG4gICAgRVJST1IgPSAnZXJyb3InXG59XG4vKipcbiAqIEJhZGdlIHByb3ZpZGVzIHZpc3VhbCBub3RpZmljYXRpb25zIHVzZWQgdG8gZGVjb3JhdGUgYXZhdGFycywgbWVudXMsIGV0Yy5cbiAqXG4gKiBAaWd4TW9kdWxlIElneEJhZGdlTW9kdWxlXG4gKlxuICogQGlneFRoZW1lIGlneC1iYWRnZS10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyBiYWRnZSwgaWNvbiwgbm90aWZpY2F0aW9uXG4gKlxuICogQGlneEdyb3VwIERhdGEgRW50cnkgJiBEaXNwbGF5XG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBJZ25pdGUgVUkgQmFkZ2UgaXMgdXNlZCB0byBkZWNvcmF0ZSBhdmF0YXJzLCBuYXZpZ2F0aW9uIG1lbnVzLCBvciBvdGhlciBjb21wb25lbnRzIGluIHRoZVxuICogYXBwbGljYXRpb24gd2hlbiB2aXN1YWwgbm90aWZpY2F0aW9uIGlzIG5lZWRlZC4gVGhleSBhcmUgdXN1YWxseSBkZXNpZ25lZCBhcyBpY29ucyB3aXRoIGEgcHJlZGVmaW5lZFxuICogc3R5bGUgdG8gY29tbXVuaWNhdGUgaW5mb3JtYXRpb24sIHN1Y2Nlc3MsIHdhcm5pbmdzLCBvciBlcnJvcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtYXZhdGFyPlxuICogICA8aWd4LWJhZGdlIGljb249XCJjaGVja1wiIHR5cGU9XCJzdWNjZXNzXCI+PC9pZ3gtYmFkZ2U+XG4gKiA8L2lneC1hdmF0YXI+XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LWJhZGdlJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2JhZGdlLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hCYWRnZUNvbXBvbmVudCB7XG5cbiAgIC8qKlxuICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBiYWRnZS5cbiAgICAqXG4gICAgKiBAcmVtYXJrc1xuICAgICogSWYgbm90IHNldCwgdGhlIGBpZGAgd2lsbCBoYXZlIHZhbHVlIGBcImlneC1iYWRnZS0wXCJgLlxuICAgICpcbiAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LWJhZGdlIGlkPVwiaWd4LWJhZGdlLTJcIj48L2lneC1iYWRnZT5cbiAgICAqIGBgYFxuICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtYmFkZ2UtJHtORVhUX0lEKyt9YDtcblxuICAgLyoqXG4gICAgKiBTZXRzL2dldHMgdGhlIHR5cGUgb2YgdGhlIGJhZGdlLlxuICAgICpcbiAgICAqIEByZW1hcmtzXG4gICAgKiBBbGxvd2VkIHZhbHVlcyBhcmUgYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZXJyb3JgLlxuICAgICogUHJvdmlkaW5nIGFuIGludmFsaWQgdmFsdWUgd29uJ3QgZGlzcGxheSBhIGJhZGdlLlxuICAgICpcbiAgICAqIEBleGFtcGxlXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LWJhZGdlIHR5cGU9XCJzdWNjZXNzXCI+PC9pZ3gtYmFkZ2U+XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHR5cGU6IHN0cmluZyB8IElneEJhZGdlVHlwZSA9IElneEJhZGdlVHlwZS5QUklNQVJZO1xuXG4gICAvKipcbiAgICAqIFNldHMvZ2V0cyB0aGUgdmFsdWUgdG8gYmUgZGlzcGxheWVkIGluc2lkZSB0aGUgYmFkZ2UuXG4gICAgKlxuICAgICogQHJlbWFya3NcbiAgICAqIElmIGFuIGBpY29uYCBwcm9wZXJ0eSBpcyBhbHJlYWR5IHNldCB0aGUgYGljb25gIHdpbGwgYmUgZGlzcGxheWVkLlxuICAgICogSWYgbmVpdGhlciBhIGB2YWx1ZWAgbm9yIGFuIGBpY29uYCBpcyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJhZGdlIHdpbGwgYmUgZW1wdHkuXG4gICAgKlxuICAgICogQGV4YW1wbGVcbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtYmFkZ2UgdmFsdWU9XCIxMVwiPjwvaWd4LWJhZGdlPlxuICAgICogYGBgXG4gICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB2YWx1ZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIGFuIGljb24gZm9yIHRoZSBiYWRnZSBmcm9tIHRoZSBtYXRlcmlhbCBpY29ucyBzZXQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEhhcyBwcmlvcml0eSBvdmVyIHRoZSBgdmFsdWVgIHByb3BlcnR5LlxuICAgICAqIElmIG5laXRoZXIgYSBgdmFsdWVgIG5vciBhbiBgaWNvbmAgaXMgc2V0IHRoZSBjb250ZW50IG9mIHRoZSBiYWRnZSB3aWxsIGJlIGVtcHR5LlxuICAgICAqIFByb3ZpZGluZyBhbiBpbnZhbGlkIHZhbHVlIHdvbid0IGRpc3BsYXkgYW55dGhpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWJhZGdlIGljb249XCJjaGVja1wiPjwvaWd4LWJhZGdlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGljb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgcm9sZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwiTXlCYWRnZVwiLCB7IHJlYWQ6IElneEJhZGdlQ29tcG9uZW50IH0pXG4gICAgICogcHVibGljIGJhZGdlOiBJZ3hCYWRnZUNvbXBvbmVudDtcbiAgICAgKlxuICAgICAqIGJhZGdlLnJvbGUgPSAnc3RhdHVzJztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgcHVibGljIHJvbGUgPSAnc3RhdHVzJztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgdGhlIGNzcyBjbGFzcyB0byB1c2Ugb24gdGhlIGJhZGdlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcIk15QmFkZ2VcIiwgeyByZWFkOiBJZ3hCYWRnZUNvbXBvbmVudCB9KVxuICAgICAqIHB1YmxpYyBiYWRnZTogSWd4QmFkZ2VDb21wb25lbnQ7XG4gICAgICpcbiAgICAgKiBiYWRnZS5jc3NDbGFzcyA9ICdteS1iYWRnZS1jbGFzcyc7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtYmFkZ2UnKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtYmFkZ2UnO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJNeUJhZGdlXCIsIHsgcmVhZDogSWd4QmFkZ2VDb21wb25lbnQgfSlcbiAgICAgKiBwdWJsaWMgYmFkZ2U6IElneEJhZGdlQ29tcG9uZW50O1xuICAgICAqXG4gICAgICogYmFkZ2UubGFiZWwgPSAnYmFkZ2UnO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWxhYmVsJylcbiAgICBwdWJsaWMgbGFiZWwgPSAnYmFkZ2UnO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhIGh1bWFuLXJlYWRhYmxlLCBhY2Nlc3NvciwgYXV0aG9yLWxvY2FsaXplZCBkZXNjcmlwdGlvbiBmb3JcbiAgICAgKiB0aGUgYHR5cGVgIGFuZCB0aGUgYGljb25gIG9yIGB2YWx1ZWAgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldCByb2xlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGxldCBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1jb25kaXRpb25hbC1leHByZXNzaW9uXG4gICAgICAgIGlmICh0aGlzLmljb24pIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLnR5cGUgKyAnIHR5cGUgYmFkZ2Ugd2l0aCBpY29uIHR5cGUgJyArIHRoaXMuaWNvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy50eXBlICsgJyBiYWRnZSB0eXBlIHdpdGggdmFsdWUgJyArIHRoaXMudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy50eXBlICsgJyBiYWRnZSB0eXBlIHdpdGhvdXQgdmFsdWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHdoaWNoIG1ha2VzIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyBtb3JlIGRlc2NyaXB0aXZlLlxuICAgICAqIFRoaXMgaGVscHMgdGhlIHN0eWxpbmcgb2YgdGhlIGJhZGdlcy5cbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHNldENsYXNzZXMoKSB7XG4gICAgICAgIGxldCBjbGFzc2VzID0ge307XG5cbiAgICAgICAgc3dpdGNoIChJZ3hCYWRnZVR5cGVbdGhpcy50eXBlLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICBjYXNlIElneEJhZGdlVHlwZS5JTkZPOlxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFtgJHt0aGlzLmNzc0NsYXNzfV9fY2lyY2xlLS1pbmZvYF06IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJZ3hCYWRnZVR5cGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0ge1xuICAgICAgICAgICAgICAgICAgICBbYCR7dGhpcy5jc3NDbGFzc31fX2NpcmNsZS0tc3VjY2Vzc2BdOiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSWd4QmFkZ2VUeXBlLldBUk5JTkc6XG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2Ake3RoaXMuY3NzQ2xhc3N9X19jaXJjbGUtLXdhcm5pbmdgXTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIElneEJhZGdlVHlwZS5FUlJPUjpcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0ge1xuICAgICAgICAgICAgICAgICAgICBbYCR7dGhpcy5jc3NDbGFzc31fX2NpcmNsZS0tZXJyb3JgXTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFtgJHt0aGlzLmNzc0NsYXNzfV9fY2lyY2xlLS1kZWZhdWx0YF06IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxuXG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW0lneEJhZGdlQ29tcG9uZW50XSxcbiAgICBleHBvcnRzOiBbSWd4QmFkZ2VDb21wb25lbnRdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIElneEljb25Nb2R1bGVdXG59KVxuZXhwb3J0IGNsYXNzIElneEJhZGdlTW9kdWxlIHsgfVxuIl19