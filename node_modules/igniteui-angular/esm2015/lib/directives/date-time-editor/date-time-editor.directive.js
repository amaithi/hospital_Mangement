var IgxDateTimeEditorDirective_1;
import { __decorate, __param } from "tslib";
import { Directive, Input, ElementRef, Renderer2, NgModule, Output, EventEmitter, Inject, LOCALE_ID, OnChanges, SimpleChanges, Host, Optional, Injector } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, } from '@angular/forms';
import { formatDate, DOCUMENT } from '@angular/common';
import { IgxMaskDirective } from '../mask/mask.directive';
import { MaskParsingService } from '../mask/mask-parsing.service';
import { DatePickerUtil } from '../../date-picker/date-picker.utils';
import { DatePart } from './date-time-editor.common';
/**
 * Date Time Editor provides a functionality to input, edit and format date and time.
 *
 * @igxModule IgxDateTimeEditorModule
 *
 * @igxParent IgxInputGroup
 *
 * @igxTheme igx-input-theme
 *
 * @igxKeywords date, time, editor
 *
 * @igxGroup Scheduling
 *
 * @remarks
 *
 * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
 * It requires input in a specified or default input format which is visible in the input element as a placeholder.
 * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
 * Supports display format that may differ from the input format.
 * Provides methods to increment and decrement any specific/targeted `DatePart`.
 *
 * @example
 * ```html
 * <igx-input-group>
 *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
 * </igx-input-group>
 * ```
 */
let IgxDateTimeEditorDirective = IgxDateTimeEditorDirective_1 = class IgxDateTimeEditorDirective extends IgxMaskDirective {
    constructor(renderer, elementRef, maskParser, _document, _locale) {
        super(elementRef, maskParser, renderer);
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this._document = _document;
        this._locale = _locale;
        /**
         * Specify if the currently spun date segment should loop over.
         * @example
         * ```html
         * <input igxDateTimeEditor [isSpinLoop]="false">
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the editor's value has changed.
         * @example
         * ```html
         * <input igxDateTimeEditor (valueChange)="onValueChanged($event)"/>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
         * @example
         * ```html
         * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
         * ```
         */
        this.validationFailed = new EventEmitter();
        this.onTouchCallback = (...args) => { };
        this.onChangeCallback = (...args) => { };
        this.onValidatorChange = (...args) => { };
        this.document = this._document;
        this.locale = this.locale || this._locale;
    }
    /**
     * Minimum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate">
     * ```
     */
    get minValue() {
        return this._minValue;
    }
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    /**
     * Maximum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed in, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [maxValue]="maxDate">
     * ```
     */
    get maxValue() {
        return this._maxValue;
    }
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    /**
     * Expected user input format (and placeholder).
     * @example
     * ```html
     * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
     * ```
     */
    set inputFormat(value) {
        if (value) {
            this._format = value;
        }
        const mask = (this.inputFormat || DatePickerUtil.DEFAULT_INPUT_FORMAT)
            .replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;
    }
    get inputFormat() {
        return this._format;
    }
    /**
     * Editor value.
     * @example
     * ```html
     * <input igxDateTimeEditor [value]="date">
     * ```
     */
    set value(value) {
        this._value = value;
        this.onChangeCallback(value);
        this.updateMask();
    }
    get value() {
        return this._value;
    }
    get emptyMask() {
        return this.maskParser.applyMask(null, this.maskOptions);
    }
    get targetDatePart() {
        var _a;
        if (this.document.activeElement === this.nativeElement) {
            return (_a = this._inputDateParts
                .find(p => p.start <= this.selectionStart && this.selectionStart <= p.end && p.type !== DatePart.Literal)) === null || _a === void 0 ? void 0 : _a.type;
        }
        else {
            if (this._inputDateParts.some(p => p.type === DatePart.Date)) {
                return DatePart.Date;
            }
            else if (this._inputDateParts.some(p => p.type === DatePart.Hours)) {
                return DatePart.Hours;
            }
        }
    }
    get hasDateParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Date
            || p.type === DatePart.Month
            || p.type === DatePart.Year);
    }
    get hasTimeParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Hours
            || p.type === DatePart.Minutes
            || p.type === DatePart.Seconds);
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['inputFormat'] || changes['locale']) {
            const defPlaceholder = this.inputFormat || DatePickerUtil.getDefaultInputFormat(this.locale);
            this._inputDateParts = DatePickerUtil.parseDateTimeFormat(this.inputFormat);
            this.inputFormat = this._inputDateParts.map(p => p.format).join('');
            if (!this.nativeElement.placeholder) {
                this.renderer.setAttribute(this.nativeElement, 'placeholder', defPlaceholder);
            }
            // TODO: fill in partial dates?
            this.updateMask();
        }
    }
    /** Clear the input element value. */
    clear() {
        this.updateValue(null);
    }
    /**
     * Increment specified DatePart.
     * @param datePart The optional DatePart to increment. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    increment(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, 1)
            : this.spinValue(targetDatePart, 1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /**
     * Decrement specified DatePart.
     *
     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    decrement(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, -1)
            : this.spinValue(targetDatePart, -1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.updateMask();
    }
    /** @hidden @internal */
    validate(control) {
        if (!this.inputIsComplete() || !control.value) {
            return { 'value': true };
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(control.value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { 'minValue': true };
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(control.value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { 'maxValue': true };
        }
        return null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) { this.onValidatorChange = fn; }
    /** @hidden @internal */
    registerOnChange(fn) { this.onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this.onTouchCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { }
    /** @hidden @internal */
    onInputChanged() {
        var _a;
        super.onInputChanged();
        if (this.inputIsComplete()) {
            const parsedDate = this.parseDate(this.inputValue);
            if (this.isValidDate(parsedDate)) {
                this.updateValue(parsedDate);
            }
            else {
                const oldValue = this.value && new Date(this.value.getTime());
                const args = { oldValue: oldValue, newValue: parsedDate, userInput: this.inputValue };
                this.validationFailed.emit(args);
                if (((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.getTime) && args.newValue.getTime() !== oldValue.getTime()) {
                    this.updateValue(args.newValue);
                }
                else {
                    this.updateValue(null);
                }
            }
        }
        else {
            this.updateValue(null);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        super.onKeyDown(event);
        if (event.altKey) {
            return;
        }
        if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
            event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
            this.spin(event);
            return;
        }
        if (event.ctrlKey && event.key === ";" /* SEMICOLON */) {
            this.updateValue(new Date());
        }
        this.moveCursor(event);
    }
    /** @hidden @internal */
    onFocus() {
        this._isFocused = true;
        this.onTouchCallback();
        this.updateMask();
        super.onFocus();
    }
    /** @hidden @internal */
    onBlur(value) {
        this._isFocused = false;
        if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {
            this.updateValue(this.parseDate(this.inputValue));
        }
        else {
            this.updateMask();
        }
        super.onBlur(value);
    }
    /** @hidden @internal */
    updateMask() {
        if (this._isFocused) {
            if (!this.value) {
                return;
            }
            // store the cursor position as it will be moved during masking
            const cursor = this.selectionEnd;
            this.inputValue = this.getMaskedValue();
            this.setSelectionRange(cursor);
        }
        else {
            if (!this.value || !this.isValidDate(this.value)) {
                this.inputValue = '';
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (format) {
                this.inputValue = formatDate(this.value, format.replace('tt', 'aa'), this.locale);
            }
            else {
                // TODO: formatter function?
                this.inputValue = this.value.toLocaleString();
            }
        }
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        for (const part of this._inputDateParts) {
            if (part.type === DatePart.Literal) {
                continue;
            }
            const targetValue = this.getPartValue(part, part.format.length);
            mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;
        }
        return mask;
    }
    // TODO: move isDate to utils
    isDate(value) {
        return value instanceof Date && typeof value === 'object';
    }
    valueInRange(value) {
        if (!value) {
            return false;
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        return true;
    }
    spinValue(datePart, delta) {
        if (!this.value || !this.isValidDate(this.value)) {
            return null;
        }
        const newDate = new Date(this.value.getTime());
        switch (datePart) {
            case DatePart.Date:
                DatePickerUtil.spinDate(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Month:
                DatePickerUtil.spinMonth(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Year:
                DatePickerUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DatePickerUtil.spinHours(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Minutes:
                DatePickerUtil.spinMinutes(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Seconds:
                DatePickerUtil.spinSeconds(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.AmPm:
                const formatPart = this._inputDateParts.find(dp => dp.type === DatePart.AmPm);
                const amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);
                return DatePickerUtil.spinAmPm(newDate, this.value, amPmFromMask);
        }
        return newDate;
    }
    updateValue(newDate) {
        this._oldValue = this.value;
        this.value = newDate;
        if (this.value && !this.valueInRange(this.value)) {
            this.validationFailed.emit({ oldValue: this._oldValue, newValue: this.value, userInput: this.inputValue });
        }
        if (this.inputIsComplete() || this.inputValue === this.emptyMask) {
            this.valueChange.emit(this.value);
        }
    }
    toTwelveHourFormat(value) {
        let hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);
        if (hour > 12) {
            hour -= 12;
        }
        else if (hour === 0) {
            hour = 12;
        }
        return hour;
    }
    getPartValue(datePartInfo, partLength) {
        let maskedValue;
        const datePart = datePartInfo.type;
        switch (datePart) {
            case DatePart.Date:
                maskedValue = this.value.getDate();
                break;
            case DatePart.Month:
                // months are zero based
                maskedValue = this.value.getMonth() + 1;
                break;
            case DatePart.Year:
                if (partLength === 2) {
                    maskedValue = this.prependValue(parseInt(this.value.getFullYear().toString().slice(-2), 10), partLength, '0');
                }
                else {
                    maskedValue = this.value.getFullYear();
                }
                break;
            case DatePart.Hours:
                if (datePartInfo.format.indexOf('h') !== -1) {
                    maskedValue = this.prependValue(this.toTwelveHourFormat(this.value.getHours().toString()), partLength, '0');
                }
                else {
                    maskedValue = this.value.getHours();
                }
                break;
            case DatePart.Minutes:
                maskedValue = this.value.getMinutes();
                break;
            case DatePart.Seconds:
                maskedValue = this.value.getSeconds();
                break;
            case DatePart.AmPm:
                maskedValue = this.value.getHours() >= 12 ? 'PM' : 'AM';
                break;
        }
        if (datePartInfo.type !== DatePart.AmPm) {
            return this.prependValue(maskedValue, partLength, '0');
        }
        return maskedValue;
    }
    prependValue(value, partLength, prependChar) {
        return (prependChar + value.toString()).slice(-partLength);
    }
    spin(event) {
        event.preventDefault();
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                this.increment();
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                this.decrement();
                break;
        }
    }
    inputIsComplete() {
        return this.inputValue.indexOf(this.promptChar) === -1;
    }
    isValidDate(date) {
        return date && date.getTime && !isNaN(date.getTime());
    }
    // TODO: move parseDate to utils
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DatePickerUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);
    }
    moveCursor(event) {
        const value = event.target.value;
        switch (event.key) {
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value));
                }
                break;
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value, 1));
                }
                break;
        }
    }
    /**
     * Move the cursor in a specific direction until it reaches a date/time separator.
     * Then return its index.
     *
     * @param value The string it operates on.
     * @param direction 0 is left, 1 is right. Default is 0.
     */
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter(p => p.type === DatePart.Literal);
        let cursorPos = this.selectionStart;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some(l => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some(l => l.start === cursorPos) && cursorPos < value.length);
            return cursorPos;
        }
    }
};
IgxDateTimeEditorDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: MaskParsingService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "locale", void 0);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "minValue", null);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "maxValue", null);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "isSpinLoop", void 0);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "displayFormat", void 0);
__decorate([
    Input(`igxDateTimeEditor`)
], IgxDateTimeEditorDirective.prototype, "inputFormat", null);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "value", null);
__decorate([
    Output()
], IgxDateTimeEditorDirective.prototype, "valueChange", void 0);
__decorate([
    Output()
], IgxDateTimeEditorDirective.prototype, "validationFailed", void 0);
IgxDateTimeEditorDirective = IgxDateTimeEditorDirective_1 = __decorate([
    Directive({
        selector: '[igxDateTimeEditor]',
        exportAs: 'igxDateTimeEditor',
        providers: [
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective_1, multi: true },
            { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective_1, multi: true }
        ]
    }),
    __param(3, Inject(DOCUMENT)),
    __param(4, Inject(LOCALE_ID))
], IgxDateTimeEditorDirective);
export { IgxDateTimeEditorDirective };
let IgxDateTimeEditorModule = class IgxDateTimeEditorModule {
};
IgxDateTimeEditorModule = __decorate([
    NgModule({
        declarations: [IgxDateTimeEditorDirective],
        exports: [IgxDateTimeEditorDirective]
    })
], IgxDateTimeEditorModule);
export { IgxDateTimeEditorModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLWVkaXRvci5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvZGF0ZS10aW1lLWVkaXRvci9kYXRlLXRpbWUtZWRpdG9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFDNUIsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFDakgsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUV5QyxhQUFhLEVBQWEsaUJBQWlCLEdBQzFGLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUVsRSxPQUFPLEVBQ0wsY0FBYyxFQUNmLE1BQU0scUNBQXFDLENBQUM7QUFDN0MsT0FBTyxFQUE0QyxRQUFRLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUUvRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJHO0FBU0gsSUFBYSwwQkFBMEIsa0NBQXZDLE1BQWEsMEJBQTJCLFNBQVEsZ0JBQWdCO0lBb0w5RCxZQUNZLFFBQW1CLEVBQ25CLFVBQXNCLEVBQ3RCLFVBQThCLEVBQ2QsU0FBYyxFQUNiLE9BQVk7UUFDdkMsS0FBSyxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFMOUIsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUNuQixlQUFVLEdBQVYsVUFBVSxDQUFZ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QURDLEtBQUssRUFBRTswREFDYztBQWtCdEI7SUFEQyxLQUFLLEVBQUU7MERBSVA7QUFrQkQ7SUFEQyxLQUFLLEVBQUU7MERBSVA7QUFVRDtJQURDLEtBQUssRUFBRTs4REFDaUI7QUFXekI7SUFEQyxLQUFLLEVBQUU7aUVBQ3FCO0FBVTdCO0lBREMsS0FBSyxDQUFDLG1CQUFtQixDQUFDOzZEQVExQjtBQWNEO0lBREMsS0FBSyxFQUFFO3VEQUtQO0FBY0Q7SUFEQyxNQUFNLEVBQUU7K0RBQ3FDO0FBVTlDO0lBREMsTUFBTSxFQUFFO29FQUNnRTtBQXZJOUQsMEJBQTBCO0lBUnRDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxxQkFBcUI7UUFDL0IsUUFBUSxFQUFFLG1CQUFtQjtRQUM3QixTQUFTLEVBQUU7WUFDVCxFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsNEJBQTBCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtZQUNwRixFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLDRCQUEwQixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7U0FDakY7S0FDRixDQUFDO0lBeUxHLFdBQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQ2hCLFdBQUEsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0dBekxULDBCQUEwQixDQXNqQnRDO1NBdGpCWSwwQkFBMEI7QUE0akJ2QyxJQUFhLHVCQUF1QixHQUFwQyxNQUFhLHVCQUF1QjtDQUFJLENBQUE7QUFBM0IsdUJBQXVCO0lBSm5DLFFBQVEsQ0FBQztRQUNSLFlBQVksRUFBRSxDQUFDLDBCQUEwQixDQUFDO1FBQzFDLE9BQU8sRUFBRSxDQUFDLDBCQUEwQixDQUFDO0tBQ3RDLENBQUM7R0FDVyx1QkFBdUIsQ0FBSTtTQUEzQix1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEaXJlY3RpdmUsIElucHV0LCBFbGVtZW50UmVmLFxuICBSZW5kZXJlcjIsIE5nTW9kdWxlLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5qZWN0LCBMT0NBTEVfSUQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgSG9zdCwgT3B0aW9uYWwsIEluamVjdG9yXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIFZhbGlkYXRvciwgQWJzdHJhY3RDb250cm9sLCBWYWxpZGF0aW9uRXJyb3JzLCBOR19WQUxJREFUT1JTLCBOZ0NvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBmb3JtYXREYXRlLCBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hNYXNrRGlyZWN0aXZlIH0gZnJvbSAnLi4vbWFzay9tYXNrLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNYXNrUGFyc2luZ1NlcnZpY2UgfSBmcm9tICcuLi9tYXNrL21hc2stcGFyc2luZy5zZXJ2aWNlJztcbmltcG9ydCB7IEtFWVMgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7XG4gIERhdGVQaWNrZXJVdGlsXG59IGZyb20gJy4uLy4uL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnV0aWxzJztcbmltcG9ydCB7IElneERhdGVUaW1lRWRpdG9yRXZlbnRBcmdzLCBEYXRlUGFydEluZm8sIERhdGVQYXJ0IH0gZnJvbSAnLi9kYXRlLXRpbWUtZWRpdG9yLmNvbW1vbic7XG5cbi8qKlxuICogRGF0ZSBUaW1lIEVkaXRvciBwcm92aWRlcyBhIGZ1bmN0aW9uYWxpdHkgdG8gaW5wdXQsIGVkaXQgYW5kIGZvcm1hdCBkYXRlIGFuZCB0aW1lLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4RGF0ZVRpbWVFZGl0b3JNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IElneElucHV0R3JvdXBcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LWlucHV0LXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIGRhdGUsIHRpbWUsIGVkaXRvclxuICpcbiAqIEBpZ3hHcm91cCBTY2hlZHVsaW5nXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBUaGUgSWduaXRlIFVJIERhdGUgVGltZSBFZGl0b3IgRGlyZWN0aXZlIG1ha2VzIGl0IGVhc3kgZm9yIGRldmVsb3BlcnMgdG8gbWFuaXB1bGF0ZSBkYXRlL3RpbWUgdXNlciBpbnB1dC5cbiAqIEl0IHJlcXVpcmVzIGlucHV0IGluIGEgc3BlY2lmaWVkIG9yIGRlZmF1bHQgaW5wdXQgZm9ybWF0IHdoaWNoIGlzIHZpc2libGUgaW4gdGhlIGlucHV0IGVsZW1lbnQgYXMgYSBwbGFjZWhvbGRlci5cbiAqIEl0IGFsbG93cyB0aGUgaW5wdXQgb2Ygb25seSBkYXRlIChleDogJ2RkL01NL3l5eXknKSwgb25seSB0aW1lIChleDonSEg6bW0gdHQnKSBvciBib3RoIGF0IG9uY2UsIGlmIG5lZWRlZC5cbiAqIFN1cHBvcnRzIGRpc3BsYXkgZm9ybWF0IHRoYXQgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCBmb3JtYXQuXG4gKiBQcm92aWRlcyBtZXRob2RzIHRvIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGFueSBzcGVjaWZpYy90YXJnZXRlZCBgRGF0ZVBhcnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBodG1sXG4gKiA8aWd4LWlucHV0LWdyb3VwPlxuICogICA8aW5wdXQgdHlwZT1cInRleHRcIiBpZ3hJbnB1dCBbaWd4RGF0ZVRpbWVFZGl0b3JdPVwiJ2RkL01NL3l5eXknXCIgW2Rpc3BsYXlGb3JtYXRdPVwiJ3Nob3J0RGF0ZSdcIiBbKG5nTW9kZWwpXT1cImRhdGVcIi8+XG4gKiA8L2lneC1pbnB1dC1ncm91cD5cbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbaWd4RGF0ZVRpbWVFZGl0b3JdJyxcbiAgZXhwb3J0QXM6ICdpZ3hEYXRlVGltZUVkaXRvcicsXG4gIHByb3ZpZGVyczogW1xuICAgIHsgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBJZ3hEYXRlVGltZUVkaXRvckRpcmVjdGl2ZSwgbXVsdGk6IHRydWUgfSxcbiAgICB7IHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBJZ3hEYXRlVGltZUVkaXRvckRpcmVjdGl2ZSwgbXVsdGk6IHRydWUgfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIElneERhdGVUaW1lRWRpdG9yRGlyZWN0aXZlIGV4dGVuZHMgSWd4TWFza0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgVmFsaWRhdG9yLCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gIC8qKlxuICAgKiBMb2NhbGUgc2V0dGluZ3MgdXNlZCBmb3IgdmFsdWUgZm9ybWF0dGluZy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVXNlcyBBbmd1bGFyJ3MgYExPQ0FMRV9JRGAgYnkgZGVmYXVsdC4gQWZmZWN0cyBib3RoIGlucHV0IG1hc2sgYW5kIGRpc3BsYXkgZm9ybWF0IGlmIHRob3NlIGFyZSBub3Qgc2V0LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBodG1sXG4gICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciBbbG9jYWxlXT1cIidlbidcIj5cbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgbG9jYWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1pbmltdW0gdmFsdWUgcmVxdWlyZWQgZm9yIHRoZSBlZGl0b3IgdG8gcmVtYWluIHZhbGlkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBhIGBzdHJpbmdgIHZhbHVlIGlzIHBhc3NlZCwgaXQgbXVzdCBiZSBpbiB0aGUgZGVmaW5lZCBpbnB1dCBmb3JtYXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGh0bWxcbiAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFttaW5WYWx1ZV09XCJtaW5EYXRlXCI+XG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGdldCBtaW5WYWx1ZSgpOiBzdHJpbmcgfCBEYXRlIHtcbiAgICByZXR1cm4gdGhpcy5fbWluVmFsdWU7XG4gIH1cblxuICBASW5wdXQoKVxuICBwdWJsaWMgc2V0IG1pblZhbHVlKHZhbHVlOiBzdHJpbmcgfCBEYXRlKSB7XG4gICAgdGhpcy5fbWluVmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm9uVmFsaWRhdG9yQ2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogTWF4aW11bSB2YWx1ZSByZXF1aXJlZCBmb3IgdGhlIGVkaXRvciB0byByZW1haW4gdmFsaWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIGEgYHN0cmluZ2AgdmFsdWUgaXMgcGFzc2VkIGluLCBpdCBtdXN0IGJlIGluIHRoZSBkZWZpbmVkIGlucHV0IGZvcm1hdC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgaHRtbFxuICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW21heFZhbHVlXT1cIm1heERhdGVcIj5cbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1heFZhbHVlKCk6IHN0cmluZyB8IERhdGUge1xuICAgIHJldHVybiB0aGlzLl9tYXhWYWx1ZTtcbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBzZXQgbWF4VmFsdWUodmFsdWU6IHN0cmluZyB8IERhdGUpIHtcbiAgICB0aGlzLl9tYXhWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGlmIHRoZSBjdXJyZW50bHkgc3B1biBkYXRlIHNlZ21lbnQgc2hvdWxkIGxvb3Agb3Zlci5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgaHRtbFxuICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW2lzU3Bpbkxvb3BdPVwiZmFsc2VcIj5cbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgaXNTcGluTG9vcCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFNldCBib3RoIHByZS1kZWZpbmVkIGZvcm1hdCBvcHRpb25zIHN1Y2ggYXMgYHNob3J0RGF0ZWAgYW5kIGBsb25nRGF0ZWAsXG4gICAqIGFzIHdlbGwgYXMgY29uc3RydWN0ZWQgZm9ybWF0IHN0cmluZyB1c2luZyBjaGFyYWN0ZXJzIHN1cHBvcnRlZCBieSBgRGF0ZVBpcGVgLCBlLmcuIGBFRS9NTS95eXl5YC5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgaHRtbFxuICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW2Rpc3BsYXlGb3JtYXRdPVwiJ3Nob3J0RGF0ZSdcIj5cbiAgICogYGBgXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgZGlzcGxheUZvcm1hdDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFeHBlY3RlZCB1c2VyIGlucHV0IGZvcm1hdCAoYW5kIHBsYWNlaG9sZGVyKS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgaHRtbFxuICAgKiA8aW5wdXQgW2lneERhdGVUaW1lRWRpdG9yXT1cIidkZC9NTS95eXl5J1wiPlxuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dChgaWd4RGF0ZVRpbWVFZGl0b3JgKVxuICBwdWJsaWMgc2V0IGlucHV0Rm9ybWF0KHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX2Zvcm1hdCA9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBtYXNrID0gKHRoaXMuaW5wdXRGb3JtYXQgfHwgRGF0ZVBpY2tlclV0aWwuREVGQVVMVF9JTlBVVF9GT1JNQVQpXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKC8oPz1bXnRdKVtcXHddLywgJ2cnKSwgJzAnKTtcbiAgICB0aGlzLm1hc2sgPSBtYXNrLmluZGV4T2YoJ3R0JykgIT09IC0xID8gbWFzay5yZXBsYWNlKG5ldyBSZWdFeHAoJ3R0JywgJ2cnKSwgJ0xMJykgOiBtYXNrO1xuICB9XG5cbiAgcHVibGljIGdldCBpbnB1dEZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogRWRpdG9yIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBodG1sXG4gICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciBbdmFsdWVdPVwiZGF0ZVwiPlxuICAgKiBgYGBcbiAgICovXG4gIEBJbnB1dCgpXG4gIHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IERhdGUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh2YWx1ZSk7XG4gICAgdGhpcy51cGRhdGVNYXNrKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IERhdGUge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIGVkaXRvcidzIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBodG1sXG4gICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciAodmFsdWVDaGFuZ2UpPVwib25WYWx1ZUNoYW5nZWQoJGV2ZW50KVwiLz5cbiAgICogYGBgXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIGVkaXRvciBpcyBub3Qgd2l0aGluIGEgc3BlY2lmaWVkIHJhbmdlIG9yIHdoZW4gdGhlIGVkaXRvcidzIHZhbHVlIGlzIGluIGFuIGludmFsaWQgc3RhdGUuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGh0bWxcbiAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFttaW5WYWx1ZV09XCJtaW5EYXRlXCIgW21heFZhbHVlXT1cIm1heERhdGVcIiAodmFsaWRhdGlvbkZhaWxlZCk9XCJvblZhbGlkYXRpb25GYWlsZWQoJGV2ZW50KVwiLz5cbiAgICogYGBgXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHZhbGlkYXRpb25GYWlsZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElneERhdGVUaW1lRWRpdG9yRXZlbnRBcmdzPigpO1xuXG4gIHByaXZhdGUgX3ZhbHVlOiBEYXRlO1xuICBwcml2YXRlIF9mb3JtYXQ6IHN0cmluZztcbiAgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQ7XG4gIHByaXZhdGUgX2lzRm9jdXNlZDogYm9vbGVhbjtcbiAgcHJpdmF0ZSBfbWluVmFsdWU6IHN0cmluZyB8IERhdGU7XG4gIHByaXZhdGUgX21heFZhbHVlOiBzdHJpbmcgfCBEYXRlO1xuICBwcml2YXRlIF9vbGRWYWx1ZTogRGF0ZSB8IHN0cmluZztcbiAgcHJpdmF0ZSBfaW5wdXREYXRlUGFydHM6IERhdGVQYXJ0SW5mb1tdO1xuICBwcml2YXRlIG9uVG91Y2hDYWxsYmFjayA9ICguLi5hcmdzOiBhbnlbXSkgPT4geyB9O1xuICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2sgPSAoLi4uYXJnczogYW55W10pID0+IHsgfTtcbiAgcHJpdmF0ZSBvblZhbGlkYXRvckNoYW5nZSA9ICguLi5hcmdzOiBhbnlbXSkgPT4geyB9O1xuXG4gIHByaXZhdGUgZ2V0IGVtcHR5TWFzaygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm1hc2tQYXJzZXIuYXBwbHlNYXNrKG51bGwsIHRoaXMubWFza09wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgdGFyZ2V0RGF0ZVBhcnQoKTogRGF0ZVBhcnQge1xuICAgIGlmICh0aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMubmF0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lucHV0RGF0ZVBhcnRzXG4gICAgICAgIC5maW5kKHAgPT4gcC5zdGFydCA8PSB0aGlzLnNlbGVjdGlvblN0YXJ0ICYmIHRoaXMuc2VsZWN0aW9uU3RhcnQgPD0gcC5lbmQgJiYgcC50eXBlICE9PSBEYXRlUGFydC5MaXRlcmFsKT8udHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2lucHV0RGF0ZVBhcnRzLnNvbWUocCA9PiBwLnR5cGUgPT09IERhdGVQYXJ0LkRhdGUpKSB7XG4gICAgICAgIHJldHVybiBEYXRlUGFydC5EYXRlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dERhdGVQYXJ0cy5zb21lKHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5Ib3VycykpIHtcbiAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkhvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGhhc0RhdGVQYXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXREYXRlUGFydHMuc29tZShcbiAgICAgIHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5EYXRlXG4gICAgICAgIHx8IHAudHlwZSA9PT0gRGF0ZVBhcnQuTW9udGhcbiAgICAgICAgfHwgcC50eXBlID09PSBEYXRlUGFydC5ZZWFyKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGhhc1RpbWVQYXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXREYXRlUGFydHMuc29tZShcbiAgICAgIHAgPT4gcC50eXBlID09PSBEYXRlUGFydC5Ib3Vyc1xuICAgICAgICB8fCBwLnR5cGUgPT09IERhdGVQYXJ0Lk1pbnV0ZXNcbiAgICAgICAgfHwgcC50eXBlID09PSBEYXRlUGFydC5TZWNvbmRzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCBtYXNrUGFyc2VyOiBNYXNrUGFyc2luZ1NlcnZpY2UsXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcbiAgICBASW5qZWN0KExPQ0FMRV9JRCkgcHJpdmF0ZSBfbG9jYWxlOiBhbnkpIHtcbiAgICBzdXBlcihlbGVtZW50UmVmLCBtYXNrUGFyc2VyLCByZW5kZXJlcik7XG4gICAgdGhpcy5kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50IGFzIERvY3VtZW50O1xuICAgIHRoaXMubG9jYWxlID0gdGhpcy5sb2NhbGUgfHwgdGhpcy5fbG9jYWxlO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXNbJ2lucHV0Rm9ybWF0J10gfHwgY2hhbmdlc1snbG9jYWxlJ10pIHtcbiAgICAgIGNvbnN0IGRlZlBsYWNlaG9sZGVyID0gdGhpcy5pbnB1dEZvcm1hdCB8fCBEYXRlUGlja2VyVXRpbC5nZXREZWZhdWx0SW5wdXRGb3JtYXQodGhpcy5sb2NhbGUpO1xuICAgICAgdGhpcy5faW5wdXREYXRlUGFydHMgPSBEYXRlUGlja2VyVXRpbC5wYXJzZURhdGVUaW1lRm9ybWF0KHRoaXMuaW5wdXRGb3JtYXQpO1xuICAgICAgdGhpcy5pbnB1dEZvcm1hdCA9IHRoaXMuX2lucHV0RGF0ZVBhcnRzLm1hcChwID0+IHAuZm9ybWF0KS5qb2luKCcnKTtcbiAgICAgIGlmICghdGhpcy5uYXRpdmVFbGVtZW50LnBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMubmF0aXZlRWxlbWVudCwgJ3BsYWNlaG9sZGVyJywgZGVmUGxhY2Vob2xkZXIpO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogZmlsbCBpbiBwYXJ0aWFsIGRhdGVzP1xuICAgICAgdGhpcy51cGRhdGVNYXNrKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENsZWFyIHRoZSBpbnB1dCBlbGVtZW50IHZhbHVlLiAqL1xuICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGVWYWx1ZShudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgc3BlY2lmaWVkIERhdGVQYXJ0LlxuICAgKiBAcGFyYW0gZGF0ZVBhcnQgVGhlIG9wdGlvbmFsIERhdGVQYXJ0IHRvIGluY3JlbWVudC4gRGVmYXVsdHMgdG8gRGF0ZSBvciBIb3Vycyh3aGVuIERhdGUgaXMgYWJzZW50IGZyb20gdGhlIGlucHV0Rm9ybWF0IC0gZXg6J0hIOm1tJykuXG4gICAqL1xuICBwdWJsaWMgaW5jcmVtZW50KGRhdGVQYXJ0PzogRGF0ZVBhcnQpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXREYXRlUGFydCA9IHRoaXMudGFyZ2V0RGF0ZVBhcnQ7XG4gICAgaWYgKCF0YXJnZXREYXRlUGFydCkgeyByZXR1cm47IH1cbiAgICBjb25zdCBuZXdWYWx1ZSA9IGRhdGVQYXJ0XG4gICAgICA/IHRoaXMuc3BpblZhbHVlKGRhdGVQYXJ0LCAxKVxuICAgICAgOiB0aGlzLnNwaW5WYWx1ZSh0YXJnZXREYXRlUGFydCwgMSk7XG4gICAgdGhpcy51cGRhdGVWYWx1ZShuZXdWYWx1ZSA/IG5ld1ZhbHVlIDogbmV3IERhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcmVtZW50IHNwZWNpZmllZCBEYXRlUGFydC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGVQYXJ0IFRoZSBvcHRpb25hbCBEYXRlUGFydCB0byBkZWNyZW1lbnQuIERlZmF1bHRzIHRvIERhdGUgb3IgSG91cnMod2hlbiBEYXRlIGlzIGFic2VudCBmcm9tIHRoZSBpbnB1dEZvcm1hdCAtIGV4OidISDptbScpLlxuICAgKi9cbiAgcHVibGljIGRlY3JlbWVudChkYXRlUGFydD86IERhdGVQYXJ0KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0RGF0ZVBhcnQgPSB0aGlzLnRhcmdldERhdGVQYXJ0O1xuICAgIGlmICghdGFyZ2V0RGF0ZVBhcnQpIHsgcmV0dXJuOyB9XG4gICAgY29uc3QgbmV3VmFsdWUgPSBkYXRlUGFydFxuICAgICAgPyB0aGlzLnNwaW5WYWx1ZShkYXRlUGFydCwgLTEpXG4gICAgICA6IHRoaXMuc3BpblZhbHVlKHRhcmdldERhdGVQYXJ0LCAtMSk7XG4gICAgdGhpcy51cGRhdGVWYWx1ZShuZXdWYWx1ZSA/IG5ld1ZhbHVlIDogbmV3IERhdGUoKSk7XG4gIH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVNYXNrKCk7XG4gIH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICBpZiAoIXRoaXMuaW5wdXRJc0NvbXBsZXRlKCkgfHwgIWNvbnRyb2wudmFsdWUpIHtcbiAgICAgIHJldHVybiB7ICd2YWx1ZSc6IHRydWUgfTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhWYWx1ZUFzRGF0ZSA9IHRoaXMuaXNEYXRlKHRoaXMubWF4VmFsdWUpID8gdGhpcy5tYXhWYWx1ZSA6IHRoaXMucGFyc2VEYXRlKHRoaXMubWF4VmFsdWUpO1xuICAgIGNvbnN0IG1pblZhbHVlQXNEYXRlID0gdGhpcy5pc0RhdGUodGhpcy5taW5WYWx1ZSkgPyB0aGlzLm1pblZhbHVlIDogdGhpcy5wYXJzZURhdGUodGhpcy5taW5WYWx1ZSk7XG4gICAgaWYgKG1pblZhbHVlQXNEYXRlXG4gICAgICAmJiBEYXRlUGlja2VyVXRpbC5sZXNzVGhhbk1pblZhbHVlKFxuICAgICAgICBjb250cm9sLnZhbHVlLCBtaW5WYWx1ZUFzRGF0ZSwgdGhpcy5oYXNUaW1lUGFydHMsIHRoaXMuaGFzRGF0ZVBhcnRzKSkge1xuICAgICAgcmV0dXJuIHsgJ21pblZhbHVlJzogdHJ1ZSB9O1xuICAgIH1cbiAgICBpZiAobWF4VmFsdWVBc0RhdGVcbiAgICAgICYmIERhdGVQaWNrZXJVdGlsLmdyZWF0ZXJUaGFuTWF4VmFsdWUoXG4gICAgICAgIGNvbnRyb2wudmFsdWUsIG1heFZhbHVlQXNEYXRlLCB0aGlzLmhhc1RpbWVQYXJ0cywgdGhpcy5oYXNEYXRlUGFydHMpKSB7XG4gICAgICByZXR1cm4geyAnbWF4VmFsdWUnOiB0cnVlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2U/KGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7IHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjsgfVxuXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7IHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuOyB9XG5cbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gIHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IHRoaXMub25Ub3VjaENhbGxiYWNrID0gZm47IH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHNldERpc2FibGVkU3RhdGU/KGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHsgfVxuXG4gIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICBwdWJsaWMgb25JbnB1dENoYW5nZWQoKSB7XG4gICAgc3VwZXIub25JbnB1dENoYW5nZWQoKTtcbiAgICBpZiAodGhpcy5pbnB1dElzQ29tcGxldGUoKSkge1xuICAgICAgY29uc3QgcGFyc2VkRGF0ZSA9IHRoaXMucGFyc2VEYXRlKHRoaXMuaW5wdXRWYWx1ZSk7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkRGF0ZShwYXJzZWREYXRlKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHBhcnNlZERhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlICYmIG5ldyBEYXRlKHRoaXMudmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHsgb2xkVmFsdWU6IG9sZFZhbHVlLCBuZXdWYWx1ZTogcGFyc2VkRGF0ZSwgdXNlcklucHV0OiB0aGlzLmlucHV0VmFsdWUgfTtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRmFpbGVkLmVtaXQoYXJncyk7XG4gICAgICAgIGlmIChhcmdzLm5ld1ZhbHVlPy5nZXRUaW1lICYmIGFyZ3MubmV3VmFsdWUuZ2V0VGltZSgpICE9PSBvbGRWYWx1ZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKGFyZ3MubmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZShudWxsKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIHN1cGVyLm9uS2V5RG93bihldmVudCk7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkgeyByZXR1cm47IH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBLRVlTLlVQX0FSUk9XIHx8IGV2ZW50LmtleSA9PT0gS0VZUy5VUF9BUlJPV19JRSB8fFxuICAgICAgZXZlbnQua2V5ID09PSBLRVlTLkRPV05fQVJST1cgfHwgZXZlbnQua2V5ID09PSBLRVlTLkRPV05fQVJST1dfSUUpIHtcbiAgICAgIHRoaXMuc3BpbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5ID09PSBLRVlTLlNFTUlDT0xPTikge1xuICAgICAgdGhpcy51cGRhdGVWYWx1ZShuZXcgRGF0ZSgpKTtcbiAgICB9XG5cbiAgICB0aGlzLm1vdmVDdXJzb3IoZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gIHB1YmxpYyBvbkZvY3VzKCk6IHZvaWQge1xuICAgIHRoaXMuX2lzRm9jdXNlZCA9IHRydWU7XG4gICAgdGhpcy5vblRvdWNoQ2FsbGJhY2soKTtcbiAgICB0aGlzLnVwZGF0ZU1hc2soKTtcbiAgICBzdXBlci5vbkZvY3VzKCk7XG4gIH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIG9uQmx1cih2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5faXNGb2N1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmlucHV0SXNDb21wbGV0ZSgpICYmIHRoaXMuaW5wdXRWYWx1ZSAhPT0gdGhpcy5lbXB0eU1hc2spIHtcbiAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5wYXJzZURhdGUodGhpcy5pbnB1dFZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlTWFzaygpO1xuICAgIH1cblxuICAgIHN1cGVyLm9uQmx1cih2YWx1ZSk7XG4gIH1cblxuICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgcHVibGljIHVwZGF0ZU1hc2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzRm9jdXNlZCkge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7IHJldHVybjsgfVxuICAgICAgLy8gc3RvcmUgdGhlIGN1cnNvciBwb3NpdGlvbiBhcyBpdCB3aWxsIGJlIG1vdmVkIGR1cmluZyBtYXNraW5nXG4gICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLnNlbGVjdGlvbkVuZDtcbiAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9IHRoaXMuZ2V0TWFza2VkVmFsdWUoKTtcbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UoY3Vyc29yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnZhbHVlIHx8ICF0aGlzLmlzVmFsaWREYXRlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuaW5wdXRWYWx1ZSA9ICcnO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmRpc3BsYXlGb3JtYXQgfHwgdGhpcy5pbnB1dEZvcm1hdDtcbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dFZhbHVlID0gZm9ybWF0RGF0ZSh0aGlzLnZhbHVlLCBmb3JtYXQucmVwbGFjZSgndHQnLCAnYWEnKSwgdGhpcy5sb2NhbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogZm9ybWF0dGVyIGZ1bmN0aW9uP1xuICAgICAgICB0aGlzLmlucHV0VmFsdWUgPSB0aGlzLnZhbHVlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNYXNrZWRWYWx1ZSgpOiBzdHJpbmcge1xuICAgIGxldCBtYXNrID0gdGhpcy5lbXB0eU1hc2s7XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX2lucHV0RGF0ZVBhcnRzKSB7XG4gICAgICBpZiAocGFydC50eXBlID09PSBEYXRlUGFydC5MaXRlcmFsKSB7IGNvbnRpbnVlOyB9XG4gICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRoaXMuZ2V0UGFydFZhbHVlKHBhcnQsIHBhcnQuZm9ybWF0Lmxlbmd0aCk7XG4gICAgICBtYXNrID0gdGhpcy5tYXNrUGFyc2VyLnJlcGxhY2VJbk1hc2sobWFzaywgdGFyZ2V0VmFsdWUsIHRoaXMubWFza09wdGlvbnMsIHBhcnQuc3RhcnQsIHBhcnQuZW5kKS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFzaztcbiAgfVxuXG4gIC8vIFRPRE86IG1vdmUgaXNEYXRlIHRvIHV0aWxzXG4gIHByaXZhdGUgaXNEYXRlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBEYXRlIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG4gIH1cblxuICBwcml2YXRlIHZhbHVlSW5SYW5nZSh2YWx1ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIGlmICghdmFsdWUpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY29uc3QgbWF4VmFsdWVBc0RhdGUgPSB0aGlzLmlzRGF0ZSh0aGlzLm1heFZhbHVlKSA/IHRoaXMubWF4VmFsdWUgOiB0aGlzLnBhcnNlRGF0ZSh0aGlzLm1heFZhbHVlKTtcbiAgICBjb25zdCBtaW5WYWx1ZUFzRGF0ZSA9IHRoaXMuaXNEYXRlKHRoaXMubWluVmFsdWUpID8gdGhpcy5taW5WYWx1ZSA6IHRoaXMucGFyc2VEYXRlKHRoaXMubWluVmFsdWUpO1xuICAgIGlmIChtaW5WYWx1ZUFzRGF0ZVxuICAgICAgJiYgRGF0ZVBpY2tlclV0aWwubGVzc1RoYW5NaW5WYWx1ZShcbiAgICAgICAgdmFsdWUsIG1pblZhbHVlQXNEYXRlLCB0aGlzLmhhc1RpbWVQYXJ0cywgdGhpcy5oYXNEYXRlUGFydHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXhWYWx1ZUFzRGF0ZVxuICAgICAgJiYgRGF0ZVBpY2tlclV0aWwuZ3JlYXRlclRoYW5NYXhWYWx1ZShcbiAgICAgICAgdmFsdWUsIG1heFZhbHVlQXNEYXRlLCB0aGlzLmhhc1RpbWVQYXJ0cywgdGhpcy5oYXNEYXRlUGFydHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHNwaW5WYWx1ZShkYXRlUGFydDogRGF0ZVBhcnQsIGRlbHRhOiBudW1iZXIpOiBEYXRlIHtcbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMuaXNWYWxpZERhdGUodGhpcy52YWx1ZSkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb25zdCBuZXdEYXRlID0gbmV3IERhdGUodGhpcy52YWx1ZS5nZXRUaW1lKCkpO1xuICAgIHN3aXRjaCAoZGF0ZVBhcnQpIHtcbiAgICAgIGNhc2UgRGF0ZVBhcnQuRGF0ZTpcbiAgICAgICAgRGF0ZVBpY2tlclV0aWwuc3BpbkRhdGUoZGVsdGEsIG5ld0RhdGUsIHRoaXMuaXNTcGluTG9vcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEYXRlUGFydC5Nb250aDpcbiAgICAgICAgRGF0ZVBpY2tlclV0aWwuc3Bpbk1vbnRoKGRlbHRhLCBuZXdEYXRlLCB0aGlzLmlzU3Bpbkxvb3ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRGF0ZVBhcnQuWWVhcjpcbiAgICAgICAgRGF0ZVBpY2tlclV0aWwuc3BpblllYXIoZGVsdGEsIG5ld0RhdGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRGF0ZVBhcnQuSG91cnM6XG4gICAgICAgIERhdGVQaWNrZXJVdGlsLnNwaW5Ib3VycyhkZWx0YSwgbmV3RGF0ZSwgdGhpcy5pc1NwaW5Mb29wKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERhdGVQYXJ0Lk1pbnV0ZXM6XG4gICAgICAgIERhdGVQaWNrZXJVdGlsLnNwaW5NaW51dGVzKGRlbHRhLCBuZXdEYXRlLCB0aGlzLmlzU3Bpbkxvb3ApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRGF0ZVBhcnQuU2Vjb25kczpcbiAgICAgICAgRGF0ZVBpY2tlclV0aWwuc3BpblNlY29uZHMoZGVsdGEsIG5ld0RhdGUsIHRoaXMuaXNTcGluTG9vcCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEYXRlUGFydC5BbVBtOlxuICAgICAgICBjb25zdCBmb3JtYXRQYXJ0ID0gdGhpcy5faW5wdXREYXRlUGFydHMuZmluZChkcCA9PiBkcC50eXBlID09PSBEYXRlUGFydC5BbVBtKTtcbiAgICAgICAgY29uc3QgYW1QbUZyb21NYXNrID0gdGhpcy5pbnB1dFZhbHVlLnN1YnN0cmluZyhmb3JtYXRQYXJ0LnN0YXJ0LCBmb3JtYXRQYXJ0LmVuZCk7XG4gICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5zcGluQW1QbShuZXdEYXRlLCB0aGlzLnZhbHVlLCBhbVBtRnJvbU1hc2spO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdEYXRlO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVWYWx1ZShuZXdEYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgdGhpcy5fb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBuZXdEYXRlO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIXRoaXMudmFsdWVJblJhbmdlKHRoaXMudmFsdWUpKSB7XG4gICAgICB0aGlzLnZhbGlkYXRpb25GYWlsZWQuZW1pdCh7IG9sZFZhbHVlOiB0aGlzLl9vbGRWYWx1ZSwgbmV3VmFsdWU6IHRoaXMudmFsdWUsIHVzZXJJbnB1dDogdGhpcy5pbnB1dFZhbHVlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dElzQ29tcGxldGUoKSB8fCB0aGlzLmlucHV0VmFsdWUgPT09IHRoaXMuZW1wdHlNYXNrKSB7XG4gICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0b1R3ZWx2ZUhvdXJGb3JtYXQodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludCh2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5wcm9tcHRDaGFyLCAnZycpLCAnMCcpLCAxMCk7XG4gICAgaWYgKGhvdXIgPiAxMikge1xuICAgICAgaG91ciAtPSAxMjtcbiAgICB9IGVsc2UgaWYgKGhvdXIgPT09IDApIHtcbiAgICAgIGhvdXIgPSAxMjtcbiAgICB9XG5cbiAgICByZXR1cm4gaG91cjtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UGFydFZhbHVlKGRhdGVQYXJ0SW5mbzogRGF0ZVBhcnRJbmZvLCBwYXJ0TGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGxldCBtYXNrZWRWYWx1ZTtcbiAgICBjb25zdCBkYXRlUGFydCA9IGRhdGVQYXJ0SW5mby50eXBlO1xuICAgIHN3aXRjaCAoZGF0ZVBhcnQpIHtcbiAgICAgIGNhc2UgRGF0ZVBhcnQuRGF0ZTpcbiAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLnZhbHVlLmdldERhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERhdGVQYXJ0Lk1vbnRoOlxuICAgICAgICAvLyBtb250aHMgYXJlIHplcm8gYmFzZWRcbiAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLnZhbHVlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRGF0ZVBhcnQuWWVhcjpcbiAgICAgICAgaWYgKHBhcnRMZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMucHJlcGVuZFZhbHVlKFxuICAgICAgICAgICAgcGFyc2VJbnQodGhpcy52YWx1ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkuc2xpY2UoLTIpLCAxMCksIHBhcnRMZW5ndGgsICcwJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLnZhbHVlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERhdGVQYXJ0LkhvdXJzOlxuICAgICAgICBpZiAoZGF0ZVBhcnRJbmZvLmZvcm1hdC5pbmRleE9mKCdoJykgIT09IC0xKSB7XG4gICAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLnByZXBlbmRWYWx1ZShcbiAgICAgICAgICAgIHRoaXMudG9Ud2VsdmVIb3VyRm9ybWF0KHRoaXMudmFsdWUuZ2V0SG91cnMoKS50b1N0cmluZygpKSwgcGFydExlbmd0aCwgJzAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMudmFsdWUuZ2V0SG91cnMoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRGF0ZVBhcnQuTWludXRlczpcbiAgICAgICAgbWFza2VkVmFsdWUgPSB0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERhdGVQYXJ0LlNlY29uZHM6XG4gICAgICAgIG1hc2tlZFZhbHVlID0gdGhpcy52YWx1ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEYXRlUGFydC5BbVBtOlxuICAgICAgICBtYXNrZWRWYWx1ZSA9IHRoaXMudmFsdWUuZ2V0SG91cnMoKSA+PSAxMiA/ICdQTScgOiAnQU0nO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoZGF0ZVBhcnRJbmZvLnR5cGUgIT09IERhdGVQYXJ0LkFtUG0pIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXBlbmRWYWx1ZShtYXNrZWRWYWx1ZSwgcGFydExlbmd0aCwgJzAnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFza2VkVmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHByZXBlbmRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBwYXJ0TGVuZ3RoOiBudW1iZXIsIHByZXBlbmRDaGFyOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiAocHJlcGVuZENoYXIgKyB2YWx1ZS50b1N0cmluZygpKS5zbGljZSgtcGFydExlbmd0aCk7XG4gIH1cblxuICBwcml2YXRlIHNwaW4oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIEtFWVMuVVBfQVJST1c6XG4gICAgICBjYXNlIEtFWVMuVVBfQVJST1dfSUU6XG4gICAgICAgIHRoaXMuaW5jcmVtZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlTLkRPV05fQVJST1c6XG4gICAgICBjYXNlIEtFWVMuRE9XTl9BUlJPV19JRTpcbiAgICAgICAgdGhpcy5kZWNyZW1lbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbnB1dElzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRWYWx1ZS5pbmRleE9mKHRoaXMucHJvbXB0Q2hhcikgPT09IC0xO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1ZhbGlkRGF0ZShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGUgJiYgZGF0ZS5nZXRUaW1lICYmICFpc05hTihkYXRlLmdldFRpbWUoKSk7XG4gIH1cblxuICAgIC8vIFRPRE86IG1vdmUgcGFyc2VEYXRlIHRvIHV0aWxzXG4gICAgcHVibGljIHBhcnNlRGF0ZSh2YWw6IHN0cmluZyk6IERhdGUgfCBudWxsIHtcbiAgICBpZiAoIXZhbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5wYXJzZVZhbHVlRnJvbU1hc2sodmFsLCB0aGlzLl9pbnB1dERhdGVQYXJ0cywgdGhpcy5wcm9tcHRDaGFyKTtcbiAgfVxuXG4gIHByaXZhdGUgbW92ZUN1cnNvcihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHZhbHVlID0gKGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBLRVlTLkxFRlRfQVJST1c6XG4gICAgICBjYXNlIEtFWVMuTEVGVF9BUlJPV19JRTpcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5nZXROZXdQb3NpdGlvbih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlTLlJJR0hUX0FSUk9XOlxuICAgICAgY2FzZSBLRVlTLlJJR0hUX0FSUk9XX0lFOlxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmdldE5ld1Bvc2l0aW9uKHZhbHVlLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGN1cnNvciBpbiBhIHNwZWNpZmljIGRpcmVjdGlvbiB1bnRpbCBpdCByZWFjaGVzIGEgZGF0ZS90aW1lIHNlcGFyYXRvci5cbiAgICogVGhlbiByZXR1cm4gaXRzIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyBpdCBvcGVyYXRlcyBvbi5cbiAgICogQHBhcmFtIGRpcmVjdGlvbiAwIGlzIGxlZnQsIDEgaXMgcmlnaHQuIERlZmF1bHQgaXMgMC5cbiAgICovXG4gIHByaXZhdGUgZ2V0TmV3UG9zaXRpb24odmFsdWU6IHN0cmluZywgZGlyZWN0aW9uID0gMCk6IG51bWJlciB7XG4gICAgY29uc3QgbGl0ZXJhbHMgPSB0aGlzLl9pbnB1dERhdGVQYXJ0cy5maWx0ZXIocCA9PiBwLnR5cGUgPT09IERhdGVQYXJ0LkxpdGVyYWwpO1xuICAgIGxldCBjdXJzb3JQb3MgPSB0aGlzLnNlbGVjdGlvblN0YXJ0O1xuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGN1cnNvclBvcyA9IGN1cnNvclBvcyA+IDAgPyAtLWN1cnNvclBvcyA6IGN1cnNvclBvcztcbiAgICAgIH0gd2hpbGUgKCFsaXRlcmFscy5zb21lKGwgPT4gbC5lbmQgPT09IGN1cnNvclBvcykgJiYgY3Vyc29yUG9zID4gMCk7XG4gICAgICByZXR1cm4gY3Vyc29yUG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBkbyB7XG4gICAgICAgIGN1cnNvclBvcysrO1xuICAgICAgfSB3aGlsZSAoIWxpdGVyYWxzLnNvbWUobCA9PiBsLnN0YXJ0ID09PSBjdXJzb3JQb3MpICYmIGN1cnNvclBvcyA8IHZhbHVlLmxlbmd0aCk7XG4gICAgICByZXR1cm4gY3Vyc29yUG9zO1xuICAgIH1cbiAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtJZ3hEYXRlVGltZUVkaXRvckRpcmVjdGl2ZV0sXG4gIGV4cG9ydHM6IFtJZ3hEYXRlVGltZUVkaXRvckRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4RGF0ZVRpbWVFZGl0b3JNb2R1bGUgeyB9XG4iXX0=