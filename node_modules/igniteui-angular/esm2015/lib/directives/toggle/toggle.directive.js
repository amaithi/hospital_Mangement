import { __decorate, __param } from "tslib";
import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, OnDestroy, OnInit, Optional, Output, Inject } from '@angular/core';
import { IgxNavigationService, IToggleView } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { AbsoluteScrollStrategy, ConnectedPositioningStrategy } from '../../services/public_api';
import { filter, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
let IgxToggleDirective = class IgxToggleDirective {
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        this._collapsed = true;
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onAppended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.onAppended = new EventEmitter();
        this.overlayClosed = () => {
            this._collapsed = true;
            this.cdr.detectChanges();
            delete this._overlayId;
            this.unsubscribe();
            this.onClosed.emit();
        };
    }
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        const openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.unsubscribe();
        this._overlayAppendedSub = this.overlayService.onAppended.pipe(...this._overlaySubFilter).subscribe(() => {
            this.onAppended.emit();
        });
        this._overlayOpenedSub = this.overlayService.onOpened.pipe(...this._overlaySubFilter).subscribe(() => {
            this.onOpened.emit();
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const eventArgs = { cancel: false, event: e.event };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close() {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer : false;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX, deltaY) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
};
IgxToggleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    Output()
], IgxToggleDirective.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onOpening", void 0);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onClosed", void 0);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onClosing", void 0);
__decorate([
    Input()
], IgxToggleDirective.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-toggle--hidden'),
    HostBinding('attr.aria-hidden')
], IgxToggleDirective.prototype, "hiddenClass", null);
__decorate([
    HostBinding('class.igx-toggle')
], IgxToggleDirective.prototype, "defaultClass", null);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onAppended", void 0);
IgxToggleDirective = __decorate([
    Directive({
        exportAs: 'toggle',
        selector: '[igxToggle]'
    }),
    __param(2, Inject(IgxOverlayService)),
    __param(3, Optional())
], IgxToggleDirective);
export { IgxToggleDirective };
let IgxToggleActionDirective = class IgxToggleActionDirective {
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludePositionTarget: true
        };
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
};
IgxToggleActionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    Input()
], IgxToggleActionDirective.prototype, "overlaySettings", void 0);
__decorate([
    Input('igxToggleOutlet')
], IgxToggleActionDirective.prototype, "outlet", void 0);
__decorate([
    Input('igxToggleAction')
], IgxToggleActionDirective.prototype, "target", null);
__decorate([
    HostListener('click')
], IgxToggleActionDirective.prototype, "onClick", null);
IgxToggleActionDirective = __decorate([
    Directive({
        exportAs: 'toggle-action',
        selector: '[igxToggleAction]'
    }),
    __param(1, Optional())
], IgxToggleActionDirective);
export { IgxToggleActionDirective };
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
let IgxOverlayOutletDirective = class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
};
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: ElementRef }
];
IgxOverlayOutletDirective = __decorate([
    Directive({
        exportAs: 'overlay-outlet',
        selector: '[igxOverlayOutlet]'
    })
], IgxOverlayOutletDirective);
export { IgxOverlayOutletDirective };
/**
 * @hidden
 */
let IgxToggleModule = class IgxToggleModule {
};
IgxToggleModule = __decorate([
    NgModule({
        declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
        exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
        providers: [IgxNavigationService]
    })
], IgxToggleModule);
export { IgxToggleModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNILGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLEVBQ1IsU0FBUyxFQUNULE1BQU0sRUFDTixRQUFRLEVBQ1IsTUFBTSxFQUNOLE1BQU0sRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsV0FBVyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDbkUsT0FBTyxFQUNILHNCQUFzQixFQUN0Qiw0QkFBNEIsRUFJL0IsTUFBTSwyQkFBMkIsQ0FBQztBQUNuQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ25ELE9BQU8sRUFBZ0IsT0FBTyxFQUE0QixNQUFNLE1BQU0sQ0FBQztBQVF2RSxJQUFhLGtCQUFrQixHQUEvQixNQUFhLGtCQUFrQjtJQWtJM0I7O09BRUc7SUFDSCxZQUNZLFVBQXNCLEVBQ3RCLEdBQXNCLEVBQ08sY0FBaUMsRUFDbEQsaUJBQXVDO1FBSG5ELGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDTyxtQkFBYyxHQUFkLGNBQWMsQ0FBbUI7UUFDbEQsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFzQjtRQXZJdkQsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFDbEMsc0JBQWlCLEdBQTZGO1lBQ2xILE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtB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Q0FBQztHQUNXLHlCQUF5QixDQU9yQztTQVBZLHlCQUF5QjtBQVN0Qzs7R0FFRztBQU1ILElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWU7Q0FBSSxDQUFBO0FBQW5CLGVBQWU7SUFMM0IsUUFBUSxDQUFDO1FBQ04sWUFBWSxFQUFFLENBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUUseUJBQXlCLENBQUM7UUFDdkYsT0FBTyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUUseUJBQXlCLENBQUM7UUFDbEYsU0FBUyxFQUFFLENBQUMsb0JBQW9CLENBQUM7S0FDcEMsQ0FBQztHQUNXLGVBQWUsQ0FBSTtTQUFuQixlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIEluamVjdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uLy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBJZ3hPdmVybGF5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvb3ZlcmxheSc7XG5pbXBvcnQge1xuICAgIEFic29sdXRlU2Nyb2xsU3RyYXRlZ3ksXG4gICAgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSxcbiAgICBJUG9zaXRpb25TdHJhdGVneSxcbiAgICBPdmVybGF5RXZlbnRBcmdzLFxuICAgIE92ZXJsYXlTZXR0aW5nc1xufSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wdWJsaWNfYXBpJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBTdWJqZWN0LCBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE92ZXJsYXlDbG9zaW5nRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS91dGlsaXRpZXMnO1xuaW1wb3J0IHsgQ2FuY2VsYWJsZUV2ZW50QXJncywgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MsIElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAndG9nZ2xlJyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hUb2dnbGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hUb2dnbGVEaXJlY3RpdmUgaW1wbGVtZW50cyBJVG9nZ2xlVmlldywgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHByb3RlY3RlZCBfb3ZlcmxheUlkOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheVN1YkZpbHRlcjogW01vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxPdmVybGF5RXZlbnRBcmdzPiwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPE92ZXJsYXlFdmVudEFyZ3M+XSA9IFtcbiAgICAgICAgZmlsdGVyKHggPT4geC5pZCA9PT0gdGhpcy5fb3ZlcmxheUlkKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgXTtcbiAgICBwcml2YXRlIF9vdmVybGF5T3BlbmVkU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NpbmdTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9vdmVybGF5Q2xvc2VkU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUFwcGVuZGVkU3ViOiBTdWJzY3JpcHRpb247XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVPcGVuZWQoZXZlbnQpIHtcbiAgICAgKiAgICBhbGVydChcIlRvZ2dsZSBvcGVuZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChvbk9wZW5lZCk9J29uVG9nZ2xlT3BlbmVkKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbk9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGJlZm9yZSB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVPcGVuaW5nKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIG9wZW5pbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChvbk9wZW5pbmcpPSdvblRvZ2dsZU9wZW5pbmcoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uT3BlbmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8Q2FuY2VsYWJsZUV2ZW50QXJncyAmIElCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlQ2xvc2VkKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIGNsb3NlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uQ2xvc2VkKT0nb25Ub2dnbGVDbG9zZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NpbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2luZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgaWd4VG9nZ2xlXG4gICAgICogIChvbkNsb3NpbmcpPSdvblRvZ2dsZUNsb3NpbmcoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uQ2xvc2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8Q2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgJiBJQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIHByaXZhdGUgX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXIgd2hpY2ggaXMgcmVnaXN0ZXJlZCBpbnRvIGBJZ3hOYXZpZ2F0aW9uU2VydmljZWBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbXlUb2dnbGVJZCA9IHRoaXMudG9nZ2xlLmlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBlbGVtZW50KCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10b2dnbGUtLWhpZGRlbicpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtaGlkZGVuJylcbiAgICBwdWJsaWMgZ2V0IGhpZGRlbkNsYXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRvZ2dsZScpXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgQEluamVjdChJZ3hPdmVybGF5U2VydmljZSkgcHJvdGVjdGVkIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZSxcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTogSWd4TmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhZnRlciB0aGUgdG9nZ2xlIGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIG92ZXJsYXkgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQXBwZW5kZWQoKSB7XG4gICAgICogIGFsZXJ0KFwiQ29udGVudCBhcHBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgIGlneFRvZ2dsZVxuICAgICAqICAgKG9uQXBwZW5kZWQpPSdvblRvZ2dsZUFwcGVuZGVkKCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkFwcGVuZGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRvZ2dsZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLm9wZW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgb3BlbihvdmVybGF5U2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpIHtcbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG9wZW4gYW5pbWF0aW9uIGRvIG5vdGhpbmdcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBub3QgY29sbGFwc2VkIGFuZCB0aGVyZSBpcyBubyBjbG9zZSBhbmltYXRpb24gZG8gbm90aGluZ1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBoYXNPcGVuQW5pbWF0aW9uID0gaW5mbyA/IGluZm8ub3BlbkFuaW1hdGlvblBsYXllciA6IGZhbHNlO1xuICAgICAgICBjb25zdCBoYXNDbG9zZUFuaW1hdGlvbiA9IGluZm8gPyBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyIDogZmFsc2U7XG4gICAgICAgIGlmIChoYXNPcGVuQW5pbWF0aW9uIHx8ICEodGhpcy5fY29sbGFwc2VkIHx8IGhhc0Nsb3NlQW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5SWQgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmF0dGFjaCh0aGlzLmVsZW1lbnRSZWYsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICAgIGNvbnN0IG9wZW5FdmVudEFyZ3M6IENhbmNlbGFibGVFdmVudEFyZ3MgPSB7IGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5vbk9wZW5pbmcuZW1pdChvcGVuRXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKG9wZW5FdmVudEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuXG4gICAgICAgIHRoaXMuX292ZXJsYXlBcHBlbmRlZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2Uub25BcHBlbmRlZC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQXBwZW5kZWQuZW1pdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5T3BlbmVkU3ViID0gdGhpcy5vdmVybGF5U2VydmljZS5vbk9wZW5lZC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uT3BlbmVkLmVtaXQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheUNsb3NpbmdTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlXG4gICAgICAgIC5vbkNsb3NpbmdcbiAgICAgICAgLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlcilcbiAgICAgICAgLnN1YnNjcmliZSgoZTogT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50QXJnczogQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgPSB7IGNhbmNlbDogZmFsc2UsIGV2ZW50OiBlLmV2ZW50IH07XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2luZy5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgICAgICBlLmNhbmNlbCA9IGV2ZW50QXJncy5jYW5jZWw7XG5cbiAgICAgICAgICAgIC8vICBpbiBjYXNlIGV2ZW50IGlzIG5vdCBjYW5jZWxlZCB0aGlzIHdpbGwgY2xvc2UgdGhlIHRvZ2dsZSBhbmQgd2UgbmVlZCB0byB1bnN1YnNjcmliZS5cbiAgICAgICAgICAgIC8vICBPdGhlcndpc2UgaWYgZm9yIHNvbWUgcmVhc29uLCBlLmcuIGNsb3NlIG9uIG91dHNpZGUgY2xpY2ssIGNsb3NlKCkgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gICAgICAgICAgICAvLyAgb25DbG9zZWQgd2FzIGZpcmVkIHdlIHdpbGwgZW5kIHdpdGggY2FsbGluZyBvbkNsb3NpbmcgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgIGlmICghZS5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheUNsb3NlZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2Uub25DbG9zZWRcbiAgICAgICAgLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlcilcbiAgICAgICAgLnN1YnNjcmliZSh0aGlzLm92ZXJsYXlDbG9zZWQpO1xuXG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2Uuc2hvdyh0aGlzLl9vdmVybGF5SWQsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpIHtcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBjb2xsYXBzZWQgZG8gbm90aGluZ1xuICAgICAgICAvLyAgaWYgdGhlcmUgaXMgY2xvc2UgYW5pbWF0aW9uIGRvIG5vdGhpbmcsIHRvZ2dsZSB3aWxsIGNsb3NlIGFueXdheVxuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBoYXNDbG9zZUFuaW1hdGlvbiA9IGluZm8gPyBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jb2xsYXBzZWQgfHwgaGFzQ2xvc2VBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuaGlkZSh0aGlzLl9vdmVybGF5SWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9nZ2xlLCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKG92ZXJsYXlTZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncykge1xuICAgICAgICAvLyAgaWYgdG9nZ2xlIGlzIGNvbGxhcHNlZCBjYWxsIG9wZW5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIGNsb3NlIGFuaW1hdGlvbiBjYWxsIG9wZW5cbiAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkIHx8IHRoaXMuaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4ob3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgaXNDbG9zaW5nKCkge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICByZXR1cm4gaW5mbyA/IGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9ucyB0aGUgdG9nZ2xlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnJlcG9zaXRpb24oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVwb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5yZXBvc2l0aW9uKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2Zmc2V0cyB0aGUgY29udGVudCBhbG9uZyB0aGUgY29ycmVzcG9uZGluZyBheGlzIGJ5IHRoZSBwcm92aWRlZCBhbW91bnRcbiAgICAgKi9cbiAgICBzZXRPZmZzZXQoZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2Uuc2V0T2Zmc2V0KHRoaXMuX292ZXJsYXlJZCwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlICYmIHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuYWRkKHRoaXMuaWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5yZW1vdmUodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvbGxhcHNlZCAmJiB0aGlzLl9vdmVybGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuaGlkZSh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvdmVybGF5Q2xvc2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vdmVybGF5SWQ7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlZC5lbWl0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5T3BlbmVkU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2luZ1N1Yik7XG4gICAgICAgIHRoaXMuY2xlYXJTdWJzY3JpcHRpb24odGhpcy5fb3ZlcmxheUNsb3NlZFN1Yik7XG4gICAgICAgIHRoaXMuY2xlYXJTdWJzY3JpcHRpb24odGhpcy5fb3ZlcmxheUFwcGVuZGVkU3ViKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZS1hY3Rpb24nLFxuICAgIHNlbGVjdG9yOiAnW2lneFRvZ2dsZUFjdGlvbl0nXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvdGVjdGVkIF9vdmVybGF5RGVmYXVsdHM6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIHRoZSB0b2dnbGUgb3ZlcmxheSBwb3NpdGlvbmluZywgaW50ZXJhY3Rpb24gYW5kIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgKiAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICAgICAqICAgICAgbW9kYWw6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBgYGBcbiAgICAgKiAtLS1cbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtvdmVybGF5U2V0dGluZ3NdPVwic2V0dGluZ3NcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBvdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hlcmUgdGhlIHRvZ2dsZSBlbGVtZW50IG92ZXJsYXkgc2hvdWxkIGJlIGF0dGFjaGVkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbaWd4VG9nZ2xlT3V0bGV0XT1cIm91dGxldFwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIFdoZXJlIGBvdXRsZXRgIGluIGFuIGluc3RhbmNlIG9mIGBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlYCBvciBhbiBgRWxlbWVudFJlZmBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneFRvZ2dsZU91dGxldCcpXG4gICAgcHVibGljIG91dGxldDogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB8IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUb2dnbGVBY3Rpb24nKVxuICAgIHNldCB0YXJnZXQodGFyZ2V0OiBhbnkpIHtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpOiBhbnkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3RhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmdldCh0aGlzLl90YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IElUb2dnbGVWaWV3IHwgc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBAT3B0aW9uYWwoKSBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5RGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBuZXcgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSh7IHRhcmdldDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgfSksXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogbmV3IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3koKSxcbiAgICAgICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBtb2RhbDogZmFsc2UsXG4gICAgICAgICAgICBleGNsdWRlUG9zaXRpb25UYXJnZXQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIHB1YmxpYyBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRsZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlEZWZhdWx0cy5vdXRsZXQgPSB0aGlzLm91dGxldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb25lZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3ZlcmxheURlZmF1bHRzLCB0aGlzLm92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheVNldHRpbmdzKGNsb25lZFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy50YXJnZXQudG9nZ2xlKGNsb25lZFNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3Mgc2V0dGluZ3MgdG8gdXBkYXRlXG4gICAgICogQHJldHVybnMgcmV0dXJucyB1cGRhdGVkIGNvcHkgb2YgcHJvdmlkZWQgb3ZlcmxheSBzZXR0aW5nc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVPdmVybGF5U2V0dGluZ3Moc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyk6IE92ZXJsYXlTZXR0aW5ncyB7XG4gICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvblN0cmF0ZWd5Q2xvbmU6IElQb3NpdGlvblN0cmF0ZWd5ID0gc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5jbG9uZSgpO1xuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneUNsb25lLnNldHRpbmdzLnRhcmdldCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneSA9IHBvc2l0aW9uU3RyYXRlZ3lDbG9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG59XG5cbi8qKlxuICogTWFyayBhbiBlbGVtZW50IGFzIGFuIGlneE92ZXJsYXkgb3V0bGV0IGNvbnRhaW5lci5cbiAqIERpcmVjdGl2ZSBpbnN0YW5jZSBpcyBleHBvcnRlZCBhcyBgb3ZlcmxheS1vdXRsZXRgIHRvIGJlIGFzc2lnbmVkIHRvIHRlbXBsYXRlcyB2YXJpYWJsZXM6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IGlneE92ZXJsYXlPdXRsZXQgI291dGxldD1cIm92ZXJsYXktb3V0bGV0XCI+PC9kaXY+XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICdvdmVybGF5LW91dGxldCcsXG4gICAgc2VsZWN0b3I6ICdbaWd4T3ZlcmxheU91dGxldF0nXG59KVxuZXhwb3J0IGNsYXNzIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmKSB7IH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hUb2dnbGVEaXJlY3RpdmUsIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSwgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneFRvZ2dsZURpcmVjdGl2ZSwgSWd4VG9nZ2xlQWN0aW9uRGlyZWN0aXZlLCBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtJZ3hOYXZpZ2F0aW9uU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlTW9kdWxlIHsgfVxuIl19