import { __decorate, __param } from "tslib";
import { Pipe, Inject } from '@angular/core';
import { IGX_DATE_PICKER_COMPONENT } from './date-picker.common';
import { DatePickerUtil } from './date-picker.utils';
/**
 * @hidden
 */
let DatePickerDisplayValuePipe = class DatePickerDisplayValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimEmptyPlaceholders(value);
        }
        return '';
    }
};
DatePickerDisplayValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
DatePickerDisplayValuePipe = __decorate([
    Pipe({
        name: 'displayValue'
    }),
    __param(0, Inject(IGX_DATE_PICKER_COMPONENT))
], DatePickerDisplayValuePipe);
export { DatePickerDisplayValuePipe };
/**
 * @hidden
 */
let DatePickerInputValuePipe = class DatePickerInputValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        /**
         * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
         * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
         */
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return this._datePicker._getEditorDate(this._datePicker.value);
                // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    }
};
DatePickerInputValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
DatePickerInputValuePipe = __decorate([
    Pipe({
        name: 'inputValue'
    }),
    __param(0, Inject(IGX_DATE_PICKER_COMPONENT))
], DatePickerInputValuePipe);
export { DatePickerInputValuePipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIucGlwZXMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnBpcGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQWlCLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUQsT0FBTyxFQUFFLHlCQUF5QixFQUFlLE1BQU0sc0JBQXNCLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXJEOztHQUVHO0FBSUgsSUFBYSwwQkFBMEIsR0FBdkMsTUFBYSwwQkFBMEI7SUFDbkMsWUFBdUQsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFBSSxDQUFDO0lBQ3BGLFNBQVMsQ0FBQyxLQUFVLEVBQUUsSUFBVTtRQUM1QixJQUFJLEtBQUssS0FBSyxFQUFFLEVBQUU7WUFDZCxJQUFJLEtBQUssS0FBSyxjQUFjLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDeEUsT0FBTyxFQUFFLENBQUM7YUFDYjtZQUNELElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztZQUN2QyxPQUFPLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0RDtRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztDQUNKLENBQUE7OzRDQVhnQixNQUFNLFNBQUMseUJBQXlCOztBQURwQywwQkFBMEI7SUFIdEMsSUFBSSxDQUFDO1FBQ0YsSUFBSSxFQUFFLGNBQWM7S0FDdkIsQ0FBQztJQUVlLFdBQUEsTUFBTSxDQUFDLHlCQUF5QixDQUFDLENBQUE7R0FEckMsMEJBQTBCLENBWXRDO1NBWlksMEJBQTBCO0FBY3ZDOztHQUVHO0FBSUgsSUFBYSx3QkFBd0IsR0FBckMsTUFBYSx3QkFBd0I7SUFDakMsWUFBdUQsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7SUFBSSxDQUFDO0lBQ3BGLFNBQVMsQ0FBQyxLQUFVLEVBQUUsSUFBVTtRQUM1Qjs7O1dBR0c7UUFDSCxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxLQUFLLEVBQUUsRUFBRTtZQUNyQyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDO1NBQ3ZDO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7Z0JBQ3pFLE9BQU8sY0FBYyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDdkU7aUJBQU07Z0JBQ0gsT0FBUSxJQUFJLENBQUMsV0FBbUIsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDeEUsaUhBQWlIO2FBQ3BIO1NBQ0o7SUFDTCxDQUFDO0NBQ0osQ0FBQTs7NENBakJnQixNQUFNLFNBQUMseUJBQXlCOztBQURwQyx3QkFBd0I7SUFIcEMsSUFBSSxDQUFDO1FBQ0YsSUFBSSxFQUFFLFlBQVk7S0FDckIsQ0FBQztJQUVlLFdBQUEsTUFBTSxDQUFDLHlCQUF5QixDQUFDLENBQUE7R0FEckMsd0JBQXdCLENBa0JwQztTQWxCWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQaXBlVHJhbnNmb3JtLCBQaXBlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElHWF9EQVRFX1BJQ0tFUl9DT01QT05FTlQsIElEYXRlUGlja2VyIH0gZnJvbSAnLi9kYXRlLXBpY2tlci5jb21tb24nO1xuaW1wb3J0IHsgRGF0ZVBpY2tlclV0aWwgfSBmcm9tICcuL2RhdGUtcGlja2VyLnV0aWxzJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnZGlzcGxheVZhbHVlJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXRlUGlja2VyRGlzcGxheVZhbHVlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0RBVEVfUElDS0VSX0NPTVBPTkVOVCkgcHJpdmF0ZSBfZGF0ZVBpY2tlcjogSURhdGVQaWNrZXIpIHsgfVxuICAgIHRyYW5zZm9ybSh2YWx1ZTogYW55LCBhcmdzPzogYW55KTogYW55IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBEYXRlUGlja2VyVXRpbC5tYXNrVG9Qcm9tcHRDaGFycyh0aGlzLl9kYXRlUGlja2VyLmlucHV0TWFzaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kYXRlUGlja2VyLnJhd0RhdGVTdHJpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC50cmltRW1wdHlQbGFjZWhvbGRlcnModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2lucHV0VmFsdWUnXG59KVxuZXhwb3J0IGNsYXNzIERhdGVQaWNrZXJJbnB1dFZhbHVlUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0RBVEVfUElDS0VSX0NPTVBPTkVOVCkgcHJpdmF0ZSBfZGF0ZVBpY2tlcjogSURhdGVQaWNrZXIpIHsgfVxuICAgIHRyYW5zZm9ybSh2YWx1ZTogYW55LCBhcmdzPzogYW55KTogYW55IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE8oRC5QLik6IFRoaXMgcGx1Z3MgaW50byB0aGUgbWFzaywgYnV0IGNvbnN0YW50bHkgcmVjZWl2ZWQgZGlzcGxheSBzdHJpbmdzIGl0IGNhbid0IGhhbmRsZSBhdCBhbGxcbiAgICAgICAgICogVGhvc2UgYXJlIGFsbW9zdCBpbW1lZGlhdGVseSBvdmVycmlkZGVuIGJ5IHRoZSBwaWNrZXJzIG9uRm9jdXMgaGFuZGxpbmcgYW55d2F5OyBSZWZhY3RvciBBU0FQXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fZGF0ZVBpY2tlci5pbnZhbGlkRGF0ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlUGlja2VyLmludmFsaWREYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGVQaWNrZXIudmFsdWUgPT09IG51bGwgfHwgdGhpcy5fZGF0ZVBpY2tlci52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLm1hc2tUb1Byb21wdENoYXJzKHRoaXMuX2RhdGVQaWNrZXIuaW5wdXRNYXNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9kYXRlUGlja2VyIGFzIGFueSkuX2dldEVkaXRvckRhdGUodGhpcy5fZGF0ZVBpY2tlci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIERhdGVQaWNrZXJVdGlsLmFkZFByb21wdENoYXJzRWRpdE1vZGUodGhpcy5fZGF0ZVBpY2tlci5kYXRlRm9ybWF0UGFydHMsIHRoaXMuX2RhdGVQaWNrZXIudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==