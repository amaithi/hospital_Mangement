import { isIE } from '../core/utils';
import { DatePart } from '../directives/date-time-editor/date-time-editor.common';
const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
export class DatePickerUtil {
    /**
     *  TODO: Unit tests for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(this.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        if (parts[DatePart.Month] < 1 || 12 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] - 1 || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type: type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        let maxValue, minValue;
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        let changedPart;
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (this.isDate(value)) {
            return this.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (this.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (let i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue, minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (let i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1waWNrZXIudXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RhdGUtcGlja2VyL2RhdGUtcGlja2VyLnV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckMsT0FBTyxFQUFFLFFBQVEsRUFBZ0IsTUFBTSx3REFBd0QsQ0FBQztBQXlCaEcsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN2RCxNQUFNLFVBQVUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQVU3QyxjQUFjO0FBQ2QsTUFBTSxPQUFnQixjQUFjO0lBV2hDOztPQUVHO0lBSUg7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxTQUFpQixFQUFFLGFBQTZCLEVBQUUsVUFBbUI7UUFDbEcsTUFBTSxLQUFLLEdBQWtDLEVBQVMsQ0FBQztRQUN2RCxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ3ZCLElBQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDUixLQUFLLEdBQUcsRUFBRSxDQUFDLElBQUksS0FBSyxRQUFRLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDM0U7WUFDRCxLQUFLLENBQUMsRUFBRSxDQUFD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bkMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsR0FBRyxDQUFDLFVBQVUsRUFBRSxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUM7d0JBQ3JELFVBQVUsSUFBSSxDQUFDLENBQUM7d0JBQ2hCLE1BQU07cUJBQ1Q7b0JBQ0QsOEJBQXlCLENBQUMsQ0FBQzt3QkFDdkIsb0NBQW9DO3dCQUNwQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsVUFBVSxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQzt3QkFDckQsVUFBVSxJQUFJLENBQUMsQ0FBQzt3QkFDaEIsTUFBTTtxQkFDVDtpQkFDSjthQUNKO2lCQUFNLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsU0FBUyxFQUFFO2dCQUN2RCxzQkFBc0I7Z0JBQ3RCLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUNyRCxVQUFVLEVBQUUsQ0FBQzthQUNoQjtTQUNKO0lBQ0wsQ0FBQzs7QUF0MUJzQixtQ0FBb0IsR0FBRyxZQUFZLENBQUM7QUFDM0Qsc0ZBQXNGO0FBQzlELDhCQUFlLEdBQUcsVUFBVSxDQUFDO0FBQzdCLHdCQUFTLEdBQUcsU0FBUyxDQUFDO0FBQ3RCLCtCQUFnQixHQUFHLEVBQUUsQ0FBQztBQUN0QiwwQkFBVyxHQUFHLEdBQUcsQ0FBQztBQUNsQiw2QkFBYyxHQUFHLElBQUksQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzSUUgfSBmcm9tICcuLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IERhdGVQYXJ0LCBEYXRlUGFydEluZm8gfSBmcm9tICcuLi9kaXJlY3RpdmVzL2RhdGUtdGltZS1lZGl0b3IvZGF0ZS10aW1lLWVkaXRvci5jb21tb24nO1xuXG4vKipcbiAqIFRoaXMgZW51bSBpcyB1c2VkIHRvIGtlZXAgdGhlIGRhdGUgdmFsaWRhdGlvbiByZXN1bHQuXG4gKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZW51bSBEYXRlU3RhdGUge1xuICAgIFZhbGlkID0gJ3ZhbGlkJyxcbiAgICBJbnZhbGlkID0gJ2ludmFsaWQnLFxufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBGb3JtYXREZXNjIHtcbiAgICBOdW1lcmljID0gJ251bWVyaWMnLFxuICAgIFR3b0RpZ2l0cyA9ICcyLWRpZ2l0J1xufVxuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBEYXRlQ2hhcnMge1xuICAgIFllYXJDaGFyID0gJ3knLFxuICAgIE1vbnRoQ2hhciA9ICdNJyxcbiAgICBEYXlDaGFyID0gJ2QnXG59XG5cbmNvbnN0IERBVEVfQ0hBUlMgPSBbJ2gnLCAnSCcsICdtJywgJ3MnLCAnUycsICd0JywgJ1QnXTtcbmNvbnN0IFRJTUVfQ0hBUlMgPSBbJ2QnLCAnRCcsICdNJywgJ3knLCAnWSddO1xuXG4vKiogQGhpZGRlbiAqL1xuY29uc3QgZW51bSBEYXRlUGFydHMge1xuICAgIERheSA9ICdkYXknLFxuICAgIE1vbnRoID0gJ21vbnRoJyxcbiAgICBZZWFyID0gJ3llYXInXG59XG5cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRlUGlja2VyVXRpbCB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0lOUFVUX0ZPUk1BVCA9ICdNTS9kZC95eXl5JztcbiAgICAvLyBUT0RPOiB0aGlzIGlzIHRoZSBkZWYgbWFzayBmb3IgdGhlIGRhdGUtcGlja2VyLCBzaG91bGQgcmVtb3ZlIGl0IGR1cmluZyByZWZhY3RvcmluZ1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFNIT1JUX0RBVEVfTUFTSyA9ICdNTS9kZC95eSc7XG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU0VQQVJBVE9SID0gJ2xpdGVyYWwnO1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE5VTUJFUl9PRl9NT05USFMgPSAxMjtcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBQUk9NUFRfQ0hBUiA9ICdfJztcbiAgICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0xPQ0FMRSA9ICdlbic7XG5cblxuXG4gICAgLyoqXG4gICAgICogIFRPRE86IFVuaXQgdGVzdHMgZm9yIGFsbCBwdWJsaWMgbWV0aG9kcy5cbiAgICAgKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIERhdGUgdmFsdWUgZnJvbSBtYXNrZWQgc3RyaW5nIGlucHV0IGJhc2VkIG9uIGRldGVybWluZWQgZGF0ZSBwYXJ0c1xuICAgICAqIEBwYXJhbSBpbnB1dERhdGEgbWFza2VkIHZhbHVlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIGRhdGVUaW1lUGFydHMgRGF0ZSBwYXJ0cyBhcnJheSBmb3IgdGhlIG1hc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHBhcnNlVmFsdWVGcm9tTWFzayhpbnB1dERhdGE6IHN0cmluZywgZGF0ZVRpbWVQYXJ0czogRGF0ZVBhcnRJbmZvW10sIHByb21wdENoYXI/OiBzdHJpbmcpOiBEYXRlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHBhcnRzOiB7IFtrZXkgaW4gRGF0ZVBhcnRdOiBudW1iZXIgfSA9IHt9IGFzIGFueTtcbiAgICAgICAgZGF0ZVRpbWVQYXJ0cy5mb3JFYWNoKGRwID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlSW50KHRoaXMuZ2V0Q2xlYW5WYWwoaW5wdXREYXRhLCBkcCwgcHJvbXB0Q2hhciksIDEwKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRwLnR5cGUgPT09IERhdGVQYXJ0LkRhdGUgfHwgZHAudHlwZSA9PT0gRGF0ZVBhcnQuTW9udGggPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRzW2RwLnR5cGVdID0gdmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5Nb250aF0gPCAxIHx8IDEyIDwgcGFydHNbRGF0ZVBhcnQuTW9udGhdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IENlbnR1cnkgdGhyZXNob2xkXG4gICAgICAgIGlmIChwYXJ0c1tEYXRlUGFydC5ZZWFyXSA8IDUwKSB7XG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5ZZWFyXSArPSAyMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkRhdGVdID4gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgocGFydHNbRGF0ZVBhcnQuWWVhcl0sIHBhcnRzW0RhdGVQYXJ0Lk1vbnRoXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSA+IDIzIHx8IHBhcnRzW0RhdGVQYXJ0Lk1pbnV0ZXNdID4gNTkgfHwgcGFydHNbRGF0ZVBhcnQuU2Vjb25kc10gPiA1OSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICBwYXJ0c1tEYXRlUGFydC5ZZWFyXSB8fCAyMDAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuTW9udGhdIC0gMSB8fCAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuRGF0ZV0gfHwgMSxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LkhvdXJzXSB8fCAwLFxuICAgICAgICAgICAgcGFydHNbRGF0ZVBhcnQuTWludXRlc10gfHwgMCxcbiAgICAgICAgICAgIHBhcnRzW0RhdGVQYXJ0LlNlY29uZHNdIHx8IDBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgbWFzayBpbnRvIGRhdGUvdGltZSBhbmQgbGl0ZXJhbCBwYXJ0c1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlVGltZUZvcm1hdChtYXNrOiBzdHJpbmcsIGxvY2FsZTogc3RyaW5nID0gRGF0ZVBpY2tlclV0aWwuREVGQVVMVF9MT0NBTEUpOiBEYXRlUGFydEluZm9bXSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IG1hc2sgfHwgRGF0ZVBpY2tlclV0aWwuZ2V0RGVmYXVsdElucHV0Rm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGRhdGVUaW1lUGFydHM6IERhdGVQYXJ0SW5mb1tdID0gW107XG4gICAgICAgIGNvbnN0IGZvcm1hdEFycmF5ID0gQXJyYXkuZnJvbShmb3JtYXQpO1xuICAgICAgICBsZXQgY3VycmVudFBhcnQ6IERhdGVQYXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRBcnJheS5sZW5ndGg7IGkrKywgcG9zaXRpb24rKykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IERhdGVQaWNrZXJVdGlsLmRldGVybWluZURhdGVQYXJ0KGZvcm1hdEFycmF5W2ldKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydC50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJ0LmZvcm1hdCArPSBmb3JtYXRBcnJheVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBmb3JtYXRBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIERhdGVQaWNrZXJVdGlsLmVuc3VyZUxlYWRpbmdaZXJvKGN1cnJlbnRQYXJ0KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFydC5lbmQgPSBjdXJyZW50UGFydC5zdGFydCArIGN1cnJlbnRQYXJ0LmZvcm1hdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBjdXJyZW50UGFydC5lbmQ7XG4gICAgICAgICAgICAgICAgZGF0ZVRpbWVQYXJ0cy5wdXNoKGN1cnJlbnRQYXJ0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFBhcnQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGVuZDogcG9zaXRpb24gKyBmb3JtYXRBcnJheVtpXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdEFycmF5W2ldXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGVUaW1lUGFydHM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXREZWZhdWx0SW5wdXRGb3JtYXQobG9jYWxlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIUludGwgfHwgIUludGwuRGF0ZVRpbWVGb3JtYXQgfHwgIUludGwuRGF0ZVRpbWVGb3JtYXQucHJvdG90eXBlLmZvcm1hdFRvUGFydHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGZhbGxiYWNrIHdpdGggSW50bC5mb3JtYXQgZm9yIElFP1xuICAgICAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLlNIT1JUX0RBVEVfTUFTSztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IERhdGVQaWNrZXJVdGlsLmdldERlZmF1bHRMb2NhbGVNYXNrKGxvY2FsZSk7XG4gICAgICAgIHBhcnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICBpZiAocC50eXBlICE9PSBEYXRlUGFydC5ZZWFyICYmIHAudHlwZSAhPT0gRGF0ZVBpY2tlclV0aWwuU0VQQVJBVE9SKSB7XG4gICAgICAgICAgICAgICAgcC5mb3JtYXRUeXBlID0gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5nZXRNYXNrKHBhcnRzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGlzRGF0ZU9yVGltZUNoYXIoY2hhcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBEQVRFX0NIQVJTLmluZGV4T2YoY2hhcikgIT09IC0xIHx8IFRJTUVfQ0hBUlMuaW5kZXhPZihjaGFyKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluRGF0ZShkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heERhdGUgPSBEYXRlUGlja2VyVXRpbC5kYXlzSW5Nb250aChuZXdEYXRlLmdldEZ1bGxZZWFyKCksIG5ld0RhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgIGxldCBkYXRlID0gbmV3RGF0ZS5nZXREYXRlKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKGRhdGUgPiBtYXhEYXRlKSB7XG4gICAgICAgICAgICBkYXRlID0gaXNTcGluTG9vcCA/IGRhdGUgJSBtYXhEYXRlIDogbWF4RGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRlIDwgMSkge1xuICAgICAgICAgICAgZGF0ZSA9IGlzU3Bpbkxvb3AgPyBtYXhEYXRlICsgKGRhdGUgJSBtYXhEYXRlKSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldERhdGUoZGF0ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluTW9udGgoZGVsdGE6IG51bWJlciwgbmV3RGF0ZTogRGF0ZSwgaXNTcGluTG9vcDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBtYXhEYXRlID0gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgobmV3RGF0ZS5nZXRGdWxsWWVhcigpLCBuZXdEYXRlLmdldE1vbnRoKCkgKyBkZWx0YSk7XG4gICAgICAgIGlmIChuZXdEYXRlLmdldERhdGUoKSA+IG1heERhdGUpIHtcbiAgICAgICAgICAgIG5ld0RhdGUuc2V0RGF0ZShtYXhEYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1heE1vbnRoID0gMTE7XG4gICAgICAgIGNvbnN0IG1pbk1vbnRoID0gMDtcbiAgICAgICAgbGV0IG1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpICsgZGVsdGE7XG4gICAgICAgIGlmIChtb250aCA+IG1heE1vbnRoKSB7XG4gICAgICAgICAgICBtb250aCA9IGlzU3Bpbkxvb3AgPyAobW9udGggJSBtYXhNb250aCkgLSAxIDogbWF4TW9udGg7XG4gICAgICAgIH0gZWxzZSBpZiAobW9udGggPCBtaW5Nb250aCkge1xuICAgICAgICAgICAgbW9udGggPSBpc1NwaW5Mb29wID8gbWF4TW9udGggKyAobW9udGggJSBtYXhNb250aCkgKyAxIDogbWluTW9udGg7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdEYXRlLnNldE1vbnRoKG1vbnRoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5ZZWFyKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4RGF0ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIGRlbHRhLCBuZXdEYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICBpZiAobmV3RGF0ZS5nZXREYXRlKCkgPiBtYXhEYXRlKSB7XG4gICAgICAgICAgICAvLyBjbGlwIHRvIG1heCB0byBhdm9pZCBsZWFwIHllYXIgY2hhbmdlIHNoaWZ0aW5nIHRoZSBlbnRpcmUgdmFsdWVcbiAgICAgICAgICAgIG5ld0RhdGUuc2V0RGF0ZShtYXhEYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIGRlbHRhKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5Ib3VycyhkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heEhvdXIgPSAyMztcbiAgICAgICAgY29uc3QgbWluSG91ciA9IDA7XG4gICAgICAgIGxldCBob3VycyA9IG5ld0RhdGUuZ2V0SG91cnMoKSArIGRlbHRhO1xuICAgICAgICBpZiAoaG91cnMgPiBtYXhIb3VyKSB7XG4gICAgICAgICAgICBob3VycyA9IGlzU3Bpbkxvb3AgPyBob3VycyAlIG1heEhvdXIgLSAxIDogbWF4SG91cjtcbiAgICAgICAgfSBlbHNlIGlmIChob3VycyA8IG1pbkhvdXIpIHtcbiAgICAgICAgICAgIGhvdXJzID0gaXNTcGluTG9vcCA/IG1heEhvdXIgKyAoaG91cnMgJSBtYXhIb3VyKSArIDEgOiBtaW5Ib3VyO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRIb3Vycyhob3Vycyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBzcGluTWludXRlcyhkZWx0YTogbnVtYmVyLCBuZXdEYXRlOiBEYXRlLCBpc1NwaW5Mb29wOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1heE1pbnV0ZXMgPSA1OTtcbiAgICAgICAgY29uc3QgbWluTWludXRlcyA9IDA7XG4gICAgICAgIGxldCBtaW51dGVzID0gbmV3RGF0ZS5nZXRNaW51dGVzKCkgKyBkZWx0YTtcbiAgICAgICAgaWYgKG1pbnV0ZXMgPiBtYXhNaW51dGVzKSB7XG4gICAgICAgICAgICBtaW51dGVzID0gaXNTcGluTG9vcCA/IG1pbnV0ZXMgJSBtYXhNaW51dGVzIC0gMSA6IG1heE1pbnV0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAobWludXRlcyA8IG1pbk1pbnV0ZXMpIHtcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBpc1NwaW5Mb29wID8gbWF4TWludXRlcyArIChtaW51dGVzICUgbWF4TWludXRlcykgKyAxIDogbWluTWludXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld0RhdGUuc2V0TWludXRlcyhtaW51dGVzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHNwaW5TZWNvbmRzKGRlbHRhOiBudW1iZXIsIG5ld0RhdGU6IERhdGUsIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbWF4U2Vjb25kcyA9IDU5O1xuICAgICAgICBjb25zdCBtaW5TZWNvbmRzID0gMDtcbiAgICAgICAgbGV0IHNlY29uZHMgPSBuZXdEYXRlLmdldFNlY29uZHMoKSArIGRlbHRhO1xuICAgICAgICBpZiAoc2Vjb25kcyA+IG1heFNlY29uZHMpIHtcbiAgICAgICAgICAgIHNlY29uZHMgPSBpc1NwaW5Mb29wID8gc2Vjb25kcyAlIG1heFNlY29uZHMgLSAxIDogbWF4U2Vjb25kcztcbiAgICAgICAgfSBlbHNlIGlmIChzZWNvbmRzIDwgbWluU2Vjb25kcykge1xuICAgICAgICAgICAgc2Vjb25kcyA9IGlzU3Bpbkxvb3AgPyBtYXhTZWNvbmRzICsgKHNlY29uZHMgJSBtYXhTZWNvbmRzKSArIDEgOiBtaW5TZWNvbmRzO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RGF0ZS5zZXRTZWNvbmRzKHNlY29uZHMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgc3BpbkFtUG0obmV3RGF0ZTogRGF0ZSwgY3VycmVudERhdGU6IERhdGUsIGFtUG1Gcm9tTWFzazogc3RyaW5nKTogRGF0ZSB7XG4gICAgICAgIHN3aXRjaCAoYW1QbUZyb21NYXNrKSB7XG4gICAgICAgICAgICBjYXNlICdBTSc6XG4gICAgICAgICAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKG5ld0RhdGUuc2V0SG91cnMobmV3RGF0ZS5nZXRIb3VycygpICsgMTIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BNJzpcbiAgICAgICAgICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUobmV3RGF0ZS5zZXRIb3VycyhuZXdEYXRlLmdldEhvdXJzKCkgLSAxMikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdEYXRlLmdldERhdGUoKSAhPT0gY3VycmVudERhdGUuZ2V0RGF0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3RGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcHJvdmlkZWQgbWF4IHZhbHVlLlxuICAgICAqIEBwYXJhbSBpbmNsdWRlVGltZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aW1lIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEBwYXJhbSBpbmNsdWRlRGF0ZSBzZXQgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gZXhjbHVkZSB0aGUgZGF0ZSBwb3J0aW9uIG9mIHRoZSB0d28gZGF0ZXNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBwcm92aWRlZCBtYXhWYWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ3JlYXRlclRoYW5NYXhWYWx1ZSh2YWx1ZTogRGF0ZSwgbWF4VmFsdWU6IERhdGUsIGluY2x1ZGVUaW1lID0gdHJ1ZSwgaW5jbHVkZURhdGUgPSB0cnVlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHByb3ZpZGVkIGRhdGVzIGFyZSB2YWxpZCBkYXRlcyBhbmQgbm90IEludmFsaWQgRGF0ZVxuICAgICAgICAvLyBpZiBtYXhWYWx1ZSBpcyBJbnZhbGlkIERhdGUgYW5kIHZhbHVlIGlzIHZhbGlkIGRhdGUgdGhpcyB3aWxsIHJldHVybjpcbiAgICAgICAgLy8gLSBmYWxzZSBpZiBpbmNsdWRlRGF0ZSBpcyB0cnVlXG4gICAgICAgIC8vIC0gdHJ1ZSBpZiBpbmNsdWRlRGF0ZSBpcyBmYWxzZVxuICAgICAgICBpZiAoaW5jbHVkZVRpbWUgJiYgaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCkgPiBtYXhWYWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBjb25zdCBfbWF4VmFsdWUgPSBuZXcgRGF0ZShtYXhWYWx1ZS5nZXRUaW1lKCkpO1xuICAgICAgICBpZiAoIWluY2x1ZGVUaW1lKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWF4VmFsdWUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgX3ZhbHVlLnNldEZ1bGxZZWFyKDAsIDAsIDApO1xuICAgICAgICAgICAgX21heFZhbHVlLnNldEZ1bGxZZWFyKDAsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF92YWx1ZS5nZXRUaW1lKCkgPiBfbWF4VmFsdWUuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBwcm92aWRlZCBtaW4gdmFsdWUuXG4gICAgICogQHBhcmFtIGluY2x1ZGVUaW1lIHNldCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBleGNsdWRlIHRpbWUgcG9ydGlvbiBvZiB0aGUgdHdvIGRhdGVzXG4gICAgICogQHBhcmFtIGluY2x1ZGVEYXRlIHNldCB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byBleGNsdWRlIHRoZSBkYXRlIHBvcnRpb24gb2YgdGhlIHR3byBkYXRlc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFsdWUgaXMgbGVzcyB0aGFuIHByb3ZpZGVkIG1pblZhbHVlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBsZXNzVGhhbk1pblZhbHVlKHZhbHVlOiBEYXRlLCBtaW5WYWx1ZTogRGF0ZSwgaW5jbHVkZVRpbWUgPSB0cnVlLCBpbmNsdWRlRGF0ZSA9IHRydWUpOiBib29sZWFuIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgaWYgcHJvdmlkZWQgZGF0ZXMgYXJlIHZhbGlkIGRhdGVzIGFuZCBub3QgSW52YWxpZCBEYXRlXG4gICAgICAgIC8vIGlmIHZhbHVlIGlzIEludmFsaWQgRGF0ZSBhbmQgbWluVmFsdWUgaXMgdmFsaWQgZGF0ZSB0aGlzIHdpbGwgcmV0dXJuOlxuICAgICAgICAvLyAtIGZhbHNlIGlmIGluY2x1ZGVEYXRlIGlzIHRydWVcbiAgICAgICAgLy8gLSB0cnVlIGlmIGluY2x1ZGVEYXRlIGlzIGZhbHNlXG4gICAgICAgIGlmIChpbmNsdWRlVGltZSAmJiBpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKSA8IG1pblZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF92YWx1ZSA9IG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNvbnN0IF9taW5WYWx1ZSA9IG5ldyBEYXRlKG1pblZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGlmICghaW5jbHVkZVRpbWUpIHtcbiAgICAgICAgICAgIF92YWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIF9taW5WYWx1ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICBfdmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgICAgICBfbWluVmFsdWUuc2V0RnVsbFllYXIoMCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3ZhbHVlLmdldFRpbWUoKSA8IF9taW5WYWx1ZS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZW5zdXJlTGVhZGluZ1plcm8ocGFydDogRGF0ZVBhcnRJbmZvKSB7XG4gICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0LkRhdGU6XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0Lk1vbnRoOlxuICAgICAgICAgICAgY2FzZSBEYXRlUGFydC5Ib3VyczpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuTWludXRlczpcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnQuU2Vjb25kczpcbiAgICAgICAgICAgICAgICBpZiAocGFydC5mb3JtYXQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQuZm9ybWF0ID0gcGFydC5mb3JtYXQucmVwZWF0KDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldENsZWFuVmFsKGlucHV0RGF0YTogc3RyaW5nLCBkYXRlUGFydDogRGF0ZVBhcnRJbmZvLCBwcm9tcHRDaGFyPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyhpbnB1dERhdGEuc3Vic3RyaW5nKGRhdGVQYXJ0LnN0YXJ0LCBkYXRlUGFydC5lbmQpLCBwcm9tcHRDaGFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBkZXRlcm1pbmVEYXRlUGFydChjaGFyOiBzdHJpbmcpOiBEYXRlUGFydCB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuRGF0ZTtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5Nb250aDtcbiAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LlllYXI7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5Ib3VycztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5NaW51dGVzO1xuICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZVBhcnQuU2Vjb25kcztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVQYXJ0LkFtUG07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGFydC5MaXRlcmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGRhdGUgcGFydHMgc3RydWN0dXJlIGJhc2VkIG9uIGVkaXRvciBtYXNrIGFuZCBsb2NhbGUuXG4gICAgICogQHBhcmFtIG1hc2tWYWx1ZTogc3RyaW5nXG4gICAgICogQHBhcmFtIGxvY2FsZTogc3RyaW5nXG4gICAgICogQHJldHVybnMgYXJyYXkgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCBkYXRlIHBhcnRzIC0gdHlwZSwgcG9zaXRpb24sIGZvcm1hdFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlRm9ybWF0KG1hc2tWYWx1ZTogc3RyaW5nLCBsb2NhbGU6IHN0cmluZyA9IERhdGVQaWNrZXJVdGlsLkRFRkFVTFRfTE9DQUxFKTogYW55W10ge1xuICAgICAgICBsZXQgZGF0ZVN0cnVjdCA9IFtdO1xuICAgICAgICBpZiAobWFza1ZhbHVlID09PSB1bmRlZmluZWQgJiYgIWlzSUUoKSkge1xuICAgICAgICAgICAgZGF0ZVN0cnVjdCA9IERhdGVQaWNrZXJVdGlsLmdldERlZmF1bHRMb2NhbGVNYXNrKGxvY2FsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gKG1hc2tWYWx1ZSkgPyBtYXNrVmFsdWUgOiBEYXRlUGlja2VyVXRpbC5TSE9SVF9EQVRFX01BU0s7XG4gICAgICAgICAgICBjb25zdCBtYXNrQXJyYXkgPSBBcnJheS5mcm9tKG1hc2spO1xuICAgICAgICAgICAgY29uc3QgbW9udGhJbml0UG9zaXRpb24gPSBtYXNrLmluZGV4T2YoRGF0ZUNoYXJzLk1vbnRoQ2hhcik7XG4gICAgICAgICAgICBjb25zdCBkYXlJbml0UG9zaXRpb24gPSBtYXNrLmluZGV4T2YoRGF0ZUNoYXJzLkRheUNoYXIpO1xuICAgICAgICAgICAgY29uc3QgeWVhckluaXRQb3NpdGlvbiA9IG1hc2suaW5kZXhPZihEYXRlQ2hhcnMuWWVhckNoYXIpO1xuXG4gICAgICAgICAgICBpZiAoeWVhckluaXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGFydHMuWWVhcixcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFBvc2l0aW9uOiB5ZWFySW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBEYXRlUGlja2VyVXRpbC5nZXRZZWFyRm9ybWF0VHlwZShtYXNrKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobW9udGhJbml0UG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVN0cnVjdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRGF0ZVBhcnRzLk1vbnRoLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IG1vbnRoSW5pdFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlOiBEYXRlUGlja2VyVXRpbC5nZXRNb250aEZvcm1hdFR5cGUobWFzaylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRheUluaXRQb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGFydHMuRGF5LFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IGRheUluaXRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VHlwZTogRGF0ZVBpY2tlclV0aWwuZ2V0RGF5Rm9ybWF0VHlwZShtYXNrKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2tBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghRGF0ZVBpY2tlclV0aWwuaXNEYXRlQ2hhcihtYXNrQXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsUG9zaXRpb246IGksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFza0FycmF5W2ldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZVN0cnVjdC5zb3J0KChhLCBiKSA9PiBhLmluaXRpYWxQb3NpdGlvbiAtIGIuaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIERhdGVQaWNrZXJVdGlsLmZpbGxEYXRlUGFydHNQb3NpdGlvbnMoZGF0ZVN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTdHJ1Y3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGlucHV0IG1hc2sgYmFzZWQgb24gZGF0ZSBwYXJ0cy5cbiAgICAgKiBAcGFyYW0gZGF0ZVN0cnVjdCBhcnJheVxuICAgICAqIEByZXR1cm5zIGlucHV0IG1hc2tcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldElucHV0TWFzayhkYXRlU3RydWN0OiBhbnlbXSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGlucHV0TWFzayA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVTdHJ1Y3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIGlucHV0TWFzay5wdXNoKGRhdGVTdHJ1Y3RbaV0udmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5EYXkgfHwgZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuWWVhcikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0ZVN0cnVjdFtpXS5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5OdW1lcmljOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dE1hc2sucHVzaCgnMDAwMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRNYXNrLnB1c2goJzAwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRNYXNrLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBlZGl0b3IgbWFzay5cbiAgICAgKiBAcGFyYW0gZGF0ZVN0cnVjdFxuICAgICAqIEByZXR1cm5zIGVkaXRvciBtYXNrXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRNYXNrKGRhdGVTdHJ1Y3Q6IGFueVtdKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbWFzayA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVTdHJ1Y3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0ZVN0cnVjdFtpXS5mb3JtYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZVN0cnVjdFtpXS50eXBlID09PSBEYXRlUGFydHMuTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2sucHVzaCgnTScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCd5eXl5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgRm9ybWF0RGVzYy5Ud29EaWdpdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFzay5wdXNoKCdkZCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGVTdHJ1Y3RbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ01NJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXNrLnB1c2goJ3l5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRlU3RydWN0W2ldLnR5cGUgPT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUikge1xuICAgICAgICAgICAgICAgIG1hc2sucHVzaChkYXRlU3RydWN0W2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXNrLmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBwYXJzZXMgYW4gaW5wdXQgc3RyaW5nIGJhc2Ugb24gZGF0ZSBwYXJ0cyBhbmQgcmV0dXJucyBhIGRhdGUgYW5kIGl0cyB2YWxpZGF0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0UGFydHNcbiAgICAgKiBAcGFyYW0gcHJldkRhdGVWYWx1ZVxuICAgICAqIEBwYXJhbSBpbnB1dFZhbHVlXG4gICAgICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgYSBkYXRlIGFuZCBpdHMgdmFsaWRhdGlvbiBzdGF0ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlQXJyYXkoZGF0ZUZvcm1hdFBhcnRzOiBhbnlbXSwgcHJldkRhdGVWYWx1ZTogRGF0ZSwgaW5wdXRWYWx1ZTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgY29uc3QgZGF5U3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF5VmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgbW9udGhTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXRWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHllYXJTdHIgPSBEYXRlUGlja2VyVXRpbC5nZXRZZWFyVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgeWVhckZvcm1hdCA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLlllYXIpLmZvcm1hdFR5cGU7XG4gICAgICAgIGNvbnN0IGRheSA9IChkYXlTdHIgIT09ICcnKSA/IHBhcnNlSW50KGRheVN0ciwgMTApIDogMTtcbiAgICAgICAgY29uc3QgbW9udGggPSAobW9udGhTdHIgIT09ICcnKSA/IHBhcnNlSW50KG1vbnRoU3RyLCAxMCkgLSAxIDogMDtcblxuICAgICAgICBsZXQgeWVhcjtcbiAgICAgICAgaWYgKHllYXJTdHIgPT09ICcnKSB7XG4gICAgICAgICAgICB5ZWFyID0gKHllYXJGb3JtYXQgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSA/ICcwMCcgOiAnMjAwMCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5ZWFyID0geWVhclN0cjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeWVhclByZWZpeDtcbiAgICAgICAgaWYgKHByZXZEYXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsWWVhciA9IHByZXZEYXRlVmFsdWUuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsWWVhci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB5ZWFyUHJlZml4ID0gb3JpZ2luYWxZZWFyLnN1YnN0cmluZygwLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHllYXJQcmVmaXggPSAnMjAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxZZWFyID0gKHllYXJGb3JtYXQgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSA/IHllYXJQcmVmaXguY29uY2F0KHllYXIpIDogeWVhcjtcblxuICAgICAgICBpZiAoKG1vbnRoIDwgMCkgfHwgKG1vbnRoID4gMTEpIHx8IChtb250aCA9PT0gTmFOKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5JbnZhbGlkLCB2YWx1ZTogaW5wdXRWYWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChkYXkgPCAxKSB8fCAoZGF5ID4gRGF0ZVBpY2tlclV0aWwuZGF5c0luTW9udGgoZnVsbFllYXIsIG1vbnRoKSkgfHwgKGRheSA9PT0gTmFOKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5JbnZhbGlkLCB2YWx1ZTogaW5wdXRWYWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgc3RhdGU6IERhdGVTdGF0ZS5WYWxpZCwgZGF0ZTogbmV3IERhdGUoZnVsbFllYXIsIG1vbnRoLCBkYXkpIH07XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBtYXNrVG9Qcm9tcHRDaGFycyhtYXNrOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBtYXNrLnJlcGxhY2UoLzB8TC9nLCBEYXRlUGlja2VyVXRpbC5QUk9NUFRfQ0hBUik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVwbGFjZXMgcHJvbXB0IGNoYXJzIHdpdGggZW1wdHkgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgdHJpbUVtcHR5UGxhY2Vob2xkZXJzKHZhbHVlOiBzdHJpbmcsIHByb21wdENoYXI/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAocHJvbXB0Q2hhciB8fCAnXycsICdnJyksICcnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciBzcGlubmluZyBkYXRlIHBhcnRzLlxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0UGFydHNcbiAgICAgKiBAcGFyYW0gaW5wdXRWYWx1ZVxuICAgICAqIEBwYXJhbSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSBkZWx0YVxuICAgICAqIEBwYXJhbSBpc1NwaW5Mb29wXG4gICAgICogQHJldHVybiBtb2RpZmllZCB0ZXh0IGlucHV0XG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRNb2RpZmllZERhdGVJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLFxuICAgICAgICBpbnB1dFZhbHVlOiBzdHJpbmcsXG4gICAgICAgIHBvc2l0aW9uOiBudW1iZXIsXG4gICAgICAgIGRlbHRhOiBudW1iZXIsXG4gICAgICAgIGlzU3Bpbkxvb3A6IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXRlUGFydCA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVQYXJ0T25Qb3NpdGlvbihkYXRlRm9ybWF0UGFydHMsIHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZGF0ZVBhcnRUeXBlID0gZGF0ZVBhcnQudHlwZTtcbiAgICAgICAgY29uc3QgZGF0ZVBhcnRGb3JtYXRUeXBlID0gZGF0ZVBhcnQuZm9ybWF0VHlwZTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGRhdGVQYXJ0VmFsdWUgPSBEYXRlUGlja2VyVXRpbC5nZXREYXRlVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBkYXRlUGFydFR5cGUsIGlucHV0VmFsdWUpO1xuICAgICAgICBuZXdWYWx1ZSA9IHBhcnNlSW50KGRhdGVQYXJ0VmFsdWUsIDEwKTtcblxuICAgICAgICBsZXQgbWF4VmFsdWUsIG1pblZhbHVlO1xuICAgICAgICBjb25zdCBtaW5NYXggPSBEYXRlUGlja2VyVXRpbC5nZXRNaW5NYXhWYWx1ZShkYXRlRm9ybWF0UGFydHMsIGRhdGVQYXJ0LCBpbnB1dFZhbHVlKTtcbiAgICAgICAgbWluVmFsdWUgPSBtaW5NYXgubWluO1xuICAgICAgICBtYXhWYWx1ZSA9IG1pbk1heC5tYXg7XG5cbiAgICAgICAgaWYgKGlzTmFOKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKG1pblZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSAyMDAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG1pblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW1wVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGVtcFZhbHVlICs9IGRlbHRhO1xuXG4gICAgICAgIC8vIEluZmluaXRlIGxvb3AgZm9yIGZ1bGwgeWVhcnNcbiAgICAgICAgaWYgKG1heFZhbHVlID09PSAnaW5maW5pdGUnICYmIG1pblZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRlbXBWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NwaW5Mb29wKSB7XG4gICAgICAgICAgICBpZiAodGVtcFZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0ZW1wVmFsdWUgPSBtaW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW1wVmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRlbXBWYWx1ZSA9IG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGVtcFZhbHVlIDw9IG1heFZhbHVlICYmIHRlbXBWYWx1ZSA+PSBtaW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGVtcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBkYXRlUGFydC5wb3NpdGlvblswXTtcbiAgICAgICAgY29uc3QgZW5kSWR4ID0gZGF0ZVBhcnQucG9zaXRpb25bMV07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5wdXRWYWx1ZS5zbGljZSgwLCBzdGFydElkeCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGlucHV0VmFsdWUuc2xpY2UoZW5kSWR4LCBpbnB1dFZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGFuZ2VkUGFydDogc3RyaW5nO1xuXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IERhdGVQaWNrZXJVdGlsLmdldE51bWVyaWNGb3JtYXRQcmVmaXgoZGF0ZVBhcnRGb3JtYXRUeXBlKTtcbiAgICAgICAgY2hhbmdlZFBhcnQgPSAobmV3VmFsdWUgPCAxMCkgPyBgJHtwcmVmaXh9JHtuZXdWYWx1ZX1gIDogYCR7bmV3VmFsdWV9YDtcblxuICAgICAgICByZXR1cm4gYCR7c3RhcnR9JHtjaGFuZ2VkUGFydH0ke2VuZH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgZGF0ZSBpbnB1dCB3aXRoIHByb21wdCBjaGFycy5cbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdFBhcnRzXG4gICAgICogQHBhcmFtIGRhdGVcbiAgICAgKiBAcGFyYW0gaW5wdXRWYWx1ZVxuICAgICAqIEByZXR1cm5zIGRhdGUgaW5wdXQgaW5jbHVkaW5nIHByb21wdCBjaGFyc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYWRkUHJvbXB0Q2hhcnNFZGl0TW9kZShkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBkYXRlOiBEYXRlLCBpbnB1dFZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBkYXRlQXJyYXkgPSBBcnJheS5mcm9tKGlucHV0VmFsdWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGVGb3JtYXRQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXRQYXJ0c1tpXS5mb3JtYXRUeXBlID09PSBGb3JtYXREZXNjLk51bWVyaWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGVGb3JtYXRQYXJ0c1tpXS50eXBlID09PSBEYXRlUGFydHMuRGF5ICYmIGRhdGUuZ2V0RGF0ZSgpIDwgMTApXG4gICAgICAgICAgICAgICAgICAgIHx8IChkYXRlRm9ybWF0UGFydHNbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoICYmIGRhdGUuZ2V0TW9udGgoKSArIDEgPCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFycmF5LnNwbGljZShkYXRlRm9ybWF0UGFydHNbaV0ucG9zaXRpb25bMF0sIDAsIERhdGVQaWNrZXJVdGlsLlBST01QVF9DSEFSKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUFycmF5LmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUFycmF5LmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBkYXRlIGlucHV0IGlzIGRvbmUuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXRQYXJ0c1xuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIGlucHV0IGNvbXBsZXRlbmVzc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgY2hlY2tGb3JDb21wbGV0ZURhdGVJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGF5VmFsdWUgPSBEYXRlUGlja2VyVXRpbC5nZXREYXlWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0KTtcbiAgICAgICAgY29uc3QgbW9udGhWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dCk7XG4gICAgICAgIGNvbnN0IHllYXJWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmdldFllYXJWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF5U3RyID0gRGF0ZVBpY2tlclV0aWwuZ2V0RGF5VmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBtb250aFN0ciA9IERhdGVQaWNrZXJVdGlsLmdldE1vbnRoVmFsdWVGcm9tSW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCBpbnB1dCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChEYXRlUGlja2VyVXRpbC5pc0Z1bGxJbnB1dChkYXlWYWx1ZSwgZGF5U3RyKVxuICAgICAgICAgICAgJiYgRGF0ZVBpY2tlclV0aWwuaXNGdWxsSW5wdXQobW9udGhWYWx1ZSwgbW9udGhTdHIpXG4gICAgICAgICAgICAmJiBEYXRlUGlja2VyVXRpbC5pc0Z1bGxZZWFySW5wdXQoZGF0ZUZvcm1hdFBhcnRzLCB5ZWFyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NvbXBsZXRlJztcbiAgICAgICAgfSBlbHNlIGlmIChkYXlWYWx1ZSA9PT0gJycgJiYgbW9udGhWYWx1ZSA9PT0gJycgJiYgeWVhclZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuICdlbXB0eSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5VmFsdWUgPT09ICcnIHx8IG1vbnRoVmFsdWUgPT09ICcnIHx8IHllYXJWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAncGFydGlhbCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZGF5c0luTW9udGgoZnVsbFllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShmdWxsWWVhciwgbW9udGggKyAxLCAwKS5nZXREYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgcHJvdmlkZWQgaW5wdXQgdG8gRGF0ZS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgaW5wdXQgdG8gcGFyc2VcbiAgICAgKiBAcmV0dXJucyBEYXRlIGlmIHBhcnNlIHN1Y2NlZWQgb3IgbnVsbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VEYXRlKHZhbHVlOiBhbnkpOiBEYXRlIHwgbnVsbCB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgSW52YWxpZCBEYXRlIHdlIHNob3VsZCByZXR1cm4gbnVsbFxuICAgICAgICBpZiAodGhpcy5pc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkRGF0ZSh2YWx1ZSkgPyB2YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZShEYXRlLnBhcnNlKHZhbHVlKSkgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBwcm92aWRlZCBpbnB1dCBpcyBkYXRlXG4gICAgICogQHBhcmFtIHZhbHVlIGlucHV0IHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCBpbnB1dCBpcyBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc0RhdGUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaW5wdXQgaXMgdmFsaWQgZGF0ZVxuICAgICAqIEBwYXJhbSB2YWx1ZSBpbnB1dCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgaW5wdXQgaXMgYSB2YWxpZCBkYXRlXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc1ZhbGlkRGF0ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRZZWFyRm9ybWF0VHlwZShmb3JtYXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0Lm1hdGNoKG5ldyBSZWdFeHAoRGF0ZUNoYXJzLlllYXJDaGFyLCAnZycpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8vIHkgKDIwMjApXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIC8vIHl5eXkgKDIwMjApXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIC8vIHl5ICgyMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRNb250aEZvcm1hdFR5cGUoZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKERhdGVDaGFycy5Nb250aENoYXIsICdnJykpLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgLy8gTSAoOClcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5OdW1lcmljO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgLy8gTU0gKDA4KVxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JtYXREZXNjLlR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERheUZvcm1hdFR5cGUoZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdC5tYXRjaChuZXcgUmVnRXhwKERhdGVDaGFycy5EYXlDaGFyLCAnZycpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIC8vIGQgKDYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZvcm1hdERlc2MuTnVtZXJpYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIC8vIGRkICgwNilcbiAgICAgICAgICAgICAgICByZXR1cm4gRm9ybWF0RGVzYy5Ud29EaWdpdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXREZWZhdWx0TG9jYWxlTWFzayhsb2NhbGU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBkYXRlU3RydWN0ID0gW107XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGxvY2FsZSk7XG4gICAgICAgIGNvbnN0IGZvcm1hdFRvUGFydHMgPSBmb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhuZXcgRGF0ZSgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3JtYXRUb1BhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9QYXJ0c1tpXS50eXBlID09PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICBkYXRlU3RydWN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmb3JtYXRUb1BhcnRzW2ldLnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVTdHJ1Y3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGZvcm1hdFRvUGFydHNbaV0udHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlck9wdGlvbnMgPSBmb3JtYXR0ZXIucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZVN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dpdGNoIChkYXRlU3RydWN0W2ldLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5EYXk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVN0cnVjdFtpXS5mb3JtYXRUeXBlID0gZm9ybWF0dGVyT3B0aW9ucy5kYXk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5Nb250aDoge1xuICAgICAgICAgICAgICAgICAgICBkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLm1vbnRoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBEYXRlUGFydHMuWWVhcjoge1xuICAgICAgICAgICAgICAgICAgICBkYXRlU3RydWN0W2ldLmZvcm1hdFR5cGUgPSBmb3JtYXR0ZXJPcHRpb25zLnllYXI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBEYXRlUGlja2VyVXRpbC5maWxsRGF0ZVBhcnRzUG9zaXRpb25zKGRhdGVTdHJ1Y3QpO1xuICAgICAgICByZXR1cm4gZGF0ZVN0cnVjdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBpc0RhdGVDaGFyKGNoYXI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGNoYXIgPT09IERhdGVDaGFycy5ZZWFyQ2hhciB8fCBjaGFyID09PSBEYXRlQ2hhcnMuTW9udGhDaGFyIHx8IGNoYXIgPT09IERhdGVDaGFycy5EYXlDaGFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXROdW1lcmljRm9ybWF0UHJlZml4KGZvcm1hdFR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEZvcm1hdERlc2MuTnVtZXJpYzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUGlja2VyVXRpbC5QUk9NUFRfQ0hBUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldE1pbk1heFZhbHVlKGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGRhdGVQYXJ0LCBpbnB1dFZhbHVlOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICBsZXQgbWF4VmFsdWUsIG1pblZhbHVlO1xuICAgICAgICBzd2l0Y2ggKGRhdGVQYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLk1vbnRoOiB7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gRGF0ZVBpY2tlclV0aWwuTlVNQkVSX09GX01PTlRIUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRGF0ZVBhcnRzLkRheToge1xuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IERhdGVQaWNrZXJVdGlsLmRheXNJbk1vbnRoKFxuICAgICAgICAgICAgICAgICAgICBEYXRlUGlja2VyVXRpbC5nZXRGdWxsWWVhckZyb21TdHJpbmcoRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhciksIGlucHV0VmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChEYXRlUGlja2VyVXRpbC5nZXRNb250aFZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgaW5wdXRWYWx1ZSksIDEwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIERhdGVQYXJ0cy5ZZWFyOiB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVQYXJ0LmZvcm1hdFR5cGUgPT09IEZvcm1hdERlc2MuVHdvRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSA5OTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIG1pblZhbHVlID0gJ2luZmluaXRlJztcbiAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSAnaW5maW5pdGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtaW46IG1pblZhbHVlLCBtYXg6IG1heFZhbHVlIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHR5cGU6IERhdGVQYXJ0cywgaW5wdXRWYWx1ZTogc3RyaW5nLCB0cmltOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHBhcnRQb3NpdGlvbiA9IERhdGVQaWNrZXJVdGlsLmdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0cywgdHlwZSkucG9zaXRpb247XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKHBhcnRQb3NpdGlvblswXSwgcGFydFBvc2l0aW9uWzFdKTtcbiAgICAgICAgcmV0dXJuICh0cmltKSA/IERhdGVQaWNrZXJVdGlsLnRyaW1FbXB0eVBsYWNlaG9sZGVycyhyZXN1bHQpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERheVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLkRheSwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TW9udGhWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCBpbnB1dFZhbHVlOiBzdHJpbmcsIHRyaW06IGJvb2xlYW4gPSB0cnVlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIERhdGVQaWNrZXJVdGlsLmdldERhdGVWYWx1ZUZyb21JbnB1dChkYXRlRm9ybWF0UGFydHMsIERhdGVQYXJ0cy5Nb250aCwgaW5wdXRWYWx1ZSwgdHJpbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0WWVhclZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIGlucHV0VmFsdWU6IHN0cmluZywgdHJpbTogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZVZhbHVlRnJvbUlucHV0KGRhdGVGb3JtYXRQYXJ0cywgRGF0ZVBhcnRzLlllYXIsIGlucHV0VmFsdWUsIHRyaW0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdldERhdGVGb3JtYXRQYXJ0KGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHR5cGU6IERhdGVQYXJ0cyk6IGFueSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRhdGVGb3JtYXRQYXJ0cy5maWx0ZXIoKGRhdGVQYXJ0KSA9PiAoZGF0ZVBhcnQudHlwZSA9PT0gdHlwZSkpWzBdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRnVsbElucHV0KHZhbHVlOiBhbnksIGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSAhPT0gJycgJiYgaW5wdXQubGVuZ3RoID09PSAyICYmIGlucHV0LmNoYXJBdCgxKSAhPT0gRGF0ZVBpY2tlclV0aWwuUFJPTVBUX0NIQVIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGlzRnVsbFllYXJJbnB1dChkYXRlRm9ybWF0UGFydHM6IGFueVtdLCB2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHN3aXRjaCAoRGF0ZVBpY2tlclV0aWwuZ2V0RGF0ZUZvcm1hdFBhcnQoZGF0ZUZvcm1hdFBhcnRzLCBEYXRlUGFydHMuWWVhcikuZm9ybWF0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9PSAnJyAmJiB2YWx1ZS5sZW5ndGggPT09IDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgIT09ICcnICYmIHZhbHVlLmxlbmd0aCA9PT0gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RGF0ZVBhcnRPblBvc2l0aW9uKGRhdGVGb3JtYXRQYXJ0czogYW55W10sIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGF0ZUZvcm1hdFBhcnRzLmZpbHRlcigoZWxlbWVudCkgPT5cbiAgICAgICAgICAgIGVsZW1lbnQucG9zaXRpb25bMF0gPD0gcG9zaXRpb24gJiYgcG9zaXRpb24gPD0gZWxlbWVudC5wb3NpdGlvblsxXSAmJiBlbGVtZW50LnR5cGUgIT09IERhdGVQaWNrZXJVdGlsLlNFUEFSQVRPUilbMF07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0RnVsbFllYXJGcm9tU3RyaW5nKHllYXJQYXJ0LCBpbnB1dFZhbHVlKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0VmFsdWUuc3Vic3RyaW5nKHllYXJQYXJ0LnBvc2l0aW9uWzBdLCB5ZWFyUGFydC5wb3NpdGlvblsxXSksIDEwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmaWxsRGF0ZVBhcnRzUG9zaXRpb25zKGRhdGVBcnJheTogYW55W10pOiB2b2lkIHtcbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBEYXl8TW9udGggcGFydCBwb3NpdGlvbnNcbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLkRheSB8fCBkYXRlQXJyYXlbaV0udHlwZSA9PT0gRGF0ZVBhcnRzLk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDIgcG9zaXRpb25zIGZvciBudW1iZXJcbiAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDJdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0ZUFycmF5W2ldLnR5cGUgPT09IERhdGVQYXJ0cy5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgLy8gWWVhciBwYXJ0IHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0ZUFycmF5W2ldLmZvcm1hdFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLk51bWVyaWM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9mZnNldCA0IHBvc2l0aW9ucyBmb3IgZnVsbCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBGb3JtYXREZXNjLlR3b0RpZ2l0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2Zmc2V0IDIgcG9zaXRpb25zIGZvciBzaG9ydCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbaV0ucG9zaXRpb24gPSBbY3VycmVudFBvcywgY3VycmVudFBvcyArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGVBcnJheVtpXS50eXBlID09PSBEYXRlUGlja2VyVXRpbC5TRVBBUkFUT1IpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXBhcmF0b3IgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgZGF0ZUFycmF5W2ldLnBvc2l0aW9uID0gW2N1cnJlbnRQb3MsIGN1cnJlbnRQb3MgKyAxXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiJdfQ==