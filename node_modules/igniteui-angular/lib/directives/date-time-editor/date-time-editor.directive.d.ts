import { ElementRef, Renderer2, EventEmitter, OnChanges, SimpleChanges } from '@angular/core';
import { ControlValueAccessor, Validator, AbstractControl, ValidationErrors } from '@angular/forms';
import { IgxMaskDirective } from '../mask/mask.directive';
import { MaskParsingService } from '../mask/mask-parsing.service';
import { IgxDateTimeEditorEventArgs, DatePart } from './date-time-editor.common';
/**
 * Date Time Editor provides a functionality to input, edit and format date and time.
 *
 * @igxModule IgxDateTimeEditorModule
 *
 * @igxParent IgxInputGroup
 *
 * @igxTheme igx-input-theme
 *
 * @igxKeywords date, time, editor
 *
 * @igxGroup Scheduling
 *
 * @remarks
 *
 * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
 * It requires input in a specified or default input format which is visible in the input element as a placeholder.
 * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
 * Supports display format that may differ from the input format.
 * Provides methods to increment and decrement any specific/targeted `DatePart`.
 *
 * @example
 * ```html
 * <igx-input-group>
 *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
 * </igx-input-group>
 * ```
 */
import * as ɵngcc0 from '@angular/core';
export declare class IgxDateTimeEditorDirective extends IgxMaskDirective implements OnChanges, Validator, ControlValueAccessor {
    protected renderer: Renderer2;
    protected elementRef: ElementRef;
    protected maskParser: MaskParsingService;
    private _document;
    private _locale;
    /**
     * Locale settings used for value formatting.
     *
     * @remarks
     * Uses Angular's `LOCALE_ID` by default. Affects both input mask and display format if those are not set.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [locale]="'en'">
     * ```
     */
    locale: string;
    /**
     * Minimum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate">
     * ```
     */
    get minValue(): string | Date;
    set minValue(value: string | Date);
    /**
     * Maximum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed in, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [maxValue]="maxDate">
     * ```
     */
    get maxValue(): string | Date;
    set maxValue(value: string | Date);
    /**
     * Specify if the currently spun date segment should loop over.
     * @example
     * ```html
     * <input igxDateTimeEditor [isSpinLoop]="false">
     * ```
     */
    isSpinLoop: boolean;
    /**
     * Set both pre-defined format options such as `shortDate` and `longDate`,
     * as well as constructed format string using characters supported by `DatePipe`, e.g. `EE/MM/yyyy`.
     * @example
     * ```html
     * <input igxDateTimeEditor [displayFormat]="'shortDate'">
     * ```
     */
    displayFormat: string;
    /**
     * Expected user input format (and placeholder).
     * @example
     * ```html
     * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
     * ```
     */
    set inputFormat(value: string);
    get inputFormat(): string;
    /**
     * Editor value.
     * @example
     * ```html
     * <input igxDateTimeEditor [value]="date">
     * ```
     */
    set value(value: Date);
    get value(): Date;
    /**
     * Emitted when the editor's value has changed.
     * @example
     * ```html
     * <input igxDateTimeEditor (valueChange)="onValueChanged($event)"/>
     * ```
     */
    valueChange: EventEmitter<Date>;
    /**
     * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
     * ```
     */
    validationFailed: EventEmitter<IgxDateTimeEditorEventArgs>;
    private _value;
    private _format;
    private document;
    private _isFocused;
    private _minValue;
    private _maxValue;
    private _oldValue;
    private _inputDateParts;
    private onTouchCallback;
    private onChangeCallback;
    private onValidatorChange;
    private get emptyMask();
    private get targetDatePart();
    private get hasDateParts();
    private get hasTimeParts();
    constructor(renderer: Renderer2, elementRef: ElementRef, maskParser: MaskParsingService, _document: any, _locale: any);
    /** @hidden @internal */
    ngOnChanges(changes: SimpleChanges): void;
    /** Clear the input element value. */
    clear(): void;
    /**
     * Increment specified DatePart.
     * @param datePart The optional DatePart to increment. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    increment(datePart?: DatePart): void;
    /**
     * Decrement specified DatePart.
     *
     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    decrement(datePart?: DatePart): void;
    /** @hidden @internal */
    writeValue(value: any): void;
    /** @hidden @internal */
    validate(control: AbstractControl): ValidationErrors | null;
    /** @hidden @internal */
    registerOnValidatorChange?(fn: () => void): void;
    /** @hidden @internal */
    registerOnChange(fn: any): void;
    /** @hidden @internal */
    registerOnTouched(fn: any): void;
    /** @hidden @internal */
    setDisabledState?(isDisabled: boolean): void;
    /** @hidden @internal */
    onInputChanged(): void;
    /** @hidden @internal */
    onKeyDown(event: KeyboardEvent): void;
    /** @hidden @internal */
    onFocus(): void;
    /** @hidden @internal */
    onBlur(value: string): void;
    /** @hidden @internal */
    updateMask(): void;
    private getMaskedValue;
    private isDate;
    private valueInRange;
    private spinValue;
    private updateValue;
    private toTwelveHourFormat;
    private getPartValue;
    private prependValue;
    private spin;
    private inputIsComplete;
    private isValidDate;
    parseDate(val: string): Date | null;
    private moveCursor;
    /**
     * Move the cursor in a specific direction until it reaches a date/time separator.
     * Then return its index.
     *
     * @param value The string it operates on.
     * @param direction 0 is left, 1 is right. Default is 0.
     */
    private getNewPosition;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDateTimeEditorDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDateTimeEditorDirective, "[igxDateTimeEditor]", ["igxDateTimeEditor"], {
    "isSpinLoop": "isSpinLoop";
    "locale": "locale";
    "minValue": "minValue";
    "maxValue": "maxValue";
    "inputFormat": "igxDateTimeEditor";
    "value": "value";
    "displayFormat": "displayFormat";
}, {
    "valueChange": "valueChange";
    "validationFailed": "validationFailed";
}, never>;
}
export declare class IgxDateTimeEditorModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxDateTimeEditorModule, [typeof IgxDateTimeEditorDirective], never, [typeof IgxDateTimeEditorDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxDateTimeEditorModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLWVkaXRvci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiZGF0ZS10aW1lLWVkaXRvci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5S0E7Ozs7QUFFQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IElneE1hc2tEaXJlY3RpdmUgfSBmcm9tICcuLi9tYXNrL21hc2suZGlyZWN0aXZlJztcbmltcG9ydCB7IE1hc2tQYXJzaW5nU2VydmljZSB9IGZyb20gJy4uL21hc2svbWFzay1wYXJzaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4RGF0ZVRpbWVFZGl0b3JFdmVudEFyZ3MsIERhdGVQYXJ0IH0gZnJvbSAnLi9kYXRlLXRpbWUtZWRpdG9yLmNvbW1vbic7XG4vKipcbiAqIERhdGUgVGltZSBFZGl0b3IgcHJvdmlkZXMgYSBmdW5jdGlvbmFsaXR5IHRvIGlucHV0LCBlZGl0IGFuZCBmb3JtYXQgZGF0ZSBhbmQgdGltZS5cbiAqXG4gKiBAaWd4TW9kdWxlIElneERhdGVUaW1lRWRpdG9yTW9kdWxlXG4gKlxuICogQGlneFBhcmVudCBJZ3hJbnB1dEdyb3VwXG4gKlxuICogQGlneFRoZW1lIGlneC1pbnB1dC10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyBkYXRlLCB0aW1lLCBlZGl0b3JcbiAqXG4gKiBAaWd4R3JvdXAgU2NoZWR1bGluZ1xuICpcbiAqIEByZW1hcmtzXG4gKlxuICogVGhlIElnbml0ZSBVSSBEYXRlIFRpbWUgRWRpdG9yIERpcmVjdGl2ZSBtYWtlcyBpdCBlYXN5IGZvciBkZXZlbG9wZXJzIHRvIG1hbmlwdWxhdGUgZGF0ZS90aW1lIHVzZXIgaW5wdXQuXG4gKiBJdCByZXF1aXJlcyBpbnB1dCBpbiBhIHNwZWNpZmllZCBvciBkZWZhdWx0IGlucHV0IGZvcm1hdCB3aGljaCBpcyB2aXNpYmxlIGluIHRoZSBpbnB1dCBlbGVtZW50IGFzIGEgcGxhY2Vob2xkZXIuXG4gKiBJdCBhbGxvd3MgdGhlIGlucHV0IG9mIG9ubHkgZGF0ZSAoZXg6ICdkZC9NTS95eXl5JyksIG9ubHkgdGltZSAoZXg6J0hIOm1tIHR0Jykgb3IgYm90aCBhdCBvbmNlLCBpZiBuZWVkZWQuXG4gKiBTdXBwb3J0cyBkaXNwbGF5IGZvcm1hdCB0aGF0IG1heSBkaWZmZXIgZnJvbSB0aGUgaW5wdXQgZm9ybWF0LlxuICogUHJvdmlkZXMgbWV0aG9kcyB0byBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBhbnkgc3BlY2lmaWMvdGFyZ2V0ZWQgYERhdGVQYXJ0YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1pbnB1dC1ncm91cD5cbiAqICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWd4SW5wdXQgW2lneERhdGVUaW1lRWRpdG9yXT1cIidkZC9NTS95eXl5J1wiIFtkaXNwbGF5Rm9ybWF0XT1cIidzaG9ydERhdGUnXCIgWyhuZ01vZGVsKV09XCJkYXRlXCIvPlxuICogPC9pZ3gtaW5wdXQtZ3JvdXA+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4RGF0ZVRpbWVFZGl0b3JEaXJlY3RpdmUgZXh0ZW5kcyBJZ3hNYXNrRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBWYWxpZGF0b3IsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgICBwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZjtcbiAgICBwcm90ZWN0ZWQgbWFza1BhcnNlcjogTWFza1BhcnNpbmdTZXJ2aWNlO1xuICAgIHByaXZhdGUgX2RvY3VtZW50O1xuICAgIHByaXZhdGUgX2xvY2FsZTtcbiAgICAvKipcbiAgICAgKiBMb2NhbGUgc2V0dGluZ3MgdXNlZCBmb3IgdmFsdWUgZm9ybWF0dGluZy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlcyBBbmd1bGFyJ3MgYExPQ0FMRV9JRGAgYnkgZGVmYXVsdC4gQWZmZWN0cyBib3RoIGlucHV0IG1hc2sgYW5kIGRpc3BsYXkgZm9ybWF0IGlmIHRob3NlIGFyZSBub3Qgc2V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFtsb2NhbGVdPVwiJ2VuJ1wiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxvY2FsZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1pbmltdW0gdmFsdWUgcmVxdWlyZWQgZm9yIHRoZSBlZGl0b3IgdG8gcmVtYWluIHZhbGlkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBhIGBzdHJpbmdgIHZhbHVlIGlzIHBhc3NlZCwgaXQgbXVzdCBiZSBpbiB0aGUgZGVmaW5lZCBpbnB1dCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW21pblZhbHVlXT1cIm1pbkRhdGVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgbWluVmFsdWUoKTogc3RyaW5nIHwgRGF0ZTtcbiAgICBzZXQgbWluVmFsdWUodmFsdWU6IHN0cmluZyB8IERhdGUpO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gdmFsdWUgcmVxdWlyZWQgZm9yIHRoZSBlZGl0b3IgdG8gcmVtYWluIHZhbGlkLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBhIGBzdHJpbmdgIHZhbHVlIGlzIHBhc3NlZCBpbiwgaXQgbXVzdCBiZSBpbiB0aGUgZGVmaW5lZCBpbnB1dCBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgW21heFZhbHVlXT1cIm1heERhdGVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgbWF4VmFsdWUoKTogc3RyaW5nIHwgRGF0ZTtcbiAgICBzZXQgbWF4VmFsdWUodmFsdWU6IHN0cmluZyB8IERhdGUpO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgaWYgdGhlIGN1cnJlbnRseSBzcHVuIGRhdGUgc2VnbWVudCBzaG91bGQgbG9vcCBvdmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciBbaXNTcGluTG9vcF09XCJmYWxzZVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGlzU3Bpbkxvb3A6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IGJvdGggcHJlLWRlZmluZWQgZm9ybWF0IG9wdGlvbnMgc3VjaCBhcyBgc2hvcnREYXRlYCBhbmQgYGxvbmdEYXRlYCxcbiAgICAgKiBhcyB3ZWxsIGFzIGNvbnN0cnVjdGVkIGZvcm1hdCBzdHJpbmcgdXNpbmcgY2hhcmFjdGVycyBzdXBwb3J0ZWQgYnkgYERhdGVQaXBlYCwgZS5nLiBgRUUvTU0veXl5eWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFtkaXNwbGF5Rm9ybWF0XT1cIidzaG9ydERhdGUnXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGlzcGxheUZvcm1hdDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHVzZXIgaW5wdXQgZm9ybWF0IChhbmQgcGxhY2Vob2xkZXIpLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCBbaWd4RGF0ZVRpbWVFZGl0b3JdPVwiJ2RkL01NL3l5eXknXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0IGlucHV0Rm9ybWF0KHZhbHVlOiBzdHJpbmcpO1xuICAgIGdldCBpbnB1dEZvcm1hdCgpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRWRpdG9yIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpbnB1dCBpZ3hEYXRlVGltZUVkaXRvciBbdmFsdWVdPVwiZGF0ZVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZTogRGF0ZSk7XG4gICAgZ2V0IHZhbHVlKCk6IERhdGU7XG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBlZGl0b3IncyB2YWx1ZSBoYXMgY2hhbmdlZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgaWd4RGF0ZVRpbWVFZGl0b3IgKHZhbHVlQ2hhbmdlKT1cIm9uVmFsdWVDaGFuZ2VkKCRldmVudClcIi8+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlPjtcbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIGVkaXRvciBpcyBub3Qgd2l0aGluIGEgc3BlY2lmaWVkIHJhbmdlIG9yIHdoZW4gdGhlIGVkaXRvcidzIHZhbHVlIGlzIGluIGFuIGludmFsaWQgc3RhdGUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IGlneERhdGVUaW1lRWRpdG9yIFttaW5WYWx1ZV09XCJtaW5EYXRlXCIgW21heFZhbHVlXT1cIm1heERhdGVcIiAodmFsaWRhdGlvbkZhaWxlZCk9XCJvblZhbGlkYXRpb25GYWlsZWQoJGV2ZW50KVwiLz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YWxpZGF0aW9uRmFpbGVkOiBFdmVudEVtaXR0ZXI8SWd4RGF0ZVRpbWVFZGl0b3JFdmVudEFyZ3M+O1xuICAgIHByaXZhdGUgX3ZhbHVlO1xuICAgIHByaXZhdGUgX2Zvcm1hdDtcbiAgICBwcml2YXRlIGRvY3VtZW50O1xuICAgIHByaXZhdGUgX2lzRm9jdXNlZDtcbiAgICBwcml2YXRlIF9taW5WYWx1ZTtcbiAgICBwcml2YXRlIF9tYXhWYWx1ZTtcbiAgICBwcml2YXRlIF9vbGRWYWx1ZTtcbiAgICBwcml2YXRlIF9pbnB1dERhdGVQYXJ0cztcbiAgICBwcml2YXRlIG9uVG91Y2hDYWxsYmFjaztcbiAgICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2s7XG4gICAgcHJpdmF0ZSBvblZhbGlkYXRvckNoYW5nZTtcbiAgICBwcml2YXRlIGdldCBlbXB0eU1hc2soKTtcbiAgICBwcml2YXRlIGdldCB0YXJnZXREYXRlUGFydCgpO1xuICAgIHByaXZhdGUgZ2V0IGhhc0RhdGVQYXJ0cygpO1xuICAgIHByaXZhdGUgZ2V0IGhhc1RpbWVQYXJ0cygpO1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyOiBSZW5kZXJlcjIsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIG1hc2tQYXJzZXI6IE1hc2tQYXJzaW5nU2VydmljZSwgX2RvY3VtZW50OiBhbnksIF9sb2NhbGU6IGFueSk7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgLyoqIENsZWFyIHRoZSBpbnB1dCBlbGVtZW50IHZhbHVlLiAqL1xuICAgIGNsZWFyKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSW5jcmVtZW50IHNwZWNpZmllZCBEYXRlUGFydC5cbiAgICAgKiBAcGFyYW0gZGF0ZVBhcnQgVGhlIG9wdGlvbmFsIERhdGVQYXJ0IHRvIGluY3JlbWVudC4gRGVmYXVsdHMgdG8gRGF0ZSBvciBIb3Vycyh3aGVuIERhdGUgaXMgYWJzZW50IGZyb20gdGhlIGlucHV0Rm9ybWF0IC0gZXg6J0hIOm1tJykuXG4gICAgICovXG4gICAgaW5jcmVtZW50KGRhdGVQYXJ0PzogRGF0ZVBhcnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERlY3JlbWVudCBzcGVjaWZpZWQgRGF0ZVBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0ZVBhcnQgVGhlIG9wdGlvbmFsIERhdGVQYXJ0IHRvIGRlY3JlbWVudC4gRGVmYXVsdHMgdG8gRGF0ZSBvciBIb3Vycyh3aGVuIERhdGUgaXMgYWJzZW50IGZyb20gdGhlIGlucHV0Rm9ybWF0IC0gZXg6J0hIOm1tJykuXG4gICAgICovXG4gICAgZGVjcmVtZW50KGRhdGVQYXJ0PzogRGF0ZVBhcnQpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZT8oZm46ICgpID0+IHZvaWQpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZT8oaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgb25JbnB1dENoYW5nZWQoKTogdm9pZDtcbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIG9uRm9jdXMoKTogdm9pZDtcbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBvbkJsdXIodmFsdWU6IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgdXBkYXRlTWFzaygpOiB2b2lkO1xuICAgIHByaXZhdGUgZ2V0TWFza2VkVmFsdWU7XG4gICAgcHJpdmF0ZSBpc0RhdGU7XG4gICAgcHJpdmF0ZSB2YWx1ZUluUmFuZ2U7XG4gICAgcHJpdmF0ZSBzcGluVmFsdWU7XG4gICAgcHJpdmF0ZSB1cGRhdGVWYWx1ZTtcbiAgICBwcml2YXRlIHRvVHdlbHZlSG91ckZvcm1hdDtcbiAgICBwcml2YXRlIGdldFBhcnRWYWx1ZTtcbiAgICBwcml2YXRlIHByZXBlbmRWYWx1ZTtcbiAgICBwcml2YXRlIHNwaW47XG4gICAgcHJpdmF0ZSBpbnB1dElzQ29tcGxldGU7XG4gICAgcHJpdmF0ZSBpc1ZhbGlkRGF0ZTtcbiAgICBwYXJzZURhdGUodmFsOiBzdHJpbmcpOiBEYXRlIHwgbnVsbDtcbiAgICBwcml2YXRlIG1vdmVDdXJzb3I7XG4gICAgLyoqXG4gICAgICogTW92ZSB0aGUgY3Vyc29yIGluIGEgc3BlY2lmaWMgZGlyZWN0aW9uIHVudGlsIGl0IHJlYWNoZXMgYSBkYXRlL3RpbWUgc2VwYXJhdG9yLlxuICAgICAqIFRoZW4gcmV0dXJuIGl0cyBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIGl0IG9wZXJhdGVzIG9uLlxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gMCBpcyBsZWZ0LCAxIGlzIHJpZ2h0LiBEZWZhdWx0IGlzIDAuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXROZXdQb3NpdGlvbjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERhdGVUaW1lRWRpdG9yTW9kdWxlIHtcbn1cbiJdfQ==