import { ElementRef, EventEmitter, NgZone, OnDestroy, OnInit, Renderer2, ChangeDetectorRef, ViewContainerRef, AfterContentInit, TemplateRef, QueryList } from '@angular/core';
import { Subject } from 'rxjs';
import { IBaseEventArgs } from '../../core/utils';
import { IDropStrategy } from './drag-drop.strategy';
import * as ɵngcc0 from '@angular/core';
export declare enum DragDirection {
    VERTICAL = 0,
    HORIZONTAL = 1,
    BOTH = 2
}
export interface IgxDragCustomEventDetails {
    startX: number;
    startY: number;
    pageX: number;
    pageY: number;
    owner: IgxDragDirective;
    originalEvent: any;
}
export interface IDropBaseEventArgs extends IBaseEventArgs {
    /**
     * Reference to the original event that caused the draggable element to enter the igxDrop element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     */
    originalEvent: any;
    /** The owner igxDrop directive that triggered this event. */
    owner: IgxDropDirective;
    /** The igxDrag directive instanced on an element that entered the area of the igxDrop element */
    drag: IgxDragDirective;
    /** The data contained for the draggable element in igxDrag directive. */
    dragData: any;
    /** The initial position of the pointer on X axis when the dragged element began moving */
    startX: number;
    /** The initial position of the pointer on Y axis when the dragged element began moving */
    startY: number;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageX: number;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageY: number;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    offsetX: number;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    offsetY: number;
}
export interface IDropDroppedEventArgs extends IDropBaseEventArgs {
    /** Specifies if the default drop logic related to the event should be canceled. */
    cancel: boolean;
}
export interface IDragBaseEventArgs extends IBaseEventArgs {
    /**
     * Reference to the original event that caused the interaction with the element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     */
    originalEvent: PointerEvent | MouseEvent | TouchEvent;
    /** The owner igxDrag directive that triggered this event. */
    owner: IgxDragDirective;
    /** The initial position of the pointer on X axis when the dragged element began moving */
    startX: number;
    /** The initial position of the pointer on Y axis when the dragged element began moving */
    startY: number;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageX: number;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     */
    pageY: number;
}
export interface IDragStartEventArgs extends IDragBaseEventArgs {
    /** Set if the the dragging should be canceled. */
    cancel: boolean;
}
export interface IDragMoveEventArgs extends IDragStartEventArgs {
    /** The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element X movement. */
    nextPageX: number;
    /** The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element Y movement. */
    nextPageY: number;
}
export interface IDragGhostBaseEventArgs extends IBaseEventArgs {
    /** The owner igxDrag directive that triggered this event. */
    owner: IgxDragDirective;
    /** Instance to the ghost element that is created when dragging starts. */
    ghostElement: any;
    /** Set if the ghost creation/destruction should be canceled. */
    cancel: boolean;
}
export interface IDragCustomTransitionArgs {
    duration?: number;
    timingFunction?: string;
    delay?: number;
}
export declare class IgxDragLocation {
    private _pageX;
    private _pageY;
    pageX: number;
    pageY: number;
    constructor(_pageX: any, _pageY: any);
}
export declare class IgxDragHandleDirective {
    element: ElementRef<any>;
    baseClass: boolean;
    constructor(element: ElementRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragHandleDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragHandleDirective, "[igxDragHandle]", never, {}, {}, never>;
}
export declare class IgxDragIgnoreDirective {
    element: ElementRef<any>;
    baseClass: boolean;
    constructor(element: ElementRef<any>);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragIgnoreDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragIgnoreDirective, "[igxDragIgnore]", never, {}, {}, never>;
}
export declare class IgxDragDirective implements AfterContentInit, OnDestroy {
    cdr: ChangeDetectorRef;
    element: ElementRef;
    viewContainer: ViewContainerRef;
    zone: NgZone;
    renderer: Renderer2;
    protected ghostContext: any;
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * @memberof IgxDragDirective
     */
    data: any;
    /**
     * An @Input property that indicates when the drag should start.
     * By default the drag starts after the draggable element is moved by 5px.
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    dragTolerance: number;
    /**
     * An @Input property that indicates the directions that the element can be dragged.
     * By default it is set to both horizontal and vertical directions.
     * ```html
     * <div igxDrag [dragDirection]="dragDir">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public dragDir = DragDirection.HORIZONTAL;
     * ```
     * @memberof IgxDragDirective
     */
    dragDirection: DragDirection;
    /**
     * An @Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    dragChannel: number | string | number[] | string[];
    /**
     * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
     * By default it is set to `true`.
     * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
     * ```html
     * <div igxDrag [ghost]="false">
     *      <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghost: boolean;
    /**
     * Sets a custom class that will be added to the `ghostElement` element.
     * ```html
     * <div igxDrag [ghostClass]="'ghostElement'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghostClass: string;
    /**
     * An @Input property that specifies a template for the ghost element created when dragging starts and `ghost` is true.
     * By default a clone of the base element the igxDrag is instanced is created.
     * ```html
     * <div igxDrag [ghostTemplate]="customGhost">
     *         <span>Drag Me!</span>
     * </div>
     * <ng-template #customGhost>
     *      <div class="customGhostStyle">
     *          <span>I am being dragged!</span>
     *      </div>
     * </ng-template>
     * ```
     * @memberof IgxDragDirective
     */
    ghostTemplate: TemplateRef<any>;
    /**
     * An @Input property that sets the element to which the dragged element will be appended.
     * By default it's set to null and the dragged element is appended to the body.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostHost]="hostDiv">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    ghostHost: any;
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value: any);
    get ghostOffsetX(): any;
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value: any);
    get ghostOffsetY(): any;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragStart: EventEmitter<IDragStartEventArgs>;
    /**
     * Event triggered when the draggable element has been moved.
     * ```html
     * <div igxDrag  (dragMove)="onDragMove()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragMove(){
     *      alert("The element has moved!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragMove: EventEmitter<IDragMoveEventArgs>;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragEnd: EventEmitter<IDragBaseEventArgs>;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag (dragClick)="onDragClick()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragClick(){
     *      alert("The element has been clicked!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    dragClick: EventEmitter<IDragBaseEventArgs>;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostCreate)="ghostCreated()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostCreated(){
     *      alert("The ghost has been created!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    ghostCreate: EventEmitter<IDragGhostBaseEventArgs>;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostDestroy)="ghostDestroyed()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostDestroyed(){
     *      alert("The ghost has been destroyed!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    ghostDestroy: EventEmitter<IDragGhostBaseEventArgs>;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag (transitioned)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * @memberof IgxDragDirective
     */
    transitioned: EventEmitter<IDragBaseEventArgs>;
    /**
     * @hidden
     */
    dragHandles: QueryList<IgxDragHandleDirective>;
    /**
     * @hidden
     */
    dragIgnoredElems: QueryList<IgxDragIgnoreDirective>;
    /**
     * @hidden
     */
    baseClass: boolean;
    /**
     * @hidden
     */
    selectDisabled: boolean;
    /**
     * Gets the current location of the element relative to the page.
     */
    get location(): IgxDragLocation;
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation(): IgxDragLocation;
    /**
     * @hidden
     */
    get pointerEventsEnabled(): boolean;
    /**
     * @hidden
     */
    get touchEventsEnabled(): boolean;
    /**
     * @hidden
     */
    get pageX(): number;
    /**
     * @hidden
     */
    get pageY(): number;
    protected get baseLeft(): number;
    protected get baseTop(): number;
    protected get baseOriginLeft(): number;
    protected get baseOriginTop(): number;
    protected set ghostLeft(pageX: number);
    protected get ghostLeft(): number;
    protected set ghostTop(pageY: number);
    protected get ghostTop(): number;
    /**
     * @hidden
     */
    defaultReturnDuration: string;
    /**
     * @hidden
     */
    ghostElement: any;
    /**
     * @hidden
     */
    animInProgress: boolean;
    protected _startX: number;
    protected _startY: number;
    protected _lastX: number;
    protected _lastY: number;
    protected _dragStarted: boolean;
    /** Drag ghost related properties */
    protected _defaultOffsetX: any;
    protected _defaultOffsetY: any;
    protected _offsetX: any;
    protected _offsetY: any;
    protected _ghostStartX: any;
    protected _ghostStartY: any;
    protected _ghostHostX: number;
    protected _ghostHostY: number;
    protected _pointerDownId: any;
    protected _clicked: boolean;
    protected _lastDropArea: any;
    protected _destroy: Subject<boolean>;
    protected _removeOnDestroy: boolean;
    constructor(cdr: ChangeDetectorRef, element: ElementRef, viewContainer: ViewContainerRef, zone: NgZone, renderer: Renderer2);
    /**
     * @hidden
     */
    ngAfterContentInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation: IgxDragLocation): void;
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs?: IDragCustomTransitionArgs, startLocation?: IgxDragLocation): void;
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target: IgxDragLocation | ElementRef, customAnimArgs?: IDragCustomTransitionArgs, startLocation?: IgxDragLocation): void;
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event: any): void;
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event: any): void;
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event: any): void;
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event: any): void;
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    protected createGhost(pageX: any, pageY: any, node?: any): void;
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    protected dispatchDragEvents(pageX: number, pageY: number, originalEvent: any): void;
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    protected dispatchDropEvent(pageX: number, pageY: number, originalEvent: any): void;
    /**
     * @hidden
     */
    onTransitionEnd(event: any): void;
    /**
     * @hidden
     */
    protected getElementsAtPoint(pageX: number, pageY: number): any;
    /**
     * @hidden
     */
    protected dispatchEvent(target: any, eventName: string, eventArgs: IgxDragCustomEventDetails): void;
    protected getTransformX(elem: any): number;
    protected getTransformY(elem: any): number;
    /** Method setting transformation to the base draggable element. */
    protected setTransformXY(x: number, y: number): void;
    protected getWindowScrollTop(): number;
    protected getWindowScrollLeft(): number;
    protected ghostHostOffsetLeft(ghostHost: any): number;
    protected ghostHostOffsetTop(ghostHost: any): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDragDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDragDirective, "[igxDrag]", ["drag"], {
    "dragTolerance": "dragTolerance";
    "dragDirection": "dragDirection";
    "ghost": "ghost";
    "ghostClass": "ghostClass";
    "ghostOffsetX": "ghostOffsetX";
    "ghostOffsetY": "ghostOffsetY";
    "data": "igxDrag";
    "dragChannel": "dragChannel";
    "ghostTemplate": "ghostTemplate";
    "ghostHost": "ghostHost";
}, {
    "dragStart": "dragStart";
    "dragMove": "dragMove";
    "dragEnd": "dragEnd";
    "dragClick": "dragClick";
    "ghostCreate": "ghostCreate";
    "ghostDestroy": "ghostDestroy";
    "transitioned": "transitioned";
}, ["dragHandles", "dragIgnoredElems"]>;
}
export declare class IgxDropDirective implements OnInit, OnDestroy {
    element: ElementRef;
    private _renderer;
    private _zone;
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * @memberof IgxDropDirective
     */
    data: any;
    /**
     * An @Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * @memberof IgxDropDirective
     */
    dropChannel: number | string | number[] | string[];
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef: any);
    get dropStrategy(): any;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    enter: EventEmitter<IDropBaseEventArgs>;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    over: EventEmitter<IDropBaseEventArgs>;
    /**
     * Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable element has left the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    leave: EventEmitter<IDropBaseEventArgs>;
    /**
     * Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable element has been dropped in the chip area!");
     * }
     * ```
     * @memberof IgxDropDirective
     */
    dropped: EventEmitter<IDropDroppedEventArgs>;
    /**
     * @hidden
     */
    droppable: boolean;
    /**
     * @hidden
     */
    dragover: boolean;
    /**
     * @hidden
     */
    protected _destroy: Subject<boolean>;
    protected _dropStrategy: IDropStrategy;
    constructor(element: ElementRef, _renderer: Renderer2, _zone: NgZone);
    /**
     * @hidden
     */
    ngOnInit(): void;
    /**
     * @hidden
     */
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    onDragOver(event: any): void;
    /**
     * @hidden
     */
    onDragEnter(event: CustomEvent<IgxDragCustomEventDetails>): void;
    /**
     * @hidden
     */
    onDragLeave(event: any): void;
    /**
     * @hidden
     */
    onDragDrop(event: any): void;
    protected getWindowScrollTop(): number;
    protected getWindowScrollLeft(): number;
    protected isDragLinked(drag: IgxDragDirective): boolean;
    protected getInsertIndexAt(draggedDir: IgxDragDirective, elementsAtPoint: any[]): number;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxDropDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<IgxDropDirective, "[igxDrop]", ["drop"], {
    "dropStrategy": "dropStrategy";
    "data": "igxDrop";
    "dropChannel": "dropChannel";
}, {
    "enter": "enter";
    "over": "over";
    "leave": "leave";
    "dropped": "dropped";
}, never>;
}
/**
 * @hidden
 */
export declare class IgxDragDropModule {
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<IgxDragDropModule, [typeof IgxDragDirective, typeof IgxDropDirective, typeof IgxDragHandleDirective, typeof IgxDragIgnoreDirective], never, [typeof IgxDragDirective, typeof IgxDropDirective, typeof IgxDragHandleDirective, typeof IgxDragIgnoreDirective]>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<IgxDragDropModule>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkcmFnLWRyb3AuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0dBOzs7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEpBOzs7Ozs7O0FBS0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFZpZXdDb250YWluZXJSZWYsIEFmdGVyQ29udGVudEluaXQsIFRlbXBsYXRlUmVmLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJRHJvcFN0cmF0ZWd5IH0gZnJvbSAnLi9kcmFnLWRyb3Auc3RyYXRlZ3knO1xuZXhwb3J0IGRlY2xhcmUgZW51bSBEcmFnRGlyZWN0aW9uIHtcbiAgICBWRVJUSUNBTCA9IDAsXG4gICAgSE9SSVpPTlRBTCA9IDEsXG4gICAgQk9USCA9IDJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyB7XG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIG93bmVyOiBJZ3hEcmFnRGlyZWN0aXZlO1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyb3BCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IHRvIGVudGVyIHRoZSBpZ3hEcm9wIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IGFueTtcbiAgICAvKiogVGhlIG93bmVyIGlneERyb3AgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyb3BEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBpZ3hEcmFnIGRpcmVjdGl2ZSBpbnN0YW5jZWQgb24gYW4gZWxlbWVudCB0aGF0IGVudGVyZWQgdGhlIGFyZWEgb2YgdGhlIGlneERyb3AgZWxlbWVudCAqL1xuICAgIGRyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIFRoZSBkYXRhIGNvbnRhaW5lZCBmb3IgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGluIGlneERyYWcgZGlyZWN0aXZlLiAqL1xuICAgIGRyYWdEYXRhOiBhbnk7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFggYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyB3aGVuIHRoZSBkcmFnZ2VkIGVsZW1lbnQgYmVnYW4gbW92aW5nICovXG4gICAgc3RhcnRZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VYOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgdGhhdCBpbml0aWFsaXplcyB0aGUgaWd4RHJvcC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgb2Zmc2V0WDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIG9uIFkgYXhpcyByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyIHRoYXQgaW5pdGlhbGl6ZXMgdGhlIGlneERyb3AuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIG9mZnNldFk6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyb3BEcm9wcGVkRXZlbnRBcmdzIGV4dGVuZHMgSURyb3BCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogU3BlY2lmaWVzIGlmIHRoZSBkZWZhdWx0IGRyb3AgbG9naWMgcmVsYXRlZCB0byB0aGUgZXZlbnQgc2hvdWxkIGJlIGNhbmNlbGVkLiAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB8IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJhZyBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVk6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdTdGFydEV2ZW50QXJncyBleHRlbmRzIElEcmFnQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFNldCBpZiB0aGUgdGhlIGRyYWdnaW5nIHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIElEcmFnTW92ZUV2ZW50QXJncyBleHRlbmRzIElEcmFnU3RhcnRFdmVudEFyZ3Mge1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBYIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmV3IHBhZ2VYIHBvc2l0aW9uIG9mIHRoZSBwb2ludGVyIHRoYXQgdGhlIGlneERyYWcgd2lsbCB1c2UuIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIGxpbWl0IGRyYWdnZWQgZWxlbWVudCBZIG1vdmVtZW50LiAqL1xuICAgIG5leHRQYWdlWTogbnVtYmVyO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0dob3N0QmFzZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogVGhlIG93bmVyIGlneERyYWcgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIEluc3RhbmNlIHRvIHRoZSBnaG9zdCBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cy4gKi9cbiAgICBnaG9zdEVsZW1lbnQ6IGFueTtcbiAgICAvKiogU2V0IGlmIHRoZSBnaG9zdCBjcmVhdGlvbi9kZXN0cnVjdGlvbiBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0N1c3RvbVRyYW5zaXRpb25BcmdzIHtcbiAgICBkdXJhdGlvbj86IG51bWJlcjtcbiAgICB0aW1pbmdGdW5jdGlvbj86IHN0cmluZztcbiAgICBkZWxheT86IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdMb2NhdGlvbiB7XG4gICAgcHJpdmF0ZSBfcGFnZVg7XG4gICAgcHJpdmF0ZSBfcGFnZVk7XG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICBwYWdlWTogbnVtYmVyO1xuICAgIGNvbnN0cnVjdG9yKF9wYWdlWDogYW55LCBfcGFnZVk6IGFueSk7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hEcmFnSGFuZGxlRGlyZWN0aXZlIHtcbiAgICBlbGVtZW50OiBFbGVtZW50UmVmPGFueT47XG4gICAgYmFzZUNsYXNzOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWY8YW55Pik7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hEcmFnSWdub3JlRGlyZWN0aXZlIHtcbiAgICBlbGVtZW50OiBFbGVtZW50UmVmPGFueT47XG4gICAgYmFzZUNsYXNzOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQ6IEVsZW1lbnRSZWY8YW55Pik7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hEcmFnRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIGVsZW1lbnQ6IEVsZW1lbnRSZWY7XG4gICAgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZjtcbiAgICB6b25lOiBOZ1pvbmU7XG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgICBwcm90ZWN0ZWQgZ2hvc3RDb250ZXh0OiBhbnk7XG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJhZ2AgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcmFnYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcmFnXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZGF0YTogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGVuIHRoZSBkcmFnIHNob3VsZCBzdGFydC5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBkcmFnIHN0YXJ0cyBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgbW92ZWQgYnkgNXB4LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdUb2xlcmFuY2U6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBpbmRpY2F0ZXMgdGhlIGRpcmVjdGlvbnMgdGhhdCB0aGUgZWxlbWVudCBjYW4gYmUgZHJhZ2dlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpcmVjdGlvbnMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ0RpcmVjdGlvbl09XCJkcmFnRGlyXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLkhPUklaT05UQUw7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnRGlyZWN0aW9uOiBEcmFnRGlyZWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHByb3ZpZGUgYSB3YXkgZm9yIGlneERyYWcgYW5kIGlneERyb3AgdG8gYmUgbGlua2VkIHRocm91Z2ggY2hhbm5lbHMuXG4gICAgICogSXQgYWNjZXB0cyBzaW5nbGUgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIGFuZCBldmFsdWF0ZXMgdGhlbiB1c2luZyBzdHJpY3QgZXF1YWxpdHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ0NoYW5uZWxdPVwiJ29kZCdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPjk1PC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJvcCBbZHJvcENoYW5uZWxdPVwiWydvZGQnLCAnaXJyYXRpb25hbCddXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5OdW1iZXJzIGRyb3AgYXJlYSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnQ2hhbm5lbDogbnVtYmVyIHwgc3RyaW5nIHwgbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgaWYgdGhlIGJhc2UgZWxlbWVudCBzaG91bGQgbm90IGJlIG1vdmVkIGFuZCBhIGdob3N0IGVsZW1lbnQgc2hvdWxkIGJlIHJlbmRlcmVkIHRoYXQgcmVwcmVzZW50cyBpdC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICogSWYgaXQgaXMgc2V0IHRvIGBmYWxzZWAgd2hlbiBkcmFnZ2luZyB0aGUgYmFzZSBlbGVtZW50IGlzIG1vdmVkIGluc3RlYWQgYW5kIG5vIGdob3N0IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdF09XCJmYWxzZVwiPlxuICAgICAqICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGNsYXNzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGdob3N0RWxlbWVudGAgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdENsYXNzXT1cIidnaG9zdEVsZW1lbnQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGdob3N0Q2xhc3M6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgYSB0ZW1wbGF0ZSBmb3IgdGhlIGdob3N0IGVsZW1lbnQgY3JlYXRlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYGdob3N0YCBpcyB0cnVlLlxuICAgICAqIEJ5IGRlZmF1bHQgYSBjbG9uZSBvZiB0aGUgYmFzZSBlbGVtZW50IHRoZSBpZ3hEcmFnIGlzIGluc3RhbmNlZCBpcyBjcmVhdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0VGVtcGxhdGVdPVwiY3VzdG9tR2hvc3RcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIDxuZy10ZW1wbGF0ZSAjY3VzdG9tR2hvc3Q+XG4gICAgICogICAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tR2hvc3RTdHlsZVwiPlxuICAgICAqICAgICAgICAgIDxzcGFuPkkgYW0gYmVpbmcgZHJhZ2dlZCE8L3NwYW4+XG4gICAgICogICAgICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZ2hvc3RUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3Mgc2V0IHRvIG51bGwgYW5kIHRoZSBkcmFnZ2VkIGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIGJvZHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgI2hvc3REaXY+PC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdEhvc3RdPVwiaG9zdERpdlwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdEhvc3Q6IGFueTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBtb3VzZSBpbiBwaXhlbHMuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHRha2luZyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIG1vdXNlIHdoZW4gdGhlIGRyYWcgc3RhcnRlZCBhbmQga2VlcHMgaXQgdGhlIHNhbWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgI2hvc3REaXY+PC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdE9mZnNldFhdPVwiMFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBzZXQgZ2hvc3RPZmZzZXRYKHZhbHVlOiBhbnkpO1xuICAgIGdldCBnaG9zdE9mZnNldFgoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIG1vdXNlIGluIHBpeGVscy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3MgdGFraW5nIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgbW91c2Ugd2hlbiB0aGUgZHJhZyBzdGFydGVkIGFuZCBrZWVwcyBpdCB0aGUgc2FtZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0T2Zmc2V0WV09XCIwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIHNldCBnaG9zdE9mZnNldFkodmFsdWU6IGFueSk7XG4gICAgZ2V0IGdob3N0T2Zmc2V0WSgpOiBhbnk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGRyYWcgc3RhcnRzLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGRyYWdTdGFydCk9XCJvbkRyYWdTdGFydCgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ1N0YXJ0KCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBkcmFnIGhhcyBzdGFyZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyYWdTdGFydDogRXZlbnRFbWl0dGVyPElEcmFnU3RhcnRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBtb3ZlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnICAoZHJhZ01vdmUpPVwib25EcmFnTW92ZSgpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ01vdmUoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGVsZW1lbnQgaGFzIG1vdmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcmFnTW92ZTogRXZlbnRFbWl0dGVyPElEcmFnTW92ZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIHJlbGVhc2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGRyYWdFbmQpPVwib25EcmFnRW5kKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnRW5kKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBkcmFnIGhhcyBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJhZ0VuZDogRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZHJhZ0NsaWNrKT1cIm9uRHJhZ0NsaWNrKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnQ2xpY2soKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGVsZW1lbnQgaGFzIGJlZW4gY2xpY2tlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZHJhZ0NsaWNrOiBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZyBnaG9zdCBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZ2hvc3RDcmVhdGUpPVwiZ2hvc3RDcmVhdGVkKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ2hvc3RDcmVhdGVkKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBnaG9zdCBoYXMgYmVlbiBjcmVhdGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBnaG9zdENyZWF0ZTogRXZlbnRFbWl0dGVyPElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzPjtcbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZyBnaG9zdCBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZ2hvc3REZXN0cm95KT1cImdob3N0RGVzdHJveWVkKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ2hvc3REZXN0cm95ZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGdob3N0IGhhcyBiZWVuIGRlc3Ryb3llZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgZ2hvc3REZXN0cm95OiBFdmVudEVtaXR0ZXI8SURyYWdHaG9zdEJhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCBhZnRlciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaXMgcmVsZWFzZWQgYW5kIGFmdGVyIGl0cyBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKHRyYW5zaXRpb25lZCk9XCJvbk1vdmVFbmQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbk1vdmVFbmQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIG1vdmUgaGFzIGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uZWQ6IEV2ZW50RW1pdHRlcjxJRHJhZ0Jhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkcmFnSGFuZGxlczogUXVlcnlMaXN0PElneERyYWdIYW5kbGVEaXJlY3RpdmU+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkcmFnSWdub3JlZEVsZW1zOiBRdWVyeUxpc3Q8SWd4RHJhZ0lnbm9yZURpcmVjdGl2ZT47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGJhc2VDbGFzczogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgc2VsZWN0RGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBvZiB0aGUgZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgbG9jYXRpb24oKTogSWd4RHJhZ0xvY2F0aW9uO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBlbGVtZW50IGJlZm9yZSBkcmFnZ2luZyBzdGFydGVkLlxuICAgICAqL1xuICAgIGdldCBvcmlnaW5Mb2NhdGlvbigpOiBJZ3hEcmFnTG9jYXRpb247XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwb2ludGVyRXZlbnRzRW5hYmxlZCgpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdG91Y2hFdmVudHNFbmFibGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwYWdlWCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBwYWdlWSgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdldCBiYXNlTGVmdCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdldCBiYXNlVG9wKCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VPcmlnaW5MZWZ0KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VPcmlnaW5Ub3AoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBzZXQgZ2hvc3RMZWZ0KHBhZ2VYOiBudW1iZXIpO1xuICAgIHByb3RlY3RlZCBnZXQgZ2hvc3RMZWZ0KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgc2V0IGdob3N0VG9wKHBhZ2VZOiBudW1iZXIpO1xuICAgIHByb3RlY3RlZCBnZXQgZ2hvc3RUb3AoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkZWZhdWx0UmV0dXJuRHVyYXRpb246IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50OiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGFuaW1JblByb2dyZXNzOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBfc3RhcnRYOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9zdGFydFk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgX2xhc3RYOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9sYXN0WTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfZHJhZ1N0YXJ0ZWQ6IGJvb2xlYW47XG4gICAgLyoqIERyYWcgZ2hvc3QgcmVsYXRlZCBwcm9wZXJ0aWVzICovXG4gICAgcHJvdGVjdGVkIF9kZWZhdWx0T2Zmc2V0WDogYW55O1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE9mZnNldFk6IGFueTtcbiAgICBwcm90ZWN0ZWQgX29mZnNldFg6IGFueTtcbiAgICBwcm90ZWN0ZWQgX29mZnNldFk6IGFueTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0U3RhcnRYOiBhbnk7XG4gICAgcHJvdGVjdGVkIF9naG9zdFN0YXJ0WTogYW55O1xuICAgIHByb3RlY3RlZCBfZ2hvc3RIb3N0WDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RIb3N0WTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfcG9pbnRlckRvd25JZDogYW55O1xuICAgIHByb3RlY3RlZCBfY2xpY2tlZDogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgX2xhc3REcm9wQXJlYTogYW55O1xuICAgIHByb3RlY3RlZCBfZGVzdHJveTogU3ViamVjdDxib29sZWFuPjtcbiAgICBwcm90ZWN0ZWQgX3JlbW92ZU9uRGVzdHJveTogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3RvcihjZHI6IENoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50OiBFbGVtZW50UmVmLCB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCB6b25lOiBOZ1pvbmUsIHJlbmRlcmVyOiBSZW5kZXJlcjIpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTZXRzIGRlc2lyZWQgbG9jYXRpb24gb2YgdGhlIGJhc2UgZWxlbWVudCBvciBnaG9zdCBlbGVtZW50IGlmIHJlbmRlZCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIG5ld0xvY2F0aW9uIE5ldyBsb2NhdGlvbiB0aGF0IHNob3VsZCBiZSBhcHBsaWVkLiBJdCBpcyBhZHZpc2VkIHRvIGdldCBuZXcgbG9jYXRpb24gdXNpbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0cygpICsgc2Nyb2xsLlxuICAgICAqL1xuICAgIHNldExvY2F0aW9uKG5ld0xvY2F0aW9uOiBJZ3hEcmFnTG9jYXRpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBiYXNlIG9yIGdob3N0IGVsZW1lbnQgZGVwZW5kaW5nIG9uIHRoZSBgZ2hvc3RgIGlucHV0IHRvIGl0cyBpbml0aWFsIGxvY2F0aW9uLlxuICAgICAqIElmIGBnaG9zdGAgaXMgdHJ1ZSBidXQgdGhlcmUgaXMgbm90IGdob3N0IHJlbmRlcmVkLCBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFuaW1hdGVkLlxuICAgICAqIElmIHRoZSBiYXNlIGVsZW1lbnQgaGFzIGNoYW5nZWQgaXRzIERPTSBwb3NpdGlvbiBpdHMgaW5pdGlhbCBsb2NhdGlvbiB3aWxsIGJlIGNoYW5nZWQgYWNjb3JkaW5nbHkuXG4gICAgICogQHBhcmFtIGN1c3RvbUFuaW1BcmdzIEN1c3RvbSB0cmFuc2l0aW9uIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBzdGFydExvY2F0aW9uIFN0YXJ0IGxvY2F0aW9uIGZyb20gd2hlcmUgdGhlIHRyYW5zaXRpb24gc2hvdWxkIHN0YXJ0LlxuICAgICAqL1xuICAgIHRyYW5zaXRpb25Ub09yaWdpbihjdXN0b21BbmltQXJncz86IElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3MsIHN0YXJ0TG9jYXRpb24/OiBJZ3hEcmFnTG9jYXRpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEFuaW1hdGVzIHRoZSBiYXNlIG9yIGdob3N0IGVsZW1lbnQgdG8gYSBzcGVjaWZpYyB0YXJnZXQgbG9jYXRpb24gb3Igb3RoZXIgZWxlbWVudCB1c2luZyB0cmFuc2l0aW9uLlxuICAgICAqIElmIGBnaG9zdGAgaXMgdHJ1ZSBidXQgdGhlcmUgaXMgbm90IGdob3N0IHJlbmRlcmVkLCBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFuaW1hdGVkLlxuICAgICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0cygpICsgcGFnZVNjcm9sbCcgd2hlbiBkZXRlcm1pbmluZyBkZXNpcmVkIGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IHRoYXQgdGhlIGJhc2Ugb3IgZ2hvc3Qgd2lsbCB0cmFuc2l0aW9uIHRvLiBJdCBjYW4gYmUgZWl0aGVyIGxvY2F0aW9uIGluIHRoZSBwYWdlIG9yIGFub3RoZXIgSFRNTCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBjdXN0b21BbmltQXJncyBDdXN0b20gdHJhbnNpdGlvbiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHdoZW4gcGVyZm9ybWluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0gc3RhcnRMb2NhdGlvbiBTdGFydCBsb2NhdGlvbiBmcm9tIHdoZXJlIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBzdGFydC5cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG8odGFyZ2V0OiBJZ3hEcmFnTG9jYXRpb24gfCBFbGVtZW50UmVmLCBjdXN0b21BbmltQXJncz86IElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3MsIHN0YXJ0TG9jYXRpb24/OiBJZ3hEcmFnTG9jYXRpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBNZXRob2QgYm91bmQgdG8gdGhlIFBvaW50ZXJEb3duIGV2ZW50IG9mIHRoZSBiYXNlIGVsZW1lbnQgaWd4RHJhZyBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlckRvd24gZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBvblBvaW50ZXJEb3duKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBQZXJmb3JtIGRyYWcgbW92ZSBsb2dpYyB3aGVuIGRyYWdnaW5nIGFuZCBkaXNwYXRjaGluZyBldmVudHMgaWYgdGhlcmUgaXMgaWd4RHJvcCB1bmRlciB0aGUgcG9pbnRlci5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCBhdCBmaXJzdCBhdCB0aGUgYmFzZSBlbGVtZW50LlxuICAgICAqIElmIGRyYWdnaW5nIHN0YXJ0cyBhbmQgYWZ0ZXIgdGhlIGdob3N0RWxlbWVudCBpcyByZW5kZXJlZCB0aGUgcG9pbnRlcklkIGlzIHJlYXNzaWduZWQgaXQuIFRoZW4gdGhpcyBtZXRob2QgaXMgYm91bmQgdG8gaXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJNb3ZlIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgb25Qb2ludGVyTW92ZShldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogUGVyZm9ybSBkcmFnIGVuZCBsb2dpYyB3aGVuIHJlbGVhc2luZyB0aGUgZ2hvc3RFbGVtZW50IGFuZCBkaXNwYXRjaGluZyBkcm9wIGV2ZW50IGlmIGlneERyb3AgaXMgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgYXQgZmlyc3QgYXQgdGhlIGJhc2UgZWxlbWVudC5cbiAgICAgKiBJZiBkcmFnZ2luZyBzdGFydHMgYW5kIGFmdGVyIHRoZSBnaG9zdEVsZW1lbnQgaXMgcmVuZGVyZWQgdGhlIHBvaW50ZXJJZCBpcyByZWFzc2lnbmVkIHRvIGl0LiBUaGVuIHRoaXMgbWV0aG9kIGlzIGJvdW5kIHRvIGl0LlxuICAgICAqIEBwYXJhbSBldmVudCBQb2ludGVyVXAgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBvblBvaW50ZXJVcChldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRXhlY3V0ZSB0aGlzIG1ldGhvZCB3aGUgdGhlIHBvaW50ZXIgY2FwdHVyZSBoYXMgYmVlbiBsb3N0LlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCBkdXJpbmcgZHJhZ2dpbmcgdGhlIHVzZXIgaGFzIHBlcmZvcm1lZCBvdGhlciBhY3Rpb24gbGlrZSByaWdodCBjbGlja2luZyBhbmQgdGhlbiBjbGlja2luZyBzb21ld2hlcmUgZWxzZS5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGVuc3VyZSB0aGF0IHRoZSBkcmFnIHN0YXRlIGlzIGJlaW5nIHJlc2V0IGluIHRoaXMgY2FzZSBhcyBpZiB0aGUgdXNlciByZWxlYXNlZCB0aGUgZHJhZ2dlZCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBFdmVudCBjYXB0dXJlZFxuICAgICAqL1xuICAgIG9uUG9pbnRlckxvc3QoZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIENyZWF0ZSBnaG9zdCBlbGVtZW50IC0gaWYgYSBOb2RlIG9iamVjdCBpcyBwcm92aWRlZCBpdCBjcmVhdGVzIGEgY2xvbmUgb2YgdGhhdCBub2RlLFxuICAgICAqIG90aGVyd2lzZSBpdCBjbG9uZXMgdGhlIGhvc3QgZWxlbWVudC5cbiAgICAgKiBCaW5kIGFsbCBuZWVkZWQgZXZlbnRzLlxuICAgICAqIEBwYXJhbSBwYWdlWCBMYXRlc3QgcG9pbnRlciBwb3NpdGlvbiBvbiB0aGUgWCBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSBwYWdlWSBMYXRlc3QgcG9pbnRlciBwb3NpdGlvbiBvbiB0aGUgWSBheGlzIHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBOb2RlIG9iamVjdCB0byBiZSBjbG9uZWQuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUdob3N0KHBhZ2VYOiBhbnksIHBhZ2VZOiBhbnksIG5vZGU/OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJhZ0VudGVyL2lneERyYWdMZWF2ZSBldmVudHMgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBpZiBkcm9wIGFyZWEgaXMgdW5kZXIuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJhZ0V2ZW50cyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBvcmlnaW5hbEV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gaWd4RHJvcCBldmVudCBiYXNlZCBvbiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gaWYgdGhlcmUgaXMgbGFzdCByZWNvcmRlciBkcm9wIGFyZWEgdW5kZXIgdGhlIHBvaW50ZXIuXG4gICAgICogTGFzdCByZWNvcmRlciBkcm9wIGFyZWEgaXMgdXBkYXRlZCBpbiBAZGlzcGF0Y2hEcmFnRXZlbnRzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGlzcGF0Y2hEcm9wRXZlbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgb3JpZ2luYWxFdmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25UcmFuc2l0aW9uRW5kKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpOiBhbnk7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaEV2ZW50KHRhcmdldDogYW55LCBldmVudE5hbWU6IHN0cmluZywgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgZ2V0VHJhbnNmb3JtWChlbGVtOiBhbnkpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGdldFRyYW5zZm9ybVkoZWxlbTogYW55KTogbnVtYmVyO1xuICAgIC8qKiBNZXRob2Qgc2V0dGluZyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgYmFzZSBkcmFnZ2FibGUgZWxlbWVudC4gKi9cbiAgICBwcm90ZWN0ZWQgc2V0VHJhbnNmb3JtWFkoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxUb3AoKTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxMZWZ0KCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2hvc3RIb3N0T2Zmc2V0TGVmdChnaG9zdEhvc3Q6IGFueSk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2hvc3RIb3N0T2Zmc2V0VG9wKGdob3N0SG9zdDogYW55KTogbnVtYmVyO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4RHJvcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBlbGVtZW50OiBFbGVtZW50UmVmO1xuICAgIHByaXZhdGUgX3JlbmRlcmVyO1xuICAgIHByaXZhdGUgX3pvbmU7XG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJvcGAgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcm9wYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcm9wXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgZGF0YTogYW55O1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHByb3ZpZGUgYSB3YXkgZm9yIGlneERyYWcgYW5kIGlneERyb3AgdG8gYmUgbGlua2VkIHRocm91Z2ggY2hhbm5lbHMuXG4gICAgICogSXQgYWNjZXB0cyBzaW5nbGUgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzIGFuZCBldmFsdWF0ZXMgdGhlbiB1c2luZyBzdHJpY3QgZXF1YWxpdHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ0NoYW5uZWxdPVwiJ29kZCdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPjk1PC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIDxkaXYgaWd4RHJvcCBbZHJvcENoYW5uZWxdPVwiWydvZGQnLCAnaXJyYXRpb25hbCddXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5OdW1iZXJzIGRyb3AgYXJlYSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBkcm9wQ2hhbm5lbDogbnVtYmVyIHwgc3RyaW5nIHwgbnVtYmVyW10gfCBzdHJpbmdbXTtcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgYSBkcm9wIHN0cmF0ZWd5IHR5cGUgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYElneERyYWdgIGVsZW1lbnQgaXMgcmVsZWFzZWQgaW5zaWRlXG4gICAgICogIHRoZSBjdXJyZW50IGRyb3AgYXJlYS4gVGhlIHByb3ZpZGVkIHN0cmF0ZWdpZXMgYXJlOlxuICAgICAqICAtIElneERlZmF1bHREcm9wU3RyYXRlZ3kgLSBUaGlzIGlzIHRoZSBkZWZhdWx0IGJhc2Ugc3RyYXRlZ3kgYW5kIGl0IGRvZXNuJ3QgcGVyZm9ybSBhbnkgYWN0aW9ucy5cbiAgICAgKiAgLSBJZ3hBcHBlbmREcm9wU3RyYXRlZ3kgLSBBcHBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgdG8gbGFzdCBwb3NpdGlvbiBhcyBhIGRpcmVjdCBjaGlsZCB0byB0aGUgYGlneERyb3BgLlxuICAgICAqICAtIElneFByZXBlbmREcm9wU3RyYXRlZ3kgLSBQcmVwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IHRvIGZpcnN0IHBvc2l0aW9uIGFzIGEgZGlyZWN0IGNoaWxkIHRvIHRoZSBgaWd4RHJvcGAuXG4gICAgICogIC0gSWd4SW5zZXJ0RHJvcFN0cmF0ZWd5IC0gSWYgdGhlIGRyb3BwZWQgZWxlbWVudCBpcyByZWxlYXNlZCBhYm92ZSBhIGNoaWxkIGVsZW1lbnQgb2YgdGhlIGBpZ3hEcm9wYCwgaXQgd2lsbCBiZSBpbnNlcnRlZFxuICAgICAqICAgICAgYXQgdGhhdCBwb3NpdGlvbi4gT3RoZXJ3aXNlIHRoZSBkcm9wcGVkIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZCBpZiByZWxlYXNlZCBvdXRzaWRlIGFueSBjaGlsZCBvZiB0aGUgYGlneERyb3BgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWc+XG4gICAgICogICAgICA8c3Bhbj5EcmFnTWU8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcm9wIFtkcm9wU3RyYXRlZ3ldPVwibXlEcm9wU3RyYXRlZ3lcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPk51bWJlcnMgZHJvcCBhcmVhITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgSWd4QXBwZW5kRHJvcFN0cmF0ZWd5IH0gZnJvbSAnaWduaXRldWktYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwIHtcbiAgICAgKiAgICAgIHB1YmxpYyBteURyb3BTdHJhdGVneSA9IElneEFwcGVuZERyb3BTdHJhdGVneTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBzZXQgZHJvcFN0cmF0ZWd5KGNsYXNzUmVmOiBhbnkpO1xuICAgIGdldCBkcm9wU3RyYXRlZ3koKTogYW55O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBlbnRlcnMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKGVudGVyKT1cImRyYWdFbnRlcigpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdFbnRlcigpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnQgaGFzIGVudGVyZWQgdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgZW50ZXI6IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBlbnRlcnMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKGVudGVyKT1cImRyYWdFbnRlcigpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdFbnRlcigpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnQgaGFzIGVudGVyZWQgdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgb3ZlcjogRXZlbnRFbWl0dGVyPElEcm9wQmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGxlYXZlcyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAobGVhdmUpPVwiZHJhZ0xlYXZlKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0xlYXZlKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgbGVmdCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBsZWF2ZTogRXZlbnRFbWl0dGVyPElEcm9wQmFzZUV2ZW50QXJncz47XG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQgaW4gdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogU2luY2UgdGhlIGBpZ3hEcm9wYCBoYXMgZGVmYXVsdCBsb2dpYyB0aGF0IGFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCBhcyBhIGNoaWxkLCBpdCBjYW4gYmUgY2FuY2VsZWQgaGVyZS5cbiAgICAgKiBUbyBjYW5jZWwgdGhlIGRlZmF1bHQgbG9naWMgdGhlIGBjYW5jZWxgIHByb3BlcnR5IG9mIHRoZSBldmVudCBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZHJvcHBlZCk9XCJkcmFnRHJvcCgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEcm9wKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBkcm9wcGVkIGluIHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIGRyb3BwZWQ6IEV2ZW50RW1pdHRlcjxJRHJvcERyb3BwZWRFdmVudEFyZ3M+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBkcm9wcGFibGU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGRyYWdvdmVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2Rlc3Ryb3k6IFN1YmplY3Q8Ym9vbGVhbj47XG4gICAgcHJvdGVjdGVkIF9kcm9wU3RyYXRlZ3k6IElEcm9wU3RyYXRlZ3k7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudFJlZiwgX3JlbmRlcmVyOiBSZW5kZXJlcjIsIF96b25lOiBOZ1pvbmUpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdPdmVyKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvbkRyYWdMZWF2ZShldmVudDogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgb25EcmFnRHJvcChldmVudDogYW55KTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsVG9wKCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgZ2V0V2luZG93U2Nyb2xsTGVmdCgpOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGlzRHJhZ0xpbmtlZChkcmFnOiBJZ3hEcmFnRGlyZWN0aXZlKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgZ2V0SW5zZXJ0SW5kZXhBdChkcmFnZ2VkRGlyOiBJZ3hEcmFnRGlyZWN0aXZlLCBlbGVtZW50c0F0UG9pbnQ6IGFueVtdKTogbnVtYmVyO1xufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIElneERyYWdEcm9wTW9kdWxlIHtcbn1cbiJdfQ==