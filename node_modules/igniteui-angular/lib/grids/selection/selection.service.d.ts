import { EventEmitter, NgZone } from '@angular/core';
import { IGridEditEventArgs } from '../common/events';
import * as ɵngcc0 from '@angular/core';
export interface GridSelectionRange {
    rowStart: number;
    rowEnd: number;
    columnStart: string | number;
    columnEnd: string | number;
}
export interface ISelectionNode {
    row: number;
    column: number;
    layout?: IMultiRowLayoutNode;
    isSummaryRow?: boolean;
}
export interface IMultiRowLayoutNode {
    rowStart: number;
    colStart: number;
    rowEnd: number;
    colEnd: number;
    columnVisibleIndex: number;
}
interface ISelectionKeyboardState {
    node: null | ISelectionNode;
    shift: boolean;
    range: GridSelectionRange;
    active: boolean;
}
interface ISelectionPointerState extends ISelectionKeyboardState {
    ctrl: boolean;
    primaryButton: boolean;
}
interface IColumnSelectionState {
    field: null | string;
    range: string[];
}
declare type SelectionState = ISelectionKeyboardState | ISelectionPointerState;
export declare class IgxRow {
    id: any;
    index: number;
    data: any;
    transactionState: any;
    state: any;
    newData: any;
    constructor(id: any, index: number, data: any);
    createEditEventArgs(): IGridEditEventArgs;
}
export declare class IgxCell {
    id: any;
    rowIndex: number;
    column: any;
    value: any;
    editValue: any;
    rowData: any;
    primaryKey: any;
    state: any;
    constructor(id: any, rowIndex: number, column: any, value: any, editValue: any, rowData: any);
    castToNumber(value: any): any;
    createEditEventArgs(): IGridEditEventArgs;
}
export declare class IgxGridCRUDService {
    grid: any;
    cell: IgxCell | null;
    row: IgxRow | null;
    isInCompositionMode: boolean;
    createCell(cell: any): IgxCell;
    createRow(cell: IgxCell): IgxRow;
    sameRow(rowID: any): boolean;
    sameCell(cell: IgxCell): boolean;
    get inEditMode(): boolean;
    get rowEditing(): boolean;
    get primaryKey(): any;
    beginRowEdit(): void;
    endRowEdit(): void;
    begin(cell: any): void;
    end(): void;
    enterEditMode(cell: any): void;
    exitEditMode(): void;
    isInEditMode(rowIndex: number, columnIndex: number): boolean;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxGridCRUDService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IgxGridCRUDService>;
}
export declare class IgxGridSelectionService {
    private zone;
    grid: any;
    dragMode: boolean;
    activeElement: ISelectionNode | null;
    keyboardState: ISelectionKeyboardState;
    pointerState: ISelectionPointerState;
    columnsState: IColumnSelectionState;
    selection: Map<number, Set<number>>;
    temp: Map<number, Set<number>>;
    _ranges: Set<string>;
    _selectionRange: Range;
    rowSelection: Set<any>;
    columnSelection: Set<string>;
    private allRowsSelected;
    /**
     * Returns the current selected ranges in the grid from both
     * keyboard and pointer interactions
     */
    get ranges(): GridSelectionRange[];
    get primaryButton(): boolean;
    set primaryButton(value: boolean);
    constructor(zone: NgZone);
    /**
     * Resets the keyboard state
     */
    initKeyboardState(): void;
    /**
     * Resets the pointer state
     */
    initPointerState(): void;
    /**
     * Resets the columns state
     */
    initColumnsState(): void;
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     */
    add(node: ISelectionNode, addToRange?: boolean): void;
    /**
     * Adds the active keyboard range selection (if any) to the `ranges` meta.
     */
    addKeyboardRange(): void;
    remove(node: ISelectionNode): void;
    isInMap(node: ISelectionNode): boolean;
    selected(node: ISelectionNode): boolean;
    isActiveNode(node: ISelectionNode): boolean;
    isActiveLayout(current: IMultiRowLayoutNode, target: IMultiRowLayoutNode): boolean;
    addRangeMeta(node: ISelectionNode, state?: SelectionState): void;
    removeRangeMeta(node: ISelectionNode, state?: SelectionState): void;
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     */
    generateRange(node: ISelectionNode, state?: SelectionState): GridSelectionRange;
    /**
     *
     */
    keyboardStateOnKeydown(node: ISelectionNode, shift: boolean, shiftTab: boolean): void;
    keyboardStateOnFocus(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>, dom: any): void;
    pointerDown(node: ISelectionNode, shift: boolean, ctrl: boolean): void;
    pointerDownShiftKey(node: ISelectionNode): void;
    mergeMap(target: Map<number, Set<number>>, source: Map<number, Set<number>>): void;
    pointerEnter(node: ISelectionNode, event: PointerEvent): boolean;
    pointerUp(node: ISelectionNode, emitter: EventEmitter<GridSelectionRange>): boolean;
    selectRange(node: ISelectionNode, state: SelectionState, collection?: Map<number, Set<number>>): void;
    dragSelect(node: ISelectionNode, state: SelectionState): void;
    clear(clearAcriveEl?: boolean): void;
    clearTextSelection(): void;
    restoreTextSelection(): void;
    /**
     * (╯°□°）╯︵ ┻━┻
     * Chrome and Chromium don't care about the active
     * range after keyboard navigation, thus this.
     */
    _moveSelectionChrome(node: Node): void;
    /** Returns array of the selected row id's. */
    getSelectedRows(): Array<any>;
    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
    clearRowSelection(event?: any): void;
    /** Select all rows, if filtering is applied select only from filtered data. */
    selectAllRows(event?: any): void;
    /** Select the specified row and emit event. */
    selectRowById(rowID: any, clearPrevSelection?: any, event?: any): void;
    /** Deselect the specified row and emit event. */
    deselectRow(rowID: any, event?: any): void;
    /** Select specified rows. No event is emitted. */
    selectRowsWithNoEvent(rowIDs: any[], clearPrevSelection?: any): void;
    /** Deselect specified rows. No event is emitted. */
    deselectRowsWithNoEvent(rowIDs: any[]): void;
    isRowSelected(rowID: any): boolean;
    /** Select range from last selected row to the current specified row. */
    selectMultipleRows(rowID: any, rowData: any, event?: any): void;
    areAllRowSelected(): boolean;
    hasSomeRowSelected(): boolean;
    get filteredSelectedRowIds(): any[];
    emitRowSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;
    getRowDataById(rowID: any): Object;
    getRowIDs(data: any): Array<any>;
    clearHeaderCBState(): void;
    /** Clear rowSelection and update checkbox state */
    clearAllSelectedRows(): void;
    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
    get allData(): Array<any>;
    private areEqualCollections;
    private isFilteringApplied;
    private isRowDeleted;
    /** Returns array of the selected columns fields. */
    getSelectedColumns(): Array<any>;
    isColumnSelected(field: string): boolean;
    /** Select the specified column and emit event. */
    selectColumn(field: string, clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;
    /** Select specified columns. And emit event. */
    selectColumns(fields: string[], clearPrevSelection?: any, selectColumnsRange?: any, event?: any): void;
    /** Select range from last clicked column to the current specified column. */
    selectColumnsRange(field: string, event: any): void;
    /** Select specified columns. No event is emitted. */
    selectColumnsWithNoEvent(fields: string[], clearPrevSelection?: any): void;
    /** Deselect the specified column and emit event. */
    deselectColumn(field: string, event?: any): void;
    /** Deselect specified columns. No event is emitted. */
    deselectColumnsWithNoEvent(fields: string[]): void;
    /** Deselect specified columns. And emit event. */
    deselectColumns(fields: string[], event?: any): void;
    emitColumnSelectionEvent(newSelection: any, added: any, removed: any, event?: any): boolean;
    /** Clear columnSelection */
    clearAllSelectedColumns(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxGridSelectionService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IgxGridSelectionService>;
}
export declare function isChromium(): boolean;
export {};

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsic2VsZWN0aW9uLnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0lBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElHcmlkRWRpdEV2ZW50QXJncyB9IGZyb20gJy4uL2NvbW1vbi9ldmVudHMnO1xuZXhwb3J0IGludGVyZmFjZSBHcmlkU2VsZWN0aW9uUmFuZ2Uge1xuICAgIHJvd1N0YXJ0OiBudW1iZXI7XG4gICAgcm93RW5kOiBudW1iZXI7XG4gICAgY29sdW1uU3RhcnQ6IHN0cmluZyB8IG51bWJlcjtcbiAgICBjb2x1bW5FbmQ6IHN0cmluZyB8IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSVNlbGVjdGlvbk5vZGUge1xuICAgIHJvdzogbnVtYmVyO1xuICAgIGNvbHVtbjogbnVtYmVyO1xuICAgIGxheW91dD86IElNdWx0aVJvd0xheW91dE5vZGU7XG4gICAgaXNTdW1tYXJ5Um93PzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgSU11bHRpUm93TGF5b3V0Tm9kZSB7XG4gICAgcm93U3RhcnQ6IG51bWJlcjtcbiAgICBjb2xTdGFydDogbnVtYmVyO1xuICAgIHJvd0VuZDogbnVtYmVyO1xuICAgIGNvbEVuZDogbnVtYmVyO1xuICAgIGNvbHVtblZpc2libGVJbmRleDogbnVtYmVyO1xufVxuaW50ZXJmYWNlIElTZWxlY3Rpb25LZXlib2FyZFN0YXRlIHtcbiAgICBub2RlOiBudWxsIHwgSVNlbGVjdGlvbk5vZGU7XG4gICAgc2hpZnQ6IGJvb2xlYW47XG4gICAgcmFuZ2U6IEdyaWRTZWxlY3Rpb25SYW5nZTtcbiAgICBhY3RpdmU6IGJvb2xlYW47XG59XG5pbnRlcmZhY2UgSVNlbGVjdGlvblBvaW50ZXJTdGF0ZSBleHRlbmRzIElTZWxlY3Rpb25LZXlib2FyZFN0YXRlIHtcbiAgICBjdHJsOiBib29sZWFuO1xuICAgIHByaW1hcnlCdXR0b246IGJvb2xlYW47XG59XG5pbnRlcmZhY2UgSUNvbHVtblNlbGVjdGlvblN0YXRlIHtcbiAgICBmaWVsZDogbnVsbCB8IHN0cmluZztcbiAgICByYW5nZTogc3RyaW5nW107XG59XG5kZWNsYXJlIHR5cGUgU2VsZWN0aW9uU3RhdGUgPSBJU2VsZWN0aW9uS2V5Ym9hcmRTdGF0ZSB8IElTZWxlY3Rpb25Qb2ludGVyU3RhdGU7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hSb3cge1xuICAgIGlkOiBhbnk7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICBkYXRhOiBhbnk7XG4gICAgdHJhbnNhY3Rpb25TdGF0ZTogYW55O1xuICAgIHN0YXRlOiBhbnk7XG4gICAgbmV3RGF0YTogYW55O1xuICAgIGNvbnN0cnVjdG9yKGlkOiBhbnksIGluZGV4OiBudW1iZXIsIGRhdGE6IGFueSk7XG4gICAgY3JlYXRlRWRpdEV2ZW50QXJncygpOiBJR3JpZEVkaXRFdmVudEFyZ3M7XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hDZWxsIHtcbiAgICBpZDogYW55O1xuICAgIHJvd0luZGV4OiBudW1iZXI7XG4gICAgY29sdW1uOiBhbnk7XG4gICAgdmFsdWU6IGFueTtcbiAgICBlZGl0VmFsdWU6IGFueTtcbiAgICByb3dEYXRhOiBhbnk7XG4gICAgcHJpbWFyeUtleTogYW55O1xuICAgIHN0YXRlOiBhbnk7XG4gICAgY29uc3RydWN0b3IoaWQ6IGFueSwgcm93SW5kZXg6IG51bWJlciwgY29sdW1uOiBhbnksIHZhbHVlOiBhbnksIGVkaXRWYWx1ZTogYW55LCByb3dEYXRhOiBhbnkpO1xuICAgIGNhc3RUb051bWJlcih2YWx1ZTogYW55KTogYW55O1xuICAgIGNyZWF0ZUVkaXRFdmVudEFyZ3MoKTogSUdyaWRFZGl0RXZlbnRBcmdzO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4R3JpZENSVURTZXJ2aWNlIHtcbiAgICBncmlkOiBhbnk7XG4gICAgY2VsbDogSWd4Q2VsbCB8IG51bGw7XG4gICAgcm93OiBJZ3hSb3cgfCBudWxsO1xuICAgIGlzSW5Db21wb3NpdGlvbk1vZGU6IGJvb2xlYW47XG4gICAgY3JlYXRlQ2VsbChjZWxsOiBhbnkpOiBJZ3hDZWxsO1xuICAgIGNyZWF0ZVJvdyhjZWxsOiBJZ3hDZWxsKTogSWd4Um93O1xuICAgIHNhbWVSb3cocm93SUQ6IGFueSk6IGJvb2xlYW47XG4gICAgc2FtZUNlbGwoY2VsbDogSWd4Q2VsbCk6IGJvb2xlYW47XG4gICAgZ2V0IGluRWRpdE1vZGUoKTogYm9vbGVhbjtcbiAgICBnZXQgcm93RWRpdGluZygpOiBib29sZWFuO1xuICAgIGdldCBwcmltYXJ5S2V5KCk6IGFueTtcbiAgICBiZWdpblJvd0VkaXQoKTogdm9pZDtcbiAgICBlbmRSb3dFZGl0KCk6IHZvaWQ7XG4gICAgYmVnaW4oY2VsbDogYW55KTogdm9pZDtcbiAgICBlbmQoKTogdm9pZDtcbiAgICBlbnRlckVkaXRNb2RlKGNlbGw6IGFueSk6IHZvaWQ7XG4gICAgZXhpdEVkaXRNb2RlKCk6IHZvaWQ7XG4gICAgaXNJbkVkaXRNb2RlKHJvd0luZGV4OiBudW1iZXIsIGNvbHVtbkluZGV4OiBudW1iZXIpOiBib29sZWFuO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2Uge1xuICAgIHByaXZhdGUgem9uZTtcbiAgICBncmlkOiBhbnk7XG4gICAgZHJhZ01vZGU6IGJvb2xlYW47XG4gICAgYWN0aXZlRWxlbWVudDogSVNlbGVjdGlvbk5vZGUgfCBudWxsO1xuICAgIGtleWJvYXJkU3RhdGU6IElTZWxlY3Rpb25LZXlib2FyZFN0YXRlO1xuICAgIHBvaW50ZXJTdGF0ZTogSVNlbGVjdGlvblBvaW50ZXJTdGF0ZTtcbiAgICBjb2x1bW5zU3RhdGU6IElDb2x1bW5TZWxlY3Rpb25TdGF0ZTtcbiAgICBzZWxlY3Rpb246IE1hcDxudW1iZXIsIFNldDxudW1iZXI+PjtcbiAgICB0ZW1wOiBNYXA8bnVtYmVyLCBTZXQ8bnVtYmVyPj47XG4gICAgX3JhbmdlczogU2V0PHN0cmluZz47XG4gICAgX3NlbGVjdGlvblJhbmdlOiBSYW5nZTtcbiAgICByb3dTZWxlY3Rpb246IFNldDxhbnk+O1xuICAgIGNvbHVtblNlbGVjdGlvbjogU2V0PHN0cmluZz47XG4gICAgcHJpdmF0ZSBhbGxSb3dzU2VsZWN0ZWQ7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzZWxlY3RlZCByYW5nZXMgaW4gdGhlIGdyaWQgZnJvbSBib3RoXG4gICAgICoga2V5Ym9hcmQgYW5kIHBvaW50ZXIgaW50ZXJhY3Rpb25zXG4gICAgICovXG4gICAgZ2V0IHJhbmdlcygpOiBHcmlkU2VsZWN0aW9uUmFuZ2VbXTtcbiAgICBnZXQgcHJpbWFyeUJ1dHRvbigpOiBib29sZWFuO1xuICAgIHNldCBwcmltYXJ5QnV0dG9uKHZhbHVlOiBib29sZWFuKTtcbiAgICBjb25zdHJ1Y3Rvcih6b25lOiBOZ1pvbmUpO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUga2V5Ym9hcmQgc3RhdGVcbiAgICAgKi9cbiAgICBpbml0S2V5Ym9hcmRTdGF0ZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcG9pbnRlciBzdGF0ZVxuICAgICAqL1xuICAgIGluaXRQb2ludGVyU3RhdGUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNvbHVtbnMgc3RhdGVcbiAgICAgKi9cbiAgICBpbml0Q29sdW1uc1N0YXRlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNpbmdsZSBub2RlLlxuICAgICAqIFNpbmdsZSBjbGlja3MgfCBDdHJsICsgc2luZ2xlIGNsaWNrcyBvbiBjZWxscyBpcyB0aGUgdXN1YWwgY2FzZS5cbiAgICAgKi9cbiAgICBhZGQobm9kZTogSVNlbGVjdGlvbk5vZGUsIGFkZFRvUmFuZ2U/OiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBhY3RpdmUga2V5Ym9hcmQgcmFuZ2Ugc2VsZWN0aW9uIChpZiBhbnkpIHRvIHRoZSBgcmFuZ2VzYCBtZXRhLlxuICAgICAqL1xuICAgIGFkZEtleWJvYXJkUmFuZ2UoKTogdm9pZDtcbiAgICByZW1vdmUobm9kZTogSVNlbGVjdGlvbk5vZGUpOiB2b2lkO1xuICAgIGlzSW5NYXAobm9kZTogSVNlbGVjdGlvbk5vZGUpOiBib29sZWFuO1xuICAgIHNlbGVjdGVkKG5vZGU6IElTZWxlY3Rpb25Ob2RlKTogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZU5vZGUobm9kZTogSVNlbGVjdGlvbk5vZGUpOiBib29sZWFuO1xuICAgIGlzQWN0aXZlTGF5b3V0KGN1cnJlbnQ6IElNdWx0aVJvd0xheW91dE5vZGUsIHRhcmdldDogSU11bHRpUm93TGF5b3V0Tm9kZSk6IGJvb2xlYW47XG4gICAgYWRkUmFuZ2VNZXRhKG5vZGU6IElTZWxlY3Rpb25Ob2RlLCBzdGF0ZT86IFNlbGVjdGlvblN0YXRlKTogdm9pZDtcbiAgICByZW1vdmVSYW5nZU1ldGEobm9kZTogSVNlbGVjdGlvbk5vZGUsIHN0YXRlPzogU2VsZWN0aW9uU3RhdGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBzZWxlY3Rpb24gcmFuZ2UgZnJvbSB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgICAqIElmIGBzdGF0ZWAgaXMgcGFzc2VkIGluc3RlYWQgaXQgd2lsbCBnZW5lcmF0ZSB0aGUgcmFuZ2UgYmFzZWQgb24gdGhlIHBhc3NlZCBgbm9kZWBcbiAgICAgKiBhbmQgdGhlIHN0YXJ0IG5vZGUgb2YgdGhlIGBzdGF0ZWAuXG4gICAgICovXG4gICAgZ2VuZXJhdGVSYW5nZShub2RlOiBJU2VsZWN0aW9uTm9kZSwgc3RhdGU/OiBTZWxlY3Rpb25TdGF0ZSk6IEdyaWRTZWxlY3Rpb25SYW5nZTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGtleWJvYXJkU3RhdGVPbktleWRvd24obm9kZTogSVNlbGVjdGlvbk5vZGUsIHNoaWZ0OiBib29sZWFuLCBzaGlmdFRhYjogYm9vbGVhbik6IHZvaWQ7XG4gICAga2V5Ym9hcmRTdGF0ZU9uRm9jdXMobm9kZTogSVNlbGVjdGlvbk5vZGUsIGVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxHcmlkU2VsZWN0aW9uUmFuZ2U+LCBkb206IGFueSk6IHZvaWQ7XG4gICAgcG9pbnRlckRvd24obm9kZTogSVNlbGVjdGlvbk5vZGUsIHNoaWZ0OiBib29sZWFuLCBjdHJsOiBib29sZWFuKTogdm9pZDtcbiAgICBwb2ludGVyRG93blNoaWZ0S2V5KG5vZGU6IElTZWxlY3Rpb25Ob2RlKTogdm9pZDtcbiAgICBtZXJnZU1hcCh0YXJnZXQ6IE1hcDxudW1iZXIsIFNldDxudW1iZXI+Piwgc291cmNlOiBNYXA8bnVtYmVyLCBTZXQ8bnVtYmVyPj4pOiB2b2lkO1xuICAgIHBvaW50ZXJFbnRlcihub2RlOiBJU2VsZWN0aW9uTm9kZSwgZXZlbnQ6IFBvaW50ZXJFdmVudCk6IGJvb2xlYW47XG4gICAgcG9pbnRlclVwKG5vZGU6IElTZWxlY3Rpb25Ob2RlLCBlbWl0dGVyOiBFdmVudEVtaXR0ZXI8R3JpZFNlbGVjdGlvblJhbmdlPik6IGJvb2xlYW47XG4gICAgc2VsZWN0UmFuZ2Uobm9kZTogSVNlbGVjdGlvbk5vZGUsIHN0YXRlOiBTZWxlY3Rpb25TdGF0ZSwgY29sbGVjdGlvbj86IE1hcDxudW1iZXIsIFNldDxudW1iZXI+Pik6IHZvaWQ7XG4gICAgZHJhZ1NlbGVjdChub2RlOiBJU2VsZWN0aW9uTm9kZSwgc3RhdGU6IFNlbGVjdGlvblN0YXRlKTogdm9pZDtcbiAgICBjbGVhcihjbGVhckFjcml2ZUVsPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgY2xlYXJUZXh0U2VsZWN0aW9uKCk6IHZvaWQ7XG4gICAgcmVzdG9yZVRleHRTZWxlY3Rpb24oKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiAo4pWvwrDilqHCsO+8ieKVr++4tSDilLvilIHilLtcbiAgICAgKiBDaHJvbWUgYW5kIENocm9taXVtIGRvbid0IGNhcmUgYWJvdXQgdGhlIGFjdGl2ZVxuICAgICAqIHJhbmdlIGFmdGVyIGtleWJvYXJkIG5hdmlnYXRpb24sIHRodXMgdGhpcy5cbiAgICAgKi9cbiAgICBfbW92ZVNlbGVjdGlvbkNocm9tZShub2RlOiBOb2RlKTogdm9pZDtcbiAgICAvKiogUmV0dXJucyBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgcm93IGlkJ3MuICovXG4gICAgZ2V0U2VsZWN0ZWRSb3dzKCk6IEFycmF5PGFueT47XG4gICAgLyoqIENsZWFycyByb3cgc2VsZWN0aW9uLCBpZiBmaWx0ZXJpbmcgaXMgYXBwbGllZCBjbGVhcnMgb25seSBzZWxlY3RlZCByb3dzIGZyb20gZmlsdGVyZWQgZGF0YS4gKi9cbiAgICBjbGVhclJvd1NlbGVjdGlvbihldmVudD86IGFueSk6IHZvaWQ7XG4gICAgLyoqIFNlbGVjdCBhbGwgcm93cywgaWYgZmlsdGVyaW5nIGlzIGFwcGxpZWQgc2VsZWN0IG9ubHkgZnJvbSBmaWx0ZXJlZCBkYXRhLiAqL1xuICAgIHNlbGVjdEFsbFJvd3MoZXZlbnQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKiBTZWxlY3QgdGhlIHNwZWNpZmllZCByb3cgYW5kIGVtaXQgZXZlbnQuICovXG4gICAgc2VsZWN0Um93QnlJZChyb3dJRDogYW55LCBjbGVhclByZXZTZWxlY3Rpb24/OiBhbnksIGV2ZW50PzogYW55KTogdm9pZDtcbiAgICAvKiogRGVzZWxlY3QgdGhlIHNwZWNpZmllZCByb3cgYW5kIGVtaXQgZXZlbnQuICovXG4gICAgZGVzZWxlY3RSb3cocm93SUQ6IGFueSwgZXZlbnQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKiBTZWxlY3Qgc3BlY2lmaWVkIHJvd3MuIE5vIGV2ZW50IGlzIGVtaXR0ZWQuICovXG4gICAgc2VsZWN0Um93c1dpdGhOb0V2ZW50KHJvd0lEczogYW55W10sIGNsZWFyUHJldlNlbGVjdGlvbj86IGFueSk6IHZvaWQ7XG4gICAgLyoqIERlc2VsZWN0IHNwZWNpZmllZCByb3dzLiBObyBldmVudCBpcyBlbWl0dGVkLiAqL1xuICAgIGRlc2VsZWN0Um93c1dpdGhOb0V2ZW50KHJvd0lEczogYW55W10pOiB2b2lkO1xuICAgIGlzUm93U2VsZWN0ZWQocm93SUQ6IGFueSk6IGJvb2xlYW47XG4gICAgLyoqIFNlbGVjdCByYW5nZSBmcm9tIGxhc3Qgc2VsZWN0ZWQgcm93IHRvIHRoZSBjdXJyZW50IHNwZWNpZmllZCByb3cuICovXG4gICAgc2VsZWN0TXVsdGlwbGVSb3dzKHJvd0lEOiBhbnksIHJvd0RhdGE6IGFueSwgZXZlbnQ/OiBhbnkpOiB2b2lkO1xuICAgIGFyZUFsbFJvd1NlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgaGFzU29tZVJvd1NlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgZ2V0IGZpbHRlcmVkU2VsZWN0ZWRSb3dJZHMoKTogYW55W107XG4gICAgZW1pdFJvd1NlbGVjdGlvbkV2ZW50KG5ld1NlbGVjdGlvbjogYW55LCBhZGRlZDogYW55LCByZW1vdmVkOiBhbnksIGV2ZW50PzogYW55KTogYm9vbGVhbjtcbiAgICBnZXRSb3dEYXRhQnlJZChyb3dJRDogYW55KTogT2JqZWN0O1xuICAgIGdldFJvd0lEcyhkYXRhOiBhbnkpOiBBcnJheTxhbnk+O1xuICAgIGNsZWFySGVhZGVyQ0JTdGF0ZSgpOiB2b2lkO1xuICAgIC8qKiBDbGVhciByb3dTZWxlY3Rpb24gYW5kIHVwZGF0ZSBjaGVja2JveCBzdGF0ZSAqL1xuICAgIGNsZWFyQWxsU2VsZWN0ZWRSb3dzKCk6IHZvaWQ7XG4gICAgLyoqIFJldHVybnMgYWxsIGRhdGEgaW4gdGhlIGdyaWQsIHdpdGggYXBwbGllZCBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcgYW5kIHdpdGhvdXQgZGVsZXRlZCByb3dzLiAqL1xuICAgIGdldCBhbGxEYXRhKCk6IEFycmF5PGFueT47XG4gICAgcHJpdmF0ZSBhcmVFcXVhbENvbGxlY3Rpb25zO1xuICAgIHByaXZhdGUgaXNGaWx0ZXJpbmdBcHBsaWVkO1xuICAgIHByaXZhdGUgaXNSb3dEZWxldGVkO1xuICAgIC8qKiBSZXR1cm5zIGFycmF5IG9mIHRoZSBzZWxlY3RlZCBjb2x1bW5zIGZpZWxkcy4gKi9cbiAgICBnZXRTZWxlY3RlZENvbHVtbnMoKTogQXJyYXk8YW55PjtcbiAgICBpc0NvbHVtblNlbGVjdGVkKGZpZWxkOiBzdHJpbmcpOiBib29sZWFuO1xuICAgIC8qKiBTZWxlY3QgdGhlIHNwZWNpZmllZCBjb2x1bW4gYW5kIGVtaXQgZXZlbnQuICovXG4gICAgc2VsZWN0Q29sdW1uKGZpZWxkOiBzdHJpbmcsIGNsZWFyUHJldlNlbGVjdGlvbj86IGFueSwgc2VsZWN0Q29sdW1uc1JhbmdlPzogYW55LCBldmVudD86IGFueSk6IHZvaWQ7XG4gICAgLyoqIFNlbGVjdCBzcGVjaWZpZWQgY29sdW1ucy4gQW5kIGVtaXQgZXZlbnQuICovXG4gICAgc2VsZWN0Q29sdW1ucyhmaWVsZHM6IHN0cmluZ1tdLCBjbGVhclByZXZTZWxlY3Rpb24/OiBhbnksIHNlbGVjdENvbHVtbnNSYW5nZT86IGFueSwgZXZlbnQ/OiBhbnkpOiB2b2lkO1xuICAgIC8qKiBTZWxlY3QgcmFuZ2UgZnJvbSBsYXN0IGNsaWNrZWQgY29sdW1uIHRvIHRoZSBjdXJyZW50IHNwZWNpZmllZCBjb2x1bW4uICovXG4gICAgc2VsZWN0Q29sdW1uc1JhbmdlKGZpZWxkOiBzdHJpbmcsIGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKiBTZWxlY3Qgc3BlY2lmaWVkIGNvbHVtbnMuIE5vIGV2ZW50IGlzIGVtaXR0ZWQuICovXG4gICAgc2VsZWN0Q29sdW1uc1dpdGhOb0V2ZW50KGZpZWxkczogc3RyaW5nW10sIGNsZWFyUHJldlNlbGVjdGlvbj86IGFueSk6IHZvaWQ7XG4gICAgLyoqIERlc2VsZWN0IHRoZSBzcGVjaWZpZWQgY29sdW1uIGFuZCBlbWl0IGV2ZW50LiAqL1xuICAgIGRlc2VsZWN0Q29sdW1uKGZpZWxkOiBzdHJpbmcsIGV2ZW50PzogYW55KTogdm9pZDtcbiAgICAvKiogRGVzZWxlY3Qgc3BlY2lmaWVkIGNvbHVtbnMuIE5vIGV2ZW50IGlzIGVtaXR0ZWQuICovXG4gICAgZGVzZWxlY3RDb2x1bW5zV2l0aE5vRXZlbnQoZmllbGRzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gICAgLyoqIERlc2VsZWN0IHNwZWNpZmllZCBjb2x1bW5zLiBBbmQgZW1pdCBldmVudC4gKi9cbiAgICBkZXNlbGVjdENvbHVtbnMoZmllbGRzOiBzdHJpbmdbXSwgZXZlbnQ/OiBhbnkpOiB2b2lkO1xuICAgIGVtaXRDb2x1bW5TZWxlY3Rpb25FdmVudChuZXdTZWxlY3Rpb246IGFueSwgYWRkZWQ6IGFueSwgcmVtb3ZlZDogYW55LCBldmVudD86IGFueSk6IGJvb2xlYW47XG4gICAgLyoqIENsZWFyIGNvbHVtblNlbGVjdGlvbiAqL1xuICAgIGNsZWFyQWxsU2VsZWN0ZWRDb2x1bW5zKCk6IHZvaWQ7XG59XG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc0Nocm9taXVtKCk6IGJvb2xlYW47XG5leHBvcnQge307XG4iXX0=