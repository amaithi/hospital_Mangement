import { NgZone } from '@angular/core';
import { IgxColumnComponent } from '../columns/column.component';
/**
 * @hidden
 * @internal
 */
import * as ɵngcc0 from '@angular/core';
export declare class IgxColumnResizingService {
    private zone;
    private pinnedMaxWidth;
    /**
     * @hidden
     */
    startResizePos: number;
    /**
     * Indicates that a column is currently being resized.
     */
    isColumnResizing: boolean;
    /**
     * @hidden
     */
    resizeCursor: string;
    /**
     * @hidden
     */
    showResizer: boolean;
    /**
     * The column being resized.
     */
    column: IgxColumnComponent;
    constructor(zone: NgZone);
    /**
     * @hidden
     */
    get resizerHeight(): number;
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin(): number;
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax(): number;
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    autosizeColumnOnDblClick(): void;
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event: MouseEvent): void;
    protected getColMinWidth(column: IgxColumnComponent): number;
    protected getColMaxWidth(column: IgxColumnComponent): number;
    protected resizeColumnLayoutFor(column: IgxColumnComponent, diff: number): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxColumnResizingService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<IgxColumnResizingService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzaXppbmcuc2VydmljZS5kLnRzIiwic291cmNlcyI6WyJyZXNpemluZy5zZXJ2aWNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtREEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbnMvY29sdW1uLmNvbXBvbmVudCc7XG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuICAgIHByaXZhdGUgem9uZTtcbiAgICBwcml2YXRlIHBpbm5lZE1heFdpZHRoO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzdGFydFJlc2l6ZVBvczogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgY29sdW1uIGlzIGN1cnJlbnRseSBiZWluZyByZXNpemVkLlxuICAgICAqL1xuICAgIGlzQ29sdW1uUmVzaXppbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHJlc2l6ZUN1cnNvcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzaG93UmVzaXplcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQ7XG4gICAgY29uc3RydWN0b3Ioem9uZTogTmdab25lKTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHJlc2l6ZXJIZWlnaHQoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1pbmltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNaW4oKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNYXgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEF1dG9zaXplcyB0aGUgY29sdW1uIHRvIHRoZSBsb25nZXN0IGN1cnJlbnRseSB2aXNpYmxlIGNlbGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgaGVhZGVyIGNlbGwuXG4gICAgICogSWYgdGhlIGNvbHVtbiBoYXMgYSBwcmVkaWZpbmVkIG1heFdpZHRoIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGJlY29tZSBiaWdnZXIgdGhhbiBpdCxcbiAgICAgKiB0aGVuIHRoZSBjb2x1bW4gaXMgc2l6ZWQgdG8gaXRzIG1heFdpZHRoLlxuICAgICAqIElmIHRoZSBjb2x1bW4gaXMgcGlubmVkIGFuZCB0aGUgYXV0b3NpemVkIGNvbHVtbiB3aWR0aCB3aWxsIGNhdXNlIHRoZSBwaW5uZWQgYXJlYSB0byBiZWNvbWUgYmlnZ2VyXG4gICAgICogdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHBpbm5lZCBhcmVhIHdpZHRoICg4MCUgb2YgdGhlIHRvdGFsIGdyaWQgd2lkdGgpLCBhdXRvc2l6aW5nIHdpbGwgYmUgZGVpc21pc3NlZC5cbiAgICAgKi9cbiAgICBhdXRvc2l6ZUNvbHVtbk9uRGJsQ2xpY2soKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBjb2x1bW4gcmVnYXJpZG5nIHRvIHRoZSBjb2x1bW4gbWluV2lkdGggYW5kIG1heFdpZHRoLlxuICAgICAqL1xuICAgIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGdldENvbE1pbldpZHRoKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KTogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBnZXRDb2xNYXhXaWR0aChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCk6IG51bWJlcjtcbiAgICBwcm90ZWN0ZWQgcmVzaXplQ29sdW1uTGF5b3V0Rm9yKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50LCBkaWZmOiBudW1iZXIpOiB2b2lkO1xufVxuIl19