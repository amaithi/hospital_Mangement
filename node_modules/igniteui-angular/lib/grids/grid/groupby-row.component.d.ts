import { ChangeDetectorRef, ElementRef, TemplateRef } from '@angular/core';
import { IGroupByRecord } from '../../data-operations/groupby-record.interface';
import { GridBaseAPIService } from '../api.service';
import { IgxGridBaseDirective } from '../grid-base.directive';
import { IgxGridSelectionService, ISelectionNode } from '../selection/selection.service';
import { GridType } from '../common/grid.interface';
import * as ɵngcc0 from '@angular/core';
export declare class IgxGridGroupByRowComponent {
    gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>;
    private gridSelection;
    element: ElementRef;
    cdr: ChangeDetectorRef;
    constructor(gridAPI: GridBaseAPIService<IgxGridBaseDirective & GridType>, gridSelection: IgxGridSelectionService, element: ElementRef, cdr: ChangeDetectorRef);
    /**
     * @hidden
     */
    protected defaultCssClass: string;
    /**
     * @hidden
     */
    protected paddingIndentationCssClass: string;
    /**
     * @hidden
     */
    protected defaultGroupByExpandedTemplate: TemplateRef<any>;
    /**
     * @hidden
     */
    protected defaultGroupByCollapsedTemplate: TemplateRef<any>;
    /**
     * @hidden
     */
    protected isFocused: boolean;
    /**
     * Returns whether the row is focused.
     * ```
     * let gridRowFocused = this.grid1.rowList.first.focused;
     * ```
     */
    get focused(): boolean;
    /**
     * An @Input property that sets the index of the row.
     * ```html
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     */
    index: number;
    /**
     * An @Input property that sets the id of the grid the row belongs to.
     * ```html
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     */
    gridID: string;
    /**
     * An @Input property that specifies the group record the component renders for.
     * ```typescript
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     */
    groupRow: IGroupByRecord;
    /**
     * Returns a reference of the content of the group.
     * ```typescript
     * const groupRowContent = this.grid1.rowList.first.groupContent;
     * ```
     */
    groupContent: ElementRef;
    /**
     * Returns whether the group row is expanded.
     * ```typescript
     * const groupRowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded(): boolean;
    /**
     * @hidden
     */
    get describedBy(): string;
    get dataRowIndex(): number;
    /**
     * Returns a reference to the underlying HTML element.
     * ```typescript
     * const groupRowElement = this.nativeElement;
     * ```
     */
    get nativeElement(): any;
    get attrCellID(): string;
    /**
     * Returns the style classes applied to the group rows.
     * ```typescript
     * const groupCssStyles = this.grid1.rowList.first.styleClasses;
     * ```
     */
    get styleClasses(): string;
    isActive(): boolean;
    activate(): void;
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle(): void;
    get iconTemplate(): any;
    protected get selectionNode(): ISelectionNode;
    /**
     * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
     * ```typescript
     * this.grid1.rowList.first.grid;
     * ```
     */
    get grid(): any;
    /**
     * @hidden
     */
    get dataType(): any;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<IgxGridGroupByRowComponent>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<IgxGridGroupByRowComponent, "igx-grid-groupby-row", never, {
    "isFocused": "isFocused";
    "index": "index";
    "gridID": "gridID";
    "groupRow": "groupRow";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JvdXBieS1yb3cuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImdyb3VwYnktcm93LmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThHQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IEdyaWRCYXNlQVBJU2VydmljZSB9IGZyb20gJy4uL2FwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSwgSVNlbGVjdGlvbk5vZGUgfSBmcm9tICcuLi9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZFR5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQge1xuICAgIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPjtcbiAgICBwcml2YXRlIGdyaWRTZWxlY3Rpb247XG4gICAgZWxlbWVudDogRWxlbWVudFJlZjtcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIGNvbnN0cnVjdG9yKGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZURpcmVjdGl2ZSAmIEdyaWRUeXBlPiwgZ3JpZFNlbGVjdGlvbjogSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGVmYXVsdENzc0NsYXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwYWRkaW5nSW5kZW50YXRpb25Dc3NDbGFzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGVmYXVsdEdyb3VwQnlFeHBhbmRlZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZGVmYXVsdEdyb3VwQnlDb2xsYXBzZWRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGlzRm9jdXNlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJvdyBpcyBmb2N1c2VkLlxuICAgICAqIGBgYFxuICAgICAqIGxldCBncmlkUm93Rm9jdXNlZCA9IHRoaXMuZ3JpZDEucm93TGlzdC5maXJzdC5mb2N1c2VkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBmb2N1c2VkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgaW5kZXggb2YgdGhlIHJvdy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkLWdyb3VwYnktcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbZ3JvdXBSb3ddPVwicm93RGF0YVwiICNyb3c+PC9pZ3gtZ3JpZC1ncm91cGJ5LXJvdz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpbmRleDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGlkIG9mIHRoZSBncmlkIHRoZSByb3cgYmVsb25ncyB0by5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkLWdyb3VwYnktcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbZ3JvdXBSb3ddPVwicm93RGF0YVwiICNyb3c+PC9pZ3gtZ3JpZC1ncm91cGJ5LXJvdz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBncmlkSUQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIGdyb3VwIHJlY29yZCB0aGUgY29tcG9uZW50IHJlbmRlcnMgZm9yLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiA8aWd4LWdyaWQtZ3JvdXBieS1yb3cgW2dyaWRJRF09XCJpZFwiIFtpbmRleF09XCJyb3dJbmRleFwiIFtncm91cFJvd109XCJyb3dEYXRhXCIgI3Jvdz48L2lneC1ncmlkLWdyb3VwYnktcm93PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIG9mIHRoZSBjb250ZW50IG9mIHRoZSBncm91cC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBSb3dDb250ZW50ID0gdGhpcy5ncmlkMS5yb3dMaXN0LmZpcnN0Lmdyb3VwQ29udGVudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBncm91cENvbnRlbnQ6IEVsZW1lbnRSZWY7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBncm91cCByb3cgaXMgZXhwYW5kZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwUm93RXhwYW5kZWQgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QuZXhwYW5kZWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkZXNjcmliZWRCeSgpOiBzdHJpbmc7XG4gICAgZ2V0IGRhdGFSb3dJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBIVE1MIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwUm93RWxlbWVudCA9IHRoaXMubmF0aXZlRWxlbWVudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgbmF0aXZlRWxlbWVudCgpOiBhbnk7XG4gICAgZ2V0IGF0dHJDZWxsSUQoKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0eWxlIGNsYXNzZXMgYXBwbGllZCB0byB0aGUgZ3JvdXAgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBDc3NTdHlsZXMgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3Quc3R5bGVDbGFzc2VzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzdHlsZUNsYXNzZXMoKTogc3RyaW5nO1xuICAgIGlzQWN0aXZlKCk6IGJvb2xlYW47XG4gICAgYWN0aXZhdGUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBncm91cCByb3cuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZDEucm93TGlzdC5maXJzdC50b2dnbGUoKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRvZ2dsZSgpOiB2b2lkO1xuICAgIGdldCBpY29uVGVtcGxhdGUoKTogYW55O1xuICAgIHByb3RlY3RlZCBnZXQgc2VsZWN0aW9uTm9kZSgpOiBJU2VsZWN0aW9uTm9kZTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgdGhlIGBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudGAgYmVsb25ncyB0by5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkMS5yb3dMaXN0LmZpcnN0LmdyaWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGdyaWQoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZGF0YVR5cGUoKTogYW55O1xufVxuIl19