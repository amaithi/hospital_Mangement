import { Observable } from 'rxjs';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
export declare function cloneArray(array: any[], deep?: boolean): any[];
/**
 * Doesn't clone leaf items
 * @hidden
 */
export declare function cloneHierarchicalArray(array: any[], childDataKey: any): any[];
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
export declare function mergeObjects(obj1: {}, obj2: {}): any;
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
export declare function cloneValue(value: any): any;
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
export declare function isObject(value: any): boolean;
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
export declare function isDate(value: any): boolean;
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
export declare function isEqual(obj1: any, obj2: any): boolean;
/**
 * @hidden
 */
export declare const enum KEYCODES {
    ENTER = 13,
    SPACE = 32,
    ESCAPE = 27,
    LEFT_ARROW = 37,
    UP_ARROW = 38,
    RIGHT_ARROW = 39,
    DOWN_ARROW = 40,
    F2 = 113,
    TAB = 9,
    CTRL = 17,
    Z = 90,
    Y = 89,
    X = 88,
    BACKSPACE = 8,
    DELETE = 46,
    INPUT_METHOD = 229
}
/**
 * @hidden
 */
export declare const enum KEYS {
    ENTER = "Enter",
    SPACE = " ",
    SPACE_IE = "Spacebar",
    ESCAPE = "Escape",
    ESCAPE_IE = "Esc",
    LEFT_ARROW = "ArrowLeft",
    LEFT_ARROW_IE = "Left",
    UP_ARROW = "ArrowUp",
    UP_ARROW_IE = "Up",
    RIGHT_ARROW = "ArrowRight",
    RIGHT_ARROW_IE = "Right",
    DOWN_ARROW = "ArrowDown",
    DOWN_ARROW_IE = "Down",
    F2 = "F2",
    TAB = "Tab",
    SEMICOLON = ";",
    HOME = "Home",
    END = "End"
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
export declare function getNodeSizeViaRange(range: Range, node: any): number;
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
export declare function getNodeSizeViaCanvas(canvas2dCtx: any, node: any): number;
/**
 * @hidden
 */
export declare function isIE(): boolean;
/**
 * @hidden
 */
export declare function isEdge(): boolean;
/**
 * @hidden
 */
export declare function isFirefox(): boolean;
/**
 * @hidden
 */
export declare class PlatformUtil {
    private platformId;
    isBrowser: boolean;
    isIOS: boolean;
    constructor(platformId: Object);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<PlatformUtil>;
}
/**
 * @hidden
 */
export declare function isLeftClick(event: PointerEvent): boolean;
/** @hidden */
export declare function isNavigationKey(key: string): boolean;
/**
 * @hidden
 */
export declare function flatten(arr: any[]): any[];
export interface CancelableEventArgs {
    /**
     * Provides the ability to cancel the event.
     */
    cancel: boolean;
}
export interface IBaseEventArgs {
    /**
     * Provides reference to the owner component.
     */
    owner?: any;
}
export interface CancelableBrowserEventArgs extends CancelableEventArgs {
    /** Browser event */
    event?: Event;
}
export declare const HORIZONTAL_NAV_KEYS: Set<string>;
export declare const NAVIGATION_KEYS: Set<string>;
export declare const ROW_EXPAND_KEYS: Set<string>;
export declare const ROW_COLLAPSE_KEYS: Set<string>;
export declare const SUPPORTED_KEYS: Set<string>;
export declare const HEADER_KEYS: Set<string>;
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
export declare function resizeObservable(target: HTMLElement): Observable<ResizeObserverEntry[]>;
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
export declare function compareMaps(map1: Map<any, any>, map2: Map<any, any>): boolean;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuZC50cyIsInNvdXJjZXMiOlsidXRpbHMuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9JQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5OiBhbnlbXSwgZGVlcD86IGJvb2xlYW4pOiBhbnlbXTtcbi8qKlxuICogRG9lc24ndCBjbG9uZSBsZWFmIGl0ZW1zXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNsb25lSGllcmFyY2hpY2FsQXJyYXkoYXJyYXk6IGFueVtdLCBjaGlsZERhdGFLZXk6IGFueSk6IGFueVtdO1xuLyoqXG4gKiBEZWVwIGNsb25lcyBhbGwgZmlyc3QgbGV2ZWwga2V5cyBvZiBPYmoyIGFuZCBtZXJnZXMgdGhlbSB0byBPYmoxXG4gKiBAcGFyYW0gb2JqMSBPYmplY3QgdG8gbWVyZ2UgaW50b1xuICogQHBhcmFtIG9iajIgT2JqZWN0IHRvIG1lcmdlIGZyb21cbiAqIEByZXR1cm5zIE9iajEgd2l0aCBtZXJnZWQgY2xvbmVkIGtleXMgZnJvbSBPYmoyXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhvYmoxOiB7fSwgb2JqMjoge30pOiBhbnk7XG4vKipcbiAqIENyZWF0ZXMgZGVlcCBjbG9uZSBvZiBwcm92aWRlZCB2YWx1ZS5cbiAqIFN1cHBvcnRzIHByaW1pdGl2ZSB2YWx1ZXMsIGRhdGVzIGFuZCBvYmplY3RzLlxuICogSWYgcGFzc2VkIHZhbHVlIGlzIGFycmF5IHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybnMgRGVlcCBjb3B5IG9mIHByb3ZpZGVkIHZhbHVlXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWU6IGFueSk6IGFueTtcbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbjtcbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIERhdGVcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZTogYW55KTogYm9vbGVhbjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB0d28gcGFzc2VkIGFyZ3VtZW50cyBhcmUgZXF1YWxcbiAqIEN1cnJlbnRseSBzdXBwb3J0cyBkYXRlIG9iamVjdHNcbiAqIEBwYXJhbSBvYmoxXG4gKiBAcGFyYW0gb2JqMlxuICogQHJldHVybnM6IGBib29sZWFuYFxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc0VxdWFsKG9iajE6IGFueSwgb2JqMjogYW55KTogYm9vbGVhbjtcbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBjb25zdCBlbnVtIEtFWUNPREVTIHtcbiAgICBFTlRFUiA9IDEzLFxuICAgIFNQQUNFID0gMzIsXG4gICAgRVNDQVBFID0gMjcsXG4gICAgTEVGVF9BUlJPVyA9IDM3LFxuICAgIFVQX0FSUk9XID0gMzgsXG4gICAgUklHSFRfQVJST1cgPSAzOSxcbiAgICBET1dOX0FSUk9XID0gNDAsXG4gICAgRjIgPSAxMTMsXG4gICAgVEFCID0gOSxcbiAgICBDVFJMID0gMTcsXG4gICAgWiA9IDkwLFxuICAgIFkgPSA4OSxcbiAgICBYID0gODgsXG4gICAgQkFDS1NQQUNFID0gOCxcbiAgICBERUxFVEUgPSA0NixcbiAgICBJTlBVVF9NRVRIT0QgPSAyMjlcbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBjb25zdCBlbnVtIEtFWVMge1xuICAgIEVOVEVSID0gXCJFbnRlclwiLFxuICAgIFNQQUNFID0gXCIgXCIsXG4gICAgU1BBQ0VfSUUgPSBcIlNwYWNlYmFyXCIsXG4gICAgRVNDQVBFID0gXCJFc2NhcGVcIixcbiAgICBFU0NBUEVfSUUgPSBcIkVzY1wiLFxuICAgIExFRlRfQVJST1cgPSBcIkFycm93TGVmdFwiLFxuICAgIExFRlRfQVJST1dfSUUgPSBcIkxlZnRcIixcbiAgICBVUF9BUlJPVyA9IFwiQXJyb3dVcFwiLFxuICAgIFVQX0FSUk9XX0lFID0gXCJVcFwiLFxuICAgIFJJR0hUX0FSUk9XID0gXCJBcnJvd1JpZ2h0XCIsXG4gICAgUklHSFRfQVJST1dfSUUgPSBcIlJpZ2h0XCIsXG4gICAgRE9XTl9BUlJPVyA9IFwiQXJyb3dEb3duXCIsXG4gICAgRE9XTl9BUlJPV19JRSA9IFwiRG93blwiLFxuICAgIEYyID0gXCJGMlwiLFxuICAgIFRBQiA9IFwiVGFiXCIsXG4gICAgU0VNSUNPTE9OID0gXCI7XCIsXG4gICAgSE9NRSA9IFwiSG9tZVwiLFxuICAgIEVORCA9IFwiRW5kXCJcbn1cbi8qKlxuICogQGhpZGRlblxuICogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgUmFuZ2VcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4gKlxuICogbGV0IHNpemUgPSBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjb2x1bW4uY2VsbHNbMF0ubmF0aXZlRWxlbWVudCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZTogUmFuZ2UsIG5vZGU6IGFueSk6IG51bWJlcjtcbi8qKlxuICogQGhpZGRlblxuICogUmV0dXJucyB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIG5vZGUgY29udGVudCwgdXNpbmcgQ2FudmFzXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBsZXQgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiAqIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbiAqXG4gKiBsZXQgc2l6ZSA9IHZhbFRvUHhsc1VzaW5nQ2FudmFzKGN0eCwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGdldE5vZGVTaXplVmlhQ2FudmFzKGNhbnZhczJkQ3R4OiBhbnksIG5vZGU6IGFueSk6IG51bWJlcjtcbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBpc0lFKCk6IGJvb2xlYW47XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaXNFZGdlKCk6IGJvb2xlYW47XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaXNGaXJlZm94KCk6IGJvb2xlYW47XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgUGxhdGZvcm1VdGlsIHtcbiAgICBwcml2YXRlIHBsYXRmb3JtSWQ7XG4gICAgaXNCcm93c2VyOiBib29sZWFuO1xuICAgIGlzSU9TOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKHBsYXRmb3JtSWQ6IE9iamVjdCk7XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaXNMZWZ0Q2xpY2soZXZlbnQ6IFBvaW50ZXJFdmVudCk6IGJvb2xlYW47XG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gaXNOYXZpZ2F0aW9uS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbjtcbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiBmbGF0dGVuKGFycjogYW55W10pOiBhbnlbXTtcbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyByZWZlcmVuY2UgdG8gdGhlIG93bmVyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBvd25lcj86IGFueTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKiogQnJvd3NlciBldmVudCAqL1xuICAgIGV2ZW50PzogRXZlbnQ7XG59XG5leHBvcnQgZGVjbGFyZSBjb25zdCBIT1JJWk9OVEFMX05BVl9LRVlTOiBTZXQ8c3RyaW5nPjtcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5BVklHQVRJT05fS0VZUzogU2V0PHN0cmluZz47XG5leHBvcnQgZGVjbGFyZSBjb25zdCBST1dfRVhQQU5EX0tFWVM6IFNldDxzdHJpbmc+O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgUk9XX0NPTExBUFNFX0tFWVM6IFNldDxzdHJpbmc+O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgU1VQUE9SVEVEX0tFWVM6IFNldDxzdHJpbmc+O1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgSEVBREVSX0tFWVM6IFNldDxzdHJpbmc+O1xuLyoqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBDcmVhdGVzIGEgbmV3IFJlc2l6ZU9ic2VydmVyIG9uIGB0YXJnZXRgIGFuZCByZXR1cm5zIGl0IGFzIGFuIE9ic2VydmFibGUuXG4gKiBSdW4gdGhlIHJlc2l6ZU9ic2VydmFibGUgb3V0c2lkZSBhbmd1bGFyIHpvbmUsIGJlY2F1c2UgaXQgcGF0Y2hlcyB0aGUgTXV0YXRpb25PYnNlcnZlciB3aGljaCBjYXVzZXMgYW4gaW5maW5pdGUgbG9vcC5cbiAqIFJlbGF0ZWQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMxNzEyXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIHJlc2l6ZU9ic2VydmFibGUodGFyZ2V0OiBIVE1MRWxlbWVudCk6IE9ic2VydmFibGU8UmVzaXplT2JzZXJ2ZXJFbnRyeVtdPjtcbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKlxuICogQ29tcGFyZXMgdHdvIG1hcHMuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIGNvbXBhcmVNYXBzKG1hcDE6IE1hcDxhbnksIGFueT4sIG1hcDI6IE1hcDxhbnksIGFueT4pOiBib29sZWFuO1xuIl19