import { style, animate, animation, keyframes, AnimationBuilder, useAnimation, trigger, transition, state } from '@angular/animations';
import { __decorate, __param } from 'tslib';
import { Injectable, Input, HostListener, Directive, NgModule, Inject, PLATFORM_ID, ɵɵdefineInjectable, ɵɵinject, Pipe, EventEmitter, Output, isDevMode, ElementRef, ComponentFactoryResolver, ApplicationRef, Injector, NgZone, INJECTOR, ChangeDetectorRef, Optional, HostBinding, InjectionToken, Component, ViewContainerRef, ViewChild, TemplateRef, IterableDiffers, ContentChild, ContentChildren, forwardRef, Self, Renderer2, LOCALE_ID, ChangeDetectionStrategy, SimpleChange, QueryList, ViewChildren, SecurityContext, NgModuleRef, inject, Host, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import { NgModel, FormControlName, NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator, FormsModule, NgControl, ReactiveFormsModule } from '@angular/forms';
import { isPlatformBrowser, DOCUMENT, CommonModule, formatDate, DatePipe, DecimalPipe } from '@angular/common';
import { Observable, Subject, fromEvent, interval, animationFrameScheduler, pipe, Subscription, timer, merge } from 'rxjs';
import { filter, takeUntil, throttleTime, first as first$1, take, throttle, debounce, tap, switchMap, skipLast, map, debounceTime } from 'rxjs/operators';
import ResizeObserver from 'resize-observer-polyfill';
import * as JSZip from 'jszip';
import { ɵgetDOM, DomSanitizer, HammerGestureConfig, HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';
import 'igniteui-trial-watermark';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/animations';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/forms';
import * as ɵngcc4 from '@angular/platform-browser';

const _c0 = [[["igx-drop-down-item"]]];
const _c1 = ["igx-drop-down-item"];
const _c2 = ["*"];
const _c3 = ["display_container"];
function DisplayContainerComponent_ng_template_0_Template(rf, ctx) { }
const _c4 = ["horizontal_container"];
const _c5 = ["container"];
const _c6 = ["scrollContainer"];
function IgxDropDownComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function IgxInputGroupComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r13 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r13);
} }
function IgxInputGroupComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function IgxInputGroupComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function IgxInputGroupComponent_ng_template_7_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_7_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_7_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r7 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r7);
} }
function IgxInputGroupComponent_ng_template_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_7_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_7_ng_container_1_Template, 1, 0, "ng-container", 7);
} if (rf & 2) {
    const ctx_r12 = ɵngcc0.ɵɵnextContext();
    const _r9 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r12.isNotMaterial);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r9);
} }
function IgxInputGroupComponent_ng_template_9_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_9_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_9_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r7 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r7);
} }
function IgxInputGroupComponent_ng_template_9_div_3_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_9_div_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_9_div_3_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r7 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r7);
} }
function IgxInputGroupComponent_ng_template_9_div_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxInputGroupComponent_ng_template_9_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, IgxInputGroupComponent_ng_template_9_div_3_ng_container_1_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, IgxInputGroupComponent_ng_template_9_div_3_ng_container_2_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r20 = ɵngcc0.ɵɵnextContext(2);
    const _r9 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r20.isNotMaterial);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r9);
} }
function IgxInputGroupComponent_ng_template_9_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function IgxInputGroupComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxInputGroupComponent_ng_template_9_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵprojection(2, 3);
    ɵngcc0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_9_div_3_Template, 3, 2, "div", 10);
    ɵngcc0.ɵɵprojection(4, 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_9_div_5_Template, 1, 0, "div", 11);
} if (rf & 2) {
    const ctx_r14 = ɵngcc0.ɵɵnextContext();
    const _r11 = ɵngcc0.ɵɵreference(8);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r14.isNotMaterial);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r14.isTypeBootstrap)("ngIfElse", _r11);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r14.hasBorder);
} }
const _c7 = [[["igx-hint"], ["", "igxHint", ""]], [["", "igxLabel", ""]], [["", "igxInput", ""]], [["igx-prefix"], ["", "igxPrefix", ""]], [["igx-suffix"], ["", "igxSuffix", ""]]];
const _c8 = ["igx-hint,[igxHint]", "[igxLabel]", "[igxInput]", "igx-prefix,[igxPrefix]", "igx-suffix,[igxSuffix]"];
const _c9 = ["radio"];
const _c10 = ["nativeLabel"];
const _c11 = ["placeholderLabel"];
const _c12 = ["dropdown"];
function IgxActionStripComponent_ng_container_2_igx_drop_down_item_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c13 = function (a0) { return { $implicit: a0 }; };
function IgxActionStripComponent_ng_container_2_igx_drop_down_item_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item");
    ɵngcc0.ɵɵelementStart(1, "div", 5);
    ɵngcc0.ɵɵtemplate(2, IgxActionStripComponent_ng_container_2_igx_drop_down_item_6_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r32 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", item_r32.templateRef)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, item_r32));
} }
function IgxActionStripComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r35 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxActionStripComponent_ng_container_2_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r35); return $event.stopPropagation(); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "more_vert");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "igx-drop-down", null, 3);
    ɵngcc0.ɵɵtemplate(6, IgxActionStripComponent_ng_container_2_igx_drop_down_item_6_Template, 3, 4, "igx-drop-down-item", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r30 = ɵngcc0.ɵɵreference(5);
    const ctx_r29 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxToggleAction", _r30)("overlaySettings", ctx_r29.menuOverlaySettings)("igxDropDownItemNavigation", _r30);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r29.menuItems);
} }
const _c14 = ["defaultCell"];
const _c15 = ["defaultPinnedIndicator"];
const _c16 = ["inlineEditor"];
function IgxGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r44 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r44.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxGridCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 4);
} if (rf & 2) {
    const ctx_r37 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r37.displayPinnedChip);
} }
function IgxGridCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵpipe(1, "igxdecimal");
    ɵngcc0.ɵɵpipe(2, "igxdate");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "igxdecimal");
    ɵngcc0.ɵɵpipe(5, "igxdate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r39 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r39.highlightClass)("activeCssClass", ctx_r39.activeHighlightClass)("groupName", ctx_r39.gridID)("value", ctx_r39.formatter ? ctx_r39.formatter(ctx_r39.value) : ctx_r39.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r39.value, ctx_r39.grid.locale) : ctx_r39.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(2, 12, ctx_r39.value, ctx_r39.grid.locale) : ctx_r39.value)("row", ctx_r39.rowData)("column", ctx_r39.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r39.searchMetadata);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r39.formatter ? ctx_r39.formatter(ctx_r39.value) : ctx_r39.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(4, 15, ctx_r39.value, ctx_r39.grid.locale) : ctx_r39.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(5, 18, ctx_r39.value, ctx_r39.grid.locale) : ctx_r39.value);
} }
function IgxGridCellComponent_ng_template_4_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r51 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(2, "input", 9);
    ɵngcc0.ɵɵlistener("input", function IgxGridCellComponent_ng_template_4_ng_container_0_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r51); const ctx_r50 = ɵngcc0.ɵɵnextContext(2); return ctx_r50.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r46 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r46.editValue)("igxFocus", true);
} }
function IgxGridCellComponent_ng_template_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r53 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(2, "input", 10);
    ɵngcc0.ɵɵlistener("input", function IgxGridCellComponent_ng_template_4_ng_container_1_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r53); const ctx_r52 = ɵngcc0.ɵɵnextContext(2); return ctx_r52.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r47 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r47.editValue)("igxFocus", true);
} }
function IgxGridCellComponent_ng_template_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r55 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 11);
    ɵngcc0.ɵɵlistener("change", function IgxGridCellComponent_ng_template_4_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r55); const ctx_r54 = ɵngcc0.ɵɵnextContext(2); return ctx_r54.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r48 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r48.editValue)("checked", ctx_r48.editValue)("igxFocus", true)("disableRipple", true);
} }
function IgxGridCellComponent_ng_template_4_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r57 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 12);
    ɵngcc0.ɵɵlistener("valueChange", function IgxGridCellComponent_ng_template_4_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r57); const ctx_r56 = ɵngcc0.ɵɵnextContext(2); return ctx_r56.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r49 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r49.grid.outletDirective)("locale", ctx_r49.grid.locale)("value", ctx_r49.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxGridCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_4_ng_container_0_Template, 3, 2, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(1, IgxGridCellComponent_ng_template_4_ng_container_1_Template, 3, 2, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_4_ng_container_2_Template, 2, 4, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(3, IgxGridCellComponent_ng_template_4_ng_container_3_Template, 2, 7, "ng-container", 7);
} if (rf & 2) {
    const ctx_r41 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r41.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r41.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r41.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r41.column.dataType === "date");
} }
function IgxGridCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridCellComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c17 = ["checkbox"];
const _c18 = ["label"];
const _c19 = ["igxDirRef"];
const _c20 = ["cell"];
function IgxColumnHidingComponent_h4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h4", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r61 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r61.title);
} }
function IgxColumnHidingComponent_igx_input_group_2_Template(rf, ctx) { if (rf & 1) {
    const _r65 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(1, "input", 9);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxColumnHidingComponent_igx_input_group_2_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r65); const ctx_r64 = ɵngcc0.ɵɵnextContext(); return ctx_r64.filterCriteria = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r62 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r62.filterCriteria)("placeholder", ctx_r62.filterColumnsPrompt);
} }
function IgxColumnHidingComponent_igx_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r68 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-checkbox", 10);
    ɵngcc0.ɵɵlistener("onColumnVisibilityChanged", function IgxColumnHidingComponent_igx_checkbox_4_Template_igx_checkbox_onColumnVisibilityChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r68); const ctx_r67 = ɵngcc0.ɵɵnextContext(); return ctx_r67.onVisibilityChanged($event); })("change", function IgxColumnHidingComponent_igx_checkbox_4_Template_igx_checkbox_change_0_listener() { const columnItem_r66 = ctx.$implicit; return columnItem_r66.value = !columnItem_r66.value; });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const columnItem_r66 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("margin-left", columnItem_r66.calcIndent, "px");
    ɵngcc0.ɵɵproperty("checked", columnItem_r66.value)("disabled", columnItem_r66.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", columnItem_r66.name, " ");
} }
function IgxColumnPinningComponent_h4_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "h4", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r70 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r70.title);
} }
function IgxColumnPinningComponent_igx_input_group_2_Template(rf, ctx) { if (rf & 1) {
    const _r74 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 6);
    ɵngcc0.ɵɵelementStart(1, "input", 7);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxColumnPinningComponent_igx_input_group_2_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r74); const ctx_r73 = ɵngcc0.ɵɵnextContext(); return ctx_r73.filterCriteria = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r71 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r71.filterCriteria)("placeholder", ctx_r71.filterColumnsPrompt);
} }
function IgxColumnPinningComponent_igx_checkbox_4_Template(rf, ctx) { if (rf & 1) {
    const _r77 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-checkbox", 8);
    ɵngcc0.ɵɵlistener("change", function IgxColumnPinningComponent_igx_checkbox_4_Template_igx_checkbox_change_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r77); const columnItem_r75 = ctx.$implicit; const ctx_r76 = ɵngcc0.ɵɵnextContext(); return ctx_r76.checkboxValueChange($event, columnItem_r75); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const columnItem_r75 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("checked", columnItem_r75.value);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", columnItem_r75.name, " ");
} }
const _c21 = ["columnHidingDropdown"];
const _c22 = ["columnHidingButton"];
const _c23 = ["exportDropdown"];
const _c24 = ["btnExport"];
const _c25 = ["columnPinningDropdown"];
const _c26 = ["columnPinningButton"];
function IgxGridToolbarComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r78 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r78.getTitle(), "\n");
} }
function IgxGridToolbarComponent_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridToolbarComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, IgxGridToolbarComponent_div_1_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r79 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r79.customContentTemplate)("ngTemplateOutletContext", ctx_r79.context);
} }
function IgxGridToolbarComponent_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r87 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 8, 9);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_3_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r87); const ctx_r86 = ɵngcc0.ɵɵnextContext(); return ctx_r86.showAdvancedFilteringUI(); });
    ɵngcc0.ɵɵelementStart(3, "div", 10);
    ɵngcc0.ɵɵelementStart(4, "igx-icon");
    ɵngcc0.ɵɵtext(5, " filter_list ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r80 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r80.grid.displayDensity)("ngClass", ctx_r80.grid.advancedFilteringExpressionsTree ? "igx-grid-toolbar__adv-filter--filtered" : "igx-grid-toolbar__adv-filter");
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵtextInterpolate(ctx_r80.grid.resourceStrings.igx_grid_advanced_filter_title);
} }
function IgxGridToolbarComponent_div_4_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "visibility_off");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridToolbarComponent_div_4_igx_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "visibility");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridToolbarComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    const _r93 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 11, 12);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_4_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r93); const ctx_r92 = ɵngcc0.ɵɵnextContext(); return ctx_r92.toggleColumnHidingUI(); });
    ɵngcc0.ɵɵelementStart(3, "div", 10);
    ɵngcc0.ɵɵtemplate(4, IgxGridToolbarComponent_div_4_igx_icon_4_Template, 2, 0, "igx-icon", 3);
    ɵngcc0.ɵɵtemplate(5, IgxGridToolbarComponent_div_4_igx_icon_5_Template, 2, 0, "igx-icon", 3);
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "span");
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "igx-drop-down", null, 13);
    ɵngcc0.ɵɵelementStart(12, "igx-column-hiding", 14);
    ɵngcc0.ɵɵlistener("onColumnVisibilityChanged", function IgxGridToolbarComponent_div_4_Template_igx_column_hiding_onColumnVisibilityChanged_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r93); const ctx_r94 = ɵngcc0.ɵɵnextContext(); return ctx_r94.grid.toggleColumnVisibility($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r81 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r81.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r81.grid.hiddenColumnsCount > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r81.grid.hiddenColumnsCount === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r81.grid.hiddenColumnsCount);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r81.grid.hiddenColumnsText);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("columns", ctx_r81.grid.columns)("title", ctx_r81.grid.columnHidingTitle)("filterColumnsPrompt", ctx_r81.filterColumnsPrompt)("columnsAreaMaxHeight", ctx_r81.defaultDropDownsMaxHeight);
} }
function IgxGridToolbarComponent_div_5_igx_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 21);
} }
function IgxGridToolbarComponent_div_5_igx_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 22);
} }
function IgxGridToolbarComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r100 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "button", 15, 16);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_5_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r100); const ctx_r99 = ɵngcc0.ɵɵnextContext(); return ctx_r99.toggleColumnPinningUI(); });
    ɵngcc0.ɵɵelementStart(3, "div", 10);
    ɵngcc0.ɵɵtemplate(4, IgxGridToolbarComponent_div_5_igx_icon_4_Template, 1, 0, "igx-icon", 17);
    ɵngcc0.ɵɵtemplate(5, IgxGridToolbarComponent_div_5_igx_icon_5_Template, 1, 0, "igx-icon", 18);
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "span");
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(10, "span");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "igx-drop-down", null, 19);
    ɵngcc0.ɵɵelement(13, "igx-column-pinning", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r82 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r82.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r82.pinnedColumnsCount > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r82.pinnedColumnsCount === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r82.pinnedColumnsCount);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r82.grid.pinnedColumnsText);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("columns", ctx_r82.grid.columns)("title", ctx_r82.grid.columnPinningTitle)("filterColumnsPrompt", ctx_r82.filterColumnsPrompt)("columnsAreaMaxHeight", ctx_r82.defaultDropDownsMaxHeight);
} }
function IgxGridToolbarComponent_div_6_li_13_Template(rf, ctx) { if (rf & 1) {
    const _r106 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 31);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_6_li_13_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r106); const ctx_r105 = ɵngcc0.ɵɵnextContext(2); return ctx_r105.exportToExcelClicked(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r103 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r103.getExportExcelText());
} }
function IgxGridToolbarComponent_div_6_li_14_Template(rf, ctx) { if (rf & 1) {
    const _r108 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 32);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_6_li_14_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r108); const ctx_r107 = ɵngcc0.ɵɵnextContext(2); return ctx_r107.exportToCsvClicked(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r104 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r104.getExportCsvText());
} }
function IgxGridToolbarComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r110 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵelementStart(1, "button", 24, 25);
    ɵngcc0.ɵɵlistener("click", function IgxGridToolbarComponent_div_6_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r110); const ctx_r109 = ɵngcc0.ɵɵnextContext(); return ctx_r109.exportClicked(); });
    ɵngcc0.ɵɵelementStart(3, "span", 10);
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 26);
    ɵngcc0.ɵɵtext(5, "import_export");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "igx-icon", 26);
    ɵngcc0.ɵɵtext(9, "arrow_drop_down");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "igx-drop-down", null, 27);
    ɵngcc0.ɵɵelementStart(12, "ul", 28);
    ɵngcc0.ɵɵtemplate(13, IgxGridToolbarComponent_div_6_li_13_Template, 2, 1, "li", 29);
    ɵngcc0.ɵɵtemplate(14, IgxGridToolbarComponent_div_6_li_14_Template, 2, 1, "li", 30);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r83 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r83.grid.displayDensity);
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵtextInterpolate(ctx_r83.getExportText());
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r83.shouldShowExportExcelButton);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r83.shouldShowExportCsvButton);
} }
const _c27 = ["leftPanningTmpl"];
const _c28 = ["rightPanningTmpl"];
function IgxListItemComponent_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7, 8);
    ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_div_0_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r111 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r111.element.offsetWidth, "px")("height", ctx_r111.element.offsetHeight, "px");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r111.list.listItemLeftPanningTemplate.template)("ngTemplateOutletContext", ctx_r111.context);
} }
function IgxListItemComponent_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10, 11);
    ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_div_1_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r112 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r112.element.offsetWidth, "px")("height", ctx_r112.element.offsetHeight, "px");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r112.list.listItemRightPanningTemplate.template)("ngTemplateOutletContext", ctx_r112.context);
} }
function IgxListItemComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxListItemComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListItemComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListItemComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵprojection(1, 3);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListItemComponent_ng_container_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxListItemComponent_ng_container_10_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r113 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r113);
} }
function IgxListItemComponent_ng_container_11_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListItemComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 16);
    ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_ng_container_11_ng_container_2_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵtemplate(3, IgxListItemComponent_ng_container_11_ng_container_3_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵtemplate(4, IgxListItemComponent_ng_container_11_ng_container_4_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵtemplate(5, IgxListItemComponent_ng_container_11_ng_container_5_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r115 = ɵngcc0.ɵɵreference(5);
    const _r117 = ɵngcc0.ɵɵreference(7);
    const _r119 = ɵngcc0.ɵɵreference(9);
    const _r113 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r115);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r117);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r119);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r113);
} }
const _c29 = ["*", [["", "igxListThumbnail", ""], ["igx-list__item-thumbnail"], ["igx-avatar"]], [["", "igxListLine", ""], ["", 8, "igx-list__item-lines"], ["", "igxListLineTitle", ""], ["", "igxListLineSubTitle", ""], ["", 8, "igx-list__item-line-title"], ["", 8, "igx-list__item-line-subtitle"]], [["", "igxListAction", ""], ["", 8, "igx-list__item-actions"]]];
const _c30 = ["*", "[igxListThumbnail], igx-list__item-thumbnail, igx-avatar", "[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle", "[igxListAction], .igx-list__item-actions"];
const _c31 = ["defaultEmptyList"];
const _c32 = ["defaultDataLoading"];
function IgxListComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "article", 3);
    ɵngcc0.ɵɵtext(1, " There are no items in the list. ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "article", 3);
    ɵngcc0.ɵɵtext(1, " Loading data from the server... ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxListComponent_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxListComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxListComponent_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r136 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r136.template)("ngTemplateOutletContext", ctx_r136.context);
} }
const _c33 = ["input"];
const _c34 = ["list"];
const _c35 = ["defaultExcelStyleLoadingValuesTemplate"];
function IgxExcelStyleSearchComponent_igx_icon_5_Template(rf, ctx) { if (rf & 1) {
    const _r146 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 10);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSearchComponent_igx_icon_5_Template_igx_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r146); const ctx_r145 = ɵngcc0.ɵɵnextContext(); return ctx_r145.clearInput(); });
    ɵngcc0.ɵɵtext(1, " clear ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxExcelStyleSearchComponent_igx_list_item_9_Template(rf, ctx) { if (rf & 1) {
    const _r149 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-list-item");
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 11);
    ɵngcc0.ɵɵlistener("change", function IgxExcelStyleSearchComponent_igx_list_item_9_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r149); const ctx_r148 = ɵngcc0.ɵɵnextContext(); return ctx_r148.onCheckboxChange($event); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r147 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", item_r147)("checked", item_r147.isSelected)("disableRipple", true)("indeterminate", item_r147.indeterminate)("disableTransitions", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", item_r147.label, " ");
} }
function IgxExcelStyleSearchComponent_ng_template_11_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxExcelStyleSearchComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, IgxExcelStyleSearchComponent_ng_template_11_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r142 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r142.valuesLoadingTemplate);
} }
function IgxExcelStyleSearchComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 14);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
const _c36 = ["noLigature"];
const _c37 = ["explicitLigature"];
const _c38 = ["svgImage"];
function IgxIconComponent_ng_template_0_Template(rf, ctx) { }
function IgxIconComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxIconComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "svg");
    ɵngcc0.ɵɵelement(1, "use");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r156 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵattribute("href", ctx_r156.getSvgKey);
} }
function IgxIconComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxButtonGroupComponent_button_1_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const button_r159 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(button_r159.icon);
} }
function IgxButtonGroupComponent_button_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const button_r159 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(button_r159.label);
} }
function IgxButtonGroupComponent_button_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtemplate(2, IgxButtonGroupComponent_button_1_igx_icon_2_Template, 2, 1, "igx-icon", 3);
    ɵngcc0.ɵɵtemplate(3, IgxButtonGroupComponent_button_1_span_3_Template, 2, 1, "span", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const button_r159 = ctx.$implicit;
    const ctx_r158 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r158.displayDensity)("selected", button_r159.selected)("disabled", ctx_r158.disabled || button_r159.disabled)("igxButtonColor", button_r159.color)("igxButtonBackground", button_r159.bgcolor)("igxLabel", button_r159.label)("igxRipple", button_r159.ripple);
    ɵngcc0.ɵɵattribute("data-togglable", button_r159.togglable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-button-group__item-content ", ctx_r158.itemContentCssClass, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", button_r159.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", button_r159.label);
} }
const _c39 = ["inputGroupConditions"];
const _c40 = ["inputValues"];
const _c41 = ["dropdownConditions"];
const _c42 = ["logicOperatorButtonGroup"];
function IgxExcelStyleDefaultExpressionComponent_igx_drop_down_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 14);
    ɵngcc0.ɵɵelement(1, "igx-icon", 15);
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r174 = ctx.$implicit;
    const ctx_r166 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", condition_r174)("selected", ctx_r166.isConditionSelected(condition_r174));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r166.getCondition(condition_r174).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r166.translateCondition(condition_r174));
} }
function IgxExcelStyleDefaultExpressionComponent_igx_icon_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 15);
} if (rf & 2) {
    const ctx_r168 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r168.getIconName());
} }
function IgxExcelStyleDefaultExpressionComponent_igx_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "filter_list");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxExcelStyleDefaultExpressionComponent_button_13_Template(rf, ctx) { if (rf & 1) {
    const _r176 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 16);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDefaultExpressionComponent_button_13_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r176); const ctx_r175 = ɵngcc0.ɵɵnextContext(); return ctx_r175.onRemoveButtonClick(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r172 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r172.displayDensity);
} }
function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_14_Template(rf, ctx) { if (rf & 1) {
    const _r181 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-buttongroup", 17, 18);
    ɵngcc0.ɵɵelementStart(2, "span", 19, 20);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_14_Template_span_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r181); const ctx_r180 = ɵngcc0.ɵɵnextContext(); return ctx_r180.onLogicOperatorKeyDown($event, 0); })("click", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_14_Template_span_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r181); const ctx_r182 = ɵngcc0.ɵɵnextContext(); return ctx_r182.onLogicOperatorButtonClicked($event, 0); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span", 19, 21);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_14_Template_span_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r181); const ctx_r183 = ɵngcc0.ɵɵnextContext(); return ctx_r183.onLogicOperatorKeyDown($event, 1); })("click", function IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_14_Template_span_click_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r181); const ctx_r184 = ɵngcc0.ɵɵnextContext(); return ctx_r184.onLogicOperatorButtonClicked($event, 1); });
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r173 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("multiSelection", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r173.displayDensity)("selected", ctx_r173.expressionUI.afterOperator === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r173.grid.resourceStrings.igx_grid_filter_operator_and, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r173.displayDensity)("selected", ctx_r173.expressionUI.afterOperator === 1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r173.grid.resourceStrings.igx_grid_filter_operator_or, " ");
} }
const _c43 = ["yearsBtn"];
function IgxMonthsViewComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r189 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵlistener("onMonthSelection", function IgxMonthsViewComponent_div_2_Template_div_onMonthSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r189); const ctx_r188 = ɵngcc0.ɵɵnextContext(); return ctx_r188.selectMonth($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "titlecase");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const month_r186 = ctx.$implicit;
    const i_r187 = ctx.index;
    const ctx_r185 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxCalendarMonth", month_r186)("date", ctx_r185.date)("index", i_r187);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(2, 4, ctx_r185.formattedMonth(month_r186)), " ");
} }
function IgxYearsViewComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    const _r193 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵlistener("onYearSelection", function IgxYearsViewComponent_span_2_Template_span_onYearSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r193); const ctx_r192 = ɵngcc0.ɵɵnextContext(); return ctx_r192.selectYear($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const year_r191 = ctx.$implicit;
    const ctx_r190 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxCalendarYear", year_r191)("date", ctx_r190.date);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r190.formattedYear(year_r191), " ");
} }
function IgxDaysViewComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "titlecase");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dayName_r196 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind1(2, 1, dayName_r196), " ");
} }
function IgxDaysViewComponent_div_2_igx_day_item_1_Template(rf, ctx) { if (rf & 1) {
    const _r203 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-day-item", 5);
    ɵngcc0.ɵɵlistener("onDateSelection", function IgxDaysViewComponent_div_2_igx_day_item_1_Template_igx_day_item_onDateSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r203); const ctx_r202 = ɵngcc0.ɵɵnextContext(2); return ctx_r202.selectDay($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r201 = ctx.$implicit;
    const ctx_r200 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("date", day_r201)("selection", ctx_r200.selection)("selected", ctx_r200.isSelected(day_r201))("isLastInRange", ctx_r200.isLastInRange(day_r201))("isFirstInRange", ctx_r200.isFirstInRange(day_r201))("isWithinRange", ctx_r200.isWithinRange(day_r201.date, true))("disabledDates", ctx_r200.disabledDates)("specialDates", ctx_r200.specialDates)("outOfRangeDates", ctx_r200.outOfRangeDates)("hideOutsideDays", ctx_r200.hideOutsideDays);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r200.formattedDate(day_r201.date), " ");
} }
function IgxDaysViewComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 0);
    ɵngcc0.ɵɵtemplate(1, IgxDaysViewComponent_div_2_igx_day_item_1_Template, 2, 11, "igx-day-item", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r197 = ctx.$implicit;
    const ctx_r195 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", week_r197)("ngForTrackBy", ctx_r195.dateTracker);
} }
const _c44 = ["months"];
const _c45 = ["decade"];
const _c46 = ["days"];
const _c47 = ["prevMonthBtn"];
const _c48 = ["nextMonthBtn"];
const _c49 = ["monthsBtn"];
function IgxCalendarComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r205 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r205.getFormattedDate().weekday, ",\u00A0");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r205.getFormattedDate().monthday);
} }
function IgxCalendarComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r218 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 6, 7);
    ɵngcc0.ɵɵlistener("keydown", function IgxCalendarComponent_ng_template_2_Template_span_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r218); const obj_r214 = ctx.$implicit; const ctx_r217 = ɵngcc0.ɵɵnextContext(); return ctx_r217.onActiveViewYearKB(ctx_r217.getViewDate(obj_r214.index), $event, obj_r214.index); })("click", function IgxCalendarComponent_ng_template_2_Template_span_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r218); const obj_r214 = ctx.$implicit; const ctx_r219 = ɵngcc0.ɵɵnextContext(); return ctx_r219.onActiveViewYear(ctx_r219.getViewDate(obj_r214.index), obj_r214.index, $event); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", 6, 8);
    ɵngcc0.ɵɵlistener("keydown", function IgxCalendarComponent_ng_template_2_Template_span_keydown_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r218); const obj_r214 = ctx.$implicit; const ctx_r220 = ɵngcc0.ɵɵnextContext(); return ctx_r220.onActiveViewDecadeKB($event, ctx_r220.getViewDate(obj_r214.index), obj_r214.index); })("click", function IgxCalendarComponent_ng_template_2_Template_span_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r218); const obj_r214 = ctx.$implicit; const ctx_r221 = ɵngcc0.ɵɵnextContext(); return ctx_r221.onActiveViewDecade(ctx_r221.getViewDate(obj_r214.index), obj_r214.index); });
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const obj_r214 = ctx.$implicit;
    const ctx_r207 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r207.formattedMonth(ctx_r207.getViewDate(obj_r214.index)), " ");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r207.formattedYear(ctx_r207.getViewDate(obj_r214.index)), " ");
} }
function IgxCalendarComponent_div_4_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCalendarComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "h5", 10);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "h2", 11);
    ɵngcc0.ɵɵtemplate(4, IgxCalendarComponent_div_4_ng_container_4_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r208 = ɵngcc0.ɵɵnextContext();
    const _r204 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r208.formattedYear(ctx_r208.headerDate));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r208.headerTemplate ? ctx_r208.headerTemplate : _r204)("ngTemplateOutletContext", ctx_r208.headerContext);
} }
function IgxCalendarComponent_div_5_div_6_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCalendarComponent_div_5_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 23);
    ɵngcc0.ɵɵpipe(1, "IgxGetViewDate");
    ɵngcc0.ɵɵtemplate(2, IgxCalendarComponent_div_5_div_6_ng_container_2_Template, 1, 0, "ng-container", 12);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r228 = ctx.index;
    const ctx_r224 = ɵngcc0.ɵɵnextContext(2);
    const _r206 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵstyleProp("width", 100 / ctx_r224.monthsViewNumber, "%");
    ɵngcc0.ɵɵattribute("data-month", ɵngcc0.ɵɵpipeBind3(1, 5, i_r228, ctx_r224.viewDate, false));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r224.subheaderTemplate ? ctx_r224.subheaderTemplate : _r206)("ngTemplateOutletContext", ctx_r224.getContext(i_r228));
} }
function IgxCalendarComponent_div_5_igx_days_view_13_Template(rf, ctx) { if (rf & 1) {
    const _r234 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-days-view", 24, 25);
    ɵngcc0.ɵɵlistener("onViewChanging", function IgxCalendarComponent_div_5_igx_days_view_13_Template_igx_days_view_onViewChanging_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r234); const ctx_r233 = ɵngcc0.ɵɵnextContext(2); return ctx_r233.viewChanging($event); })("onDateSelection", function IgxCalendarComponent_div_5_igx_days_view_13_Template_igx_days_view_onDateSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r234); const ctx_r235 = ɵngcc0.ɵɵnextContext(2); return ctx_r235.childClicked($event); });
    ɵngcc0.ɵɵpipe(2, "IgxGetViewDate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const i_r231 = ctx.index;
    const ctx_r226 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("changeDaysView", true)("selection", ctx_r226.selection)("locale", ctx_r226.locale)("value", ctx_r226.value)("viewDate", ɵngcc0.ɵɵpipeBind2(2, 11, i_r231, ctx_r226.viewDate))("weekStart", ctx_r226.weekStart)("formatOptions", ctx_r226.formatOptions)("formatViews", ctx_r226.formatViews)("disabledDates", ctx_r226.disabledDates)("specialDates", ctx_r226.specialDates)("hideOutsideDays", ctx_r226.hideOutsideDays);
} }
const _c50 = function (a0) { return { "min-width.%": a0 }; };
function IgxCalendarComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    const _r237 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵlistener("swiperight", function IgxCalendarComponent_div_5_Template_div_swiperight_0_listener() { ɵngcc0.ɵɵrestoreView(_r237); const ctx_r236 = ɵngcc0.ɵɵnextContext(); return ctx_r236.previousMonth(); })("swipeleft", function IgxCalendarComponent_div_5_Template_div_swipeleft_0_listener() { ɵngcc0.ɵɵrestoreView(_r237); const ctx_r238 = ɵngcc0.ɵɵnextContext(); return ctx_r238.nextMonth(); });
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵelementStart(2, "div", 15, 16);
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 17);
    ɵngcc0.ɵɵtext(5, "keyboard_arrow_left");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, IgxCalendarComponent_div_5_div_6_Template, 3, 9, "div", 18);
    ɵngcc0.ɵɵpipe(7, "IgxMonthViewSlots");
    ɵngcc0.ɵɵelementStart(8, "div", 19, 20);
    ɵngcc0.ɵɵelementStart(10, "igx-icon", 17);
    ɵngcc0.ɵɵtext(11, "keyboard_arrow_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "div", 21);
    ɵngcc0.ɵɵlistener("@animateChange.done", function IgxCalendarComponent_div_5_Template_div_animation_animateChange_done_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r237); const ctx_r239 = ɵngcc0.ɵɵnextContext(); return ctx_r239.animationDone($event); });
    ɵngcc0.ɵɵtemplate(13, IgxCalendarComponent_div_5_igx_days_view_13_Template, 3, 14, "igx-days-view", 22);
    ɵngcc0.ɵɵpipe(14, "IgxMonthViewSlots");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r209 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r209.activeView);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("startScroll", ctx_r209.startPrevMonthScroll)("stopScroll", ctx_r209.stopMonthScroll)("ngStyle", ɵngcc0.ɵɵpureFunction1(14, _c50, 100 / (ctx_r209.monthsViewNumber * 7)));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(7, 10, ctx_r209.monthsViewNumber));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("startScroll", ctx_r209.startNextMonthScroll)("stopScroll", ctx_r209.stopMonthScroll)("ngStyle", ɵngcc0.ɵɵpureFunction1(16, _c50, 100 / (ctx_r209.monthsViewNumber * 7)));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("@animateChange", ctx_r209.animationAction);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(14, 12, ctx_r209.monthsViewNumber));
} }
function IgxCalendarComponent_igx_months_view_6_Template(rf, ctx) { if (rf & 1) {
    const _r242 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-months-view", 26, 27);
    ɵngcc0.ɵɵlistener("onSelection", function IgxCalendarComponent_igx_months_view_6_Template_igx_months_view_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r242); const ctx_r241 = ɵngcc0.ɵɵnextContext(); return ctx_r241.changeMonth($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r210 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r210.activeView)("date", ctx_r210.viewDate)("locale", ctx_r210.locale)("formatView", ctx_r210.formatViews.month)("monthFormat", ctx_r210.formatOptions.month);
} }
function IgxCalendarComponent_igx_years_view_7_Template(rf, ctx) { if (rf & 1) {
    const _r245 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-years-view", 28, 29);
    ɵngcc0.ɵɵlistener("onSelection", function IgxCalendarComponent_igx_years_view_7_Template_igx_years_view_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r245); const ctx_r244 = ɵngcc0.ɵɵnextContext(); return ctx_r244.changeYear($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r211 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r211.activeView)("date", ctx_r211.viewDate)("locale", ctx_r211.locale)("formatView", ctx_r211.formatViews.year)("yearFormat", ctx_r211.formatOptions.year);
} }
const _c51 = function () { return { "min-width.%": 25, "left": 0 }; };
const _c52 = function () { return { "min-width.%": 25, "right": 0 }; };
function IgxMonthPickerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r251 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵlistener("swiperight", function IgxMonthPickerComponent_div_0_Template_div_swiperight_0_listener() { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r250 = ɵngcc0.ɵɵnextContext(); return ctx_r250.previousYear(); })("swipeleft", function IgxMonthPickerComponent_div_0_Template_div_swipeleft_0_listener() { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r252 = ɵngcc0.ɵɵnextContext(); return ctx_r252.nextYear(); });
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵlistener("click", function IgxMonthPickerComponent_div_0_Template_div_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r253 = ɵngcc0.ɵɵnextContext(); return ctx_r253.previousYear(); })("keydown", function IgxMonthPickerComponent_div_0_Template_div_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r254 = ɵngcc0.ɵɵnextContext(); return ctx_r254.previousYearKB($event); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 5);
    ɵngcc0.ɵɵtext(4, "keyboard_arrow_left");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div");
    ɵngcc0.ɵɵelementStart(6, "span", 6, 7);
    ɵngcc0.ɵɵlistener("keydown", function IgxMonthPickerComponent_div_0_Template_span_keydown_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r255 = ɵngcc0.ɵɵnextContext(); return ctx_r255.activeViewDecadeKB($event); })("click", function IgxMonthPickerComponent_div_0_Template_span_click_6_listener() { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r256 = ɵngcc0.ɵɵnextContext(); return ctx_r256.activeViewDecade(); });
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 8);
    ɵngcc0.ɵɵlistener("click", function IgxMonthPickerComponent_div_0_Template_div_click_9_listener() { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r257 = ɵngcc0.ɵɵnextContext(); return ctx_r257.nextYear(); })("keydown", function IgxMonthPickerComponent_div_0_Template_div_keydown_9_listener($event) { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r258 = ɵngcc0.ɵɵnextContext(); return ctx_r258.nextYearKB($event); });
    ɵngcc0.ɵɵelementStart(10, "igx-icon", 5);
    ɵngcc0.ɵɵtext(11, "keyboard_arrow_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "igx-months-view", 9, 10);
    ɵngcc0.ɵɵlistener("@animateChange.done", function IgxMonthPickerComponent_div_0_Template_igx_months_view_animation_animateChange_done_12_listener() { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r259 = ɵngcc0.ɵɵnextContext(); return ctx_r259.animationDone(); })("onSelection", function IgxMonthPickerComponent_div_0_Template_igx_months_view_onSelection_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r251); const ctx_r260 = ɵngcc0.ɵɵnextContext(); return ctx_r260.selectMonth($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r246 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r246.activeView);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction0(11, _c51));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r246.formattedYear(ctx_r246.viewDate), " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction0(12, _c52));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("@animateChange", ctx_r246.yearAction)("date", ctx_r246.viewDate)("locale", ctx_r246.locale)("formatView", ctx_r246.formatViews.month)("monthFormat", ctx_r246.formatOptions.month);
} }
function IgxMonthPickerComponent_igx_years_view_1_Template(rf, ctx) { if (rf & 1) {
    const _r263 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-years-view", 11, 12);
    ɵngcc0.ɵɵlistener("onSelection", function IgxMonthPickerComponent_igx_years_view_1_Template_igx_years_view_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r263); const ctx_r262 = ɵngcc0.ɵɵnextContext(); return ctx_r262.selectYear($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r247 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@animateView", ctx_r247.activeView)("date", ctx_r247.viewDate)("locale", ctx_r247.locale)("formatView", ctx_r247.formatViews.year)("yearFormat", ctx_r247.formatOptions.year);
} }
const _c53 = ["calendar"];
function IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r273 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 6, 7);
    ɵngcc0.ɵɵlistener("click", function IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r273); const ctx_r272 = ɵngcc0.ɵɵnextContext(3); return ctx_r272.closeCalendar(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r269 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r269.cancelButtonLabel, " ");
} }
function IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r276 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 6, 8);
    ɵngcc0.ɵɵlistener("click", function IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r276); const ctx_r275 = ɵngcc0.ɵɵnextContext(3); return ctx_r275.triggerTodaySelection(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r270 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r270.todayButtonLabel, " ");
} }
function IgxCalendarContainerComponent_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, IgxCalendarContainerComponent_ng_template_0_div_0_button_1_Template, 3, 1, "button", 5);
    ɵngcc0.ɵɵtemplate(2, IgxCalendarContainerComponent_ng_template_0_div_0_button_2_Template, 3, 1, "button", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r268 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r268.cancelButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r268.todayButtonLabel);
} }
function IgxCalendarContainerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxCalendarContainerComponent_ng_template_0_div_0_Template, 3, 2, "div", 3);
} if (rf & 2) {
    const ctx_r265 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r265.cancelButtonLabel || ctx_r265.todayButtonLabel);
} }
function IgxCalendarContainerComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c54 = ["readOnlyDatePickerTemplate"];
const _c55 = ["editableDatePickerTemplate"];
function IgxDatePickerComponent_ng_template_0_label_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r282 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r282.label);
} }
function IgxDatePickerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r284 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 3);
    ɵngcc0.ɵɵlistener("click", function IgxDatePickerComponent_ng_template_0_Template_igx_input_group_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r284); const ctx_r283 = ɵngcc0.ɵɵnextContext(); return ctx_r283.openDialog(); });
    ɵngcc0.ɵɵelementStart(1, "igx-prefix");
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "today");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, IgxDatePickerComponent_ng_template_0_label_4_Template, 2, 1, "label", 4);
    ɵngcc0.ɵɵelementStart(5, "input", 5);
    ɵngcc0.ɵɵlistener("blur", function IgxDatePickerComponent_ng_template_0_Template_input_blur_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r284); const ctx_r285 = ɵngcc0.ɵɵnextContext(); return ctx_r285.onBlur($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r278 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r278.labelVisibility);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r278.displayData || "")("disabled", ctx_r278.disabled);
} }
function IgxDatePickerComponent_ng_template_2_label_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "label", 6);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r287 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r287.label);
} }
function IgxDatePickerComponent_ng_template_2_igx_suffix_7_Template(rf, ctx) { if (rf & 1) {
    const _r290 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix", 3);
    ɵngcc0.ɵɵlistener("click", function IgxDatePickerComponent_ng_template_2_igx_suffix_7_Template_igx_suffix_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r290); const ctx_r289 = ɵngcc0.ɵɵnextContext(2); return ctx_r289.clear(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDatePickerComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r292 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", null, 7);
    ɵngcc0.ɵɵelementStart(2, "igx-prefix", 3);
    ɵngcc0.ɵɵlistener("click", function IgxDatePickerComponent_ng_template_2_Template_igx_prefix_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r292); const ctx_r291 = ɵngcc0.ɵɵnextContext(); return ctx_r291.onOpenClick($event); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon");
    ɵngcc0.ɵɵtext(4, "today");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDatePickerComponent_ng_template_2_label_5_Template, 2, 1, "label", 4);
    ɵngcc0.ɵɵelementStart(6, "input", 8);
    ɵngcc0.ɵɵlistener("blur", function IgxDatePickerComponent_ng_template_2_Template_input_blur_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r292); const ctx_r293 = ɵngcc0.ɵɵnextContext(); return ctx_r293.onBlur($event); })("wheel", function IgxDatePickerComponent_ng_template_2_Template_input_wheel_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r292); const ctx_r294 = ɵngcc0.ɵɵnextContext(); return ctx_r294.onWheel($event); })("input", function IgxDatePickerComponent_ng_template_2_Template_input_input_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r292); const ctx_r295 = ɵngcc0.ɵɵnextContext(); return ctx_r295.onInput($event); })("focus", function IgxDatePickerComponent_ng_template_2_Template_input_focus_6_listener() { ɵngcc0.ɵɵrestoreView(_r292); const ctx_r296 = ɵngcc0.ɵɵnextContext(); return ctx_r296.onFocus(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, IgxDatePickerComponent_ng_template_2_igx_suffix_7_Template, 3, 0, "igx-suffix", 9);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r280 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r280.labelVisibility);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxTextSelection", true)("value", ctx_r280.transformedDate)("igxMask", ctx_r280.inputMask)("placeholder", ctx_r280.mask)("disabled", ctx_r280.disabled)("displayValuePipe", ctx_r280.displayValuePipe)("focusedValuePipe", ctx_r280.inputValuePipe);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r280.isEmpty);
} }
function IgxDatePickerComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c56 = ["datePicker"];
function IgxExcelStyleDateExpressionComponent_igx_drop_down_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 13);
    ɵngcc0.ɵɵelement(1, "igx-icon", 14);
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r306 = ctx.$implicit;
    const ctx_r298 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", condition_r306)("selected", ctx_r298.isConditionSelected(condition_r306));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r298.getCondition(condition_r306).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r298.translateCondition(condition_r306));
} }
function IgxExcelStyleDateExpressionComponent_igx_icon_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 14);
} if (rf & 2) {
    const ctx_r300 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("name", ctx_r300.getIconName());
} }
function IgxExcelStyleDateExpressionComponent_igx_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "filter_list");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxExcelStyleDateExpressionComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    const _r312 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 15, 16);
    ɵngcc0.ɵɵelementStart(2, "input", 17, 18);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDateExpressionComponent_ng_template_11_Template_input_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r312); const openDialog_r307 = ctx.openDialog; const _r309 = ɵngcc0.ɵɵreference(1); return openDialog_r307(_r309.element.nativeElement); });
    ɵngcc0.ɵɵpipe(4, "igxdate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r308 = ctx.value;
    const ctx_r303 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r303.displayDensity);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r303.inputDatePlaceholder)("value", ɵngcc0.ɵɵpipeBind2(4, 5, value_r308, ctx_r303.grid.locale))("readonly", true)("disabled", ctx_r303.expressionUI.expression.condition && ctx_r303.expressionUI.expression.condition.isUnary);
} }
function IgxExcelStyleDateExpressionComponent_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r314 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 19);
    ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDateExpressionComponent_button_12_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r314); const ctx_r313 = ɵngcc0.ɵɵnextContext(); return ctx_r313.onRemoveButtonClick(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r304 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r304.displayDensity);
} }
function IgxExcelStyleDateExpressionComponent_igx_buttongroup_13_Template(rf, ctx) { if (rf & 1) {
    const _r319 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-buttongroup", 20, 21);
    ɵngcc0.ɵɵelementStart(2, "span", 22, 23);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_13_Template_span_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r319); const ctx_r318 = ɵngcc0.ɵɵnextContext(); return ctx_r318.onLogicOperatorKeyDown($event, 0); })("click", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_13_Template_span_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r319); const ctx_r320 = ɵngcc0.ɵɵnextContext(); return ctx_r320.onLogicOperatorButtonClicked($event, 0); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span", 22, 24);
    ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_13_Template_span_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r319); const ctx_r321 = ɵngcc0.ɵɵnextContext(); return ctx_r321.onLogicOperatorKeyDown($event, 1); })("click", function IgxExcelStyleDateExpressionComponent_igx_buttongroup_13_Template_span_click_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r319); const ctx_r322 = ɵngcc0.ɵɵnextContext(); return ctx_r322.onLogicOperatorButtonClicked($event, 1); });
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r305 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("multiSelection", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r305.displayDensity)("selected", ctx_r305.expressionUI.afterOperator === 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r305.grid.resourceStrings.igx_grid_filter_operator_and, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r305.displayDensity)("selected", ctx_r305.expressionUI.afterOperator === 1);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r305.grid.resourceStrings.igx_grid_filter_operator_or, " ");
} }
const _c57 = ["toggle"];
const _c58 = ["defaultExpressionTemplate"];
const _c59 = ["dateExpressionTemplate"];
const _c60 = ["expressionsContainer"];
function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template(rf, ctx) { if (rf & 1) {
    const _r330 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-excel-style-date-expression", 12);
    ɵngcc0.ɵɵlistener("onExpressionRemoved", function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template_igx_excel_style_date_expression_onExpressionRemoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r330); const ctx_r329 = ɵngcc0.ɵɵnextContext(2); return ctx_r329.onExpressionRemoved($event); })("onLogicOperatorChanged", function IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template_igx_excel_style_date_expression_onLogicOperatorChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r330); const ctx_r331 = ɵngcc0.ɵɵnextContext(2); return ctx_r331.onLogicOperatorChanged($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expression_r328 = ctx.$implicit;
    const ctx_r327 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("expressionUI", expression_r328)("column", ctx_r327.column)("grid", ctx_r327.grid)("displayDensity", ctx_r327.displayDensity)("expressionsList", ctx_r327.expressionsList);
} }
function IgxExcelStyleCustomDialogComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxExcelStyleCustomDialogComponent_ng_container_7_igx_excel_style_date_expression_1_Template, 1, 5, "igx-excel-style-date-expression", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r325 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r325.expressionsList);
} }
function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template(rf, ctx) { if (rf & 1) {
    const _r335 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-excel-style-default-expression", 12);
    ɵngcc0.ɵɵlistener("onExpressionRemoved", function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template_igx_excel_style_default_expression_onExpressionRemoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r335); const ctx_r334 = ɵngcc0.ɵɵnextContext(2); return ctx_r334.onExpressionRemoved($event); })("onLogicOperatorChanged", function IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template_igx_excel_style_default_expression_onLogicOperatorChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r335); const ctx_r336 = ɵngcc0.ɵɵnextContext(2); return ctx_r336.onLogicOperatorChanged($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expression_r333 = ctx.$implicit;
    const ctx_r332 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("expressionUI", expression_r333)("column", ctx_r332.column)("grid", ctx_r332.grid)("displayDensity", ctx_r332.displayDensity)("expressionsList", ctx_r332.expressionsList);
} }
function IgxExcelStyleCustomDialogComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxExcelStyleCustomDialogComponent_ng_container_8_igx_excel_style_default_expression_1_Template, 1, 5, "igx-excel-style-default-expression", 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r326 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r326.expressionsList);
} }
const _c61 = function (a0, a1) { return { "igx-excel-filter__secondary--cosy": a0, "igx-excel-filter__secondary--compact": a1 }; };
const _c62 = ["sortButtonGroup"];
const _c63 = ["subMenu"];
const _c64 = ["customDialog"];
const _c65 = ["excelStyleSearch"];
const _c66 = ["excelStyleSorting"];
const _c67 = ["defaultExcelStyleSortingTemplate"];
const _c68 = ["defaultExcelStyleHidingTemplate"];
const _c69 = ["defaultExcelStyleSelectingTemplate"];
const _c70 = ["defaultExcelStyleMovingTemplate"];
const _c71 = ["defaultExcelStylePinningTemplate"];
function IgxGridExcelStyleFilteringComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-sorting", 8, 9);
} if (rf & 2) {
    const ctx_r339 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r339.column)("grid", ctx_r339.grid)("displayDensity", ctx_r339.grid.displayDensity);
} }
function IgxGridExcelStyleFilteringComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-column-moving", 10);
} if (rf & 2) {
    const ctx_r341 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r341.column)("grid", ctx_r341.grid)("isColumnPinnable", ctx_r341.isColumnPinnable)("displayDensity", ctx_r341.grid.displayDensity);
} }
function IgxGridExcelStyleFilteringComponent_ng_template_4_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r355 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_ng_template_4_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r355); const ctx_r354 = ɵngcc0.ɵɵnextContext(2); return ctx_r354.onPin(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-icon", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r352 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r352.pinClass());
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r352.grid.resourceStrings.igx_grid_excel_pin);
} }
function IgxGridExcelStyleFilteringComponent_ng_template_4_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r357 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_ng_template_4_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r357); const ctx_r356 = ɵngcc0.ɵɵnextContext(2); return ctx_r356.onPin(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-icon", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r353 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r353.grid.resourceStrings.igx_grid_excel_unpin);
} }
function IgxGridExcelStyleFilteringComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridExcelStyleFilteringComponent_ng_template_4_div_0_Template, 4, 2, "div", 11);
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_ng_template_4_div_1_Template, 4, 1, "div", 12);
} if (rf & 2) {
    const ctx_r343 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r343.column.pinned);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r343.column.pinned);
} }
function IgxGridExcelStyleFilteringComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    const _r359 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 17);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_ng_template_6_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r359); const ctx_r358 = ɵngcc0.ɵɵnextContext(); return ctx_r358.onHideToggle(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r345 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r345.column.hidden ? ctx_r345.grid.resourceStrings.igx_grid_excel_show : ctx_r345.grid.resourceStrings.igx_grid_excel_hide);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r345.column.hidden ? "visibility" : "visibility_off");
} }
function IgxGridExcelStyleFilteringComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    const _r361 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_ng_template_8_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r361); const ctx_r360 = ɵngcc0.ɵɵnextContext(); return ctx_r360.onSelect(); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 18);
    ɵngcc0.ɵɵtext(4, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r347 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r347.selectedClass());
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r347.grid.resourceStrings.igx_grid_excel_select);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r375 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 36);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r375); const ctx_r374 = ɵngcc0.ɵɵnextContext(3); return ctx_r374.onSelect(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 18);
    ɵngcc0.ɵɵtext(2, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r370 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r370.grid.displayDensity)("ngClass", ctx_r370.selectedClass());
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r377 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 37);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r377); const ctx_r376 = ɵngcc0.ɵɵnextContext(3); return ctx_r376.onPin(); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r371 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r371.grid.displayDensity)("disabled", !ctx_r371.isColumnPinnable);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r379 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 38);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r379); const ctx_r378 = ɵngcc0.ɵɵnextContext(3); return ctx_r378.onPin(); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r372 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r372.grid.displayDensity);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r381 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 38);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_article_10_div_5_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r381); const ctx_r380 = ɵngcc0.ɵɵnextContext(3); return ctx_r380.onHideToggle(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r373 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r373.grid.displayDensity);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r373.column.hidden ? "visibility" : "visibility_off");
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 32);
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_article_10_div_5_button_1_Template, 3, 2, "button", 33);
    ɵngcc0.ɵɵtemplate(2, IgxGridExcelStyleFilteringComponent_article_10_div_5_button_2_Template, 2, 2, "button", 34);
    ɵngcc0.ɵɵtemplate(3, IgxGridExcelStyleFilteringComponent_article_10_div_5_button_3_Template, 2, 1, "button", 35);
    ɵngcc0.ɵɵtemplate(4, IgxGridExcelStyleFilteringComponent_article_10_div_5_button_4_Template, 3, 2, "button", 35);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r363 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r363.columnSelectable());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r363.column.disablePinning && !ctx_r363.column.pinned);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r363.column.disablePinning && ctx_r363.column.pinned);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r363.column.disableHiding);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_article_10_div_6_ng_container_1_Template, 1, 0, "ng-container", 39);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r364 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r364.sortingTemplate);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_8_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_article_10_div_8_ng_container_1_Template, 1, 0, "ng-container", 39);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r365 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r365.movingTemplate);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_article_10_div_9_ng_container_1_Template, 1, 0, "ng-container", 39);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r366 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r366.selectingTemplate);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_article_10_div_10_ng_container_1_Template, 1, 0, "ng-container", 39);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r367 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r367.pinningTemplate);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_11_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExcelStyleFilteringComponent_article_10_div_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵtemplate(1, IgxGridExcelStyleFilteringComponent_article_10_div_11_ng_container_1_Template, 1, 0, "ng-container", 39);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r368 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r368.hidingTemplate);
} }
const _c72 = function (a0, a1) { return { "igx-excel-filter__menu--cosy": a0, "igx-excel-filter__menu--compact": a1 }; };
function IgxGridExcelStyleFilteringComponent_article_10_Template(rf, ctx) { if (rf & 1) {
    const _r388 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "article", 19, 20);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridExcelStyleFilteringComponent_article_10_Template_article_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r387 = ɵngcc0.ɵɵnextContext(); return ctx_r387.onKeyDown($event); });
    ɵngcc0.ɵɵelementStart(2, "header", 21);
    ɵngcc0.ɵɵelementStart(3, "h4");
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxGridExcelStyleFilteringComponent_article_10_div_5_Template, 5, 4, "div", 22);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, IgxGridExcelStyleFilteringComponent_article_10_div_6_Template, 2, 1, "div", 23);
    ɵngcc0.ɵɵelementStart(7, "section", 24);
    ɵngcc0.ɵɵtemplate(8, IgxGridExcelStyleFilteringComponent_article_10_div_8_Template, 2, 1, "div", 23);
    ɵngcc0.ɵɵtemplate(9, IgxGridExcelStyleFilteringComponent_article_10_div_9_Template, 2, 1, "div", 23);
    ɵngcc0.ɵɵtemplate(10, IgxGridExcelStyleFilteringComponent_article_10_div_10_Template, 2, 1, "div", 23);
    ɵngcc0.ɵɵtemplate(11, IgxGridExcelStyleFilteringComponent_article_10_div_11_Template, 2, 1, "div", 23);
    ɵngcc0.ɵɵelementStart(12, "div", 25);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridExcelStyleFilteringComponent_article_10_Template_div_keydown_12_listener($event) { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r389 = ɵngcc0.ɵɵnextContext(); return ctx_r389.onClearFilterKeyDown($event); })("click", function IgxGridExcelStyleFilteringComponent_article_10_Template_div_click_12_listener() { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r390 = ɵngcc0.ɵɵnextContext(); return ctx_r390.clearFilter(); });
    ɵngcc0.ɵɵelementStart(13, "span");
    ɵngcc0.ɵɵtext(14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(15, "igx-icon");
    ɵngcc0.ɵɵtext(16, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(17, "div", 26);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridExcelStyleFilteringComponent_article_10_Template_div_keydown_17_listener($event) { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r391 = ɵngcc0.ɵɵnextContext(); return ctx_r391.onTextFilterKeyDown($event); })("click", function IgxGridExcelStyleFilteringComponent_article_10_Template_div_click_17_listener($event) { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r392 = ɵngcc0.ɵɵnextContext(); return ctx_r392.onTextFilterClick($event); });
    ɵngcc0.ɵɵelementStart(18, "span");
    ɵngcc0.ɵɵtext(19);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(20, "igx-icon");
    ɵngcc0.ɵɵtext(21, "keyboard_arrow_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(22, "igx-excel-style-search", 27, 28);
    ɵngcc0.ɵɵelementStart(24, "footer", 29);
    ɵngcc0.ɵɵelementStart(25, "button", 30);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_article_10_Template_button_click_25_listener() { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r393 = ɵngcc0.ɵɵnextContext(); return ctx_r393.cancel(); });
    ɵngcc0.ɵɵtext(26);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(27, "button", 31);
    ɵngcc0.ɵɵlistener("click", function IgxGridExcelStyleFilteringComponent_article_10_Template_button_click_27_listener() { ɵngcc0.ɵɵrestoreView(_r388); const ctx_r394 = ɵngcc0.ɵɵnextContext(); return ctx_r394.applyFilter(); });
    ɵngcc0.ɵɵtext(28);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r348 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r348.minHeight)("max-height", ctx_r348.maxHeight);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(27, _c72, ctx_r348.grid.displayDensity === "cosy", ctx_r348.grid.displayDensity === "compact"))("id", ctx_r348.overlayComponentId);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r348.column.header || ctx_r348.column.field);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r348.grid.displayDensity !== "comfortable");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r348.column.sortable);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r348.column.movable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r348.columnSelectable() && ctx_r348.grid.displayDensity === "comfortable");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r348.column.disablePinning && ctx_r348.grid.displayDensity === "comfortable");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r348.column.disableHiding && ctx_r348.grid.displayDensity === "comfortable");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r348.clearFilterClass());
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r348.grid.resourceStrings.igx_grid_excel_filter_clear);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", ctx_r348.subMenu);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r348.subMenuText);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("column", ctx_r348.column)("data", ctx_r348.listData)("grid", ctx_r348.grid)("inline", ctx_r348.inline)("displayDensity", ctx_r348.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r348.grid.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r348.grid.resourceStrings.igx_grid_excel_cancel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r348.grid.displayDensity)("disabled", ctx_r348.applyButtonDisabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r348.grid.resourceStrings.igx_grid_excel_apply);
} }
function IgxGridExcelStyleFilteringComponent_igx_drop_down_11_igx_drop_down_item_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 43);
    ɵngcc0.ɵɵelement(1, "igx-icon", 44);
    ɵngcc0.ɵɵelementStart(2, "span", 45);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r398 = ctx.$implicit;
    const ctx_r396 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("value", condition_r398);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r396.getCondition(condition_r398).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r396.translateCondition(condition_r398));
} }
function IgxGridExcelStyleFilteringComponent_igx_drop_down_11_igx_drop_down_item_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item");
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", 45);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r397 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r397.grid.resourceStrings.igx_grid_excel_custom_filter);
} }
function IgxGridExcelStyleFilteringComponent_igx_drop_down_11_Template(rf, ctx) { if (rf & 1) {
    const _r400 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down", 40, 41);
    ɵngcc0.ɵɵlistener("onSelection", function IgxGridExcelStyleFilteringComponent_igx_drop_down_11_Template_igx_drop_down_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r400); const ctx_r399 = ɵngcc0.ɵɵnextContext(); return ctx_r399.onSubMenuSelection($event); })("onClosed", function IgxGridExcelStyleFilteringComponent_igx_drop_down_11_Template_igx_drop_down_onClosed_0_listener() { ɵngcc0.ɵɵrestoreView(_r400); const ctx_r401 = ɵngcc0.ɵɵnextContext(); return ctx_r401.onSubMenuClosed(); });
    ɵngcc0.ɵɵelementStart(2, "div");
    ɵngcc0.ɵɵtemplate(3, IgxGridExcelStyleFilteringComponent_igx_drop_down_11_igx_drop_down_item_3_Template, 4, 3, "igx-drop-down-item", 42);
    ɵngcc0.ɵɵtemplate(4, IgxGridExcelStyleFilteringComponent_igx_drop_down_11_igx_drop_down_item_4_Template, 5, 1, "igx-drop-down-item", 23);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r349 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("maxHeight", "397px")("displayDensity", ctx_r349.grid.displayDensity);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r349.conditions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r349.showCustomFilterItem());
} }
function IgxGridExcelStyleFilteringComponent_igx_excel_style_custom_dialog_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-excel-style-custom-dialog", 46, 47);
} if (rf & 2) {
    const ctx_r350 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r350.column)("filteringService", ctx_r350.filteringService)("overlayComponentId", ctx_r350.overlayComponentId)("overlayService", ctx_r350.overlayService)("displayDensity", ctx_r350.grid.displayDensity);
} }
function IgxGridHeaderComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r404 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ctx_r404.columnTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r404.column.header || ctx_r404.column.field);
} }
function IgxGridHeaderComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderComponent_div_4_igx_icon_1_Template(rf, ctx) { if (rf & 1) {
    const _r410 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 7);
    ɵngcc0.ɵɵlistener("click", function IgxGridHeaderComponent_div_4_igx_icon_1_Template_igx_icon_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r410); const ctx_r409 = ɵngcc0.ɵɵnextContext(2); return ctx_r409.onSortingIconClick($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r407 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r407.sortingIcon, " ");
} }
function IgxGridHeaderComponent_div_4_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    const _r412 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 8);
    ɵngcc0.ɵɵlistener("click", function IgxGridHeaderComponent_div_4_igx_icon_2_Template_igx_icon_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r412); const ctx_r411 = ɵngcc0.ɵɵnextContext(2); return ctx_r411.onFilteringIconClick($event); });
    ɵngcc0.ɵɵtext(1, " filter_list ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r408 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r408.filterIconClassName);
    ɵngcc0.ɵɵattribute("draggable", false);
} }
function IgxGridHeaderComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderComponent_div_4_igx_icon_1_Template, 2, 2, "igx-icon", 5);
    ɵngcc0.ɵɵtemplate(2, IgxGridHeaderComponent_div_4_igx_icon_2_Template, 2, 2, "igx-icon", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r406 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r406.column.sortable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r406.grid.allowFiltering == true && ctx_r406.column.filterable && ctx_r406.grid.filterMode == "excelStyleFilter");
} }
const _c73 = function (a0, a1) { return { $implicit: a0, column: a1 }; };
const _c74 = ["chipArea"];
const _c75 = ["selectContainer"];
const _c76 = ["defaultRemoveIcon"];
const _c77 = ["defaultSelectIcon"];
function IgxChipComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxChipComponent_div_9_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxChipComponent_div_9_Template(rf, ctx) { if (rf & 1) {
    const _r423 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵlistener("keydown", function IgxChipComponent_div_9_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r423); const ctx_r422 = ɵngcc0.ɵɵnextContext(); return ctx_r422.onRemoveBtnKeyDown($event); })("pointerdown", function IgxChipComponent_div_9_Template_div_pointerdown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r423); const ctx_r424 = ɵngcc0.ɵɵnextContext(); return ctx_r424.onRemoveMouseDown($event); })("mousedown", function IgxChipComponent_div_9_Template_div_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r423); const ctx_r425 = ɵngcc0.ɵɵnextContext(); return ctx_r425.onRemoveMouseDown($event); })("click", function IgxChipComponent_div_9_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r423); const ctx_r426 = ɵngcc0.ɵɵnextContext(); return ctx_r426.onRemoveClick($event); })("touchmove", function IgxChipComponent_div_9_Template_div_touchmove_0_listener() { ɵngcc0.ɵɵrestoreView(_r423); const ctx_r427 = ɵngcc0.ɵɵnextContext(); return ctx_r427.onRemoveTouchMove(); })("touchend", function IgxChipComponent_div_9_Template_div_touchend_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r423); const ctx_r428 = ɵngcc0.ɵɵnextContext(); return ctx_r428.onRemoveTouchEnd($event); });
    ɵngcc0.ɵɵtemplate(1, IgxChipComponent_div_9_ng_container_1_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r416 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("tabIndex", ctx_r416.tabIndex);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r416.removeButtonTemplate);
} }
function IgxChipComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxChipComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, "cancel");
    ɵngcc0.ɵɵelementEnd();
} }
const _c78 = [[["igx-prefix"], ["", "igxPrefix", ""]], "*", [["igx-suffix"], ["", "igxSuffix", ""]]];
const _c79 = function (a0) { return { chip: a0 }; };
const _c80 = ["igx-prefix,[igxPrefix]", "*", "igx-suffix,[igxSuffix]"];
const _c81 = ["image"];
const _c82 = ["defaultTemplate"];
const _c83 = ["imageTemplate"];
const _c84 = ["initialsTemplate"];
const _c85 = ["iconTemplate"];
function IgxAvatarComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function IgxAvatarComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 5, 6);
} if (rf & 2) {
    const ctx_r432 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r432.getSrcUrl(), ɵngcc0.ɵɵdefaultStyleSanitizer);
} }
function IgxAvatarComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r434 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r434.initials.substring(0, 2));
} }
function IgxAvatarComponent_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r436 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r436.icon);
} }
function IgxAvatarComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c86 = ["emptyFilter"];
const _c87 = ["defaultFilter"];
const _c88 = ["complexFilter"];
const _c89 = ["chipsArea"];
const _c90 = ["moreIcon"];
const _c91 = ["ghostChip"];
const _c92 = ["complexChip"];
function IgxGridFilteringCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r448 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chips-area", 4);
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 5, 6);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringCellComponent_ng_template_0_Template_igx_chip_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r448); const ctx_r447 = ɵngcc0.ɵɵnextContext(); return ctx_r447.onChipClicked(); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 7);
    ɵngcc0.ɵɵtext(4, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span");
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r440 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", "cosy");
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r440.filteringService.grid.resourceStrings.igx_grid_filter);
} }
function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template(rf, ctx) { if (rf & 1) {
    const _r460 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 15);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template_igx_chip_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r460); const item_r452 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r458 = ɵngcc0.ɵɵnextContext(2); return ctx_r458.onChipClicked(item_r452.expression); })("onRemove", function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template_igx_chip_onRemove_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r460); const item_r452 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r461 = ɵngcc0.ɵɵnextContext(2); return ctx_r461.onChipRemoved($event, item_r452); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 16);
    ɵngcc0.ɵɵelementStart(2, "span", null, 17);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r452 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r455 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("removable", true)("displayDensity", "cosy");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", item_r452.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r455.filteringService.getChipLabel(item_r452.expression), " ");
} }
function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 18);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r452 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r456 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r456.filteringService.getOperatorAsString(item_r452.afterOperator));
} }
function IgxGridFilteringCellComponent_ng_template_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_igx_chip_1_Template, 5, 4, "igx-chip", 13);
    ɵngcc0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_span_2_Template, 2, 1, "span", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r453 = ctx.last;
    const index_r454 = ctx.index;
    const ctx_r450 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r450.isChipVisible(index_r454));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r453 && ctx_r450.isChipVisible(index_r454 + 1));
} }
function IgxGridFilteringCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r466 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chips-area", 4, 8);
    ɵngcc0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_ng_container_2_Template, 3, 2, "ng-container", 9);
    ɵngcc0.ɵɵelementStart(3, "div", 10, 11);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringCellComponent_ng_template_2_Template_div_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r466); const ctx_r465 = ɵngcc0.ɵɵnextContext(); return ctx_r465.onChipClicked(); });
    ɵngcc0.ɵɵelementStart(5, "igx-icon");
    ɵngcc0.ɵɵtext(6, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(7, "igx-badge", 12);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r442 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r442.expressionsList);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r442.filteringIndicatorClass());
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("value", ctx_r442.moreFiltersCount);
} }
function IgxGridFilteringCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    const _r469 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 19, 20);
    ɵngcc0.ɵɵlistener("onRemove", function IgxGridFilteringCellComponent_ng_template_4_Template_igx_chip_onRemove_0_listener() { ɵngcc0.ɵɵrestoreView(_r469); const ctx_r468 = ɵngcc0.ɵɵnextContext(); return ctx_r468.clearFiltering(); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon", 7);
    ɵngcc0.ɵɵtext(3, "filter_list");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r444 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("removable", true)("displayDensity", "cosy");
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r444.filteringService.grid.resourceStrings.igx_grid_complex_filter);
} }
function IgxGridFilteringCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderGroupComponent_ng_container_0_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
function IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_igx_grid_header_group_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 9);
} if (rf & 2) {
    const child_r480 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r481 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", child_r480)("gridID", child_r480.grid.id)("igxColumnMovingDrag", child_r480)("ghostHost", ctx_r481.grid.outletDirective.nativeElement)("igxColumnMovingDrop", child_r480);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_igx_grid_header_group_1_Template, 1, 6, "igx-grid-header-group", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const child_r480 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !child_r480.hidden);
} }
function IgxGridHeaderGroupComponent_ng_container_0_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
const _c93 = function (a0, a1) { return { "igx-grid__th--pinned-last": a0, "igx-grid__th--pinned-first": a1 }; };
const _c94 = function (a0, a1, a2, a3) { return { "grid-template-rows": a0, "grid-template-columns": a1, "-ms-grid-rows": a2, "-ms-grid-columns": a3 }; };
function IgxGridHeaderGroupComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_0_span_1_Template, 1, 0, "span", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 4);
    ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_0_ng_container_3_Template, 2, 1, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_0_span_4_Template, 1, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r470 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r470.grid.hasMovableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(5, _c93, ctx_r470.hasLastPinnedChildColumn, ctx_r470.hasFirstPinnedChildColumn))("ngStyle", ɵngcc0.ɵɵpureFunction4(8, _c94, ctx_r470.column.getGridTemplate(true, false), ctx_r470.column.getGridTemplate(false, false), ctx_r470.column.getGridTemplate(true, true), ctx_r470.column.getGridTemplate(false, true)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r470.column.children);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r470.grid.hasMovableColumns);
} }
function IgxGridHeaderGroupComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r472 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("title", ctx_r472.columnTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r472.column.header);
} }
function IgxGridHeaderGroupComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r474 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("draggable", false);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r474.column.expanded ? "expand_more" : "chevron_right", " ");
} }
function IgxGridHeaderGroupComponent_ng_container_5_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r490 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 15);
    ɵngcc0.ɵɵlistener("click", function IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r490); const ctx_r489 = ɵngcc0.ɵɵnextContext(2); return ctx_r489.toggleExpandState($event); });
    ɵngcc0.ɵɵtemplate(2, IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_ng_container_2_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r484 = ɵngcc0.ɵɵnextContext(2);
    const _r473 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r484.column.collapsibleIndicatorTemplate ? ctx_r484.column.collapsibleIndicatorTemplate : _r473)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(2, _c73, ctx_r484.column, ctx_r484.column));
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_igx_grid_header_group_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 17);
} if (rf & 2) {
    const child_r491 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r492 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r492.grid.getHeaderGroupWidth(child_r491))("flex-basis", ctx_r492.grid.getHeaderGroupWidth(child_r491));
    ɵngcc0.ɵɵproperty("column", child_r491)("gridID", child_r491.grid.id);
} }
function IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_igx_grid_header_group_1_Template, 1, 6, "igx-grid-header-group", 16);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const child_r491 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !child_r491.hidden);
} }
function IgxGridHeaderGroupComponent_ng_container_5_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
const _c95 = function (a0, a1, a2, a3, a4, a5) { return { "igx-grid__th--pinned-last": a0, "igx-grid__th--pinned-first": a1, "igx-grid__th--collapsible": a2, "igx-grid__th--selectable": a3, "igx-grid__th--selected": a4, "igx-grid__th--active": a5 }; };
function IgxGridHeaderGroupComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r495 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_5_span_1_Template, 1, 0, "span", 3);
    ɵngcc0.ɵɵelementStart(2, "div", 12);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerdown_2_listener() { ɵngcc0.ɵɵrestoreView(_r495); const ctx_r494 = ɵngcc0.ɵɵnextContext(); return ctx_r494.activate(); })("click", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r495); const ctx_r496 = ɵngcc0.ɵɵnextContext(); return ctx_r496.groupClicked($event); })("pointerenter", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerenter_2_listener() { ɵngcc0.ɵɵrestoreView(_r495); const ctx_r497 = ɵngcc0.ɵɵnextContext(); return ctx_r497.onPinterEnter(); })("pointerleave", function IgxGridHeaderGroupComponent_ng_container_5_Template_div_pointerleave_2_listener() { ɵngcc0.ɵɵrestoreView(_r495); const ctx_r498 = ɵngcc0.ɵɵnextContext(); return ctx_r498.onPointerLeave(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_5_ng_container_3_Template, 3, 5, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_5_ng_container_4_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "div", 14);
    ɵngcc0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_5_ng_container_6_Template, 2, 1, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, IgxGridHeaderGroupComponent_ng_container_5_span_7_Template, 1, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r475 = ɵngcc0.ɵɵnextContext();
    const _r471 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r475.grid.hasMovableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction6(14, _c95, ctx_r475.hasLastPinnedChildColumn, ctx_r475.hasFirstPinnedChildColumn, ctx_r475.column.collapsible, ctx_r475.selectable, ctx_r475.selected, ctx_r475.activeGroup))("igxColumnMovingDrag", ctx_r475.column)("ghostHost", ctx_r475.grid.outletDirective.nativeElement)("igxColumnMovingDrop", ctx_r475.column);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r475.column.header || ctx_r475.column.field)("aria-expanded", ctx_r475.column.expanded)("aria-selected", ctx_r475.column.selected)("droppable", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r475.column.collapsible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r475.column.headerTemplate ? ctx_r475.column.headerTemplate : _r471)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(21, _c73, ctx_r475.column, ctx_r475.column));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r475.column.children);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r475.grid.hasMovableColumns);
} }
function IgxGridHeaderGroupComponent_ng_container_6_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 7);
} }
function IgxGridHeaderGroupComponent_ng_container_6_igx_grid_filtering_cell_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-cell", 21);
} if (rf & 2) {
    const ctx_r500 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("column", ctx_r500.column);
    ɵngcc0.ɵɵattribute("draggable", false);
} }
function IgxGridHeaderGroupComponent_ng_container_6_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 22);
} if (rf & 2) {
    const ctx_r501 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("cursor", ctx_r501.colResizingService.resizeCursor);
    ɵngcc0.ɵɵproperty("igxResizeHandle", ctx_r501.column);
    ɵngcc0.ɵɵattribute("draggable", false);
} }
function IgxGridHeaderGroupComponent_ng_container_6_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 10);
} }
function IgxGridHeaderGroupComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    const _r504 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_container_6_span_1_Template, 1, 0, "span", 3);
    ɵngcc0.ɵɵelementStart(2, "igx-grid-header", 18);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridHeaderGroupComponent_ng_container_6_Template_igx_grid_header_pointerdown_2_listener() { ɵngcc0.ɵɵrestoreView(_r504); const ctx_r503 = ɵngcc0.ɵɵnextContext(); return ctx_r503.activate(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_container_6_igx_grid_filtering_cell_3_Template, 1, 2, "igx-grid-filtering-cell", 19);
    ɵngcc0.ɵɵtemplate(4, IgxGridHeaderGroupComponent_ng_container_6_span_4_Template, 1, 4, "span", 20);
    ɵngcc0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_6_span_5_Template, 1, 0, "span", 6);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r476 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r476.grid.hasMovableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxColumnMovingDrag", ctx_r476.column)("ghostHost", ctx_r476.grid.outletDirective.nativeElement)("igxColumnMovingDrop", ctx_r476.column)("gridID", ctx_r476.column.grid.id)("column", ctx_r476.column);
    ɵngcc0.ɵɵattribute("droppable", true);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r476.grid.allowFiltering && ctx_r476.grid.filterMode == "quickFilter");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r476.column.columnGroup && ctx_r476.column.resizable);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r476.grid.hasMovableColumns);
} }
function IgxSummaryCellComponent_ng_container_0_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementStart(2, "div", 5, 6);
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 7);
    ɵngcc0.ɵɵtext(5, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r508 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__tree-cell--padding-level-", ctx_r508.firstCellIndentation, "");
} }
function IgxSummaryCellComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, IgxSummaryCellComponent_ng_container_0_ng_container_1_ng_container_2_Template, 6, 3, "ng-container", 0);
    ɵngcc0.ɵɵelementStart(3, "span", 3);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span", 4);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵpipe(7, "igxdecimal");
    ɵngcc0.ɵɵpipe(8, "igxdate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const summary_r507 = ctx.$implicit;
    const ctx_r506 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("height", ctx_r506.itemHeight, "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r506.visibleColumnIndex === 0 && ctx_r506.firstCellIndentation >= 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("title", summary_r507.label);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r506.translateSummary(summary_r507));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate("title", summary_r507.summaryResult);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r506.columnDatatype === "number" ? ɵngcc0.ɵɵpipeBind2(7, 7, summary_r507.summaryResult, ctx_r506.grid.locale) : ctx_r506.columnDatatype === "date" ? ɵngcc0.ɵɵpipeBind2(8, 10, summary_r507.summaryResult, ctx_r506.grid.locale) : summary_r507.summaryResult, " ");
} }
function IgxSummaryCellComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryCellComponent_ng_container_0_ng_container_1_Template, 9, 13, "ng-container", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r505 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r505.summaryResults);
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", 4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r513 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r513.grid.summariesMargin, "px")("flex-basis", ctx_r513.grid.summariesMargin, "px");
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r514 = ɵngcc0.ɵɵnextContext(2);
    const _r511 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r511)("ngTemplateOutletContext", ctx_r514.getContext(ctx_r514));
} }
function IgxSummaryRowComponent_ng_container_0_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-cell", 6);
} if (rf & 2) {
    const col_r519 = ctx.$implicit;
    const ctx_r516 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("max-height", ctx_r516.minHeight, "px")("min-height", ctx_r516.minHeight, "px")("min-width", col_r519.getCellWidth())("max-width", col_r519.getCellWidth())("flex-basis", col_r519.getCellWidth());
    ɵngcc0.ɵɵclassProp("igx-grid-summary--cosy", ctx_r516.grid.displayDensity === "cosy")("igx-grid-summary--compact", ctx_r516.grid.displayDensity === "compact")("igx-grid-summary--empty", !col_r519.hasSummary)("igx-grid-summary--pinned-last", col_r519.isLastPinned);
    ɵngcc0.ɵɵproperty("column", col_r519)("rowIndex", ctx_r516.index)("firstCellIndentation", ctx_r516.firstCellIndentation)("summaryResults", ctx_r516.getColumnSummaries(col_r519.field))("hasSummary", col_r519.hasSummary)("density", ctx_r516.grid.displayDensity)("active", ctx_r516.isCellActive(col_r519.visibleIndex));
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSummaryRowComponent_ng_container_0_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_6_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r517 = ɵngcc0.ɵɵnextContext(2);
    const _r511 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r511)("ngTemplateOutletContext", ctx_r517.getContext(ctx_r517));
} }
function IgxSummaryRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_container_0_ng_container_1_Template, 2, 4, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(2, IgxSummaryRowComponent_ng_container_0_ng_container_2_Template, 2, 2, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(3, IgxSummaryRowComponent_ng_container_0_ng_template_3_Template, 1, 25, "ng-template", 2, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(5, "igxNotGrouped");
    ɵngcc0.ɵɵtemplate(6, IgxSummaryRowComponent_ng_container_0_ng_container_6_Template, 2, 2, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r510 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r510.grid.summariesMargin);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r510.pinnedColumns.length > 0 && ctx_r510.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(5, 9, ctx_r510.unpinnedColumns))("igxForScrollContainer", ctx_r510.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r510.grid.unpinnedWidth)("igxForTrackBy", ctx_r510.grid.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r510.pinnedColumns.length > 0 && !ctx_r510.grid.isPinningToStart);
} }
function IgxSummaryRowComponent_ng_template_1_igx_grid_summary_cell_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-cell", 8);
} if (rf & 2) {
    const col_r524 = ctx.$implicit;
    const ctx_r523 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("max-height", ctx_r523.minHeight, "px")("min-height", ctx_r523.minHeight, "px")("min-width", col_r524.getCellWidth())("max-width", col_r524.getCellWidth())("flex-basis", col_r524.getCellWidth())("left", col_r524.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid-summary--cosy", ctx_r523.grid.displayDensity === "cosy")("igx-grid-summary--compact", ctx_r523.grid.displayDensity === "compact")("igx-grid-summary--empty", !col_r524.hasSummary)("igx-grid-summary--pinned-first", col_r524.isFirstPinned)("igx-grid-summary--pinned-last", col_r524.isLastPinned);
    ɵngcc0.ɵɵproperty("column", col_r524)("firstCellIndentation", ctx_r523.firstCellIndentation)("rowIndex", ctx_r523.index)("summaryResults", ctx_r523.getColumnSummaries(col_r524.field))("hasSummary", col_r524.hasSummary)("density", ctx_r523.grid.displayDensity)("active", ctx_r523.isCellActive(col_r524.visibleIndex));
} }
function IgxSummaryRowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxSummaryRowComponent_ng_template_1_igx_grid_summary_cell_0_Template, 1, 29, "igx-grid-summary-cell", 7);
    ɵngcc0.ɵɵpipe(1, "igxNotGrouped");
} if (rf & 2) {
    const ctx_r512 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r512.pinnedColumns));
} }
const _c96 = ["defaultFilterUI"];
const _c97 = ["defaultDateUI"];
const _c98 = ["inputGroup"];
const _c99 = ["inputGroupPrefix"];
const _c100 = ["operand"];
const _c101 = ["closeButton"];
const _c102 = ["operators"];
function IgxGridFilteringRowComponent_igx_drop_down_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-drop-down-item", 17);
    ɵngcc0.ɵɵelement(1, "igx-icon", 18);
    ɵngcc0.ɵɵelementStart(2, "span", 19);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r539 = ctx.$implicit;
    const ctx_r526 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", condition_r539)("selected", ctx_r526.isConditionSelected(condition_r539));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r526.getCondition(condition_r539).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r526.translateCondition(condition_r539));
} }
function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template(rf, ctx) { if (rf & 1) {
    const _r545 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix");
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 27);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r545); const ctx_r544 = ɵngcc0.ɵɵnextContext(2); return ctx_r544.onCommitKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r545); const ctx_r546 = ɵngcc0.ɵɵnextContext(2); return ctx_r546.onCommitClick(); });
    ɵngcc0.ɵɵtext(2, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 27);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_keydown_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r545); const ctx_r547 = ɵngcc0.ɵɵnextContext(2); return ctx_r547.onClearKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template_igx_icon_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r545); const ctx_r548 = ɵngcc0.ɵɵnextContext(2); return ctx_r548.onClearClick(); });
    ɵngcc0.ɵɵtext(4, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridFilteringRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    const _r550 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 20, 21);
    ɵngcc0.ɵɵlistener("focusout", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_input_group_focusout_0_listener() { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r549 = ɵngcc0.ɵɵnextContext(); return ctx_r549.onInputGroupFocusout(); });
    ɵngcc0.ɵɵelementStart(2, "igx-prefix", 22, 23);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_prefix_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r551 = ɵngcc0.ɵɵnextContext(); return ctx_r551.inputGroupPrefixClick($event); })("keydown", function IgxGridFilteringRowComponent_ng_template_3_Template_igx_prefix_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r552 = ɵngcc0.ɵɵnextContext(); return ctx_r552.onPrefixKeyDown($event); });
    ɵngcc0.ɵɵelement(4, "igx-icon", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "input", 24, 25);
    ɵngcc0.ɵɵlistener("input", function IgxGridFilteringRowComponent_ng_template_3_Template_input_input_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r553 = ɵngcc0.ɵɵnextContext(); return ctx_r553.onInput($event); })("click", function IgxGridFilteringRowComponent_ng_template_3_Template_input_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r554 = ɵngcc0.ɵɵnextContext(); return ctx_r554.onInputClick(); })("compositionstart", function IgxGridFilteringRowComponent_ng_template_3_Template_input_compositionstart_5_listener() { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r555 = ɵngcc0.ɵɵnextContext(); return ctx_r555.onCompositionStart(); })("compositionend", function IgxGridFilteringRowComponent_ng_template_3_Template_input_compositionend_5_listener() { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r556 = ɵngcc0.ɵɵnextContext(); return ctx_r556.onCompositionEnd(); })("keydown", function IgxGridFilteringRowComponent_ng_template_3_Template_input_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r557 = ɵngcc0.ɵɵnextContext(); return ctx_r557.onInputKeyDown($event); })("keyup", function IgxGridFilteringRowComponent_ng_template_3_Template_input_keyup_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r550); const ctx_r558 = ɵngcc0.ɵɵnextContext(); return ctx_r558.onInputKeyUp($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_template_3_igx_suffix_7_Template, 5, 0, "igx-suffix", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r528 = ɵngcc0.ɵɵnextContext();
    const _r525 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r525);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r528.getIconName());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r528.placeholder)("value", ctx_r528.value)("type", ctx_r528.type)("readonly", ctx_r528.isUnaryCondition);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r528.value || ctx_r528.value === 0);
} }
function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template(rf, ctx) { if (rf & 1) {
    const _r566 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix");
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 27);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r566); const ctx_r565 = ɵngcc0.ɵɵnextContext(3); return ctx_r565.onCommitKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r566); const ctx_r567 = ɵngcc0.ɵɵnextContext(3); return ctx_r567.onCommitClick(); });
    ɵngcc0.ɵɵtext(2, "done");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 27);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_keydown_3_listener($event) { ɵngcc0.ɵɵrestoreView(_r566); const ctx_r568 = ɵngcc0.ɵɵnextContext(3); return ctx_r568.onClearKeyDown($event); })("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template_igx_icon_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r566); const ctx_r569 = ɵngcc0.ɵɵnextContext(3); return ctx_r569.clearInput(); });
    ɵngcc0.ɵɵtext(4, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r571 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 20, 21);
    ɵngcc0.ɵɵlistener("focusout", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_igx_input_group_focusout_0_listener() { ɵngcc0.ɵɵrestoreView(_r571); const ctx_r570 = ɵngcc0.ɵɵnextContext(2); return ctx_r570.onInputGroupFocusout(); });
    ɵngcc0.ɵɵelementStart(2, "igx-prefix", 22, 23);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_igx_prefix_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r571); const ctx_r572 = ɵngcc0.ɵɵnextContext(2); return ctx_r572.inputGroupPrefixClick($event); })("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_igx_prefix_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r571); const ctx_r573 = ɵngcc0.ɵɵnextContext(2); return ctx_r573.onPrefixKeyDown($event); });
    ɵngcc0.ɵɵelement(4, "igx-icon", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "input", 30, 25);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_input_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r571); const openDialog_r560 = ctx.openDialog; const _r561 = ɵngcc0.ɵɵreference(1); const ctx_r574 = ɵngcc0.ɵɵnextContext(2); return ctx_r574.expression.condition.isUnary ? ctx_r574.noop() : openDialog_r560(_r561.element.nativeElement); })("keydown", function IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template_input_keydown_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r571); const ctx_r575 = ɵngcc0.ɵɵnextContext(2); return ctx_r575.onInputKeyDown($event); });
    ɵngcc0.ɵɵpipe(7, "igxdate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxGridFilteringRowComponent_ng_template_5_ng_template_1_igx_suffix_8_Template, 5, 0, "igx-suffix", 26);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r559 = ɵngcc0.ɵɵnextContext(2);
    const _r525 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r525);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", ctx_r559.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r559.placeholder)("value", ɵngcc0.ɵɵpipeBind2(7, 7, ctx_r559.value, ctx_r559.filteringService.grid.locale))("readonly", true);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r559.value);
} }
function IgxGridFilteringRowComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    const _r577 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-date-picker", 28);
    ɵngcc0.ɵɵlistener("onSelection", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_onSelection_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r577); const ctx_r576 = ɵngcc0.ɵɵnextContext(); return ctx_r576.onDateSelected($event); })("onClosed", function IgxGridFilteringRowComponent_ng_template_5_Template_igx_date_picker_onClosed_0_listener() { ɵngcc0.ɵɵrestoreView(_r577); const ctx_r578 = ɵngcc0.ɵɵnextContext(); return ctx_r578.datePickerClose(); });
    ɵngcc0.ɵɵtemplate(1, IgxGridFilteringRowComponent_ng_template_5_ng_template_1_Template, 9, 10, "ng-template", 29);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r530 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("value", ctx_r530.value)("outlet", ctx_r530.filteringService.grid.outletDirective)("locale", ctx_r530.filteringService.grid.locale);
} }
function IgxGridFilteringRowComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridFilteringRowComponent_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r580 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 31);
    ɵngcc0.ɵɵlistener("keydown", function IgxGridFilteringRowComponent_button_8_Template_button_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r580); const ctx_r579 = ɵngcc0.ɵɵnextContext(); return ctx_r579.onLeftArrowKeyDown($event); })("click", function IgxGridFilteringRowComponent_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r580); const ctx_r581 = ɵngcc0.ɵɵnextContext(); return ctx_r581.scrollChipsOnArrowPress("left"); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "navigate_before");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridFilteringRowComponent_ng_container_14_span_6_Template(rf, ctx) { if (rf & 1) {
    const _r589 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "span", 37);
    ɵngcc0.ɵɵelementStart(1, "button", 38);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_ng_container_14_span_6_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r589); const i_r583 = ɵngcc0.ɵɵnextContext().index; const ctx_r588 = ɵngcc0.ɵɵnextContext(); return ctx_r588.toggleOperatorsDropDown($event, i_r583); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "expand_more");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "igx-drop-down", 39, 40);
    ɵngcc0.ɵɵlistener("onSelection", function IgxGridFilteringRowComponent_ng_container_14_span_6_Template_igx_drop_down_onSelection_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r589); const item_r582 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r591 = ɵngcc0.ɵɵnextContext(); return ctx_r591.onLogicOperatorChanged($event, item_r582); });
    ɵngcc0.ɵɵelementStart(8, "igx-drop-down-item", 17);
    ɵngcc0.ɵɵtext(9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "igx-drop-down-item", 17);
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r587 = ɵngcc0.ɵɵreference(7);
    const item_r582 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r586 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r587);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r586.filteringService.getOperatorAsString(item_r582.afterOperator));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("value", 0)("selected", item_r582.afterOperator === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r586.filteringService.grid.resourceStrings.igx_grid_filter_operator_and);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", 1)("selected", item_r582.afterOperator === 1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r586.filteringService.grid.resourceStrings.igx_grid_filter_operator_or);
} }
function IgxGridFilteringRowComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    const _r595 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0, 32);
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 33, 34);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_pointerdown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r595); const _r585 = ɵngcc0.ɵɵreference(2); const ctx_r594 = ɵngcc0.ɵɵnextContext(); return ctx_r594.onChipPointerdown($event, _r585); })("click", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r595); const item_r582 = ctx.$implicit; const ctx_r596 = ɵngcc0.ɵɵnextContext(); return ctx_r596.onChipClick($event, item_r582); })("keydown", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r595); const item_r582 = ctx.$implicit; const ctx_r597 = ɵngcc0.ɵɵnextContext(); return ctx_r597.onChipKeyDown($event, item_r582); })("onRemove", function IgxGridFilteringRowComponent_ng_container_14_Template_igx_chip_onRemove_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r595); const item_r582 = ctx.$implicit; const ctx_r598 = ɵngcc0.ɵɵnextContext(); return ctx_r598.onChipRemoved($event, item_r582); });
    ɵngcc0.ɵɵelement(3, "igx-icon", 35);
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, IgxGridFilteringRowComponent_ng_container_14_span_6_Template, 12, 8, "span", 36);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r582 = ctx.$implicit;
    const last_r584 = ctx.last;
    const ctx_r535 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("selectable", false)("selected", item_r582.isSelected)("displayDensity", "cosy")("removable", true);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("name", item_r582.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r535.filteringService.getChipLabel(item_r582.expression));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r584);
} }
function IgxGridFilteringRowComponent_button_15_Template(rf, ctx) { if (rf & 1) {
    const _r600 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 41);
    ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_button_15_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r600); const ctx_r599 = ɵngcc0.ɵɵnextContext(); return ctx_r599.scrollChipsOnArrowPress("right"); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon");
    ɵngcc0.ɵɵtext(2, "navigate_next");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxSelectComponent_ng_container_11_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSelectComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSelectComponent_ng_container_11_ng_container_1_Template, 1, 0, "ng-container", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r603 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r603.toggleIconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r603.collapsed));
} }
function IgxSelectComponent_igx_icon_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 15);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r604 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r604.collapsed ? "arrow_drop_down" : "arrow_drop_up");
} }
function IgxSelectComponent_div_14_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 4, ["*ngTemplateOutlet", "headerTemplate"]);
} }
function IgxSelectComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵtemplate(1, IgxSelectComponent_div_14_1_Template, 1, 0, undefined, 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r605 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r605.headerTemplate);
} }
function IgxSelectComponent_div_18_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxSelectComponent_div_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 18);
    ɵngcc0.ɵɵtemplate(1, IgxSelectComponent_div_18_ng_container_1_Template, 1, 0, "ng-container", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r607 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r607.footerTemplate);
} }
const _c103 = [[["", "igxLabel", ""]], [["igx-prefix"], ["", "igxPrefix", ""]], [["igx-suffix"], ["", "igxSuffix", ""]], [["igx-select-item"], ["igx-select-item-group"]], "*"];
const _c104 = ["[igxLabel]", "igx-prefix,[igxPrefix]", "igx-suffix,[igxSuffix]", "igx-select-item, igx-select-item-group", "*"];
const _c105 = ["editingInputsContainer"];
const _c106 = ["addModeContainer"];
const _c107 = ["currentGroupButtonsContainer"];
const _c108 = ["columnSelect"];
const _c109 = ["conditionSelect"];
const _c110 = ["searchValueInput"];
const _c111 = ["addRootAndGroupButton"];
const _c112 = ["addConditionButton"];
const _c113 = ["overlayOutlet"];
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    const _r626 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 20, 21);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r626); const ctx_r625 = ɵngcc0.ɵɵnextContext(2); return ctx_r625.addAndGroup(); });
    ɵngcc0.ɵɵelementStart(3, "igx-icon", 22);
    ɵngcc0.ɵɵtext(4, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "span");
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "button", 20);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template_button_click_7_listener() { ɵngcc0.ɵɵrestoreView(_r626); const ctx_r627 = ɵngcc0.ɵɵnextContext(2); return ctx_r627.addOrGroup(); });
    ɵngcc0.ɵɵelementStart(8, "igx-icon", 22);
    ɵngcc0.ɵɵtext(9, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(10, "span");
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(12, "div", 23);
    ɵngcc0.ɵɵelementStart(13, "h6", 24);
    ɵngcc0.ɵɵtext(14);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r614 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r614.displayDensity);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r614.grid.resourceStrings.igx_grid_advanced_filter_and_group);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r614.displayDensity);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r614.grid.resourceStrings.igx_grid_advanced_filter_or_group);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r614.grid.resourceStrings.igx_grid_advanced_filter_initial_text, " ");
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    const _r632 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 25, 26);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r632); const expressionItem_r628 = ctx.$implicit; const afterExpression_r629 = ctx.afterExpression; const ctx_r631 = ɵngcc0.ɵɵnextContext(2); return ctx_r631.addCondition(expressionItem_r628, afterExpression_r629); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon", 22);
    ɵngcc0.ɵɵtext(3, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_6_listener() { ɵngcc0.ɵɵrestoreView(_r632); const expressionItem_r628 = ctx.$implicit; const afterExpression_r629 = ctx.afterExpression; const ctx_r633 = ɵngcc0.ɵɵnextContext(2); return ctx_r633.addAndGroup(expressionItem_r628, afterExpression_r629); });
    ɵngcc0.ɵɵelementStart(7, "igx-icon", 22);
    ɵngcc0.ɵɵtext(8, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template_button_click_11_listener() { ɵngcc0.ɵɵrestoreView(_r632); const expressionItem_r628 = ctx.$implicit; const afterExpression_r629 = ctx.afterExpression; const ctx_r634 = ɵngcc0.ɵɵnextContext(2); return ctx_r634.addOrGroup(expressionItem_r628, afterExpression_r629); });
    ɵngcc0.ɵɵelementStart(12, "igx-icon", 22);
    ɵngcc0.ɵɵtext(13, "add");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(14, "span");
    ɵngcc0.ɵɵtext(15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r616 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r616.displayDensity)("disabled", ctx_r616.editedExpression);
    ɵngcc0.ɵɵadvance(5);
    ɵngcc0.ɵɵtextInterpolate(ctx_r616.grid.resourceStrings.igx_grid_advanced_filter_add_condition);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r616.displayDensity)("disabled", ctx_r616.editedExpression);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r616.grid.resourceStrings.igx_grid_advanced_filter_and_group);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r616.displayDensity)("disabled", ctx_r616.editedExpression);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r616.grid.resourceStrings.igx_grid_advanced_filter_or_group);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 37);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵpipe(2, "igxdate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r635 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r639 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r639.isDate(expressionItem_r635.expression.searchVal) ? ɵngcc0.ɵɵpipeBind2(2, 1, expressionItem_r635.expression.searchVal, ctx_r639.grid.locale) : expressionItem_r635.expression.searchVal, " ");
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_igx_icon_3_Template(rf, ctx) { if (rf & 1) {
    const _r644 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 39);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_igx_icon_3_Template_igx_icon_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r644); const ctx_r643 = ɵngcc0.ɵɵnextContext(5); return ctx_r643.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_igx_icon_3_Template_igx_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r644); const expressionItem_r635 = ɵngcc0.ɵɵnextContext(3).$implicit; const ctx_r645 = ɵngcc0.ɵɵnextContext(2); return ctx_r645.enterExpressionAdd(expressionItem_r635); });
    ɵngcc0.ɵɵtext(1, " add ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r648 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 38);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 39);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_Template_igx_icon_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r648); const ctx_r647 = ɵngcc0.ɵɵnextContext(4); return ctx_r647.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_Template_igx_icon_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r648); const expressionItem_r635 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r649 = ɵngcc0.ɵɵnextContext(2); return ctx_r649.enterExpressionEdit(expressionItem_r635); });
    ɵngcc0.ɵɵtext(2, " edit ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_igx_icon_3_Template, 2, 0, "igx-icon", 40);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r635 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r640 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !expressionItem_r635.inAddMode && (expressionItem_r635.parent !== ctx_r640.currentGroup || expressionItem_r635 !== ctx_r640.currentGroup.children[ctx_r640.currentGroup.children.length - 1]));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r654 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 30);
    ɵngcc0.ɵɵlistener("mouseenter", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_div_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r654); const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit; return expressionItem_r635.hovered = true; })("mouseleave", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_div_mouseleave_0_listener() { ɵngcc0.ɵɵrestoreView(_r654); const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit; return expressionItem_r635.hovered = false; });
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 31);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r654); const ctx_r657 = ɵngcc0.ɵɵnextContext(3); return ctx_r657.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r654); const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r658 = ɵngcc0.ɵɵnextContext(2); return ctx_r658.onChipClick(expressionItem_r635); })("dblclick", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_dblclick_1_listener() { ɵngcc0.ɵɵrestoreView(_r654); const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r660 = ɵngcc0.ɵɵnextContext(2); return ctx_r660.onChipDblClick(expressionItem_r635); })("onRemove", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_onRemove_1_listener() { ɵngcc0.ɵɵrestoreView(_r654); const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r662 = ɵngcc0.ɵɵnextContext(2); return ctx_r662.onChipRemove(expressionItem_r635); })("onSelectionDone", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template_igx_chip_onSelectionDone_1_listener() { ɵngcc0.ɵɵrestoreView(_r654); const ctx_r664 = ɵngcc0.ɵɵnextContext(3); return ctx_r664.onChipSelectionEnd(); });
    ɵngcc0.ɵɵelementStart(2, "span", 32);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(4, "igx-icon", 33);
    ɵngcc0.ɵɵelementStart(5, "span", 34);
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(7, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_span_7_Template, 3, 4, "span", 35);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_div_8_Template, 4, 1, "div", 36);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r636 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("data", expressionItem_r635)("displayDensity", ctx_r636.displayDensity === "compact" ? "cosy" : ctx_r636.displayDensity)("removable", true)("selected", expressionItem_r635.selected);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(expressionItem_r635.columnHeader || expressionItem_r635.expression.fieldName);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", expressionItem_r635.expression.condition.iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r636.getConditionFriendlyName(expressionItem_r635.expression.condition.name), " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !expressionItem_r635.expression.condition.isUnary);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r635.selected && ctx_r636.selectedExpressions.length === 1 || expressionItem_r635.hovered);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 54);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const column_r674 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", column_r674);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", column_r674.header || column_r674.field, " ");
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 33);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r669 = ɵngcc0.ɵɵreference(6);
    const ctx_r670 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵproperty("name", ctx_r670.selectedColumn.filters.condition(_r669.value).iconName);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 54);
    ɵngcc0.ɵɵelement(1, "igx-icon", 55);
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const condition_r675 = ctx.$implicit;
    const ctx_r671 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("value", condition_r675);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("name", ctx_r671.selectedColumn.filters.condition(condition_r675).iconName);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r671.getConditionFriendlyName(condition_r675));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template(rf, ctx) { if (rf & 1) {
    const _r678 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 56);
    ɵngcc0.ɵɵelementStart(1, "input", 57, 58);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r678); const ctx_r677 = ɵngcc0.ɵɵnextContext(4); return ctx_r677.searchValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r672 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("disabled", !ctx_r672.selectedColumn || !ctx_r672.selectedCondition || ctx_r672.selectedColumn && ctx_r672.selectedColumn.filters.condition(ctx_r672.selectedCondition).isUnary)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("type", ctx_r672.selectedColumn && ctx_r672.selectedColumn.dataType === "number" ? "number" : "text")("placeholder", ctx_r672.grid.resourceStrings.igx_grid_advanced_filter_value_placeholder)("ngModel", ctx_r672.searchValue);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    const _r685 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 61, 62);
    ɵngcc0.ɵɵelementStart(2, "input", 63, 58);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template_input_keydown_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r685); const ctx_r684 = ɵngcc0.ɵɵnextContext(5); return ctx_r684.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template_input_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r685); const openDialog_r680 = ctx.openDialog; const _r682 = ɵngcc0.ɵɵreference(1); return openDialog_r680(_r682.element.nativeElement); });
    ɵngcc0.ɵɵpipe(4, "igxdate");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const value_r681 = ctx.value;
    const ctx_r679 = ɵngcc0.ɵɵnextContext(5);
    ɵngcc0.ɵɵproperty("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r679.grid.resourceStrings.igx_grid_filter_row_date_placeholder)("value", ɵngcc0.ɵɵpipeBind2(4, 5, value_r681, ctx_r679.grid.locale))("readonly", true)("disabled", !ctx_r679.selectedColumn || !ctx_r679.selectedCondition || ctx_r679.selectedColumn && ctx_r679.selectedColumn.filters.condition(ctx_r679.selectedCondition).isUnary);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template(rf, ctx) { if (rf & 1) {
    const _r688 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-date-picker", 59);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template_igx_date_picker_ngModelChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r688); const ctx_r687 = ɵngcc0.ɵɵnextContext(4); return ctx_r687.searchValue = $event; });
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_ng_template_1_Template, 5, 8, "ng-template", 60);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r673 = ɵngcc0.ɵɵnextContext(4);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r673.searchValue)("locale", ctx_r673.grid.locale)("outlet", ctx_r673.grid.outletDirective);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r690 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 41, 42);
    ɵngcc0.ɵɵelementStart(2, "igx-select", 43, 44);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_igx_select_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r690); const ctx_r689 = ɵngcc0.ɵɵnextContext(3); return ctx_r689.selectedColumn = $event; });
    ɵngcc0.ɵɵtemplate(4, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_4_Template, 2, 2, "igx-select-item", 45);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "igx-select", 46, 47);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_igx_select_ngModelChange_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r690); const ctx_r691 = ɵngcc0.ɵɵnextContext(3); return ctx_r691.selectedCondition = $event; });
    ɵngcc0.ɵɵtemplate(7, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_icon_7_Template, 1, 1, "igx-icon", 48);
    ɵngcc0.ɵɵtemplate(8, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_select_item_8_Template, 4, 3, "igx-select-item", 45);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(9, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_input_group_9_Template, 3, 5, "igx-input-group", 49);
    ɵngcc0.ɵɵtemplate(10, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_igx_date_picker_10_Template, 2, 3, "igx-date-picker", 50);
    ɵngcc0.ɵɵelementStart(11, "div", 51);
    ɵngcc0.ɵɵelementStart(12, "button", 52);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_button_click_12_listener() { ɵngcc0.ɵɵrestoreView(_r690); const ctx_r692 = ɵngcc0.ɵɵnextContext(3); return ctx_r692.commitOperandEdit(); });
    ɵngcc0.ɵɵelementStart(13, "igx-icon", 22);
    ɵngcc0.ɵɵtext(14, "check");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(15, "button", 53);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template_button_click_15_listener() { ɵngcc0.ɵɵrestoreView(_r690); const ctx_r693 = ɵngcc0.ɵɵnextContext(3); return ctx_r693.cancelOperandEdit(); });
    ɵngcc0.ɵɵelementStart(16, "igx-icon", 22);
    ɵngcc0.ɵɵtext(17, "close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r669 = ɵngcc0.ɵɵreference(6);
    const ctx_r637 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", "compact")("overlaySettings", ctx_r637.columnSelectOverlaySettings)("placeholder", ctx_r637.grid.resourceStrings.igx_grid_advanced_filter_column_placeholder)("ngModel", ctx_r637.selectedColumn);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r637.filterableColumns);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", "compact")("overlaySettings", ctx_r637.conditionSelectOverlaySettings)("placeholder", ctx_r637.grid.resourceStrings.igx_grid_filter_condition_placeholder)("ngModel", ctx_r637.selectedCondition)("disabled", !ctx_r637.selectedColumn);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r637.selectedColumn && _r669.value && ctx_r637.selectedColumn.filters.condition(_r669.value));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r637.getConditionList());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r637.selectedColumn || ctx_r637.selectedColumn.dataType !== "date");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r637.selectedColumn && ctx_r637.selectedColumn.dataType === "date");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r637.displayDensity)("disabled", !ctx_r637.operandCanBeCommitted());
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r637.displayDensity);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r697 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 64, 65);
    ɵngcc0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_ng_container_2_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵelementStart(3, "button", 53);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r697); const ctx_r696 = ɵngcc0.ɵɵnextContext(3); return ctx_r696.cancelOperandAdd(); });
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 22);
    ɵngcc0.ɵɵtext(5, "close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r635 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵnextContext();
    const _r615 = ɵngcc0.ɵɵreference(15);
    const ctx_r638 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r615)("ngTemplateOutletContext", ctx_r638.context(expressionItem_r635.parent, expressionItem_r635));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r638.displayDensity);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_0_Template, 9, 9, "div", 27);
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_1_Template, 18, 17, "div", 28);
    ɵngcc0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_div_2_Template, 6, 3, "div", 29);
} if (rf & 2) {
    const expressionItem_r635 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", !expressionItem_r635.inEditMode);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r635.inEditMode);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r635.inAddMode);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_ng_container_1_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const expr_r702 = ctx.$implicit;
    ɵngcc0.ɵɵnextContext(2);
    const _r619 = ɵngcc0.ɵɵreference(19);
    const _r617 = ɵngcc0.ɵɵreference(17);
    const ctx_r700 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r700.isExpressionGroup(expr_r702) ? _r619 : _r617)("ngTemplateOutletContext", ctx_r700.context(expr_r702));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r709 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r709); const expressionItem_r699 = ɵngcc0.ɵɵnextContext(2).$implicit; const ctx_r707 = ɵngcc0.ɵɵnextContext(2); return ctx_r707.endGroup(expressionItem_r699); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r699 = ɵngcc0.ɵɵnextContext(2).$implicit;
    const ctx_r706 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r706.displayDensity)("disabled", ctx_r706.editedExpression || expressionItem_r699.children.length < 2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r706.grid.resourceStrings.igx_grid_advanced_filter_end_group);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 64, 71);
    ɵngcc0.ɵɵtemplate(2, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_ng_container_2_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_button_3_Template, 3, 3, "button", 72);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r699 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵnextContext();
    const _r615 = ɵngcc0.ɵɵreference(15);
    const ctx_r701 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r615)("ngTemplateOutletContext", ctx_r701.context(expressionItem_r699));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", expressionItem_r699 !== ctx_r701.rootGroup);
} }
const _c114 = function (a0, a1, a2) { return { "igx-filter-tree__line--and": a0, "igx-filter-tree__line--or": a1, "igx-filter-tree__line--selected": a2 }; };
function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template(rf, ctx) { if (rf & 1) {
    const _r713 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 67);
    ɵngcc0.ɵɵelementStart(1, "div", 68);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template_div_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r713); const ctx_r712 = ɵngcc0.ɵɵnextContext(2); return ctx_r712.invokeClick($event); })("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template_div_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r713); const expressionItem_r699 = ctx.$implicit; const ctx_r714 = ɵngcc0.ɵɵnextContext(2); return ctx_r714.onGroupClick(expressionItem_r699); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "div", 69);
    ɵngcc0.ɵɵtemplate(3, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_ng_container_3_Template, 2, 2, "ng-container", 70);
    ɵngcc0.ɵɵtemplate(4, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_div_4_Template, 4, 3, "div", 29);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const expressionItem_r699 = ctx.$implicit;
    const ctx_r620 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction3(3, _c114, expressionItem_r699.operator === 0, expressionItem_r699.operator === 1, expressionItem_r699.selected));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", expressionItem_r699.children);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r620.currentGroup === expressionItem_r699);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_ng_container_1_Template, 1, 0, "ng-container", 66);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r619 = ɵngcc0.ɵɵreference(19);
    const ctx_r621 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r619)("ngTemplateOutletContext", ctx_r621.context(ctx_r621.rootGroup));
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template(rf, ctx) { if (rf & 1) {
    const _r717 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-buttongroup", 73);
    ɵngcc0.ɵɵlistener("onSelect", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_igx_buttongroup_onSelect_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r717); const ctx_r716 = ɵngcc0.ɵɵnextContext(2); return ctx_r716.selectFilteringLogic($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 25);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_button_click_2_listener() { ɵngcc0.ɵɵrestoreView(_r717); const ctx_r718 = ɵngcc0.ɵɵnextContext(2); return ctx_r718.ungroup(); });
    ɵngcc0.ɵɵelement(3, "igx-icon", 74);
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "button", 75);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template_button_click_6_listener() { ɵngcc0.ɵɵrestoreView(_r717); const ctx_r719 = ɵngcc0.ɵɵnextContext(2); return ctx_r719.deleteGroup(); });
    ɵngcc0.ɵɵelementStart(7, "igx-icon");
    ɵngcc0.ɵɵtext(8, "delete");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r622 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r622.displayDensity)("multiSelection", false)("values", ctx_r622.filteringLogics);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r622.displayDensity)("disabled", !ctx_r622.contextualGroup.parent);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r622.grid.resourceStrings.igx_grid_advanced_filter_ungroup);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r622.displayDensity);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r622.grid.resourceStrings.igx_grid_advanced_filter_delete);
} }
function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template(rf, ctx) { if (rf & 1) {
    const _r721 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 20);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r721); const ctx_r720 = ɵngcc0.ɵɵnextContext(2); return ctx_r720.createAndGroup(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "button", 20);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_3_listener() { ɵngcc0.ɵɵrestoreView(_r721); const ctx_r722 = ɵngcc0.ɵɵnextContext(2); return ctx_r722.createOrGroup(); });
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(5, "button", 75);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template_button_click_5_listener() { ɵngcc0.ɵɵrestoreView(_r721); const ctx_r723 = ɵngcc0.ɵɵnextContext(2); return ctx_r723.deleteFilters(); });
    ɵngcc0.ɵɵtext(6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r623 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r623.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r623.grid.resourceStrings.igx_grid_advanced_filter_create_and_group, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r623.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r623.grid.resourceStrings.igx_grid_advanced_filter_create_or_group, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r623.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r623.grid.resourceStrings.igx_grid_advanced_filter_delete_filters, " ");
} }
const _c115 = function (a0, a1, a2) { return { "igx-advanced-filter--cosy": a0, "igx-advanced-filter--compact": a1, "igx-advanced-filter--inline": a2 }; };
const _c116 = function (a0, a1) { return { "igx-filter-contextual-menu--cosy": a0, "igx-filter-contextual-menu--compact": a1 }; };
function IgxAdvancedFilteringDialogComponent_article_0_Template(rf, ctx) { if (rf & 1) {
    const _r725 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "article", 3);
    ɵngcc0.ɵɵlistener("dragStart", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r724 = ɵngcc0.ɵɵnextContext(); return ctx_r724.dragStart($event); })("dragEnd", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragEnd_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r726 = ɵngcc0.ɵɵnextContext(); return ctx_r726.dragEnd($event); })("dragMove", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_dragMove_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r727 = ɵngcc0.ɵɵnextContext(); return ctx_r727.onDragMove($event); })("keydown", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r728 = ɵngcc0.ɵɵnextContext(); return ctx_r728.onKeyDown($event); });
    ɵngcc0.ɵɵelementStart(1, "header", 4);
    ɵngcc0.ɵɵelementStart(2, "h4", 5);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 6);
    ɵngcc0.ɵɵelementStart(5, "div", 7);
    ɵngcc0.ɵɵelementStart(6, "span");
    ɵngcc0.ɵɵtext(7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(8, "div", 8);
    ɵngcc0.ɵɵelementStart(9, "span");
    ɵngcc0.ɵɵtext(10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "article", 9, 10);
    ɵngcc0.ɵɵlistener("scroll", function IgxAdvancedFilteringDialogComponent_article_0_Template_article_scroll_11_listener() { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r729 = ɵngcc0.ɵɵnextContext(); return ctx_r729.onExpressionsScrolled(); });
    ɵngcc0.ɵɵtemplate(13, IgxAdvancedFilteringDialogComponent_article_0_ng_container_13_Template, 15, 5, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(14, IgxAdvancedFilteringDialogComponent_article_0_ng_template_14_Template, 16, 9, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(16, IgxAdvancedFilteringDialogComponent_article_0_ng_template_16_Template, 3, 3, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(18, IgxAdvancedFilteringDialogComponent_article_0_ng_template_18_Template, 5, 7, "ng-template", null, 14, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(20, IgxAdvancedFilteringDialogComponent_article_0_ng_container_20_Template, 2, 2, "ng-container", 11);
    ɵngcc0.ɵɵelementStart(21, "div", 15);
    ɵngcc0.ɵɵlistener("keydown", function IgxAdvancedFilteringDialogComponent_article_0_Template_div_keydown_21_listener($event) { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r730 = ɵngcc0.ɵɵnextContext(); return ctx_r730.onKeyDown($event); })("onClosed", function IgxAdvancedFilteringDialogComponent_article_0_Template_div_onClosed_21_listener() { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r731 = ɵngcc0.ɵɵnextContext(); return ctx_r731.contextMenuClosed(); });
    ɵngcc0.ɵɵelementStart(22, "button", 16);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_22_listener() { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r732 = ɵngcc0.ɵɵnextContext(); return ctx_r732.clearSelection(); });
    ɵngcc0.ɵɵelementStart(23, "igx-icon");
    ɵngcc0.ɵɵtext(24, "close");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(25, IgxAdvancedFilteringDialogComponent_article_0_ng_container_25_Template, 11, 8, "ng-container", 11);
    ɵngcc0.ɵɵtemplate(26, IgxAdvancedFilteringDialogComponent_article_0_ng_container_26_Template, 7, 6, "ng-container", 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(27, "footer", 17);
    ɵngcc0.ɵɵelementStart(28, "button", 18);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_28_listener() { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r733 = ɵngcc0.ɵɵnextContext(); return ctx_r733.onClearButtonClick(); });
    ɵngcc0.ɵɵtext(29);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(30, "div");
    ɵngcc0.ɵɵelementStart(31, "button", 18);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_31_listener() { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r734 = ɵngcc0.ɵɵnextContext(); return ctx_r734.cancelChanges(); });
    ɵngcc0.ɵɵtext(32);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(33, "button", 19);
    ɵngcc0.ɵɵlistener("click", function IgxAdvancedFilteringDialogComponent_article_0_Template_button_click_33_listener() { ɵngcc0.ɵɵrestoreView(_r725); const ctx_r735 = ɵngcc0.ɵɵnextContext(); return ctx_r735.onApplyButtonClick(); });
    ɵngcc0.ɵɵtext(34);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r611 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ghost", false)("dragTolerance", 0)("ngClass", ɵngcc0.ɵɵpureFunction3(17, _c115, ctx_r611.grid.displayDensity === "cosy", ctx_r611.grid.displayDensity === "compact", ctx_r611.inline));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r611.grid.resourceStrings.igx_grid_advanced_filter_title, " ");
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(ctx_r611.grid.resourceStrings.igx_grid_advanced_filter_and_label);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r611.grid.resourceStrings.igx_grid_advanced_filter_or_label);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r611.rootGroup);
    ɵngcc0.ɵɵadvance(7);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r611.rootGroup);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(21, _c116, ctx_r611.displayDensity === "cosy", ctx_r611.displayDensity === "compact"));
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r611.contextualGroup);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r611.contextualGroup);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r611.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r611.grid.resourceStrings.igx_grid_excel_custom_dialog_clear);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r611.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r611.grid.resourceStrings.igx_grid_excel_cancel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r611.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r611.grid.resourceStrings.igx_grid_excel_apply, " ");
} }
const _c117 = ["toolbar"];
const _c118 = ["defaultExpandedTemplate"];
const _c119 = ["defaultCollapsedTemplate"];
const _c120 = ["loadingOverlay"];
const _c121 = ["igxLoadingOverlayOutlet"];
const _c122 = ["emptyFilteredGrid"];
const _c123 = ["defaultEmptyGrid"];
const _c124 = ["defaultLoadingGrid"];
const _c125 = ["verticalScrollContainer"];
const _c126 = ["verticalScrollHolder"];
const _c127 = ["scr"];
const _c128 = ["footer"];
const _c129 = ["hContainer"];
const _c130 = ["headerSelectorContainer"];
const _c131 = ["headerDragContainer"];
const _c132 = ["headerGroupContainer"];
const _c133 = ["filteringRow"];
const _c134 = ["theadRow"];
const _c135 = ["tbody"];
const _c136 = ["pinContainer"];
const _c137 = ["tfoot"];
const _c138 = ["igxFilteringOverlayOutlet"];
const _c139 = ["igxRowEditingOverlayOutlet"];
const _c140 = ["dragIndicatorIconBase"];
const _c141 = ["defaultRowEditTemplate"];
const _c142 = ["row"];
const _c143 = ["pinnedRow"];
const _c144 = ["summaryRow"];
const _c145 = [[["igx-select-item"]]];
const _c146 = ["igx-select-item"];
function IgxPaginatorComponent_igx_select_item_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-select-item", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const val_r737 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("value", val_r737);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", val_r737, " ");
} }
const _c147 = function (a0, a1, a2, a3, a4) { return { "igx-linear-bar__value--start": a0, "igx-linear-bar__value--center": a1, "igx-linear-bar__value--end": a2, "igx-linear-bar__value--top": a3, "igx-linear-bar__value--hidden": a4 }; };
const _c148 = ["circle"];
function IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCircularProgressBarComponent__svg_text_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "text", 9);
    ɵngcc0.ɵɵtemplate(1, IgxCircularProgressBarComponent__svg_text_5__svg_ng_container_1_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r740 = ɵngcc0.ɵɵnextContext();
    const _r742 = ɵngcc0.ɵɵreference(9);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r740.textTemplate ? ctx_r740.textTemplate.template : _r742)("ngTemplateOutletContext", ctx_r740.context);
} }
function IgxCircularProgressBarComponent__svg_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCircularProgressBarComponent__svg_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "tspan", 10);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r743 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r743.textContent ? ctx_r743.textContent : ctx_r743.valueInPercent + "%", " ");
} }
function IgxCircularProgressBarComponent__svg_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelementStart(0, "linearGradient", 11);
    ɵngcc0.ɵɵelement(1, "stop", 12);
    ɵngcc0.ɵɵelement(2, "stop", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r745 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("id", ctx_r745.gradientId);
} }
function IgxBadgeComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r747 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r747.value);
} }
function IgxBadgeComponent_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r748 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r748.icon);
} }
const _c149 = ["defaultGroupByExpandedTemplate"];
const _c150 = ["defaultGroupByCollapsedTemplate"];
const _c151 = ["groupContent"];
function IgxGridGroupByRowComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridGroupByRowComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridGroupByRowComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 8);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridGroupByRowComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 8);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 15);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r759 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r759.groupRow.value);
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 15);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "number");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r762 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(3, 1, ctx_r762.groupRow.value));
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "span", 15);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵpipe(3, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r763 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(3, 1, ctx_r763.groupRow.value));
} }
function IgxGridGroupByRowComponent_ng_template_11_ng_template_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_0_Template, 4, 3, "ng-container", 16);
    ɵngcc0.ɵɵtemplate(1, IgxGridGroupByRowComponent_ng_template_11_ng_template_6_ng_container_1_Template, 4, 3, "ng-container", 16);
} if (rf & 2) {
    const ctx_r761 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r761.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r761.dataType === "date");
} }
function IgxGridGroupByRowComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 10);
    ɵngcc0.ɵɵtext(2, "group_work");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "span", 11);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxGridGroupByRowComponent_ng_template_11_ng_container_5_Template, 3, 1, "ng-container", 12);
    ɵngcc0.ɵɵtemplate(6, IgxGridGroupByRowComponent_ng_template_11_ng_template_6_Template, 2, 2, "ng-template", null, 13, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelement(8, "igx-badge", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r760 = ɵngcc0.ɵɵreference(7);
    const ctx_r758 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r758.groupRow.expression ? ctx_r758.groupRow.expression.fieldName : "", ": ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r758.dataType === "boolean" || ctx_r758.dataType === "string")("ngIfElse", _r760);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("value", ctx_r758.groupRow.records ? ctx_r758.groupRow.records.length : 0);
} }
const _c152 = ["defaultDropArea"];
const _c153 = ["groupArea"];
const _c154 = ["record_template"];
const _c155 = ["detail_template_container"];
const _c156 = ["group_template"];
const _c157 = ["summary_template"];
function IgxGridComponent_igx_grid_toolbar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-toolbar", 67, 68);
} if (rf & 2) {
    const ctx_r764 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r764.outerWidth, "px")("flex-basis", ctx_r764.outerWidth, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r764.id)("displayDensity", ctx_r764.displayDensity);
} }
function IgxGridComponent_div_1_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r846 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-chip", 74);
    ɵngcc0.ɵɵlistener("onKeyDown", function IgxGridComponent_div_1_ng_container_3_Template_igx_chip_onKeyDown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r846); const ctx_r845 = ɵngcc0.ɵɵnextContext(2); return ctx_r845.onChipKeyDown($event); })("onRemove", function IgxGridComponent_div_1_ng_container_3_Template_igx_chip_onRemove_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r846); const ctx_r847 = ɵngcc0.ɵɵnextContext(2); return ctx_r847.onChipRemoved($event); })("onClick", function IgxGridComponent_div_1_ng_container_3_Template_igx_chip_onClick_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r846); const expr_r843 = ctx.$implicit; const ctx_r848 = ɵngcc0.ɵɵnextContext(2); return ctx_r848.getColumnGroupable(expr_r843.fieldName) ? ctx_r848.onChipClicked($event) : null; });
    ɵngcc0.ɵɵelementStart(2, "span");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "igx-icon", 75);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "span", 76);
    ɵngcc0.ɵɵelementStart(7, "igx-icon");
    ɵngcc0.ɵɵtext(8, "arrow_forward ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const expr_r843 = ctx.$implicit;
    const last_r844 = ctx.last;
    const ctx_r841 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("id", expr_r843.fieldName)("removable", ctx_r841.getColumnGroupable(expr_r843.fieldName))("draggable", ctx_r841.getColumnGroupable(expr_r843.fieldName))("displayDensity", ctx_r841.displayDensity)("disabled", !ctx_r841.getColumnGroupable(expr_r843.fieldName));
    ɵngcc0.ɵɵattribute("title", ctx_r841.getGroupByChipTitle(expr_r843));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r841.getGroupByChipTitle(expr_r843));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(expr_r843.dir == 1 ? "arrow_upward" : "arrow_downward");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵstyleProp("visibility", !last_r844 || ctx_r841.dropAreaVisible ? "visible" : "hidden");
} }
function IgxGridComponent_div_1_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r850 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 69, 70);
    ɵngcc0.ɵɵelementStart(2, "igx-chips-area", 71);
    ɵngcc0.ɵɵlistener("onReorder", function IgxGridComponent_div_1_Template_igx_chips_area_onReorder_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r850); const ctx_r849 = ɵngcc0.ɵɵnextContext(); return ctx_r849.chipsOrderChanged($event); })("onMoveEnd", function IgxGridComponent_div_1_Template_igx_chips_area_onMoveEnd_2_listener() { ɵngcc0.ɵɵrestoreView(_r850); const ctx_r851 = ɵngcc0.ɵɵnextContext(); return ctx_r851.chipsMovingEnded(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_div_1_ng_container_3_Template, 9, 10, "ng-container", 72);
    ɵngcc0.ɵɵelementStart(4, "div", 73);
    ɵngcc0.ɵɵtemplate(5, IgxGridComponent_div_1_ng_container_5_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r765 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("flex-basis", ctx_r765.outerWidth, "px");
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r765.chipsGoupingExpressions);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r765.groupAreaHostClass);
    ɵngcc0.ɵɵstyleProp("visibility", ctx_r765.dropAreaVisible ? "visible" : "hidden");
    ɵngcc0.ɵɵattribute("gridId", ctx_r765.id);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r765.dropAreaTemplateResolved);
} }
function IgxGridComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 77);
} if (rf & 2) {
    const ctx_r767 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r767.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r767.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_span_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 78);
} if (rf & 2) {
    const ctx_r768 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r768.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r768.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_ng_container_8_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c158 = function (a0) { return { "igx-grid__header-indentation--no-border": a0 }; };
function IgxGridComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    const _r855 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 79, 80);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_container_8_Template_div_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r855); const ctx_r854 = ɵngcc0.ɵɵnextContext(); return ctx_r854.toggleAllGroupRows(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_container_8_ng_container_3_Template, 1, 0, "ng-container", 81);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r769 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__header-indentation igx-grid__row-indentation--level-", ctx_r769.groupingExpressions.length, "");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c158, ctx_r769.isRowSelectable || ctx_r769.rowDraggable));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r769.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c13, ctx_r769));
} }
function IgxGridComponent_ng_container_9_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c159 = function (a0) { return { "igx-grid__drag-indicator--header": a0 }; };
function IgxGridComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 82, 83);
    ɵngcc0.ɵɵelementStart(3, "div", 84);
    ɵngcc0.ɵɵtemplate(4, IgxGridComponent_ng_container_9_ng_container_4_Template, 1, 0, "ng-container", 18);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r770 = ɵngcc0.ɵɵnextContext();
    const _r832 = ɵngcc0.ɵɵreference(100);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c159, !ctx_r770.isRowSelectable));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r770.dragIndicatorIconTemplate ? ctx_r770.dragIndicatorIconTemplate : _r832);
} }
function IgxGridComponent_ng_container_10_3_ng_template_0_Template(rf, ctx) { }
function IgxGridComponent_ng_container_10_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_container_10_3_ng_template_0_Template, 0, 0, "ng-template", null, 87, ɵngcc0.ɵɵtemplateRefExtractor);
} }
const _c160 = function (a0) { return { "igx-grid__cbx-selection--push": a0 }; };
const _c161 = function (a0, a1) { return { selectedCount: a0, totalCount: a1 }; };
function IgxGridComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    const _r863 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 85, 86);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_container_10_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r863); const ctx_r862 = ɵngcc0.ɵɵnextContext(); return ctx_r862.onHeaderSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_container_10_3_Template, 2, 0, undefined, 81);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r771 = ɵngcc0.ɵɵnextContext();
    const _r834 = ɵngcc0.ɵɵreference(102);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c160, ctx_r771.filteringService.isFilterRowVisible));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r771.headSelectorTemplate ? ctx_r771.headSelectorTemplate : _r834)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c13, ɵngcc0.ɵɵpureFunction2(5, _c161, ctx_r771.selectionService.filteredSelectedRowIds.length, ctx_r771.totalRowsCountAfterFilter)));
} }
function IgxGridComponent_ng_container_11_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 89);
} if (rf & 2) {
    const col_r865 = ctx.$implicit;
    const ctx_r864 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r864.getHeaderGroupWidth(col_r865))("flex-basis", ctx_r864.getHeaderGroupWidth(col_r865));
    ɵngcc0.ɵɵproperty("column", col_r865)("gridID", ctx_r864.id);
} }
function IgxGridComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_container_11_ng_template_1_Template, 1, 6, "ng-template", 88);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r772 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r772.pinnedColumns));
} }
function IgxGridComponent_ng_template_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 89);
} if (rf & 2) {
    const col_r866 = ctx.$implicit;
    const ctx_r774 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r774.getHeaderGroupWidth(col_r866))("flex-basis", ctx_r774.getHeaderGroupWidth(col_r866));
    ɵngcc0.ɵɵproperty("column", col_r866)("gridID", ctx_r774.id);
} }
function IgxGridComponent_ng_container_15_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 89);
} if (rf & 2) {
    const col_r868 = ctx.$implicit;
    const ctx_r867 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r867.getHeaderGroupWidth(col_r868))("flex-basis", ctx_r867.getHeaderGroupWidth(col_r868))("left", col_r868.rightPinnedOffset);
    ɵngcc0.ɵɵproperty("column", col_r868)("gridID", ctx_r867.id);
} }
function IgxGridComponent_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_container_15_ng_template_1_Template, 1, 8, "ng-template", 88);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r775 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r775.pinnedColumns));
} }
function IgxGridComponent_igx_grid_filtering_row_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-row", 90, 91);
} if (rf & 2) {
    const ctx_r776 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r776.calcWidth, "px");
    ɵngcc0.ɵɵproperty("column", ctx_r776.filteringService.filteredColumn);
} }
function IgxGridComponent_span_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 92);
} if (rf & 2) {
    const ctx_r777 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r777.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_span_22_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 77);
} if (rf & 2) {
    const ctx_r779 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r779.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_span_23_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 78);
} if (rf & 2) {
    const ctx_r780 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r780.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r780.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_ng_container_24_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 81);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const rowData_r875 = ctx.$implicit;
    const rowIndex_r876 = ctx.index;
    const ctx_r874 = ɵngcc0.ɵɵnextContext(4);
    const _r789 = ɵngcc0.ɵɵreference(42);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r789)("ngTemplateOutletContext", ctx_r874.getContext(rowData_r875, rowIndex_r876, true));
} }
const _c162 = function (a0, a1) { return { "igx-grid__tr--pinned-bottom": a0, "igx-grid__tr--pinned-top": a1 }; };
function IgxGridComponent_ng_template_25_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 94, 95);
    ɵngcc0.ɵɵtemplate(2, IgxGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template, 2, 2, "ng-container", 72);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const pinnedData_r871 = ɵngcc0.ɵɵnextContext().ngIf;
    const ctx_r872 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r872.calcWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c162, !ctx_r872.isRowPinningToTop, ctx_r872.isRowPinningToTop));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", pinnedData_r871);
} }
function IgxGridComponent_ng_template_25_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_template_25_ng_container_0_div_1_Template, 3, 7, "div", 93);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const pinnedData_r871 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", pinnedData_r871.length > 0);
} }
const _c163 = function (a0, a1, a2, a3, a4, a5, a6) { return [a0, a1, a2, a3, a4, a5, a6, true]; };
const _c164 = function (a0, a1, a2, a3, a4) { return [a0, a1, a2, a3, a4, true]; };
function IgxGridComponent_ng_template_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_template_25_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵpipe(1, "gridSort");
    ɵngcc0.ɵɵpipe(2, "gridFiltering");
    ɵngcc0.ɵɵpipe(3, "gridRowPinning");
    ɵngcc0.ɵɵpipe(4, "visibleColumns");
    ɵngcc0.ɵɵpipe(5, "gridTransaction");
} if (rf & 2) {
    const ctx_r783 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBindV(1, 1, ɵngcc0.ɵɵpureFunction5(37, _c164, ɵngcc0.ɵɵpipeBindV(2, 8, ɵngcc0.ɵɵpureFunction7(29, _c163, ɵngcc0.ɵɵpipeBind4(3, 17, ɵngcc0.ɵɵpipeBind2(4, 22, ɵngcc0.ɵɵpipeBind3(5, 25, ctx_r783.data, ctx_r783.id, ctx_r783.pipeTrigger), ctx_r783.hasVisibleColumns), ctx_r783.id, true, ctx_r783.pipeTrigger), ctx_r783.filteringExpressionsTree, ctx_r783.filterStrategy, ctx_r783.advancedFilteringExpressionsTree, ctx_r783.id, ctx_r783.pipeTrigger, ctx_r783.filteringPipeTrigger)), ctx_r783.sortingExpressions, ctx_r783.sortStrategy, ctx_r783.id, ctx_r783.pipeTrigger)));
} }
function IgxGridComponent_ng_template_27_ng_template_0_Template(rf, ctx) { }
function IgxGridComponent_ng_template_27_Template(rf, ctx) { if (rf & 1) {
    const _r883 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, IgxGridComponent_ng_template_27_ng_template_0_Template, 0, 0, "ng-template", 96);
    ɵngcc0.ɵɵlistener("onCachedViewLoaded", function IgxGridComponent_ng_template_27_Template_ng_template_onCachedViewLoaded_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r883); const ctx_r882 = ɵngcc0.ɵɵnextContext(); return ctx_r882.cachedViewLoaded($event); })("onViewCreated", function IgxGridComponent_ng_template_27_Template_ng_template_onViewCreated_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r883); const ctx_r884 = ɵngcc0.ɵɵnextContext(); return ctx_r884.viewCreatedHandler($event); })("onViewMoved", function IgxGridComponent_ng_template_27_Template_ng_template_onViewMoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r883); const ctx_r885 = ɵngcc0.ɵɵnextContext(); return ctx_r885.viewMovedHandler($event); });
} if (rf & 2) {
    const rowData_r879 = ctx.$implicit;
    const rowIndex_r880 = ctx.index;
    const ctx_r785 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxTemplateOutlet", ctx_r785.getRowTemplate(rowData_r879))("igxTemplateOutletContext", ctx_r785.getContext(rowData_r879, rowIndex_r880));
} }
function IgxGridComponent_ng_container_38_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_39_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-row", 97, 98);
} if (rf & 2) {
    const rowIndex_r886 = ctx.index;
    const rowData_r887 = ctx.$implicit;
    const disabledRow_r888 = ctx.disabled;
    const ctx_r788 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r788.id)("index", rowIndex_r886)("rowData", rowData_r887)("disabled", disabledRow_r888);
} }
function IgxGridComponent_ng_template_41_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-row", 99, 100);
} if (rf & 2) {
    const rowIndex_r890 = ctx.index;
    const rowData_r891 = ctx.$implicit;
    const ctx_r790 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r790.id)("index", rowIndex_r890)("rowData", rowData_r891);
} }
function IgxGridComponent_ng_template_43_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-groupby-row", 101, 98);
} if (rf & 2) {
    const rowIndex_r894 = ctx.index;
    const rowData_r895 = ctx.$implicit;
    const ctx_r792 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r792.id)("index", rowIndex_r894)("groupRow", rowData_r895);
} }
function IgxGridComponent_ng_template_45_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 102, 103);
} if (rf & 2) {
    const rowIndex_r897 = ctx.index;
    const rowData_r898 = ctx.$implicit;
    const ctx_r794 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r794.id)("summaries", rowData_r898.summaries)("index", rowIndex_r897);
} }
function IgxGridComponent_ng_template_47_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r903 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__row-indentation igx-grid__row-indentation--level-", ctx_r903.groupingExpressions.length, "");
} }
function IgxGridComponent_ng_template_47_ng_template_4_Template(rf, ctx) { }
const _c165 = function (a1) { return { "igx-grid__tr-container": true, "igx-grid__tr-container--active": a1 }; };
function IgxGridComponent_ng_template_47_Template(rf, ctx) { if (rf & 1) {
    const _r906 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 104, 105);
    ɵngcc0.ɵɵlistener("pointerdown", function IgxGridComponent_ng_template_47_Template_div_pointerdown_0_listener() { ɵngcc0.ɵɵrestoreView(_r906); const rowIndex_r900 = ctx.index; const _r902 = ɵngcc0.ɵɵreference(1); const ctx_r905 = ɵngcc0.ɵɵnextContext(); return ctx_r905.detailsViewFocused(_r902, rowIndex_r900); });
    ɵngcc0.ɵɵelementStart(2, "div", 106);
    ɵngcc0.ɵɵtemplate(3, IgxGridComponent_ng_template_47_ng_container_3_Template, 2, 3, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(4, IgxGridComponent_ng_template_47_ng_template_4_Template, 0, 0, "ng-template", 107);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const rowIndex_r900 = ctx.index;
    const rowData_r901 = ctx.$implicit;
    const ctx_r796 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate2("id", "", ctx_r796.id, "_", rowIndex_r900, "");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(7, _c165, ctx_r796.isDetailActive(rowIndex_r900)));
    ɵngcc0.ɵɵattribute("data-rowindex", rowIndex_r900);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r796.groupingExpressions.length > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r796.detailTemplate)("ngTemplateOutletContext", ctx_r796.getDetailsContext(rowData_r901, rowIndex_r900));
} }
function IgxGridComponent_ng_container_49_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_igx_circular_bar_55_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 108);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxGridComponent_span_56_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 92);
} if (rf & 2) {
    const ctx_r801 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r801.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxGridComponent_ng_template_60_Template(rf, ctx) { }
function IgxGridComponent_igx_grid_summary_row_65_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 109, 103);
    ɵngcc0.ɵɵpipe(2, "igxGridSummaryDataPipe");
} if (rf & 2) {
    const ctx_r805 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r805.calcWidth, "px")("height", ctx_r805.summariesHeight, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r805.id)("summaries", ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r805.id, ctx_r805.summaryService.retriggerRootPipe))("index", ctx_r805.dataView.length);
} }
function IgxGridComponent_ng_template_71_Template(rf, ctx) { }
function IgxGridComponent_ng_container_77_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_container_77_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridComponent_ng_container_77_ng_container_1_Template, 1, 0, "ng-container", 81);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r810 = ɵngcc0.ɵɵnextContext();
    const _r811 = ɵngcc0.ɵɵreference(79);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r810.paginationTemplate ? ctx_r810.paginationTemplate : _r811)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r810));
} }
function IgxGridComponent_ng_template_78_Template(rf, ctx) { if (rf & 1) {
    const _r910 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-paginator", 110);
    ɵngcc0.ɵɵlistener("pageChange", function IgxGridComponent_ng_template_78_Template_igx_paginator_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r910); const ctx_r909 = ɵngcc0.ɵɵnextContext(); return ctx_r909.page = $event; })("perPageChange", function IgxGridComponent_ng_template_78_Template_igx_paginator_perPageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r910); const ctx_r911 = ɵngcc0.ɵɵnextContext(); return ctx_r911.perPage = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r812 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r812.displayDensity)("page", ctx_r812.page)("totalRecords", ctx_r812.totalRecords)("perPage", ctx_r812.perPage);
} }
function IgxGridComponent_ng_template_80_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 111);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r814 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r814.emptyFilteredGridMessage);
} }
function IgxGridComponent_ng_template_82_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 111);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r816 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r816.emptyGridMessage);
} }
function IgxGridComponent_ng_template_84_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 112);
    ɵngcc0.ɵɵelement(1, "igx-circular-bar", 108);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxGridComponent_ng_template_86_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 113);
    ɵngcc0.ɵɵtext(1, "group_work");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "span", 114);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r820 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r820.dropAreaMessage);
} }
const _c166 = function (a0) { return { "igx-grid__group-expand-btn--push": a0 }; };
function IgxGridComponent_ng_template_88_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 115);
    ɵngcc0.ɵɵtext(1, "unfold_less");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r822 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c166, ctx_r822.filteringService.isFilterRowVisible));
} }
function IgxGridComponent_ng_template_90_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 115);
    ɵngcc0.ɵɵtext(1, "unfold_more");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r824 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(1, _c166, ctx_r824.filteringService.isFilterRowVisible));
} }
function IgxGridComponent_div_92_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c167 = function (a0, a1) { return { rowChangesCount: a0, endEdit: a1 }; };
function IgxGridComponent_div_92_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 116);
    ɵngcc0.ɵɵelementStart(1, "div", 117);
    ɵngcc0.ɵɵtemplate(2, IgxGridComponent_div_92_ng_container_2_Template, 1, 0, "ng-container", 81);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r825 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r825.bannerClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r825.rowEditContainer)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c167, ctx_r825.rowChangesCount, ctx_r825.endEdit.bind(ctx_r825)));
} }
function IgxGridComponent_ng_template_93_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r827 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" You have ", ctx_r827.rowChangesCount, " changes in this row\n");
} }
function IgxGridComponent_ng_template_95_Template(rf, ctx) { if (rf & 1) {
    const _r914 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 118);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_template_95_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r914); const ctx_r913 = ɵngcc0.ɵɵnextContext(); return ctx_r913.endRowEdit(false, $event); });
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 118);
    ɵngcc0.ɵɵlistener("click", function IgxGridComponent_ng_template_95_Template_button_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r914); const ctx_r915 = ɵngcc0.ɵɵnextContext(); return ctx_r915.endRowEdit(true, $event); });
    ɵngcc0.ɵɵtext(3, "Done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridComponent_ng_template_97_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_97_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridComponent_ng_template_97_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 119);
    ɵngcc0.ɵɵelementStart(1, "span", 120);
    ɵngcc0.ɵɵtemplate(2, IgxGridComponent_ng_template_97_ng_container_2_Template, 1, 0, "ng-container", 81);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 121);
    ɵngcc0.ɵɵelementStart(4, "div", 122);
    ɵngcc0.ɵɵtemplate(5, IgxGridComponent_ng_template_97_ng_container_5_Template, 1, 0, "ng-container", 81);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r831 = ɵngcc0.ɵɵnextContext();
    const _r826 = ɵngcc0.ɵɵreference(94);
    const _r828 = ɵngcc0.ɵɵreference(96);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r831.rowEditText ? ctx_r831.rowEditText : _r826)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c13, ctx_r831.rowChangesCount));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r831.rowEditActions ? ctx_r831.rowEditActions : _r828)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c13, ctx_r831.endEdit.bind(ctx_r831)));
} }
function IgxGridComponent_ng_template_99_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 123);
    ɵngcc0.ɵɵtext(1, "drag_indicator");
    ɵngcc0.ɵɵelementEnd();
} }
const _c168 = function (a0) { return { "visibility": a0 }; };
function IgxGridComponent_ng_template_101_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 124);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 125, 126);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r918 = ctx.$implicit;
    const ctx_r835 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", 0 - 1)("readonly", true)("checked", context_r918.selectedCount > 0 && context_r918.totalCount === context_r918.selectedCount)("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c168, ctx_r835.isMultiRowSelectionEnabled ? "visible" : "hidden"))("indeterminate", context_r918.selectedCount > 0 && context_r918.selectedCount !== context_r918.totalCount)("aria-label", ctx_r835.headSelectorBaseAriaLabel);
} }
function IgxGridComponent_igx_grid_column_resizer_103_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-column-resizer");
} }
const _c169 = [[["igx-grid-footer"]]];
const _c170 = function (a0, a1, a2, a3, a4, a5, a6) { return [a0, a1, a2, a3, a4, a5, a6]; };
const _c171 = function (a0, a1, a2, a3, a4) { return [a0, a1, a2, a3, a4]; };
const _c172 = function () { return []; };
const _c173 = ["igx-grid-footer"];
function IgxGridEditingActionsComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r922 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 1);
    ɵngcc0.ɵɵlistener("click", function IgxGridEditingActionsComponent_ng_container_0_Template_button_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r922); const ctx_r921 = ɵngcc0.ɵɵnextContext(); return ctx_r921.startEdit($event); });
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "edit");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxGridEditingActionsComponent_ng_container_0_Template_button_click_4_listener($event) { ɵngcc0.ɵɵrestoreView(_r922); const ctx_r923 = ɵngcc0.ɵɵnextContext(); return ctx_r923.deleteRow($event); });
    ɵngcc0.ɵɵelementStart(5, "igx-icon");
    ɵngcc0.ɵɵtext(6, "delete");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r920 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("disabled", ctx_r920.disabled);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("disabled", ctx_r920.disabled);
} }
function IgxGridPinningActionsComponent_ng_container_0_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r930 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxGridPinningActionsComponent_ng_container_0_button_1_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r930); const ctx_r929 = ɵngcc0.ɵɵnextContext(2); return ctx_r929.scrollToRow($event); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 3);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridPinningActionsComponent_ng_container_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r932 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxGridPinningActionsComponent_ng_container_0_button_2_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r932); const ctx_r931 = ɵngcc0.ɵɵnextContext(2); return ctx_r931.scrollToRow($event); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 4);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridPinningActionsComponent_ng_container_0_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r934 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxGridPinningActionsComponent_ng_container_0_button_3_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r934); const ctx_r933 = ɵngcc0.ɵɵnextContext(2); return ctx_r933.pin($event); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridPinningActionsComponent_ng_container_0_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r936 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function IgxGridPinningActionsComponent_ng_container_0_button_4_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r936); const ctx_r935 = ɵngcc0.ɵɵnextContext(2); return ctx_r935.unpin($event); });
    ɵngcc0.ɵɵelement(1, "igx-icon", 6);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridPinningActionsComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridPinningActionsComponent_ng_container_0_button_1_Template, 2, 0, "button", 1);
    ɵngcc0.ɵɵtemplate(2, IgxGridPinningActionsComponent_ng_container_0_button_2_Template, 2, 0, "button", 1);
    ɵngcc0.ɵɵtemplate(3, IgxGridPinningActionsComponent_ng_container_0_button_3_Template, 2, 0, "button", 1);
    ɵngcc0.ɵɵtemplate(4, IgxGridPinningActionsComponent_ng_container_0_button_4_Template, 2, 0, "button", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r924 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r924.inPinnedArea && ctx_r924.pinnedTop);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r924.inPinnedArea && !ctx_r924.pinnedTop);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r924.pinned);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r924.pinned);
} }
function IgxExpansionPanelHeaderComponent_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 3, ["*ngIf", "iconTemplate"]);
} }
function IgxExpansionPanelHeaderComponent_igx_icon_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 4);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r938 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r938.panel.collapsed ? "expand_more" : "expand_less", " ");
} }
const _c174 = [[["igx-expansion-panel-title"]], [["igx-expansion-panel-description"]], "*", [["igx-expansion-panel-icon"]]];
const _c175 = ["igx-expansion-panel-title", "igx-expansion-panel-description", "*", "igx-expansion-panel-icon"];
function IgxExpansionPanelComponent_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1, ["*ngIf", "!collapsed"]);
} }
const _c176 = [[["igx-expansion-panel-header"]], [["igx-expansion-panel-body"]]];
const _c177 = ["igx-expansion-panel-header", "igx-expansion-panel-body"];
const _c178 = ["expansionPanel"];
function IgxBannerComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxBannerComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    const _r945 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 10);
    ɵngcc0.ɵɵlistener("click", function IgxBannerComponent_ng_container_10_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r945); const ctx_r944 = ɵngcc0.ɵɵnextContext(); return ctx_r944.close(); });
    ɵngcc0.ɵɵtext(2, " Dismiss ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} }
function IgxBannerComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1, 2);
    ɵngcc0.ɵɵelementContainerEnd();
} }
const _c179 = ["*", [["igx-icon"]], [["igx-banner-actions"]]];
const _c180 = ["*", "igx-icon", "igx-banner-actions"];
const _c181 = [[["igx-avatar"], ["igx-card-media"], ["", "igxCardThumbnail", ""]], [["", "igxCardHeaderTitle", ""], ["", "igxCardHeaderSubtitle", ""], ["", 8, "igx-card-header__title"], ["", 8, "igx-card-header__subtitle"]], "*"];
const _c182 = ["igx-avatar, igx-card-media, [igxCardThumbnail]", "\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle", "*"];
const _c183 = [[["igx-icon"], ["", "igxButton", "icon"]], [["", "igxButton", ""]], "*"];
const _c184 = ["igx-icon, [igxButton='icon']", "[igxButton]", "*"];
const _c185 = ["defaultIndicator"];
const _c186 = ["defaultNextButton"];
const _c187 = ["defaultPrevButton"];
function IgxCarouselComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 7);
} if (rf & 2) {
    const slide_r957 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("igx-nav-dot--active", slide_r957.active);
} }
function IgxCarouselComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 9);
    ɵngcc0.ɵɵtext(2, "arrow_forward");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const disabled_r958 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("igx-nav-arrow--disabled", disabled_r958);
} }
function IgxCarouselComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 9);
    ɵngcc0.ɵɵtext(2, "arrow_back");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const disabled_r959 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("igx-nav-arrow--disabled", disabled_r959);
} }
function IgxCarouselComponent_div_6_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCarouselComponent_div_6_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r964 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵlistener("click", function IgxCarouselComponent_div_6_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r964); const slide_r961 = ctx.$implicit; const ctx_r963 = ɵngcc0.ɵɵnextContext(2); return ctx_r963.select(slide_r961); });
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_6_div_1_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const slide_r961 = ctx.$implicit;
    const ctx_r960 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("aria-label", ctx_r960.setAriaLabel(slide_r961))("aria-selected", slide_r961.active);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r960.getIndicatorTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c13, slide_r961));
} }
function IgxCarouselComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_6_div_1_Template, 2, 6, "div", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r953 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r953.indicatorsOrientationClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r953.slides);
} }
function IgxCarouselComponent_div_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵelementStart(1, "span", 14);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r954 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r954.indicatorsOrientationClass);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r954.getCarouselLabel);
} }
function IgxCarouselComponent_div_10_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCarouselComponent_div_10_Template(rf, ctx) { if (rf & 1) {
    const _r967 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵlistener("click", function IgxCarouselComponent_div_10_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r967); const ctx_r966 = ɵngcc0.ɵɵnextContext(); return ctx_r966.prev(); });
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_10_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r955 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r955.getPrevButtonTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r955.prevButtonDisabled));
} }
function IgxCarouselComponent_div_11_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxCarouselComponent_div_11_Template(rf, ctx) { if (rf & 1) {
    const _r970 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵlistener("click", function IgxCarouselComponent_div_11_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r970); const ctx_r969 = ɵngcc0.ɵɵnextContext(); return ctx_r969.next(); });
    ɵngcc0.ɵɵtemplate(1, IgxCarouselComponent_div_11_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r956 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r956.getNextButtonTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r956.nextButtonDisabled));
} }
function IgxComboItemComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r973 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 1);
    ɵngcc0.ɵɵlistener("click", function IgxComboItemComponent_ng_container_0_Template_igx_checkbox_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r973); const ctx_r972 = ɵngcc0.ɵɵnextContext(); return ctx_r972.disableCheck($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r971 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("checked", ctx_r971.selected)("disableTransitions", ctx_r971.disableTransitions)("tabindex", 0 - 1);
} }
function IgxComboDropDownComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
const _c188 = ["searchInput"];
const _c189 = ["dropdownItemContainer"];
const _c190 = ["comboInput"];
const _c191 = ["primitive"];
const _c192 = ["complex"];
function IgxComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_igx_suffix_12_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_suffix_12_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r998 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r998.clearIconTemplate);
} }
function IgxComboComponent_igx_suffix_12_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 26);
    ɵngcc0.ɵɵtext(1, " clear ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxComboComponent_igx_suffix_12_Template(rf, ctx) { if (rf & 1) {
    const _r1002 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix", 25);
    ɵngcc0.ɵɵlistener("click", function IgxComboComponent_igx_suffix_12_Template_igx_suffix_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1002); const ctx_r1001 = ɵngcc0.ɵɵnextContext(); return ctx_r1001.handleClearItems($event); });
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_suffix_12_ng_container_1_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxComboComponent_igx_suffix_12_igx_icon_2_Template, 2, 0, "igx-icon", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r978 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r978.clearIconTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r978.clearIconTemplate);
} }
function IgxComboComponent_ng_container_14_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_ng_container_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_ng_container_14_ng_container_1_Template, 1, 0, "ng-container", 27);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r979 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r979.toggleIconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r979.collapsed));
} }
function IgxComboComponent_igx_icon_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 26);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r980 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r980.dropdown.collapsed ? "arrow_drop_down" : "arrow_drop_up", " ");
} }
function IgxComboComponent_igx_input_group_18_Template(rf, ctx) { if (rf & 1) {
    const _r1006 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 28);
    ɵngcc0.ɵɵelementStart(1, "input", 29, 30);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxComboComponent_igx_input_group_18_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1006); const ctx_r1005 = ɵngcc0.ɵɵnextContext(); return ctx_r1005.searchValue = $event; })("ngModelChange", function IgxComboComponent_igx_input_group_18_Template_input_ngModelChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1006); const ctx_r1007 = ɵngcc0.ɵɵnextContext(); return ctx_r1007.handleInputChange($event); })("keyup", function IgxComboComponent_igx_input_group_18_Template_input_keyup_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1006); const ctx_r1008 = ɵngcc0.ɵɵnextContext(); return ctx_r1008.handleKeyUp($event); })("keydown", function IgxComboComponent_igx_input_group_18_Template_input_keydown_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1006); const ctx_r1009 = ɵngcc0.ɵɵnextContext(); return ctx_r1009.handleKeyDown($event); })("focus", function IgxComboComponent_igx_input_group_18_Template_input_focus_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1006); const ctx_r1010 = ɵngcc0.ɵɵnextContext(); return ctx_r1010.dropdown.onBlur($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r982 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r982.displayDensity);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r982.searchValue);
    ɵngcc0.ɵɵattribute("placeholder", ctx_r982.searchPlaceholder)("aria-owns", ctx_r982.dropdown.id)("aria-labelledby", ctx_r982.ariaLabelledBy);
} }
function IgxComboComponent_ng_container_19_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c193 = function (a0, a1, a2, a3, a4) { return { $implicit: a0, data: a1, valueKey: a2, groupKey: a3, displayKey: a4 }; };
function IgxComboComponent_igx_combo_item_22_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 27);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1011 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1013 = ɵngcc0.ɵɵnextContext();
    const _r996 = ɵngcc0.ɵɵreference(36);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1013.headerItemTemplate ? ctx_r1013.headerItemTemplate : _r996)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction5(2, _c193, item_r1011, ctx_r1013.data, ctx_r1013.valueKey, ctx_r1013.groupKey, ctx_r1013.displayKey));
} }
function IgxComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0, null, 32);
} }
const _c194 = function (a0, a1, a2, a3) { return { $implicit: a0, data: a1, valueKey: a2, displayKey: a3 }; };
function IgxComboComponent_igx_combo_item_22_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_2_ng_container_1_Template, 2, 0, "ng-container", 27);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1011 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1014 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1014.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction4(2, _c194, item_r1011, ctx_r1014.data, ctx_r1014.valueKey, ctx_r1014.displayKey));
} }
function IgxComboComponent_igx_combo_item_22_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-combo-item", 31);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_igx_combo_item_22_ng_container_1_Template, 2, 8, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, IgxComboComponent_igx_combo_item_22_ng_container_2_Template, 2, 7, "ng-container", 10);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r1011 = ctx.$implicit;
    const rowIndex_r1012 = ctx.index;
    const ctx_r985 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("itemHeight", ctx_r985.itemHeight)("value", item_r1011)("isHeader", item_r1011.isHeader)("index", rowIndex_r1012);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", item_r1011.isHeader);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r1011.isHeader);
} }
function IgxComboComponent_div_25_div_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_div_25_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 36);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_div_25_div_1_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1020 = ɵngcc0.ɵɵnextContext(2);
    const _r992 = ɵngcc0.ɵɵreference(32);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1020.emptyTemplate ? ctx_r1020.emptyTemplate : _r992);
} }
function IgxComboComponent_div_25_igx_combo_add_item_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_div_25_igx_combo_add_item_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-combo-add-item", 37);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_div_25_igx_combo_add_item_2_ng_container_1_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1021 = ɵngcc0.ɵɵnextContext(2);
    const _r994 = ɵngcc0.ɵɵreference(34);
    ɵngcc0.ɵɵproperty("itemHeight", ctx_r1021.itemHeight)("tabindex", ctx_r1021.dropdown.collapsed ? 0 - 1 : ctx_r1021.customValueFlag ? 1 : 0 - 1)("index", ctx_r1021.virtualScrollContainer.igxForOf.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1021.addItemTemplate ? ctx_r1021.addItemTemplate : _r994);
} }
function IgxComboComponent_div_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 33);
    ɵngcc0.ɵɵtemplate(1, IgxComboComponent_div_25_div_1_Template, 2, 1, "div", 34);
    ɵngcc0.ɵɵtemplate(2, IgxComboComponent_div_25_igx_combo_add_item_2_Template, 2, 4, "igx-combo-add-item", 35);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r986 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r986.filteredData.length === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r986.isAddButtonVisible());
} }
function IgxComboComponent_ng_container_26_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxComboComponent_ng_template_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const display_r1024 = ctx.$implicit;
    const key_r1026 = ctx.displayKey;
    ɵngcc0.ɵɵtextInterpolate1(" ", display_r1024[key_r1026], "\n");
} }
function IgxComboComponent_ng_template_29_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const display_r1027 = ctx.$implicit;
    ɵngcc0.ɵɵtextInterpolate1(" ", display_r1027, "\n");
} }
function IgxComboComponent_ng_template_31_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1, "The list is empty");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxComboComponent_ng_template_33_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "button", 38);
    ɵngcc0.ɵɵtext(1, "Add item");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxComboComponent_ng_template_35_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const item_r1029 = ctx.$implicit;
    const key_r1030 = ctx.valueKey;
    ɵngcc0.ɵɵtextInterpolate1(" ", item_r1029[key_r1030], "\n");
} }
const _c195 = [[["", "igxLabel", ""]], [["igx-prefix"]], [["igx-hint"], ["", "igxHint", ""]], [["igx-suffix"]]];
const _c196 = ["[igxLabel]", "igx-prefix", "igx-hint, [igxHint]", "igx-suffix"];
function IgxDialogComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1034 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵattribute("id", ctx_r1034.titleId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1034.title, " ");
} }
function IgxDialogComponent_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "!title"]);
} }
function IgxDialogComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1036 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1036.message);
} }
function IgxDialogComponent_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1, ["*ngIf", "!message"]);
} }
function IgxDialogComponent_div_8_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r1043 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 12);
    ɵngcc0.ɵɵlistener("click", function IgxDialogComponent_div_8_button_1_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1043); const ctx_r1042 = ɵngcc0.ɵɵnextContext(2); return ctx_r1042.onInternalLeftButtonSelect($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1040 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵpropertyInterpolate("igxButton", ctx_r1040.leftButtonType);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonColor", ctx_r1040.leftButtonColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonBackground", ctx_r1040.leftButtonBackgroundColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxRipple", ctx_r1040.leftButtonRipple);
    ɵngcc0.ɵɵproperty("igxFocus", ctx_r1040.isOpen);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1040.leftButtonLabel, " ");
} }
function IgxDialogComponent_div_8_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r1045 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 12);
    ɵngcc0.ɵɵlistener("click", function IgxDialogComponent_div_8_button_2_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1045); const ctx_r1044 = ɵngcc0.ɵɵnextContext(2); return ctx_r1044.onInternalRightButtonSelect($event); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1041 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵpropertyInterpolate("igxButton", ctx_r1041.rightButtonType);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonColor", ctx_r1041.rightButtonColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxButtonBackground", ctx_r1041.rightButtonBackgroundColor);
    ɵngcc0.ɵɵpropertyInterpolate("igxRipple", ctx_r1041.rightButtonRipple);
    ɵngcc0.ɵɵproperty("igxFocus", ctx_r1041.isOpen);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1041.rightButtonLabel, " ");
} }
function IgxDialogComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 10);
    ɵngcc0.ɵɵtemplate(1, IgxDialogComponent_div_8_button_1_Template, 2, 6, "button", 11);
    ɵngcc0.ɵɵtemplate(2, IgxDialogComponent_div_8_button_2_Template, 2, 6, "button", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1038 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1038.leftButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1038.rightButtonLabel);
} }
function IgxDialogComponent_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2, ["*ngIf", "!leftButtonLabel && !rightButtonLabel"]);
} }
const _c197 = [[["igx-dialog-title"], ["", "igxDialogTitle", ""]], "*", [["igx-dialog-actions"], ["", "igxDialogActions", ""]]];
const _c198 = ["igx-dialog-title,[igxDialogTitle]", "*", "igx-dialog-actions,[igxDialogActions]"];
function IgxGridRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1046 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__row-indentation igx-grid__row-indentation--level-", ctx_r1046.grid.groupingExpressions.length, "");
} }
function IgxGridRowComponent_ng_container_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r1065 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 7);
    ɵngcc0.ɵɵlistener("click", function IgxGridRowComponent_ng_container_1_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1065); return $event.stopPropagation(); });
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_container_1_ng_container_2_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1047 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r1047.resolveDragIndicatorClasses);
    ɵngcc0.ɵɵproperty("igxRowDrag", ctx_r1047)("ghostTemplate", ctx_r1047.grid.getDragGhostCustomTemplate());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1047.grid.dragIndicatorIconTemplate ? ctx_r1047.grid.dragIndicatorIconTemplate : ctx_r1047.grid.dragIndicatorIconBase);
} }
function IgxGridRowComponent_ng_container_2_2_ng_template_0_Template(rf, ctx) { }
function IgxGridRowComponent_ng_container_2_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_2_2_ng_template_0_Template, 0, 0, "ng-template");
} }
const _c199 = function (a0, a1, a2) { return { index: a0, rowID: a1, selected: a2 }; };
function IgxGridRowComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r1069 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵlistener("click", function IgxGridRowComponent_ng_container_2_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1069); const ctx_r1068 = ɵngcc0.ɵɵnextContext(); return ctx_r1068.onRowSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_container_2_2_Template, 1, 0, undefined, 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1048 = ɵngcc0.ɵɵnextContext();
    const _r1053 = ɵngcc0.ɵɵreference(8);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1048.grid.rowSelectorTemplate ? ctx_r1048.grid.rowSelectorTemplate : _r1053)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c13, ɵngcc0.ɵɵpureFunction3(2, _c199, ctx_r1048.viewIndex, ctx_r1048.rowID, ctx_r1048.selected)));
} }
function IgxGridRowComponent_ng_container_3_ng_container_1_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_3_ng_container_1_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_3_ng_container_1_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 10);
} if (rf & 2) {
    const col_r1075 = ctx.$implicit;
    const ctx_r1074 = ɵngcc0.ɵɵnextContext(3);
    const _r1057 = ɵngcc0.ɵɵreference(12);
    const _r1055 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1075.visibleIndex === 0 && ctx_r1074.grid.hasDetails ? _r1057 : _r1055)("ngTemplateOutletContext", ctx_r1074.getContext(col_r1075, ctx_r1074));
} }
function IgxGridRowComponent_ng_container_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_3_ng_container_1_ng_template_1_Template, 1, 2, "ng-template", 13);
    ɵngcc0.ɵɵpipe(2, "igxNotGrouped");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1070 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1070.pinnedColumns));
} }
function IgxGridRowComponent_ng_container_3_ng_template_2_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_3_ng_template_2_ng_container_0_Template, 1, 0, "ng-container", 10);
} if (rf & 2) {
    const col_r1077 = ctx.$implicit;
    const ctx_r1072 = ɵngcc0.ɵɵnextContext(2);
    const _r1057 = ɵngcc0.ɵɵreference(12);
    const _r1055 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1077.visibleIndex === 0 && ctx_r1072.grid.hasDetails ? _r1057 : _r1055)("ngTemplateOutletContext", ctx_r1072.getContext(col_r1077, ctx_r1072));
} }
function IgxGridRowComponent_ng_container_3_ng_container_5_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_3_ng_container_5_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_3_ng_container_5_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 10);
} if (rf & 2) {
    const col_r1080 = ctx.$implicit;
    const ctx_r1079 = ɵngcc0.ɵɵnextContext(3);
    const _r1057 = ɵngcc0.ɵɵreference(12);
    const _r1055 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1080.visibleIndex === 0 && ctx_r1079.grid.hasDetails ? _r1057 : _r1055)("ngTemplateOutletContext", ctx_r1079.getContext(col_r1080, ctx_r1079));
} }
function IgxGridRowComponent_ng_container_3_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_3_ng_container_5_ng_template_1_Template, 1, 2, "ng-template", 13);
    ɵngcc0.ɵɵpipe(2, "igxNotGrouped");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1073 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1073.pinnedColumns));
} }
function IgxGridRowComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_3_ng_container_1_Template, 3, 3, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_container_3_ng_template_2_Template, 1, 2, "ng-template", 11, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(4, "igxNotGrouped");
    ɵngcc0.ɵɵtemplate(5, IgxGridRowComponent_ng_container_3_ng_container_5_Template, 3, 3, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1049 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1049.pinnedColumns.length > 0 && ctx_r1049.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(4, 8, ctx_r1049.unpinnedColumns))("igxForScrollContainer", ctx_r1049.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r1049.grid.unpinnedWidth)("igxForSizePropName", "calcPixelWidth")("igxForTrackBy", ctx_r1049.grid.trackColumnChanges);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1049.pinnedColumns.length > 0 && !ctx_r1049.grid.isPinningToStart);
} }
function IgxGridRowComponent_ng_container_4_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_4_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1082 = ɵngcc0.ɵɵnextContext(2);
    const _r1051 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1051)("ngTemplateOutletContext", ctx_r1082.getContextMRL(ctx_r1082.pinnedColumns, ctx_r1082));
} }
function IgxGridRowComponent_ng_container_4_ng_template_2_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_4_ng_template_2_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_4_ng_template_2_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 10);
} if (rf & 2) {
    const col_r1090 = ctx.$implicit;
    const ctx_r1089 = ɵngcc0.ɵɵnextContext(3);
    const _r1061 = ɵngcc0.ɵɵreference(16);
    const _r1059 = ɵngcc0.ɵɵreference(14);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1090.visibleIndex === 0 && ctx_r1089.grid.hasDetails ? _r1061 : _r1059)("ngTemplateOutletContext", ctx_r1089.getContext(col_r1090, ctx_r1089));
} }
function IgxGridRowComponent_ng_container_4_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_4_ng_template_2_ng_template_1_Template, 1, 2, "ng-template", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r1087 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction4(2, _c94, col_r1087.getGridTemplate(true, false), col_r1087.getGridTemplate(false, false), col_r1087.getGridTemplate(true, true), col_r1087.getGridTemplate(false, true)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", col_r1087.children);
} }
function IgxGridRowComponent_ng_container_4_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_container_4_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_4_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 10);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1085 = ɵngcc0.ɵɵnextContext(2);
    const _r1051 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1051)("ngTemplateOutletContext", ctx_r1085.getContextMRL(ctx_r1085.pinnedColumns, ctx_r1085));
} }
function IgxGridRowComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_4_ng_container_1_Template, 2, 2, "ng-container", 0);
    ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_container_4_ng_template_2_Template, 2, 7, "ng-template", 11, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵpipe(4, "igxTopLevel");
    ɵngcc0.ɵɵtemplate(5, IgxGridRowComponent_ng_container_4_ng_container_5_Template, 2, 2, "ng-container", 0);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1050 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1050.pinnedColumns.length > 0 && ctx_r1050.grid.isPinningToStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(4, 8, ctx_r1050.unpinnedColumns))("igxForScrollContainer", ctx_r1050.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx_r1050.grid.unpinnedWidth)("igxForSizePropName", "calcPixelWidth")("igxForTrackBy", ctx_r1050.grid.trackColumnChanges);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1050.pinnedColumns.length > 0 && !ctx_r1050.grid.isPinningToStart);
} }
function IgxGridRowComponent_ng_template_5_div_0_ng_template_1_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridRowComponent_ng_template_5_div_0_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_5_div_0_ng_template_1_ng_container_0_Template, 1, 0, "ng-container", 10);
} if (rf & 2) {
    const col_r1097 = ctx.$implicit;
    const ctx_r1096 = ɵngcc0.ɵɵnextContext(3);
    const _r1061 = ɵngcc0.ɵɵreference(16);
    const _r1059 = ɵngcc0.ɵɵreference(14);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1097.visibleIndex === 0 && ctx_r1096.grid.hasDetails ? _r1061 : _r1059)("ngTemplateOutletContext", ctx_r1096.getContext(col_r1097, ctx_r1096));
} }
const _c200 = function (a0, a1, a2, a3, a4) { return { "grid-template-rows": a0, "grid-template-columns": a1, "z-index": a2, "-ms-grid-rows": a3, "-ms-grid-columns": a4 }; };
function IgxGridRowComponent_ng_template_5_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_template_5_div_0_ng_template_1_Template, 1, 2, "ng-template", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const col_r1095 = ctx.$implicit;
    const ctx_r1094 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("left", ctx_r1094.mrlRightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned-last", col_r1095.hasLastPinnedChildColumn)("igx-grid__td--pinned-first", col_r1095.hasFirstPinnedChildColumn);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction5(8, _c200, col_r1095.getGridTemplate(true, false), col_r1095.getGridTemplate(false, false), col_r1095.pinned ? 1 : null, col_r1095.getGridTemplate(true, true), col_r1095.getGridTemplate(false, true)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", col_r1095.children);
} }
function IgxGridRowComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_template_5_div_0_Template, 2, 14, "div", 15);
    ɵngcc0.ɵɵpipe(1, "igxTopLevel");
} if (rf & 2) {
    const pinnedColumns_r1093 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, pinnedColumns_r1093));
} }
function IgxGridRowComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 16);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 17);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1054 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", 0 - 1)("checked", ctx_r1054.selected)("readonly", true)("disabled", ctx_r1054.deleted)("disableTransitions", ctx_r1054.grid.disableTransitions)("aria-label", ctx_r1054.rowCheckboxAriaLabel);
} }
function IgxGridRowComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-cell", 18, 19);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1099 = ctx.$implicit;
    const ctx_r1056 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1056.grid.rowHeight || 32, "px")("min-width", col_r1099.width)("max-width", col_r1099.width)("flex-basis", col_r1099.width)("left", col_r1099.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned", col_r1099.pinned)("igx-grid__td--number", col_r1099.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 31, ɵngcc0.ɵɵpureFunction5(43, _c171, col_r1099.cellClasses, ctx_r1056.rowData[col_r1099.field], ctx_r1056.rowData, col_r1099.field, ctx_r1056.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 37, ɵngcc0.ɵɵpureFunction5(49, _c171, col_r1099.cellStyles, ctx_r1056.rowData[col_r1099.field], ctx_r1056.rowData, col_r1099.field, ctx_r1056.viewIndex)))("editMode", col_r1099.editable && ctx_r1056.crudService.isInEditMode(ctx_r1056.index, col_r1099.index))("column", col_r1099)("formatter", col_r1099.formatter)("row", ctx_r1056)("lastPinned", col_r1099.columnLayoutChild ? null : col_r1099.isLastPinned)("firstPinned", col_r1099.columnLayoutChild ? null : col_r1099.isFirstPinned)("rowData", ctx_r1056.rowData)("width", col_r1099.getCellWidth())("visibleColumnIndex", col_r1099.visibleIndex)("value", ctx_r1056.rowData[col_r1099.field])("cellTemplate", col_r1099.bodyTemplate)("lastSearchInfo", ctx_r1056.grid.lastSearchInfo)("active", ctx_r1056.isCellActive(col_r1099.visibleIndex))("cellSelectionMode", ctx_r1056.grid.cellSelection)("displayPinnedChip", ctx_r1056.shouldDisplayPinnedChip(col_r1099.visibleIndex));
} }
function IgxGridRowComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-expandable-grid-cell", 20, 19);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1101 = ctx.$implicit;
    const ctx_r1058 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1058.grid.rowHeight || 32, "px")("min-width", col_r1101.width)("max-width", col_r1101.width)("flex-basis", col_r1101.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned", col_r1101.pinned)("igx-grid__td--number", col_r1101.dataType === "number" && col_r1101.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 29, ɵngcc0.ɵɵpureFunction5(41, _c171, col_r1101.cellClasses, ctx_r1058.rowData[col_r1101.field], ctx_r1058.rowData, col_r1101.field, ctx_r1058.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 35, ɵngcc0.ɵɵpureFunction5(47, _c171, col_r1101.cellStyles, ctx_r1058.rowData[col_r1101.field], ctx_r1058.rowData, col_r1101.field, ctx_r1058.viewIndex)))("expanded", ctx_r1058.expanded)("editMode", col_r1101.editable && ctx_r1058.crudService.isInEditMode(ctx_r1058.index, col_r1101.index))("column", col_r1101)("formatter", col_r1101.formatter)("row", ctx_r1058)("lastPinned", col_r1101.columnLayoutChild ? null : col_r1101.isLastPinned)("rowData", ctx_r1058.rowData)("width", col_r1101.getCellWidth())("visibleColumnIndex", col_r1101.visibleIndex)("value", ctx_r1058.rowData[col_r1101.field])("cellTemplate", col_r1101.bodyTemplate)("lastSearchInfo", ctx_r1058.grid.lastSearchInfo)("active", ctx_r1058.isCellActive(col_r1101.visibleIndex))("cellSelectionMode", ctx_r1058.grid.cellSelection)("displayPinnedChip", ctx_r1058.shouldDisplayPinnedChip(col_r1101.visibleIndex));
} }
function IgxGridRowComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-cell", 21, 19);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1103 = ctx.$implicit;
    const ctx_r1060 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("-ms-grid-row-span", col_r1103.gridRowSpan)("-ms-grid-column-span", col_r1103.gridColumnSpan)("grid-row-end", col_r1103.rowEnd)("grid-column-end", col_r1103.colEnd)("-ms-grid-row", col_r1103.rowStart)("grid-row-start", col_r1103.rowStart)("-ms-grid-column", col_r1103.colStart)("grid-column-start", col_r1103.colStart)("min-height", ctx_r1060.grid.rowHeight || 32, "px");
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned", col_r1103.pinned)("igx-grid__td--number", col_r1103.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 38, ɵngcc0.ɵɵpureFunction5(50, _c171, col_r1103.cellClasses, ctx_r1060.rowData[col_r1103.field], ctx_r1060.rowData, col_r1103.field, ctx_r1060.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 44, ɵngcc0.ɵɵpureFunction5(56, _c171, col_r1103.cellStyles, ctx_r1060.rowData[col_r1103.field], ctx_r1060.rowData, col_r1103.field, ctx_r1060.viewIndex)))("editMode", col_r1103.editable && ctx_r1060.crudService.isInEditMode(ctx_r1060.index, col_r1103.index))("column", col_r1103)("lastPinned", col_r1103.columnLayoutChild ? null : col_r1103.isLastPinned)("firstPinned", col_r1103.columnLayoutChild ? null : col_r1103.isFirstPinned)("formatter", col_r1103.formatter)("row", ctx_r1060)("rowData", ctx_r1060.rowData)("visibleColumnIndex", col_r1103.visibleIndex)("value", ctx_r1060.rowData[col_r1103.field])("cellTemplate", col_r1103.bodyTemplate)("lastSearchInfo", ctx_r1060.grid.lastSearchInfo)("active", ctx_r1060.isCellActive(col_r1103.visibleIndex))("cellSelectionMode", ctx_r1060.grid.cellSelection)("displayPinnedChip", ctx_r1060.shouldDisplayPinnedChip(col_r1103.visibleIndex));
} }
function IgxGridRowComponent_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-expandable-grid-cell", 22, 19);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1105 = ctx.$implicit;
    const ctx_r1062 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("-ms-grid-row-span", col_r1105.gridRowSpan)("-ms-grid-column-span", col_r1105.gridColumnSpan)("grid-row-end", col_r1105.rowEnd)("grid-column-end", col_r1105.colEnd)("-ms-grid-row", col_r1105.rowStart)("grid-row-start", col_r1105.rowStart)("-ms-grid-column", col_r1105.colStart)("grid-column-start", col_r1105.colStart)("min-height", ctx_r1062.grid.rowHeight || 32, "px");
    ɵngcc0.ɵɵclassProp("igx-grid__td--pinned", col_r1105.pinned)("igx-grid__td--number", col_r1105.dataType === "number" && col_r1105.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 38, ɵngcc0.ɵɵpureFunction5(50, _c171, col_r1105.cellClasses, ctx_r1062.rowData[col_r1105.field], ctx_r1062.rowData, col_r1105.field, ctx_r1062.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 44, ɵngcc0.ɵɵpureFunction5(56, _c171, col_r1105.cellStyles, ctx_r1062.rowData[col_r1105.field], ctx_r1062.rowData, col_r1105.field, ctx_r1062.viewIndex)))("expanded", ctx_r1062.expanded)("editMode", col_r1105.editable && ctx_r1062.crudService.isInEditMode(ctx_r1062.index, col_r1105.index))("column", col_r1105)("lastPinned", col_r1105.columnLayoutChild ? null : col_r1105.isLastPinned)("formatter", col_r1105.formatter)("row", ctx_r1062)("rowData", ctx_r1062.rowData)("visibleColumnIndex", col_r1105.visibleIndex)("value", ctx_r1062.rowData[col_r1105.field])("cellTemplate", col_r1105.bodyTemplate)("lastSearchInfo", ctx_r1062.grid.lastSearchInfo)("active", ctx_r1062.isCellActive(col_r1105.visibleIndex))("cellSelectionMode", ctx_r1062.grid.cellSelection)("displayPinnedChip", ctx_r1062.shouldDisplayPinnedChip(col_r1105.visibleIndex));
} }
const _c201 = ["indicator"];
const _c202 = ["indentationDiv"];
function IgxGridExpandableCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1120 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1120.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxGridExpandableCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 7);
} if (rf & 2) {
    const ctx_r1108 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1108.displayPinnedChip);
} }
function IgxGridExpandableCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵpipe(1, "igxdecimal");
    ɵngcc0.ɵɵpipe(2, "igxdate");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "igxdecimal");
    ɵngcc0.ɵɵpipe(5, "igxdate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1110 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r1110.highlightClass)("activeCssClass", ctx_r1110.activeHighlightClass)("groupName", ctx_r1110.gridID)("value", ctx_r1110.formatter ? ctx_r1110.formatter(ctx_r1110.value) : ctx_r1110.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r1110.value, ctx_r1110.grid.locale) : ctx_r1110.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(2, 12, ctx_r1110.value, ctx_r1110.grid.locale) : ctx_r1110.value)("row", ctx_r1110.rowData)("column", ctx_r1110.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r1110.searchMetadata);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1110.formatter ? ctx_r1110.formatter(ctx_r1110.value) : ctx_r1110.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(4, 15, ctx_r1110.value, ctx_r1110.grid.locale) : ctx_r1110.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(5, 18, ctx_r1110.value, ctx_r1110.grid.locale) : ctx_r1110.value);
} }
function IgxGridExpandableCellComponent_ng_template_4_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r1127 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 10);
    ɵngcc0.ɵɵelementStart(2, "input", 11);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxGridExpandableCellComponent_ng_template_4_ng_container_0_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1127); const ctx_r1126 = ɵngcc0.ɵɵnextContext(2); return ctx_r1126.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1122 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1122.editValue)("igxFocus", true);
} }
function IgxGridExpandableCellComponent_ng_template_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r1129 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 10);
    ɵngcc0.ɵɵelementStart(2, "input", 12);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxGridExpandableCellComponent_ng_template_4_ng_container_1_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1129); const ctx_r1128 = ɵngcc0.ɵɵnextContext(2); return ctx_r1128.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1123 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1123.editValue)("igxFocus", true);
} }
function IgxGridExpandableCellComponent_ng_template_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r1131 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 13);
    ɵngcc0.ɵɵlistener("change", function IgxGridExpandableCellComponent_ng_template_4_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1131); const ctx_r1130 = ɵngcc0.ɵɵnextContext(2); return ctx_r1130.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1124 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r1124.editValue)("checked", ctx_r1124.editValue)("disableRipple", true);
} }
function IgxGridExpandableCellComponent_ng_template_4_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r1133 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 14);
    ɵngcc0.ɵɵlistener("valueChange", function IgxGridExpandableCellComponent_ng_template_4_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1133); const ctx_r1132 = ɵngcc0.ɵɵnextContext(2); return ctx_r1132.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1125 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r1125.grid.outletDirective)("locale", ctx_r1125.grid.locale)("value", ctx_r1125.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxGridExpandableCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_4_ng_container_0_Template, 3, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(1, IgxGridExpandableCellComponent_ng_template_4_ng_container_1_Template, 3, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_4_ng_container_2_Template, 2, 3, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(3, IgxGridExpandableCellComponent_ng_template_4_ng_container_3_Template, 2, 7, "ng-container", 3);
} if (rf & 2) {
    const ctx_r1112 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1112.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1112.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1112.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1112.column.dataType === "date");
} }
function IgxGridExpandableCellComponent_ng_container_6_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExpandableCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    const _r1137 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 15, 16);
    ɵngcc0.ɵɵlistener("click", function IgxGridExpandableCellComponent_ng_container_6_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1137); const ctx_r1136 = ɵngcc0.ɵɵnextContext(); return ctx_r1136.toggle($event); })("focus", function IgxGridExpandableCellComponent_ng_container_6_Template_div_focus_1_listener() { ɵngcc0.ɵɵrestoreView(_r1137); const ctx_r1138 = ɵngcc0.ɵɵnextContext(); return ctx_r1138.onIndicatorFocus(); });
    ɵngcc0.ɵɵtemplate(3, IgxGridExpandableCellComponent_ng_container_6_ng_container_3_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1113 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1113.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r1113));
} }
function IgxGridExpandableCellComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExpandableCellComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxGridExpandableCellComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 17);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxGridExpandableCellComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 17);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridComponent_igx_grid_toolbar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-toolbar", 61, 62);
} if (rf & 2) {
    const ctx_r1139 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r1139.outerWidth, "px")("flex-basis", ctx_r1139.outerWidth, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r1139.id)("displayDensity", ctx_r1139.displayDensity);
} }
function IgxTreeGridComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 63);
} if (rf & 2) {
    const ctx_r1141 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r1141.featureColumnsWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1141.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 64);
} if (rf & 2) {
    const ctx_r1142 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r1142.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1142.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_ng_container_7_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 65, 66);
    ɵngcc0.ɵɵelementStart(3, "div", 67);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridComponent_ng_container_7_ng_container_4_Template, 1, 0, "ng-container", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1143 = ɵngcc0.ɵɵnextContext();
    const _r1195 = ɵngcc0.ɵɵreference(88);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1143.dragIndicatorIconTemplate ? ctx_r1143.dragIndicatorIconTemplate : _r1195);
} }
function IgxTreeGridComponent_ng_container_8_3_ng_template_0_Template(rf, ctx) { }
function IgxTreeGridComponent_ng_container_8_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_container_8_3_ng_template_0_Template, 0, 0, "ng-template", null, 71, ɵngcc0.ɵɵtemplateRefExtractor);
} }
function IgxTreeGridComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    const _r1210 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 68, 69);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_container_8_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1210); const ctx_r1209 = ɵngcc0.ɵɵnextContext(); return ctx_r1209.onHeaderSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridComponent_ng_container_8_3_Template, 2, 0, undefined, 70);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1144 = ɵngcc0.ɵɵnextContext();
    const _r1197 = ɵngcc0.ɵɵreference(90);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c160, ctx_r1144.filteringService.isFilterRowVisible));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1144.headSelectorTemplate ? ctx_r1144.headSelectorTemplate : _r1197)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c13, ɵngcc0.ɵɵpureFunction2(5, _c161, ctx_r1144.selectionService.filteredSelectedRowIds.length, ctx_r1144.totalRowsCountAfterFilter)));
} }
function IgxTreeGridComponent_ng_container_9_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 73);
} if (rf & 2) {
    const col_r1212 = ctx.$implicit;
    const ctx_r1211 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r1211.getHeaderGroupWidth(col_r1212))("flex-basis", ctx_r1211.getHeaderGroupWidth(col_r1212));
    ɵngcc0.ɵɵproperty("column", col_r1212)("gridID", ctx_r1211.id);
} }
function IgxTreeGridComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_container_9_ng_template_1_Template, 1, 6, "ng-template", 72);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1145 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1145.pinnedColumns));
} }
function IgxTreeGridComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 73);
} if (rf & 2) {
    const col_r1213 = ctx.$implicit;
    const ctx_r1147 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r1147.getHeaderGroupWidth(col_r1213))("flex-basis", ctx_r1147.getHeaderGroupWidth(col_r1213));
    ɵngcc0.ɵɵproperty("column", col_r1213)("gridID", ctx_r1147.id);
} }
function IgxTreeGridComponent_ng_container_13_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 73);
} if (rf & 2) {
    const col_r1215 = ctx.$implicit;
    const ctx_r1214 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r1214.getHeaderGroupWidth(col_r1215))("flex-basis", ctx_r1214.getHeaderGroupWidth(col_r1215))("left", col_r1215.rightPinnedOffset);
    ɵngcc0.ɵɵproperty("column", col_r1215)("gridID", ctx_r1214.id);
} }
function IgxTreeGridComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_container_13_ng_template_1_Template, 1, 8, "ng-template", 72);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1148 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1148.pinnedColumns));
} }
function IgxTreeGridComponent_igx_grid_filtering_row_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-row", 74, 75);
} if (rf & 2) {
    const ctx_r1149 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("column", ctx_r1149.filteringService.filteredColumn);
} }
function IgxTreeGridComponent_igx_circular_bar_18_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 76);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxTreeGridComponent_span_19_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 77);
} if (rf & 2) {
    const ctx_r1152 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1152.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_span_23_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 63);
} if (rf & 2) {
    const ctx_r1154 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1154.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_span_24_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 64);
} if (rf & 2) {
    const ctx_r1155 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r1155.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1155.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 70);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const rowData_r1222 = ctx.$implicit;
    const rowIndex_r1223 = ctx.index;
    const ctx_r1221 = ɵngcc0.ɵɵnextContext(4);
    const _r1164 = ɵngcc0.ɵɵreference(43);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1164)("ngTemplateOutletContext", ctx_r1221.getContext(rowData_r1222, rowIndex_r1223, true));
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 79, 80);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_ng_container_2_Template, 2, 2, "ng-container", 81);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const pinnedData_r1218 = ɵngcc0.ɵɵnextContext().ngIf;
    const ctx_r1219 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r1219.calcWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c162, !ctx_r1219.isRowPinningToTop, ctx_r1219.isRowPinningToTop));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", pinnedData_r1218);
} }
function IgxTreeGridComponent_ng_template_25_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_template_25_ng_container_0_div_1_Template, 3, 7, "div", 78);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const pinnedData_r1218 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", pinnedData_r1218.length > 0);
} }
function IgxTreeGridComponent_ng_template_25_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_25_ng_container_0_Template, 2, 1, "ng-container", 7);
    ɵngcc0.ɵɵpipe(1, "treeGridSorting");
    ɵngcc0.ɵɵpipe(2, "treeGridFiltering");
    ɵngcc0.ɵɵpipe(3, "gridRowPinning");
    ɵngcc0.ɵɵpipe(4, "treeGridNormalizeRecord");
    ɵngcc0.ɵɵpipe(5, "visibleColumns");
    ɵngcc0.ɵɵpipe(6, "treeGridTransaction");
} if (rf & 2) {
    const ctx_r1157 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBindV(1, 1, ɵngcc0.ɵɵpureFunction5(40, _c164, ɵngcc0.ɵɵpipeBindV(2, 8, ɵngcc0.ɵɵpureFunction7(32, _c163, ɵngcc0.ɵɵpipeBind4(3, 17, ɵngcc0.ɵɵpipeBind2(4, 22, ɵngcc0.ɵɵpipeBind2(5, 25, ɵngcc0.ɵɵpipeBind3(6, 28, ctx_r1157.data, ctx_r1157.id, ctx_r1157.pipeTrigger), ctx_r1157.hasVisibleColumns), ctx_r1157.pipeTrigger), ctx_r1157.id, true, ctx_r1157.pipeTrigger), ctx_r1157.filteringExpressionsTree, ctx_r1157.filterStrategy, ctx_r1157.advancedFilteringExpressionsTree, ctx_r1157.id, ctx_r1157.pipeTrigger, ctx_r1157.filteringPipeTrigger)), ctx_r1157.sortingExpressions, ctx_r1157.sortStrategy, ctx_r1157.id, ctx_r1157.pipeTrigger)));
} }
function IgxTreeGridComponent_ng_container_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_28_ng_template_0_Template(rf, ctx) { }
function IgxTreeGridComponent_ng_template_28_Template(rf, ctx) { if (rf & 1) {
    const _r1230 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_ng_template_28_ng_template_0_Template, 0, 0, "ng-template", 82);
    ɵngcc0.ɵɵlistener("onCachedViewLoaded", function IgxTreeGridComponent_ng_template_28_Template_ng_template_onCachedViewLoaded_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1230); const ctx_r1229 = ɵngcc0.ɵɵnextContext(); return ctx_r1229.cachedViewLoaded($event); });
} if (rf & 2) {
    const rowData_r1226 = ctx.$implicit;
    const rowIndex_r1227 = ctx.index;
    const ctx_r1160 = ɵngcc0.ɵɵnextContext();
    const _r1166 = ɵngcc0.ɵɵreference(45);
    const _r1162 = ɵngcc0.ɵɵreference(41);
    ɵngcc0.ɵɵproperty("igxTemplateOutlet", ctx_r1160.isSummaryRow(rowData_r1226) ? _r1166 : _r1162)("igxTemplateOutletContext", ctx_r1160.getContext(rowData_r1226, rowIndex_r1227, false));
} }
function IgxTreeGridComponent_ng_container_39_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_40_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tree-grid-row", 83, 84);
} if (rf & 2) {
    const rowIndex_r1231 = ctx.index;
    const disabledRow_r1232 = ctx.disabled;
    const rowData_r1233 = ctx.$implicit;
    const ctx_r1163 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r1163.id)("index", rowIndex_r1231)("treeRow", rowData_r1233)("disabled", disabledRow_r1232);
} }
function IgxTreeGridComponent_ng_template_42_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tree-grid-row", 85, 86);
} if (rf & 2) {
    const rowIndex_r1235 = ctx.index;
    const rowData_r1236 = ctx.$implicit;
    const ctx_r1165 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r1165.id)("index", rowIndex_r1235)("treeRow", rowData_r1236);
} }
function IgxTreeGridComponent_ng_template_44_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 87, 88);
} if (rf & 2) {
    const rowIndex_r1239 = ctx.index;
    const rowData_r1240 = ctx.$implicit;
    const ctx_r1167 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r1167.id)("summaries", rowData_r1240.summaries)("firstCellIndentation", rowData_r1240.cellIndentation)("index", rowIndex_r1239);
} }
function IgxTreeGridComponent_ng_container_46_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_span_50_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 77);
} if (rf & 2) {
    const ctx_r1170 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1170.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxTreeGridComponent_ng_template_54_Template(rf, ctx) { }
function IgxTreeGridComponent_igx_grid_summary_row_59_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 89, 88);
    ɵngcc0.ɵɵpipe(2, "igxGridSummaryDataPipe");
} if (rf & 2) {
    const ctx_r1174 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r1174.calcWidth, "px")("height", ctx_r1174.summariesHeight, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r1174.id)("summaries", ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r1174.id, ctx_r1174.summaryService.retriggerRootPipe))("index", ctx_r1174.dataView.length);
} }
function IgxTreeGridComponent_ng_template_65_Template(rf, ctx) { }
function IgxTreeGridComponent_ng_container_71_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_container_71_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridComponent_ng_container_71_ng_container_1_Template, 1, 0, "ng-container", 70);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1179 = ɵngcc0.ɵɵnextContext();
    const _r1180 = ɵngcc0.ɵɵreference(73);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1179.paginationTemplate ? ctx_r1179.paginationTemplate : _r1180)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r1179));
} }
function IgxTreeGridComponent_ng_template_72_Template(rf, ctx) { if (rf & 1) {
    const _r1245 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-paginator", 90);
    ɵngcc0.ɵɵlistener("pageChange", function IgxTreeGridComponent_ng_template_72_Template_igx_paginator_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1245); const ctx_r1244 = ɵngcc0.ɵɵnextContext(); return ctx_r1244.page = $event; })("perPageChange", function IgxTreeGridComponent_ng_template_72_Template_igx_paginator_perPageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1245); const ctx_r1246 = ɵngcc0.ɵɵnextContext(); return ctx_r1246.perPage = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1181 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r1181.displayDensity)("page", ctx_r1181.page)("totalRecords", ctx_r1181.processedExpandedFlatData.length)("perPage", ctx_r1181.perPage);
} }
function IgxTreeGridComponent_ng_template_74_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 91);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1183 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1183.emptyFilteredGridMessage);
} }
function IgxTreeGridComponent_ng_template_76_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 91);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1185 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1185.emptyGridMessage);
} }
function IgxTreeGridComponent_ng_template_78_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 92);
    ɵngcc0.ɵɵelement(1, "igx-circular-bar", 76);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxTreeGridComponent_div_80_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_div_80_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 93);
    ɵngcc0.ɵɵelementStart(1, "div", 94);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridComponent_div_80_ng_container_2_Template, 1, 0, "ng-container", 70);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1188 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r1188.bannerClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1188.rowEditContainer)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c167, ctx_r1188.rowChangesCount, ctx_r1188.endEdit.bind(ctx_r1188)));
} }
function IgxTreeGridComponent_ng_template_81_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r1190 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" You have ", ctx_r1190.rowChangesCount, " changes in this row\n");
} }
function IgxTreeGridComponent_ng_template_83_Template(rf, ctx) { if (rf & 1) {
    const _r1249 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 95);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_template_83_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1249); const ctx_r1248 = ɵngcc0.ɵɵnextContext(); return ctx_r1248.endRowEdit(false, $event); });
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 95);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridComponent_ng_template_83_Template_button_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1249); const ctx_r1250 = ɵngcc0.ɵɵnextContext(); return ctx_r1250.endRowEdit(true, $event); });
    ɵngcc0.ɵɵtext(3, "Done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridComponent_ng_template_85_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_85_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridComponent_ng_template_85_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 96);
    ɵngcc0.ɵɵelementStart(1, "span", 97);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridComponent_ng_template_85_ng_container_2_Template, 1, 0, "ng-container", 70);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 98);
    ɵngcc0.ɵɵelementStart(4, "div", 99);
    ɵngcc0.ɵɵtemplate(5, IgxTreeGridComponent_ng_template_85_ng_container_5_Template, 1, 0, "ng-container", 70);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1194 = ɵngcc0.ɵɵnextContext();
    const _r1189 = ɵngcc0.ɵɵreference(82);
    const _r1191 = ɵngcc0.ɵɵreference(84);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1194.rowEditText ? ctx_r1194.rowEditText : _r1189)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c13, ctx_r1194.rowChangesCount));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1194.rowEditActions ? ctx_r1194.rowEditActions : _r1191)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c13, ctx_r1194.endEdit.bind(ctx_r1194)));
} }
function IgxTreeGridComponent_ng_template_87_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 100);
    ɵngcc0.ɵɵtext(1, "drag_indicator");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridComponent_ng_template_89_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 101);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 102, 103);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r1253 = ctx.$implicit;
    const ctx_r1198 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", 0 - 1)("checked", context_r1253.selectedCount > 0 && context_r1253.totalCount === context_r1253.selectedCount)("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c168, ctx_r1198.isMultiRowSelectionEnabled ? "visible" : "hidden"))("readonly", true)("indeterminate", context_r1253.selectedCount > 0 && context_r1253.selectedCount !== context_r1253.totalCount)("aria-label", ctx_r1198.headSelectorBaseAriaLabel);
} }
function IgxTreeGridComponent_igx_grid_column_resizer_91_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-column-resizer");
} }
const _c203 = function (a0, a1, a2, a3, a4, a5) { return [a0, a1, a2, a3, a4, a5]; };
const _c204 = ["treeCell"];
function IgxTreeGridRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r1267 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 5);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridRowComponent_ng_container_0_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1267); return $event.stopPropagation(); });
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_container_0_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1255 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r1255.resolveDragIndicatorClasses);
    ɵngcc0.ɵɵproperty("igxRowDrag", ctx_r1255)("ghostTemplate", ctx_r1255.grid.getDragGhostCustomTemplate());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1255.grid.dragIndicatorIconTemplate ? ctx_r1255.grid.dragIndicatorIconTemplate : ctx_r1255.grid.dragIndicatorIconBase);
} }
function IgxTreeGridRowComponent_ng_container_1_2_ng_template_0_Template(rf, ctx) { }
function IgxTreeGridRowComponent_ng_container_1_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_container_1_2_ng_template_0_Template, 0, 0, "ng-template");
} }
function IgxTreeGridRowComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r1271 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 7);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridRowComponent_ng_container_1_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1271); const ctx_r1270 = ɵngcc0.ɵɵnextContext(); return ctx_r1270.onRowSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_container_1_2_Template, 1, 0, undefined, 8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1256 = ɵngcc0.ɵɵnextContext();
    const _r1261 = ɵngcc0.ɵɵreference(8);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1256.grid.rowSelectorTemplate ? ctx_r1256.grid.rowSelectorTemplate : _r1261)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c13, ɵngcc0.ɵɵpureFunction3(2, _c199, ctx_r1256.viewIndex, ctx_r1256.rowID, ctx_r1256.selected)));
} }
function IgxTreeGridRowComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1257 = ɵngcc0.ɵɵnextContext();
    const _r1263 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1263)("ngTemplateOutletContext", ctx_r1257);
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-cell", 11, 12);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1273 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1276 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1276.grid.rowHeight || 32, "px")("min-width", col_r1273.width)("max-width", col_r1273.width)("flex-basis", col_r1273.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--number", col_r1273.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 25, ɵngcc0.ɵɵpureFunction5(37, _c171, col_r1273.cellClasses, ctx_r1276.rowData[col_r1273.field], ctx_r1276.rowData, col_r1273.field, ctx_r1276.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 31, ɵngcc0.ɵɵpureFunction5(43, _c171, col_r1273.cellStyles, ctx_r1276.rowData[col_r1273.field], ctx_r1276.rowData, col_r1273.field, ctx_r1276.viewIndex)))("editMode", col_r1273.editable && ctx_r1276.crudService.isInEditMode(ctx_r1276.index, col_r1273.index))("column", col_r1273)("formatter", col_r1273.formatter)("row", ctx_r1276)("rowData", ctx_r1276.rowData)("width", col_r1273.getCellWidth())("visibleColumnIndex", col_r1273.visibleIndex)("value", ctx_r1276.rowData[col_r1273.field])("cellTemplate", col_r1273.bodyTemplate)("lastSearchInfo", ctx_r1276.grid.lastSearchInfo)("active", ctx_r1276.isCellActive(col_r1273.visibleIndex))("cellSelectionMode", ctx_r1276.grid.cellSelection)("displayPinnedChip", ctx_r1276.shouldDisplayPinnedChip(col_r1273.visibleIndex));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tree-grid-cell", 13, 12);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1273 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1278 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1278.grid.rowHeight || 32, "px")("min-width", col_r1273.width)("max-width", col_r1273.width)("flex-basis", col_r1273.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--number", col_r1273.dataType === "number" && col_r1273.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 29, ɵngcc0.ɵɵpureFunction5(41, _c171, col_r1273.cellClasses, ctx_r1278.rowData[col_r1273.field], ctx_r1278.rowData, col_r1273.field, ctx_r1278.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 35, ɵngcc0.ɵɵpureFunction5(47, _c171, col_r1273.cellStyles, ctx_r1278.rowData[col_r1273.field], ctx_r1278.rowData, col_r1273.field, ctx_r1278.viewIndex)))("level", ctx_r1278.treeRow.level)("expanded", ctx_r1278.treeRow.expanded)("showIndicator", ctx_r1278.showIndicator)("editMode", col_r1273.editable && ctx_r1278.crudService.isInEditMode(ctx_r1278.index, col_r1273.index))("column", col_r1273)("formatter", col_r1273.formatter)("row", ctx_r1278)("rowData", ctx_r1278.rowData)("width", col_r1273.getCellWidth())("visibleColumnIndex", col_r1273.visibleIndex)("value", ctx_r1278.rowData[col_r1273.field])("isLoading", ctx_r1278.isLoading)("cellTemplate", col_r1273.bodyTemplate)("lastSearchInfo", ctx_r1278.grid.lastSearchInfo)("active", ctx_r1278.isCellActive(col_r1273.visibleIndex))("cellSelectionMode", ctx_r1278.grid.cellSelection)("displayPinnedChip", ctx_r1278.shouldDisplayPinnedChip(col_r1273.visibleIndex));
} }
function IgxTreeGridRowComponent_ng_template_3_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_3_ng_template_0_Template, 4, 49, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_3_ng_template_2_Template, 4, 53, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridRowComponent_ng_template_3_ng_container_4_Template, 1, 0, "ng-container", 6);
} if (rf & 2) {
    const col_r1273 = ctx.$implicit;
    const _r1275 = ɵngcc0.ɵɵreference(1);
    const _r1277 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1273.visibleIndex === 0 ? _r1277 : _r1275);
} }
function IgxTreeGridRowComponent_ng_container_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_container_6_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1260 = ɵngcc0.ɵɵnextContext();
    const _r1263 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1263)("ngTemplateOutletContext", ctx_r1260);
} }
function IgxTreeGridRowComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 14);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1262 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", 0 - 1)("readonly", true)("checked", ctx_r1262.selected)("disabled", ctx_r1262.deleted)("disableTransitions", ctx_r1262.grid.disableTransitions)("aria-label", ctx_r1262.rowCheckboxAriaLabel);
} }
function IgxTreeGridRowComponent_ng_template_9_ng_template_0_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-cell", 17, 12);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1287 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1289 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1289.grid.rowHeight || 32, "px")("min-width", col_r1287.width)("max-width", col_r1287.width)("flex-basis", col_r1287.width)("left", col_r1287.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--number", col_r1287.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 29, ɵngcc0.ɵɵpureFunction5(41, _c171, col_r1287.cellClasses, ctx_r1289.rowData[col_r1287.field], ctx_r1289.rowData, col_r1287.field, ctx_r1289.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 35, ɵngcc0.ɵɵpureFunction5(47, _c171, col_r1287.cellStyles, ctx_r1289.rowData[col_r1287.field], ctx_r1289.rowData, col_r1287.field, ctx_r1289.viewIndex)))("editMode", col_r1287.editable && ctx_r1289.crudService.isInEditMode(ctx_r1289.index, col_r1287.index))("column", col_r1287)("formatter", col_r1287.formatter)("row", ctx_r1289)("firstPinned", col_r1287.isFirstPinned)("lastPinned", col_r1287.isLastPinned)("rowData", ctx_r1289.rowData)("width", col_r1287.getCellWidth())("visibleColumnIndex", col_r1287.visibleIndex)("value", ctx_r1289.rowData[col_r1287.field])("cellTemplate", col_r1287.bodyTemplate)("lastSearchInfo", ctx_r1289.grid.lastSearchInfo)("active", ctx_r1289.isCellActive(col_r1287.visibleIndex))("cellSelectionMode", ctx_r1289.grid.cellSelection)("displayPinnedChip", ctx_r1289.shouldDisplayPinnedChip(col_r1287.visibleIndex));
} }
function IgxTreeGridRowComponent_ng_template_9_ng_template_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tree-grid-cell", 18, 12);
    ɵngcc0.ɵɵpipe(2, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(3, "igxCellStyles");
} if (rf & 2) {
    const col_r1287 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1291 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1291.grid.rowHeight || 32, "px")("min-width", col_r1287.width)("max-width", col_r1287.width)("flex-basis", col_r1287.width)("left", col_r1287.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--number", col_r1287.dataType === "number" && col_r1287.visibleIndex !== 0);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(2, 32, ɵngcc0.ɵɵpureFunction5(44, _c171, col_r1287.cellClasses, ctx_r1291.rowData[col_r1287.field], ctx_r1291.rowData, col_r1287.field, ctx_r1291.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(3, 38, ɵngcc0.ɵɵpureFunction5(50, _c171, col_r1287.cellStyles, ctx_r1291.rowData[col_r1287.field], ctx_r1291.rowData, col_r1287.field, ctx_r1291.viewIndex)))("level", ctx_r1291.treeRow.level)("expanded", ctx_r1291.treeRow.expanded)("showIndicator", ctx_r1291.showIndicator)("editMode", col_r1287.editable && ctx_r1291.crudService.isInEditMode(ctx_r1291.index, col_r1287.index))("column", col_r1287)("formatter", col_r1287.formatter)("row", ctx_r1291)("lastPinned", col_r1287.isLastPinned)("rowData", ctx_r1291.rowData)("width", col_r1287.getCellWidth())("visibleColumnIndex", col_r1287.visibleIndex)("value", ctx_r1291.rowData[col_r1287.field])("isLoading", ctx_r1291.isLoading)("cellTemplate", col_r1287.bodyTemplate)("lastSearchInfo", ctx_r1291.grid.lastSearchInfo)("active", ctx_r1291.isCellActive(col_r1287.visibleIndex))("cellSelectionMode", ctx_r1291.grid.cellSelection)("displayPinnedChip", ctx_r1291.shouldDisplayPinnedChip(col_r1287.visibleIndex));
} }
function IgxTreeGridRowComponent_ng_template_9_ng_template_0_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridRowComponent_ng_template_9_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_9_ng_template_0_ng_template_0_Template, 4, 53, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_template_9_ng_template_0_ng_template_2_Template, 4, 56, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridRowComponent_ng_template_9_ng_template_0_ng_container_4_Template, 1, 0, "ng-container", 6);
} if (rf & 2) {
    const col_r1287 = ctx.$implicit;
    const _r1288 = ɵngcc0.ɵɵreference(1);
    const _r1290 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", col_r1287.visibleIndex === 0 ? _r1290 : _r1288);
} }
function IgxTreeGridRowComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_template_9_ng_template_0_Template, 5, 1, "ng-template", 16);
    ɵngcc0.ɵɵpipe(1, "igxNotGrouped");
} if (rf & 2) {
    const ctx_r1264 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r1264.pinnedColumns));
} }
function IgxTreeGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1309 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1309.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxTreeGridCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 7);
} if (rf & 2) {
    const ctx_r1298 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1298.displayPinnedChip);
} }
function IgxTreeGridCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵpipe(1, "igxdecimal");
    ɵngcc0.ɵɵpipe(2, "igxdate");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "igxdecimal");
    ɵngcc0.ɵɵpipe(5, "igxdate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1300 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r1300.highlightClass)("activeCssClass", ctx_r1300.activeHighlightClass)("groupName", ctx_r1300.gridID)("value", ctx_r1300.formatter ? ctx_r1300.formatter(ctx_r1300.value) : ctx_r1300.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r1300.value, ctx_r1300.grid.locale) : ctx_r1300.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(2, 12, ctx_r1300.value, ctx_r1300.grid.locale) : ctx_r1300.value)("row", ctx_r1300.rowData)("column", ctx_r1300.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r1300.searchMetadata);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1300.formatter ? ctx_r1300.formatter(ctx_r1300.value) : ctx_r1300.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(4, 15, ctx_r1300.value, ctx_r1300.grid.locale) : ctx_r1300.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(5, 18, ctx_r1300.value, ctx_r1300.grid.locale) : ctx_r1300.value);
} }
function IgxTreeGridCellComponent_ng_template_4_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r1316 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 10);
    ɵngcc0.ɵɵelementStart(2, "input", 11);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxTreeGridCellComponent_ng_template_4_ng_container_0_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1316); const ctx_r1315 = ɵngcc0.ɵɵnextContext(2); return ctx_r1315.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1311 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1311.editValue)("igxFocus", ctx_r1311.focused);
} }
function IgxTreeGridCellComponent_ng_template_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r1318 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 10);
    ɵngcc0.ɵɵelementStart(2, "input", 12);
    ɵngcc0.ɵɵlistener("ngModelChange", function IgxTreeGridCellComponent_ng_template_4_ng_container_1_Template_input_ngModelChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1318); const ctx_r1317 = ɵngcc0.ɵɵnextContext(2); return ctx_r1317.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1312 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngModel", ctx_r1312.editValue)("igxFocus", ctx_r1312.focused);
} }
function IgxTreeGridCellComponent_ng_template_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r1320 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 13);
    ɵngcc0.ɵɵlistener("change", function IgxTreeGridCellComponent_ng_template_4_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1320); const ctx_r1319 = ɵngcc0.ɵɵnextContext(2); return ctx_r1319.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1313 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r1313.editValue)("checked", ctx_r1313.editValue)("disableRipple", true);
} }
function IgxTreeGridCellComponent_ng_template_4_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r1322 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 14);
    ɵngcc0.ɵɵlistener("valueChange", function IgxTreeGridCellComponent_ng_template_4_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1322); const ctx_r1321 = ɵngcc0.ɵɵnextContext(2); return ctx_r1321.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1314 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r1314.grid.outletDirective)("locale", ctx_r1314.grid.locale)("value", ctx_r1314.editValue)("igxFocus", ctx_r1314.focused)("labelVisibility", false);
} }
function IgxTreeGridCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_4_ng_container_0_Template, 3, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_template_4_ng_container_1_Template, 3, 2, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_4_ng_container_2_Template, 2, 3, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_template_4_ng_container_3_Template, 2, 7, "ng-container", 3);
} if (rf & 2) {
    const ctx_r1302 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1302.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1302.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1302.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1302.column.dataType === "date");
} }
function IgxTreeGridCellComponent_ng_container_6_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelement(1, "div", null, 18);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1323 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMapInterpolate1("igx-grid__tree-cell--padding-level-", ctx_r1323.level, "");
} }
function IgxTreeGridCellComponent_ng_container_6_div_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_container_6_div_2_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_container_6_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r1333 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 19, 20);
    ɵngcc0.ɵɵlistener("click", function IgxTreeGridCellComponent_ng_container_6_div_2_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1333); const ctx_r1332 = ɵngcc0.ɵɵnextContext(2); return ctx_r1332.toggle($event); })("focus", function IgxTreeGridCellComponent_ng_container_6_div_2_Template_div_focus_0_listener() { ɵngcc0.ɵɵrestoreView(_r1333); const ctx_r1334 = ɵngcc0.ɵɵnextContext(2); return ctx_r1334.onIndicatorFocus(); });
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_container_6_div_2_ng_container_2_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_container_6_div_2_ng_container_3_Template, 1, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1324 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngStyle", ɵngcc0.ɵɵpureFunction1(5, _c168, ctx_r1324.showIndicator ? "visible" : "hidden"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1324.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(7, _c13, ctx_r1324));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1324.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx_r1324.context);
} }
function IgxTreeGridCellComponent_ng_container_6_div_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_container_6_div_3_Template(rf, ctx) { if (rf & 1) {
    const _r1337 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 21);
    ɵngcc0.ɵɵlistener("dblclick", function IgxTreeGridCellComponent_ng_container_6_div_3_Template_div_dblclick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1337); const ctx_r1336 = ɵngcc0.ɵɵnextContext(2); return ctx_r1336.onLoadingDblClick($event); });
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_container_6_div_3_ng_container_1_Template, 1, 0, "ng-container", 22);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r1326 = ɵngcc0.ɵɵreference(5);
    const ctx_r1325 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1325.grid.rowLoadingIndicatorTemplate ? ctx_r1325.grid.rowLoadingIndicatorTemplate : _r1326);
} }
function IgxTreeGridCellComponent_ng_container_6_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 23);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxTreeGridCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTreeGridCellComponent_ng_container_6_ng_container_1_Template, 3, 3, "ng-container", 3);
    ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_container_6_div_2_Template, 4, 9, "div", 15);
    ɵngcc0.ɵɵtemplate(3, IgxTreeGridCellComponent_ng_container_6_div_3_Template, 2, 1, "div", 16);
    ɵngcc0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_container_6_ng_template_4_Template, 1, 1, "ng-template", null, 17, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1303 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1303.level > 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1303.isLoading);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1303.isLoading);
} }
function IgxTreeGridCellComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTreeGridCellComponent_ng_template_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 24);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTreeGridCellComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 24);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} }
const _c205 = ["hgrid"];
const _c206 = function (a0) { return { "igx-grid__hierarchical-indent--scroll": a0 }; };
const _c207 = ["hierarchical_record_template"];
const _c208 = ["child_record_template"];
const _c209 = ["headerHierarchyExpander"];
function IgxHierarchicalGridComponent_igx_grid_toolbar_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-toolbar", 65, 66);
} if (rf & 2) {
    const ctx_r1339 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("max-width", ctx_r1339.outerWidth, "px")("flex-basis", ctx_r1339.outerWidth, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r1339.id)("displayDensity", ctx_r1339.displayDensity);
} }
function IgxHierarchicalGridComponent_span_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 67);
} if (rf & 2) {
    const ctx_r1341 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1341.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 68);
} if (rf & 2) {
    const ctx_r1342 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r1342.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1342.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_10_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 69, 70);
    ɵngcc0.ɵɵelementStart(3, "div", 71);
    ɵngcc0.ɵɵtemplate(4, IgxHierarchicalGridComponent_ng_container_10_ng_container_4_Template, 1, 0, "ng-container", 22);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1345 = ɵngcc0.ɵɵnextContext();
    const _r1403 = ɵngcc0.ɵɵreference(94);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c159, !ctx_r1345.isRowSelectable));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1345.dragIndicatorIconTemplate ? ctx_r1345.dragIndicatorIconTemplate : _r1403);
} }
function IgxHierarchicalGridComponent_ng_container_11_3_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_ng_container_11_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_container_11_3_ng_template_0_Template, 0, 0, "ng-template", null, 74, ɵngcc0.ɵɵtemplateRefExtractor);
} }
const _c210 = function (a0, a1, a2, a3) { return { selectedCount: a0, totalCount: a1, selectAll: a2, deselectAll: a3 }; };
function IgxHierarchicalGridComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    const _r1418 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 72, 73);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_container_11_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1418); const ctx_r1417 = ɵngcc0.ɵɵnextContext(); return ctx_r1417.onHeaderSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridComponent_ng_container_11_3_Template, 2, 0, undefined, 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1346 = ɵngcc0.ɵɵnextContext();
    const _r1405 = ɵngcc0.ɵɵreference(96);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c160, ctx_r1346.filteringService.isFilterRowVisible));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1346.headSelectorTemplate ? ctx_r1346.headSelectorTemplate : _r1405)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(10, _c13, ɵngcc0.ɵɵpureFunction4(5, _c210, ctx_r1346.selectionService.filteredSelectedRowIds.length, ctx_r1346.totalRowsCountAfterFilter, ctx_r1346.selectAllRows.bind(ctx_r1346), ctx_r1346.deselectAllRows.bind(ctx_r1346))));
} }
function IgxHierarchicalGridComponent_ng_container_12_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 76);
} if (rf & 2) {
    const col_r1420 = ctx.$implicit;
    const ctx_r1419 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r1419.getHeaderGroupWidth(col_r1420))("flex-basis", ctx_r1419.getHeaderGroupWidth(col_r1420));
    ɵngcc0.ɵɵproperty("column", col_r1420)("gridID", ctx_r1419.id);
} }
function IgxHierarchicalGridComponent_ng_container_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_container_12_ng_template_1_Template, 1, 6, "ng-template", 75);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1347 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1347.pinnedColumns));
} }
function IgxHierarchicalGridComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 76);
} if (rf & 2) {
    const col_r1421 = ctx.$implicit;
    const ctx_r1349 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r1349.getHeaderGroupWidth(col_r1421))("flex-basis", ctx_r1349.getHeaderGroupWidth(col_r1421));
    ɵngcc0.ɵɵproperty("column", col_r1421)("gridID", ctx_r1349.id);
} }
function IgxHierarchicalGridComponent_ng_container_16_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-header-group", 76);
} if (rf & 2) {
    const col_r1423 = ctx.$implicit;
    const ctx_r1422 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-width", ctx_r1422.getHeaderGroupWidth(col_r1423))("flex-basis", ctx_r1422.getHeaderGroupWidth(col_r1423))("left", col_r1423.rightPinnedOffset);
    ɵngcc0.ɵɵproperty("column", col_r1423)("gridID", ctx_r1422.id);
} }
function IgxHierarchicalGridComponent_ng_container_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_container_16_ng_template_1_Template, 1, 8, "ng-template", 75);
    ɵngcc0.ɵɵpipe(2, "igxTopLevel");
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1350 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r1350.pinnedColumns));
} }
function IgxHierarchicalGridComponent_igx_grid_filtering_row_17_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-filtering-row", 77, 78);
} if (rf & 2) {
    const ctx_r1351 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r1351.calcWidth, "px");
    ɵngcc0.ɵɵproperty("column", ctx_r1351.filteringService.filteredColumn);
} }
function IgxHierarchicalGridComponent_igx_circular_bar_20_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-circular-bar", 79);
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxHierarchicalGridComponent_span_21_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 80);
} if (rf & 2) {
    const ctx_r1354 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1354.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_span_26_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 67);
} if (rf & 2) {
    const ctx_r1356 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1356.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_span_27_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 68);
} if (rf & 2) {
    const ctx_r1357 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("left", ctx_r1357.pinnedWidth, "px");
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1357.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const rowData_r1430 = ctx.$implicit;
    const rowIndex_r1431 = ctx.index;
    const ctx_r1429 = ɵngcc0.ɵɵnextContext(4);
    const _r1365 = ɵngcc0.ɵɵreference(43);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1365)("ngTemplateOutletContext", ctx_r1429.getContext(rowData_r1430, rowIndex_r1431, true));
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 82, 83);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_ng_container_2_Template, 2, 2, "ng-container", 84);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const pinnedData_r1426 = ɵngcc0.ɵɵnextContext().ngIf;
    const ctx_r1427 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("width", ctx_r1427.calcWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(4, _c162, !ctx_r1427.isRowPinningToTop, ctx_r1427.isRowPinningToTop));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", pinnedData_r1426);
} }
function IgxHierarchicalGridComponent_ng_template_28_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_div_1_Template, 3, 7, "div", 81);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const pinnedData_r1426 = ctx.ngIf;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", pinnedData_r1426.length > 0);
} }
function IgxHierarchicalGridComponent_ng_template_28_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_28_ng_container_0_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵpipe(1, "gridSort");
    ɵngcc0.ɵɵpipe(2, "gridFiltering");
    ɵngcc0.ɵɵpipe(3, "gridRowPinning");
    ɵngcc0.ɵɵpipe(4, "visibleColumns");
    ɵngcc0.ɵɵpipe(5, "gridTransaction");
} if (rf & 2) {
    const ctx_r1359 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBindV(1, 1, ɵngcc0.ɵɵpureFunction5(37, _c164, ɵngcc0.ɵɵpipeBindV(2, 8, ɵngcc0.ɵɵpureFunction7(29, _c163, ɵngcc0.ɵɵpipeBind4(3, 17, ɵngcc0.ɵɵpipeBind2(4, 22, ɵngcc0.ɵɵpipeBind3(5, 25, ctx_r1359.data, ctx_r1359.id, ctx_r1359.pipeTrigger), ctx_r1359.hasVisibleColumns), ctx_r1359.id, true, ctx_r1359.pipeTrigger), ctx_r1359.filteringExpressionsTree, ctx_r1359.filterStrategy, ctx_r1359.advancedFilteringExpressionsTree, ctx_r1359.id, ctx_r1359.pipeTrigger, ctx_r1359.filteringPipeTrigger)), ctx_r1359.sortingExpressions, ctx_r1359.sortStrategy, ctx_r1359.id, ctx_r1359.pipeTrigger)));
} }
function IgxHierarchicalGridComponent_ng_container_30_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_31_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_ng_template_31_Template(rf, ctx) { if (rf & 1) {
    const _r1438 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_ng_template_31_ng_template_0_Template, 0, 0, "ng-template", 85);
    ɵngcc0.ɵɵlistener("onViewCreated", function IgxHierarchicalGridComponent_ng_template_31_Template_ng_template_onViewCreated_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1438); const ctx_r1437 = ɵngcc0.ɵɵnextContext(); return ctx_r1437.viewCreatedHandler($event); })("onViewMoved", function IgxHierarchicalGridComponent_ng_template_31_Template_ng_template_onViewMoved_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1438); const ctx_r1439 = ɵngcc0.ɵɵnextContext(); return ctx_r1439.viewMovedHandler($event); })("onCachedViewLoaded", function IgxHierarchicalGridComponent_ng_template_31_Template_ng_template_onCachedViewLoaded_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1438); const ctx_r1440 = ɵngcc0.ɵɵnextContext(); return ctx_r1440.cachedViewLoaded($event); });
} if (rf & 2) {
    const rowData_r1434 = ctx.$implicit;
    const rowIndex_r1435 = ctx.index;
    const ctx_r1362 = ɵngcc0.ɵɵnextContext();
    const _r1363 = ɵngcc0.ɵɵreference(41);
    const _r1367 = ɵngcc0.ɵɵreference(45);
    ɵngcc0.ɵɵproperty("igxTemplateOutlet", ctx_r1362.isHierarchicalRecord(rowData_r1434) ? _r1363 : ctx_r1362.isChildGridRecord(rowData_r1434) && ctx_r1362.isExpanded(rowData_r1434) ? _r1367 : _r1363)("igxTemplateOutletContext", ctx_r1362.getContext(rowData_r1434, rowIndex_r1435, false));
} }
function IgxHierarchicalGridComponent_ng_template_40_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-hierarchical-grid-row", 86, 87);
} if (rf & 2) {
    const rowIndex_r1441 = ctx.index;
    const disabledRow_r1442 = ctx.disabled;
    const rowData_r1443 = ctx.$implicit;
    const ctx_r1364 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r1364.id)("index", rowIndex_r1441)("disabled", disabledRow_r1442)("rowData", rowData_r1443);
} }
function IgxHierarchicalGridComponent_ng_template_42_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-hierarchical-grid-row", 88, 89);
} if (rf & 2) {
    const rowIndex_r1445 = ctx.index;
    const rowData_r1446 = ctx.$implicit;
    const ctx_r1366 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("gridID", ctx_r1366.id)("index", rowIndex_r1445)("rowData", rowData_r1446);
} }
function IgxHierarchicalGridComponent_ng_template_44_igx_child_grid_row_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-child-grid-row", 92, 87);
} if (rf & 2) {
    const layout_r1452 = ctx.$implicit;
    const ctx_r1454 = ɵngcc0.ɵɵnextContext();
    const rowIndex_r1449 = ctx_r1454.index;
    const rowData_r1450 = ctx_r1454.$implicit;
    const ctx_r1451 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("parentGridID", ctx_r1451.id)("index", rowIndex_r1449)("rowData", rowData_r1450)("layout", layout_r1452);
} }
const _c211 = function (a1) { return { "igx-grid__tr-container": true, "igx-grid__tr--highlighted": a1 }; };
function IgxHierarchicalGridComponent_ng_template_44_Template(rf, ctx) { if (rf & 1) {
    const _r1456 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 90);
    ɵngcc0.ɵɵlistener("scroll", function IgxHierarchicalGridComponent_ng_template_44_Template_div_scroll_0_listener() { ɵngcc0.ɵɵrestoreView(_r1456); const ctx_r1455 = ɵngcc0.ɵɵnextContext(); return ctx_r1455.onContainerScroll(); });
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_template_44_igx_child_grid_row_1_Template, 2, 4, "igx-child-grid-row", 91);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const rowIndex_r1449 = ctx.index;
    const rowData_r1450 = ctx.$implicit;
    const ctx_r1368 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(3, _c211, ctx_r1368.isRowHighlighted(rowData_r1450)));
    ɵngcc0.ɵɵattribute("data-rowindex", rowIndex_r1449);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1368.childLayoutList);
} }
function IgxHierarchicalGridComponent_ng_container_46_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_47_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_span_48_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 80);
} if (rf & 2) {
    const ctx_r1371 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1371.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_igc_trial_watermark_51_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igc-trial-watermark");
} }
function IgxHierarchicalGridComponent_span_52_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 80);
} if (rf & 2) {
    const ctx_r1374 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxColumnMovingDrop", ctx_r1374.headerContainer);
    ɵngcc0.ɵɵattribute("droppable", true);
} }
function IgxHierarchicalGridComponent_ng_template_56_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_igx_grid_summary_row_61_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-summary-row", 93, 94);
    ɵngcc0.ɵɵpipe(2, "igxGridSummaryDataPipe");
} if (rf & 2) {
    const ctx_r1378 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r1378.calcWidth, "px")("height", ctx_r1378.summariesHeight, "px");
    ɵngcc0.ɵɵproperty("gridID", ctx_r1378.id)("summaries", ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r1378.id, ctx_r1378.summaryService.retriggerRootPipe))("index", ctx_r1378.dataView.length);
} }
function IgxHierarchicalGridComponent_ng_template_67_Template(rf, ctx) { }
function IgxHierarchicalGridComponent_ng_container_73_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_container_73_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridComponent_ng_container_73_ng_container_1_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1383 = ɵngcc0.ɵɵnextContext();
    const _r1384 = ɵngcc0.ɵɵreference(75);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1383.paginationTemplate ? ctx_r1383.paginationTemplate : _r1384)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx_r1383));
} }
function IgxHierarchicalGridComponent_ng_template_74_Template(rf, ctx) { if (rf & 1) {
    const _r1460 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-paginator", 95);
    ɵngcc0.ɵɵlistener("pageChange", function IgxHierarchicalGridComponent_ng_template_74_Template_igx_paginator_pageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1460); const ctx_r1459 = ɵngcc0.ɵɵnextContext(); return ctx_r1459.page = $event; })("perPageChange", function IgxHierarchicalGridComponent_ng_template_74_Template_igx_paginator_perPageChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1460); const ctx_r1461 = ɵngcc0.ɵɵnextContext(); return ctx_r1461.perPage = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1385 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("displayDensity", ctx_r1385.displayDensity)("page", ctx_r1385.page)("totalRecords", ctx_r1385.totalRecords)("perPage", ctx_r1385.perPage);
} }
function IgxHierarchicalGridComponent_ng_template_76_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 96);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1387 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1387.emptyFilteredGridMessage);
} }
function IgxHierarchicalGridComponent_ng_template_78_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 96);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1389 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1389.emptyGridMessage);
} }
function IgxHierarchicalGridComponent_ng_template_80_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 97);
    ɵngcc0.ɵɵelement(1, "igx-circular-bar", 79);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("indeterminate", true);
} }
function IgxHierarchicalGridComponent_ng_template_82_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 98);
    ɵngcc0.ɵɵtext(1, "unfold_more");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxHierarchicalGridComponent_ng_template_84_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 99);
    ɵngcc0.ɵɵtext(1, "unfold_less");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1395 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", ctx_r1395.hasExpandedRecords() && ctx_r1395.hasExpandableChildren);
} }
function IgxHierarchicalGridComponent_div_86_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_div_86_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 100);
    ɵngcc0.ɵɵelementStart(1, "div", 101);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridComponent_div_86_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1396 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r1396.bannerClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1396.rowEditContainer)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c167, ctx_r1396.rowChangesCount, ctx_r1396.endEdit.bind(ctx_r1396)));
} }
function IgxHierarchicalGridComponent_ng_template_87_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r1398 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" You have ", ctx_r1398.rowChangesCount, " changes in this row\n");
} }
function IgxHierarchicalGridComponent_ng_template_89_Template(rf, ctx) { if (rf & 1) {
    const _r1464 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 102);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_template_89_Template_button_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1464); const ctx_r1463 = ɵngcc0.ɵɵnextContext(); return ctx_r1463.endRowEdit(false, $event); });
    ɵngcc0.ɵɵtext(1, "Cancel");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "button", 102);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_ng_template_89_Template_button_click_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1464); const ctx_r1465 = ɵngcc0.ɵɵnextContext(); return ctx_r1465.endRowEdit(true, $event); });
    ɵngcc0.ɵɵtext(3, "Done");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxHierarchicalGridComponent_ng_template_91_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_91_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridComponent_ng_template_91_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 103);
    ɵngcc0.ɵɵelementStart(1, "span", 104);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridComponent_ng_template_91_ng_container_2_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 105);
    ɵngcc0.ɵɵelementStart(4, "div", 106);
    ɵngcc0.ɵɵtemplate(5, IgxHierarchicalGridComponent_ng_template_91_ng_container_5_Template, 1, 0, "ng-container", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1402 = ɵngcc0.ɵɵnextContext();
    const _r1397 = ɵngcc0.ɵɵreference(88);
    const _r1399 = ɵngcc0.ɵɵreference(90);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1402.rowEditText ? ctx_r1402.rowEditText : _r1397)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c13, ctx_r1402.rowChangesCount));
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1402.rowEditActions ? ctx_r1402.rowEditActions : _r1399)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c13, ctx_r1402.endEdit.bind(ctx_r1402)));
} }
function IgxHierarchicalGridComponent_ng_template_93_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 107);
    ɵngcc0.ɵɵtext(1, "drag_indicator");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxHierarchicalGridComponent_ng_template_95_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 108);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 109, 110);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r1468 = ctx.$implicit;
    const ctx_r1406 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", 0 - 1)("readonly", true)("checked", context_r1468.selectedCount > 0 && context_r1468.totalCount === context_r1468.selectedCount)("ngStyle", ɵngcc0.ɵɵpureFunction1(6, _c168, ctx_r1406.isMultiRowSelectionEnabled ? "visible" : "hidden"))("indeterminate", context_r1468.selectedCount > 0 && context_r1468.selectedCount !== context_r1468.totalCount)("aria-label", ctx_r1406.headSelectorBaseAriaLabel);
} }
function IgxHierarchicalGridComponent_igx_grid_column_resizer_97_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-grid-column-resizer");
} }
const _c212 = function (a0, a1, a2) { return { "igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header": a0, "igx-grid__hierarchical-expander--push": a1, "igx-grid__hierarchical-expander--no-border": a2 }; };
function IgxHierarchicalGridCellComponent_ng_template_0_igx_chip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-chip", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1478 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("disabled", true)("displayDensity", "compact");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1478.grid.resourceStrings.igx_grid_pinned_row_indicator);
} }
function IgxHierarchicalGridCellComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_0_igx_chip_0_Template, 2, 3, "igx-chip", 4);
} if (rf & 2) {
    const ctx_r1471 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1471.displayPinnedChip);
} }
function IgxHierarchicalGridCellComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵpipe(1, "igxdecimal");
    ɵngcc0.ɵɵpipe(2, "igxdate");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "igxdecimal");
    ɵngcc0.ɵɵpipe(5, "igxdate");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1473 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("cssClass", ctx_r1473.highlightClass)("activeCssClass", ctx_r1473.activeHighlightClass)("groupName", ctx_r1473.gridID)("value", ctx_r1473.formatter ? ctx_r1473.formatter(ctx_r1473.value) : ctx_r1473.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(1, 9, ctx_r1473.value, ctx_r1473.grid.locale) : ctx_r1473.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(2, 12, ctx_r1473.value, ctx_r1473.grid.locale) : ctx_r1473.value)("row", ctx_r1473.rowData)("column", ctx_r1473.column.field)("containerClass", "igx-grid__td-text")("metadata", ctx_r1473.searchMetadata);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1473.formatter ? ctx_r1473.formatter(ctx_r1473.value) : ctx_r1473.column.dataType === "number" ? ɵngcc0.ɵɵpipeBind2(4, 15, ctx_r1473.value, ctx_r1473.grid.locale) : ctx_r1473.column.dataType === "date" ? ɵngcc0.ɵɵpipeBind2(5, 18, ctx_r1473.value, ctx_r1473.grid.locale) : ctx_r1473.value);
} }
function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    const _r1485 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(2, "input", 9);
    ɵngcc0.ɵɵlistener("input", function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_0_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1485); const ctx_r1484 = ɵngcc0.ɵɵnextContext(2); return ctx_r1484.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1480 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r1480.editValue)("igxFocus", true);
} }
function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r1487 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-input-group", 8);
    ɵngcc0.ɵɵelementStart(2, "input", 10);
    ɵngcc0.ɵɵlistener("input", function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_1_Template_input_input_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r1487); const ctx_r1486 = ɵngcc0.ɵɵnextContext(2); return ctx_r1486.editValue = $event.target.value; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1481 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("value", ctx_r1481.editValue)("igxFocus", true);
} }
function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    const _r1489 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-checkbox", 11);
    ɵngcc0.ɵɵlistener("change", function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_2_Template_igx_checkbox_change_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1489); const ctx_r1488 = ɵngcc0.ɵɵnextContext(2); return ctx_r1488.editValue = $event.checked; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1482 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r1482.editValue)("checked", ctx_r1482.editValue)("igxFocus", true)("disableRipple", true);
} }
function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r1491 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "igx-date-picker", 12);
    ɵngcc0.ɵɵlistener("valueChange", function IgxHierarchicalGridCellComponent_ng_template_4_ng_container_3_Template_igx_date_picker_valueChange_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1491); const ctx_r1490 = ɵngcc0.ɵɵnextContext(2); return ctx_r1490.editValue = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1483 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("width", 100, "%");
    ɵngcc0.ɵɵproperty("outlet", ctx_r1483.grid.outletDirective)("locale", ctx_r1483.grid.locale)("value", ctx_r1483.editValue)("igxFocus", true)("labelVisibility", false);
} }
function IgxHierarchicalGridCellComponent_ng_template_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_4_ng_container_0_Template, 3, 2, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalGridCellComponent_ng_template_4_ng_container_1_Template, 3, 2, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_4_ng_container_2_Template, 2, 4, "ng-container", 7);
    ɵngcc0.ɵɵtemplate(3, IgxHierarchicalGridCellComponent_ng_template_4_ng_container_3_Template, 2, 7, "ng-container", 7);
} if (rf & 2) {
    const ctx_r1475 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1475.column.dataType === "string");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1475.column.dataType === "number");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1475.column.dataType === "boolean");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1475.column.dataType === "date");
} }
function IgxHierarchicalGridCellComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalGridCellComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c213 = ["expander"];
const _c214 = ["defaultEmptyTemplate"];
function IgxHierarchicalRowComponent_div_0_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalRowComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r1512 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 9, 10);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalRowComponent_div_0_Template_div_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1512); const ctx_r1511 = ɵngcc0.ɵɵnextContext(); return ctx_r1511.expanderClick($event); })("mousedown", function IgxHierarchicalRowComponent_div_0_Template_div_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1512); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_div_0_ng_container_2_Template, 1, 0, "ng-container", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1492 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1492.expanderClassResolved);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1492.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(3, _c13, ctx_r1492));
} }
function IgxHierarchicalRowComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 12);
    ɵngcc0.ɵɵtext(1, "expand_more");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1494 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", !ctx_r1494.added);
} }
function IgxHierarchicalRowComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 12);
    ɵngcc0.ɵɵtext(1, "chevron_right");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1496 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("isActive", !ctx_r1496.added);
} }
function IgxHierarchicalRowComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-icon", 13);
} }
function IgxHierarchicalRowComponent_ng_container_7_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxHierarchicalRowComponent_ng_container_7_Template(rf, ctx) { if (rf & 1) {
    const _r1516 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalRowComponent_ng_container_7_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1516); return $event.stopPropagation(); });
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_container_7_ng_container_2_Template, 1, 0, "ng-container", 15);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1499 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassMap(ctx_r1499.resolveDragIndicatorClasses);
    ɵngcc0.ɵɵproperty("igxRowDrag", ctx_r1499)("ghostTemplate", ctx_r1499.grid.getDragGhostCustomTemplate());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1499.grid.dragIndicatorIconTemplate ? ctx_r1499.grid.dragIndicatorIconTemplate : ctx_r1499.grid.dragIndicatorIconBase);
} }
function IgxHierarchicalRowComponent_ng_container_8_2_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalRowComponent_ng_container_8_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_container_8_2_ng_template_0_Template, 0, 0, "ng-template");
} }
const _c215 = function (a0, a1, a2, a3, a4) { return { index: a0, rowID: a1, selected: a2, select: a3, deselect: a4 }; };
function IgxHierarchicalRowComponent_ng_container_8_Template(rf, ctx) { if (rf & 1) {
    const _r1520 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 16);
    ɵngcc0.ɵɵlistener("click", function IgxHierarchicalRowComponent_ng_container_8_Template_div_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r1520); const ctx_r1519 = ɵngcc0.ɵɵnextContext(); return ctx_r1519.onRowSelectorClick($event); });
    ɵngcc0.ɵɵtemplate(2, IgxHierarchicalRowComponent_ng_container_8_2_Template, 1, 0, undefined, 11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1500 = ɵngcc0.ɵɵnextContext();
    const _r1505 = ɵngcc0.ɵɵreference(15);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1500.grid.rowSelectorTemplate ? ctx_r1500.grid.rowSelectorTemplate : _r1505)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(8, _c13, ɵngcc0.ɵɵpureFunction5(2, _c215, ctx_r1500.viewIndex, ctx_r1500.rowID, ctx_r1500.selected, ctx_r1500.select, ctx_r1500.deselect)));
} }
function IgxHierarchicalRowComponent_ng_container_9_1_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalRowComponent_ng_container_9_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_container_9_1_ng_template_0_Template, 0, 0, "ng-template");
} }
function IgxHierarchicalRowComponent_ng_container_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_container_9_1_Template, 1, 0, undefined, 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1501 = ɵngcc0.ɵɵnextContext();
    const _r1507 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1507)("ngTemplateOutletContext", ctx_r1501);
} }
function IgxHierarchicalRowComponent_ng_template_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-hierarchical-grid-cell", 17);
    ɵngcc0.ɵɵpipe(1, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(2, "igxCellStyles");
} if (rf & 2) {
    const col_r1523 = ctx.$implicit;
    const ctx_r1503 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1503.grid.rowHeight || 32, "px")("min-width", col_r1523.width)("max-width", col_r1523.width)("flex-basis", col_r1523.width);
    ɵngcc0.ɵɵclassProp("igx-grid__td--number", col_r1523.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(1, 25, ɵngcc0.ɵɵpureFunction5(37, _c171, col_r1523.cellClasses, ctx_r1503.rowData[col_r1523.field], ctx_r1503.rowData, col_r1523.field, ctx_r1503.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(2, 31, ɵngcc0.ɵɵpureFunction5(43, _c171, col_r1523.cellStyles, ctx_r1503.rowData[col_r1523.field], ctx_r1503.rowData, col_r1523.field, ctx_r1503.viewIndex)))("editMode", col_r1523.editable && ctx_r1503.crudService.isInEditMode(ctx_r1503.index, col_r1523.index))("column", col_r1523)("formatter", col_r1523.formatter)("row", ctx_r1503)("active", ctx_r1503.isCellActive(col_r1523.visibleIndex))("rowData", ctx_r1503.rowData)("width", col_r1523.getCellWidth())("visibleColumnIndex", col_r1523.visibleIndex)("value", ctx_r1503.rowData[col_r1523.field])("cellTemplate", col_r1523.bodyTemplate)("lastSearchInfo", ctx_r1503.grid.lastSearchInfo)("cellSelectionMode", ctx_r1503.grid.cellSelection)("displayPinnedChip", ctx_r1503.shouldDisplayPinnedChip(col_r1523.visibleIndex));
} }
function IgxHierarchicalRowComponent_ng_container_13_1_ng_template_0_Template(rf, ctx) { }
function IgxHierarchicalRowComponent_ng_container_13_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_container_13_1_ng_template_0_Template, 0, 0, "ng-template");
} }
function IgxHierarchicalRowComponent_ng_container_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_container_13_1_Template, 1, 0, undefined, 11);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1504 = ɵngcc0.ɵɵnextContext();
    const _r1507 = ɵngcc0.ɵɵreference(17);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1507)("ngTemplateOutletContext", ctx_r1504);
} }
function IgxHierarchicalRowComponent_ng_template_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 18);
    ɵngcc0.ɵɵelement(1, "igx-checkbox", 19);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1506 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("tabindex", 0 - 1)("readonly", true)("checked", ctx_r1506.selected)("disabled", ctx_r1506.deleted)("disableTransitions", ctx_r1506.grid.disableTransitions)("aria-label", ctx_r1506.rowCheckboxAriaLabel);
} }
function IgxHierarchicalRowComponent_ng_template_16_igx_hierarchical_grid_cell_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-hierarchical-grid-cell", 21);
    ɵngcc0.ɵɵpipe(1, "igxCellStyleClasses");
    ɵngcc0.ɵɵpipe(2, "igxCellStyles");
} if (rf & 2) {
    const col_r1529 = ctx.$implicit;
    const ctx_r1528 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("min-height", ctx_r1528.grid.rowHeight || 32, "px")("min-width", col_r1529.width)("max-width", col_r1529.width)("flex-basis", col_r1529.width)("left", col_r1529.rightPinnedOffset);
    ɵngcc0.ɵɵclassProp("igx-grid__td--number", col_r1529.dataType === "number");
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpipeBindV(1, 29, ɵngcc0.ɵɵpureFunction5(41, _c171, col_r1529.cellClasses, ctx_r1528.rowData[col_r1529.field], ctx_r1528.rowData, col_r1529.field, ctx_r1528.viewIndex)))("ngStyle", ɵngcc0.ɵɵpipeBindV(2, 35, ɵngcc0.ɵɵpureFunction5(47, _c171, col_r1529.cellStyles, ctx_r1528.rowData[col_r1529.field], ctx_r1528.rowData, col_r1529.field, ctx_r1528.viewIndex)))("editMode", col_r1529.editable && ctx_r1528.crudService.isInEditMode(ctx_r1528.index, col_r1529.index))("column", col_r1529)("formatter", col_r1529.formatter)("row", ctx_r1528)("active", ctx_r1528.isCellActive(col_r1529.visibleIndex))("firstPinned", col_r1529.isFirstPinned)("lastPinned", col_r1529.isLastPinned)("rowData", ctx_r1528.rowData)("width", col_r1529.getCellWidth())("visibleColumnIndex", col_r1529.visibleIndex)("value", ctx_r1528.rowData[col_r1529.field])("cellTemplate", col_r1529.bodyTemplate)("lastSearchInfo", ctx_r1528.grid.lastSearchInfo)("cellSelectionMode", ctx_r1528.grid.cellSelection)("displayPinnedChip", ctx_r1528.shouldDisplayPinnedChip(col_r1529.visibleIndex));
} }
function IgxHierarchicalRowComponent_ng_template_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_ng_template_16_igx_hierarchical_grid_cell_0_Template, 3, 53, "igx-hierarchical-grid-cell", 20);
    ɵngcc0.ɵɵpipe(1, "igxNotGrouped");
} if (rf & 2) {
    const ctx_r1508 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r1508.pinnedColumns));
} }
function IgxNavbarComponent_igx_icon_2_Template(rf, ctx) { if (rf & 1) {
    const _r1532 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-icon", 5);
    ɵngcc0.ɵɵlistener("click", function IgxNavbarComponent_igx_icon_2_Template_igx_icon_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1532); const ctx_r1531 = ɵngcc0.ɵɵnextContext(); return ctx_r1531._triggerAction(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1530 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1530.actionButtonIcon);
} }
const _c216 = [[["igx-action-icon"]], "*"];
const _c217 = ["igx-action-icon", "*"];
const _c218 = ["aside"];
const _c219 = ["overlay"];
const _c220 = ["dummy"];
function IgxNavigationDrawerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵtext(1, "Navigation Drawer");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "div", 9);
    ɵngcc0.ɵɵtext(3, " Start by adding");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 9);
    ɵngcc0.ɵɵelementStart(5, "code");
    ɵngcc0.ɵɵtext(6, "<ng-template igxDrawer>");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "div", 9);
    ɵngcc0.ɵɵtext(8, " And some items inside ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 9);
    ɵngcc0.ɵɵtext(10, " Style with igxDrawerItem ");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(11, "div", 9);
    ɵngcc0.ɵɵtext(12, " and igxRipple directives");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵproperty("isHeader", true);
} }
function IgxNavigationDrawerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxThumbLabelComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxThumbLabelComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r1541 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1541.value, "\n");
} }
function IgxTicksComponent_div_0_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c221 = function (a0) { return { "igx-slider__ticks-group--tall": a0 }; };
const _c222 = function (a0) { return { "igx-slider__tick-label--hidden": a0 }; };
function IgxTicksComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵelementStart(1, "div", 3);
    ɵngcc0.ɵɵelementStart(2, "span", 4);
    ɵngcc0.ɵɵtemplate(3, IgxTicksComponent_div_0_ng_container_3_Template, 1, 0, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const idx_r1546 = ctx.index;
    const ctx_r1542 = ɵngcc0.ɵɵnextContext();
    const _r1543 = ɵngcc0.ɵɵreference(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(4, _c221, ctx_r1542.isPrimary(idx_r1546)));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(6, _c222, !ctx_r1542.hiddenTickLabels(idx_r1546)));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1542.tickLabelTemplateRef ? ctx_r1542.tickLabelTemplateRef : _r1543)("ngTemplateOutletContext", ctx_r1542.context(idx_r1546));
} }
function IgxTicksComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const value_r1548 = ctx.$implicit;
    ɵngcc0.ɵɵtextInterpolate1(" ", value_r1548, "\n");
} }
const _c223 = ["ticks"];
const _c224 = ["track"];
function IgxSliderComponent_igx_ticks_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-ticks", 12);
    ɵngcc0.ɵɵpipe(1, "spreadTickLabels");
} if (rf & 2) {
    const ctx_r1549 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ticksOrientation", 0)("primaryTicks", ctx_r1549.primaryTicks)("secondaryTicks", ctx_r1549.secondaryTicks)("primaryTickLabels", ctx_r1549.primaryTickLabels)("secondaryTickLabels", ctx_r1549.secondaryTickLabels)("tickLabelsOrientation", ctx_r1549.tickLabelsOrientation)("labelsViewEnabled", ctx_r1549.labelsViewEnabled)("labels", ɵngcc0.ɵɵpipeBind2(1, 11, ctx_r1549.labels, ctx_r1549.secondaryTicks))("tickLabelTemplateRef", ctx_r1549.tickLabelTemplateRef)("minValue", ctx_r1549.minValue)("maxValue", ctx_r1549.maxValue);
} }
function IgxSliderComponent_igx_ticks_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-ticks", 12);
    ɵngcc0.ɵɵpipe(1, "spreadTickLabels");
} if (rf & 2) {
    const ctx_r1552 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ticksOrientation", 1)("primaryTicks", ctx_r1552.primaryTicks)("secondaryTicks", ctx_r1552.secondaryTicks)("primaryTickLabels", ctx_r1552.primaryTickLabels)("secondaryTickLabels", ctx_r1552.secondaryTickLabels)("tickLabelsOrientation", ctx_r1552.tickLabelsOrientation)("labelsViewEnabled", ctx_r1552.labelsViewEnabled)("labels", ɵngcc0.ɵɵpipeBind2(1, 11, ctx_r1552.labels, ctx_r1552.secondaryTicks))("tickLabelTemplateRef", ctx_r1552.tickLabelTemplateRef)("minValue", ctx_r1552.minValue)("maxValue", ctx_r1552.maxValue);
} }
function IgxSliderComponent_igx_thumb_label_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-thumb-label", 13);
} if (rf & 2) {
    const ctx_r1553 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", 0)("value", ctx_r1553.lowerLabel)("templateRef", ctx_r1553.thumbFromTemplateRef)("continuous", ctx_r1553.continuous)("context", ctx_r1553.context)("deactiveState", ctx_r1553.deactivateThumbLabel);
} }
function IgxSliderComponent_igx_thumb_9_Template(rf, ctx) { if (rf & 1) {
    const _r1558 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-thumb", 10, 14);
    ɵngcc0.ɵɵlistener("onChange", function IgxSliderComponent_igx_thumb_9_Template_igx_thumb_onChange_0_listener() { ɵngcc0.ɵɵrestoreView(_r1558); const ctx_r1557 = ɵngcc0.ɵɵnextContext(); return ctx_r1557.onThumbChange(); })("onHoverChange", function IgxSliderComponent_igx_thumb_9_Template_igx_thumb_onHoverChange_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1558); const ctx_r1559 = ɵngcc0.ɵɵnextContext(); return ctx_r1559.onHoverChange($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1554 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("type", 0)("value", ctx_r1554.lowerLabel)("disabled", ctx_r1554.disabled)("continuous", ctx_r1554.continuous)("onPan", ctx_r1554.onPan)("stepDistance", ctx_r1554.stepDistance)("step", ctx_r1554.step)("templateRef", ctx_r1554.thumbFromTemplateRef)("context", ctx_r1554.context)("deactiveState", ctx_r1554.deactivateThumbLabel)("thumbLabelVisibilityDuration", ctx_r1554.thumbLabelVisibilityDuration);
} }
function IgxSnackbarComponent_div_0_button_4_Template(rf, ctx) { if (rf & 1) {
    const _r1563 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 4);
    ɵngcc0.ɵɵlistener("click", function IgxSnackbarComponent_div_0_button_4_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1563); const ctx_r1562 = ɵngcc0.ɵɵnextContext(2); return ctx_r1562.triggerAction(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1561 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("@fadeInOut", undefined);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1561.actionText, " ");
} }
function IgxSnackbarComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    const _r1565 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵlistener("@slideInOut.start", function IgxSnackbarComponent_div_0_Template_div_animation_slideInOut_start_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1565); const ctx_r1564 = ɵngcc0.ɵɵnextContext(); return ctx_r1564.snackbarAnimationStarted($event); })("@slideInOut.done", function IgxSnackbarComponent_div_0_Template_div_animation_slideInOut_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1565); const ctx_r1566 = ɵngcc0.ɵɵnextContext(); return ctx_r1566.snackbarAnimationDone($event); });
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵprojection(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, IgxSnackbarComponent_div_0_button_4_Template, 2, 2, "button", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1560 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@slideInOut", ctx_r1560.isVisible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("@fadeInOut", ctx_r1560.isVisible);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1560.message, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1560.actionText);
} }
function IgxBottomNavComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵprojection(1, 1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxBottomNavComponent_ng_container_3_igx_tab_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-tab", 4);
    ɵngcc0.ɵɵtext(1, "> ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const panel_r1574 = ctx.$implicit;
    const i_r1575 = ctx.index;
    const ctx_r1573 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("relatedPanel", panel_r1574)("autoGenerated", true)("id", ctx_r1573.getTabId(i_r1575));
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r1573.getTabPanelId(i_r1575));
} }
function IgxBottomNavComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxBottomNavComponent_ng_container_3_igx_tab_1_Template, 2, 4, "igx-tab", 3);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1572 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1572.panels);
} }
const _c225 = [[["igx-tab"]], "*"];
const _c226 = ["igx-tab", "*"];
const _c227 = ["defaultTabTemplate"];
function IgxTabComponent_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-badge", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r1579 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(context_r1579.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", context_r1579.changesCount)("hidden", context_r1579.changesCount === 0);
} }
function IgxTabComponent_ng_template_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r1579 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(context_r1579.label);
} }
function IgxTabComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTabComponent_ng_template_0_div_0_Template, 4, 3, "div", 2);
    ɵngcc0.ɵɵtemplate(1, IgxTabComponent_ng_template_0_div_1_Template, 2, 1, "div", 3);
} if (rf & 2) {
    const context_r1579 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", context_r1579.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", context_r1579.label);
} }
function IgxTabComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTabItemComponent_ng_template_0_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(3, "igx-badge", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r1587 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r1588 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(context_r1587.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("value", ctx_r1588.changesCount)("hidden", ctx_r1588.changesCount === 0);
} }
function IgxTabItemComponent_ng_template_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const context_r1587 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(context_r1587.label);
} }
function IgxTabItemComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTabItemComponent_ng_template_0_div_0_Template, 4, 3, "div", 2);
    ɵngcc0.ɵɵtemplate(1, IgxTabItemComponent_ng_template_0_div_1_Template, 2, 1, "div", 3);
} if (rf & 2) {
    const context_r1587 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngIf", context_r1587.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", context_r1587.label);
} }
function IgxTabItemComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTabsGroupComponent_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 0, ["*ngIf", "isSelected"]);
} }
const _c228 = ["contentsContainer"];
const _c229 = ["headerContainer"];
const _c230 = ["itemsContainer"];
const _c231 = ["selectedIndicator"];
const _c232 = ["tabsContainer"];
const _c233 = ["viewPort"];
function IgxTabsComponent_ng_container_11_igx_tab_item_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "igx-tab-item", 16);
} if (rf & 2) {
    const group_r1601 = ctx.$implicit;
    const i_r1602 = ctx.index;
    const ctx_r1600 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("relatedGroup", group_r1601)("autoGenerated", true)("id", ctx_r1600.getTabItemId(i_r1602));
    ɵngcc0.ɵɵattribute("aria-controls", ctx_r1600.getTabsGroupId(i_r1602));
} }
function IgxTabsComponent_ng_container_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxTabsComponent_ng_container_11_igx_tab_item_1_Template, 1, 4, "igx-tab-item", 15);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1597 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1597.groups);
} }
function IgxTabsComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 17, 18);
} }
const _c234 = [[["igx-tab-item"]], "*"];
const _c235 = ["igx-tab-item", "*"];
const _c236 = ["hourList"];
const _c237 = ["minuteList"];
const _c238 = ["secondsList"];
const _c239 = ["ampmList"];
const _c240 = ["defaultTimePickerTemplate"];
const _c241 = ["dropdownInputTemplate"];
function IgxTimePickerComponent_ng_template_0_igx_suffix_8_Template(rf, ctx) { if (rf & 1) {
    const _r1620 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-suffix", 16);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_0_igx_suffix_8_Template_igx_suffix_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1620); const ctx_r1619 = ɵngcc0.ɵɵnextContext(2); return ctx_r1619.clear(); });
    ɵngcc0.ɵɵelementStart(1, "igx-icon", 17);
    ɵngcc0.ɵɵtext(2, "clear");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function IgxTimePickerComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    const _r1622 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 10, 11);
    ɵngcc0.ɵɵlistener("mousedown", function IgxTimePickerComponent_ng_template_0_Template_igx_input_group_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1622); const ctx_r1621 = ɵngcc0.ɵɵnextContext(); return ctx_r1621.mouseDown($event); });
    ɵngcc0.ɵɵelementStart(2, "label", 12);
    ɵngcc0.ɵɵtext(3, "Time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "igx-prefix", 13);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_0_Template_igx_prefix_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r1622); const _r1617 = ɵngcc0.ɵɵreference(1); const ctx_r1623 = ɵngcc0.ɵɵnextContext(); return ctx_r1623.openDialog(_r1617.element.nativeElement); });
    ɵngcc0.ɵɵelementStart(5, "igx-icon");
    ɵngcc0.ɵɵtext(6, "access_time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(7, "input", 14);
    ɵngcc0.ɵɵlistener("input", function IgxTimePickerComponent_ng_template_0_Template_input_input_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r1622); const ctx_r1624 = ɵngcc0.ɵɵnextContext(); return ctx_r1624.onInput($event); })("blur", function IgxTimePickerComponent_ng_template_0_Template_input_blur_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r1622); const ctx_r1625 = ɵngcc0.ɵɵnextContext(); return ctx_r1625.onBlur($event); })("focus", function IgxTimePickerComponent_ng_template_0_Template_input_focus_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r1622); const ctx_r1626 = ɵngcc0.ɵɵnextContext(); return ctx_r1626.onFocus($event); })("wheel", function IgxTimePickerComponent_ng_template_0_Template_input_wheel_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r1622); const ctx_r1627 = ɵngcc0.ɵɵnextContext(); return ctx_r1627.spinOnEdit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(8, IgxTimePickerComponent_ng_template_0_igx_suffix_8_Template, 3, 0, "igx-suffix", 15);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1605 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(7);
    ɵngcc0.ɵɵproperty("igxMask", ctx_r1605.mask)("includeLiterals", true)("placeholder", ctx_r1605.format)("displayValuePipe", ctx_r1605.displayFormat)("focusedValuePipe", ctx_r1605.inputFormat)("promptChar", ctx_r1605.promptChar)("value", ctx_r1605.displayValue)("disabled", ctx_r1605.disabled);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1605.showClearButton);
} }
function IgxTimePickerComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r1629 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 18);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_2_Template_igx_input_group_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1629); const ctx_r1628 = ɵngcc0.ɵɵnextContext(); return ctx_r1628.openDialog(); })("mousedown", function IgxTimePickerComponent_ng_template_2_Template_igx_input_group_mousedown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1629); const ctx_r1630 = ɵngcc0.ɵɵnextContext(); return ctx_r1630.mouseDown($event); });
    ɵngcc0.ɵɵelementStart(1, "igx-prefix");
    ɵngcc0.ɵɵelementStart(2, "igx-icon");
    ɵngcc0.ɵɵtext(3, "access_time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "label", 12);
    ɵngcc0.ɵɵtext(5, "Time");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(6, "input", 19);
    ɵngcc0.ɵɵlistener("blur", function IgxTimePickerComponent_ng_template_2_Template_input_blur_6_listener($event) { ɵngcc0.ɵɵrestoreView(_r1629); const ctx_r1631 = ɵngcc0.ɵɵnextContext(); return ctx_r1631.onBlur($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1607 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(6);
    ɵngcc0.ɵɵproperty("value", ctx_r1607.displayTime || "")("disabled", ctx_r1607.disabled);
} }
function IgxTimePickerComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxTimePickerComponent_ng_template_5_div_0_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r1636 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 23);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_5_div_0_button_1_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1636); const ctx_r1635 = ɵngcc0.ɵɵnextContext(3); return ctx_r1635.cancelButtonClick(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1633 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1633.cancelButtonLabel, " ");
} }
function IgxTimePickerComponent_ng_template_5_div_0_button_2_Template(rf, ctx) { if (rf & 1) {
    const _r1638 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 23);
    ɵngcc0.ɵɵlistener("click", function IgxTimePickerComponent_ng_template_5_div_0_button_2_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1638); const ctx_r1637 = ɵngcc0.ɵɵnextContext(3); return ctx_r1637.okButtonClick(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1634 = ɵngcc0.ɵɵnextContext(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1634.okButtonLabel, " ");
} }
function IgxTimePickerComponent_ng_template_5_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 21);
    ɵngcc0.ɵɵtemplate(1, IgxTimePickerComponent_ng_template_5_div_0_button_1_Template, 2, 1, "button", 22);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_ng_template_5_div_0_button_2_Template, 2, 1, "button", 22);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1632 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1632.cancelButtonLabel);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1632.okButtonLabel);
} }
function IgxTimePickerComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxTimePickerComponent_ng_template_5_div_0_Template, 3, 2, "div", 20);
} if (rf & 2) {
    const ctx_r1610 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1610.cancelButtonLabel || ctx_r1610.okButtonLabel);
} }
function IgxTimePickerComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 24);
    ɵngcc0.ɵɵelementStart(1, "h5", 25);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "h2", 26);
    ɵngcc0.ɵɵelementStart(4, "span");
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(6, ":");
    ɵngcc0.ɵɵelementStart(7, "span");
    ɵngcc0.ɵɵtext(8);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtext(9, ":");
    ɵngcc0.ɵɵelementStart(10, "span");
    ɵngcc0.ɵɵtext(11);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1611 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1611.selectedAmPm);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1611.selectedHour);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1611.selectedMinute);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1611.selectedSeconds);
} }
function IgxTimePickerComponent_div_11_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 30);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const hour_r1641 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("igxHourItem", hour_r1641);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(hour_r1641);
} }
function IgxTimePickerComponent_div_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 27, 28);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_11_span_2_Template, 2, 2, "span", 29);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1612 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "hourList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1612.hourView);
} }
function IgxTimePickerComponent_div_12_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 33);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const minute_r1644 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("igxMinuteItem", minute_r1644);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(minute_r1644);
} }
function IgxTimePickerComponent_div_12_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 27, 31);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_12_span_2_Template, 2, 2, "span", 32);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1613 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "minuteList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1613.minuteView);
} }
function IgxTimePickerComponent_div_13_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 36);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const seconds_r1647 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("igxSecondsItem", seconds_r1647);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(seconds_r1647);
} }
function IgxTimePickerComponent_div_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 27, 34);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_13_span_2_Template, 2, 2, "span", 35);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1614 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "secondsList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1614.secondsView);
} }
function IgxTimePickerComponent_div_14_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 39);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ampm_r1650 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("igxAmPmItem", ampm_r1650);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ampm_r1650);
} }
function IgxTimePickerComponent_div_14_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 27, 37);
    ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_div_14_span_2_Template, 2, 2, "span", 38);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1615 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("igxItemList", "ampmList");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r1615.ampmView);
} }
function IgxTimePickerComponent_ng_container_15_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
const _c242 = function (a0, a1) { return { "igx-time-picker--dropdown": a0, "igx-time-picker--vertical": a1 }; };
function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template(rf, ctx) { if (rf & 1) {
    const _r1657 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-splitter-bar", 2);
    ɵngcc0.ɵɵlistener("moveStart", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moveStart_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1657); const ctx_r1656 = ɵngcc0.ɵɵnextContext(2); return ctx_r1656.onMoveStart($event); })("moving", function IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template_igx_splitter_bar_moving_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r1657); const ctx_r1658 = ɵngcc0.ɵɵnextContext(2); return ctx_r1658.onMoving($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1659 = ɵngcc0.ɵɵnextContext();
    const pane_r1652 = ctx_r1659.$implicit;
    const index_r1654 = ctx_r1659.index;
    const ctx_r1655 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("order", pane_r1652.order + 1)("type", ctx_r1655.type)("pane", pane_r1652)("siblings", ctx_r1655.getPaneSiblingsByOrder(pane_r1652.order + 1, index_r1654));
} }
function IgxSplitterComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_igx_splitter_bar_1_Template, 1, 4, "igx-splitter-bar", 1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const last_r1653 = ctx.last;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !last_r1653);
} }
const _c243 = [[["igx-splitter-pane"]]];
const _c244 = ["igx-splitter-pane"];
function IgxDateRangeStartComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r1667 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1667);
} }
function IgxDateRangeStartComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function IgxDateRangeStartComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function IgxDateRangeStartComponent_ng_template_7_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_7_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_7_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r1661 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1661);
} }
function IgxDateRangeStartComponent_ng_template_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_7_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_7_ng_container_1_Template, 1, 0, "ng-container", 7);
} if (rf & 2) {
    const ctx_r1666 = ɵngcc0.ɵɵnextContext();
    const _r1663 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1666.isNotMaterial);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1663);
} }
function IgxDateRangeStartComponent_ng_template_9_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_9_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_9_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r1661 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1661);
} }
function IgxDateRangeStartComponent_ng_template_9_div_3_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_9_div_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_9_div_3_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r1661 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1661);
} }
function IgxDateRangeStartComponent_ng_template_9_div_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeStartComponent_ng_template_9_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeStartComponent_ng_template_9_div_3_ng_container_1_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeStartComponent_ng_template_9_div_3_ng_container_2_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1674 = ɵngcc0.ɵɵnextContext(2);
    const _r1663 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1674.isNotMaterial);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1663);
} }
function IgxDateRangeStartComponent_ng_template_9_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function IgxDateRangeStartComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeStartComponent_ng_template_9_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵprojection(2, 3);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_9_div_3_Template, 3, 2, "div", 10);
    ɵngcc0.ɵɵprojection(4, 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_9_div_5_Template, 1, 0, "div", 11);
} if (rf & 2) {
    const ctx_r1668 = ɵngcc0.ɵɵnextContext();
    const _r1665 = ɵngcc0.ɵɵreference(8);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1668.isNotMaterial);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1668.isTypeBootstrap)("ngIfElse", _r1665);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1668.hasBorder);
} }
function IgxDateRangeEndComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_div_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r1687 = ɵngcc0.ɵɵreference(10);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1687);
} }
function IgxDateRangeEndComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
} }
function IgxDateRangeEndComponent_ng_template_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 2);
} }
function IgxDateRangeEndComponent_ng_template_7_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_7_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_7_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r1681 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1681);
} }
function IgxDateRangeEndComponent_ng_template_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_7_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_7_ng_container_1_Template, 1, 0, "ng-container", 7);
} if (rf & 2) {
    const ctx_r1686 = ɵngcc0.ɵɵnextContext();
    const _r1683 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1686.isNotMaterial);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1683);
} }
function IgxDateRangeEndComponent_ng_template_9_ng_container_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_9_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_9_ng_container_0_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r1681 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1681);
} }
function IgxDateRangeEndComponent_ng_template_9_div_3_ng_container_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_9_div_3_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_9_div_3_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(3);
    const _r1681 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1681);
} }
function IgxDateRangeEndComponent_ng_template_9_div_3_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangeEndComponent_ng_template_9_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtemplate(1, IgxDateRangeEndComponent_ng_template_9_div_3_ng_container_1_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangeEndComponent_ng_template_9_div_3_ng_container_2_Template, 1, 0, "ng-container", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1694 = ɵngcc0.ɵɵnextContext(2);
    const _r1683 = ɵngcc0.ɵɵreference(6);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1694.isNotMaterial);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1683);
} }
function IgxDateRangeEndComponent_ng_template_9_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 13);
} }
function IgxDateRangeEndComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, IgxDateRangeEndComponent_ng_template_9_ng_container_0_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵprojection(2, 3);
    ɵngcc0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_9_div_3_Template, 3, 2, "div", 10);
    ɵngcc0.ɵɵprojection(4, 4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_9_div_5_Template, 1, 0, "div", 11);
} if (rf & 2) {
    const ctx_r1688 = ɵngcc0.ɵɵnextContext();
    const _r1685 = ɵngcc0.ɵɵreference(8);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1688.isNotMaterial);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1688.isTypeBootstrap)("ngIfElse", _r1685);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1688.hasBorder);
} }
function IgxDateRangePickerComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r1715 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "button", 12);
    ɵngcc0.ɵɵlistener("click", function IgxDateRangePickerComponent_ng_container_5_Template_button_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r1715); const ctx_r1714 = ɵngcc0.ɵɵnextContext(); return ctx_r1714.close(); });
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r1702 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1702.doneButtonText);
} }
function IgxDateRangePickerComponent_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangePickerComponent_ng_template_7_Template(rf, ctx) { if (rf & 1) {
    const _r1717 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 13);
    ɵngcc0.ɵɵlistener("click", function IgxDateRangePickerComponent_ng_template_7_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1717); const ctx_r1716 = ɵngcc0.ɵɵnextContext(); return ctx_r1716.open(); });
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDateRangePickerComponent_ng_template_9_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangePickerComponent_ng_template_9_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0, 1);
    ɵngcc0.ɵɵelementStart(1, "div", 14);
    ɵngcc0.ɵɵtemplate(2, IgxDateRangePickerComponent_ng_template_9_ng_container_2_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵprojection(3, 2);
} if (rf & 2) {
    const ctx_r1707 = ɵngcc0.ɵɵnextContext();
    const _r1710 = ɵngcc0.ɵɵreference(14);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("className", ctx_r1707.separatorClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1707.dateSeparatorTemplate ? ctx_r1707.dateSeparatorTemplate : _r1710);
} }
function IgxDateRangePickerComponent_ng_template_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-icon");
    ɵngcc0.ɵɵtext(1, " calendar_today ");
    ɵngcc0.ɵɵelementEnd();
} }
function IgxDateRangePickerComponent_ng_template_13_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r1711 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r1711.dateSeparator);
} }
function IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "igx-prefix");
    ɵngcc0.ɵɵtemplate(1, IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_ng_container_1_Template, 1, 0, "ng-container", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r1708 = ɵngcc0.ɵɵreference(12);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", _r1708);
} }
function IgxDateRangePickerComponent_ng_template_15_Template(rf, ctx) { if (rf & 1) {
    const _r1723 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "igx-input-group", 15);
    ɵngcc0.ɵɵlistener("click", function IgxDateRangePickerComponent_ng_template_15_Template_igx_input_group_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r1723); const ctx_r1722 = ɵngcc0.ɵɵnextContext(); return ctx_r1722.open(); });
    ɵngcc0.ɵɵelement(1, "input", 16, 17);
    ɵngcc0.ɵɵpipe(3, "dateRange");
    ɵngcc0.ɵɵtemplate(4, IgxDateRangePickerComponent_ng_template_15_igx_prefix_4_Template, 2, 1, "igx-prefix", 5);
    ɵngcc0.ɵɵelementContainerStart(5, 18);
    ɵngcc0.ɵɵprojection(6, 3);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerStart(7, 19);
    ɵngcc0.ɵɵprojection(8, 4);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerStart(9, 20);
    ɵngcc0.ɵɵprojection(10, 5);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementContainerStart(11, 21);
    ɵngcc0.ɵɵprojection(12, 6);
    ɵngcc0.ɵɵelementContainerEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1713 = ɵngcc0.ɵɵnextContext();
    const _r1700 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", ctx_r1713.value ? "" : ctx_r1713.appliedFormat)("value", ɵngcc0.ɵɵpipeBind3(3, 5, ctx_r1713.value, ctx_r1713.inputFormat, ctx_r1713.locale));
    ɵngcc0.ɵɵattribute("aria-expanded", !_r1700.collapsed)("aria-labelledby", ctx_r1713.label == null ? null : ctx_r1713.label.id);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1713.toggleComponents.length);
} }
const _c245 = [[["igx-date-single"]], [["igx-date-range-start"]], [["igx-date-range-end"]], [["", "igxLabel", ""]], [["igx-prefix"], ["", "igxPrefix", ""]], [["igx-suffix"], ["", "igxSuffix", ""]], [["igx-hint"], ["", "igxHint", ""]]];
const _c246 = ["igx-date-single", "igx-date-range-start", "igx-date-range-end", "[igxLabel]", "igx-prefix,[igxPrefix]", "igx-suffix,[igxSuffix]", "igx-hint,[igxHint]"];
var EaseIn;
(function (EaseIn) {
    EaseIn[EaseIn["quad"] = `cubic-bezier(0.550, 0.085, 0.680, 0.530)`] = "quad";
    EaseIn[EaseIn["cubic"] = `cubic-bezier(0.550, 0.055, 0.675, 0.190)`] = "cubic";
    EaseIn[EaseIn["quart"] = `cubic-bezier(0.895, 0.030, 0.685, 0.220)`] = "quart";
    EaseIn[EaseIn["quint"] = `cubic-bezier(0.755, 0.050, 0.855, 0.060)`] = "quint";
    EaseIn[EaseIn["sine"] = `cubic-bezier(0.470, 0.000, 0.745, 0.715)`] = "sine";
    EaseIn[EaseIn["expo"] = `cubic-bezier(0.950, 0.050, 0.795, 0.035)`] = "expo";
    EaseIn[EaseIn["circ"] = `cubic-bezier(0.600, 0.040, 0.980, 0.335)`] = "circ";
    EaseIn[EaseIn["back"] = `cubic-bezier(0.600, -0.280, 0.735, 0.045)`] = "back";
})(EaseIn || (EaseIn = {}));
var EaseOut;
(function (EaseOut) {
    EaseOut[EaseOut["quad"] = `cubic-bezier(0.250, 0.460, 0.450, 0.940)`] = "quad";
    EaseOut[EaseOut["cubic"] = `cubic-bezier(0.215, 0.610, 0.355, 1.000)`] = "cubic";
    EaseOut[EaseOut["quart"] = `cubic-bezier(0.165, 0.840, 0.440, 1.000)`] = "quart";
    EaseOut[EaseOut["quint"] = `cubic-bezier(0.230, 1.000, 0.320, 1.000)`] = "quint";
    EaseOut[EaseOut["sine"] = `cubic-bezier(0.390, 0.575, 0.565, 1.000)`] = "sine";
    EaseOut[EaseOut["expo"] = `cubic-bezier(0.190, 1.000, 0.220, 1.000)`] = "expo";
    EaseOut[EaseOut["circ"] = `cubic-bezier(0.075, 0.820, 0.165, 1.000)`] = "circ";
    EaseOut[EaseOut["back"] = `cubic-bezier(0.175, 0.885, 0.320, 1.275)`] = "back";
})(EaseOut || (EaseOut = {}));
var EaseInOut;
(function (EaseInOut) {
    EaseInOut[EaseInOut["quad"] = `cubic-bezier(0.455, 0.030, 0.515, 0.955)`] = "quad";
    EaseInOut[EaseInOut["cubic"] = `cubic-bezier(0.645, 0.045, 0.355, 1.000)`] = "cubic";
    EaseInOut[EaseInOut["quart"] = `cubic-bezier(0.770, 0.000, 0.175, 1.000)`] = "quart";
    EaseInOut[EaseInOut["quint"] = `cubic-bezier(0.860, 0.000, 0.070, 1.000)`] = "quint";
    EaseInOut[EaseInOut["sine"] = `cubic-bezier(0.445, 0.050, 0.550, 0.950)`] = "sine";
    EaseInOut[EaseInOut["expo"] = `cubic-bezier(1.000, 0.000, 0.000, 1.000)`] = "expo";
    EaseInOut[EaseInOut["circ"] = `cubic-bezier(0.785, 0.135, 0.150, 0.860)`] = "circ";
    EaseInOut[EaseInOut["back"] = `cubic-bezier(0.680, -0.550, 0.265, 1.550)`] = "back";
})(EaseInOut || (EaseInOut = {}));

const base = [
    style({
        opacity: `{{startOpacity}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`
    }))
];
const baseParams = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.sine,
    endOpacity: 1,
    startOpacity: 0
};
const fadeIn = animation(base, {
    params: baseParams
});
const fadeOut = animation(base, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.sine,
        endOpacity: 0,
        startOpacity: 1
    }
});

const baseRecipe = [
    style({
        backfaceVisibility: 'hidden',
        transformStyle: 'preserve-3d'
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `translateZ({{startDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)`
        }),
        style({
            offset: 1,
            transform: `translateZ({{endDistance}})
                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)`
        })
    ]))
];
const baseParams$1 = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 180,
    endDistance: '0px',
    rotateX: 1,
    rotateY: 0,
    rotateZ: 0,
    startAngle: 0,
    startDistance: '0px'
};
const flipTop = animation(baseRecipe, {
    params: Object.assign({}, baseParams$1)
});
const flipBottom = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180 })
});
const flipLeft = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { rotateX: 0, rotateY: 1 })
});
const flipRight = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endAngle: -180, rotateX: 0, rotateY: 1 })
});
const flipHorFwd = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px' })
});
const flipHorBck = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px' })
});
const flipVerFwd = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '170px', rotateX: 0, rotateY: 1 })
});
const flipVerBck = animation(baseRecipe, {
    params: Object.assign(Object.assign({}, baseParams$1), { endDistance: '-170px', rotateX: 0, rotateY: 1 })
});

const baseRecipe$1 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        offset: 0,
        opacity: `{{endOpacity}}`,
        transform: `rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const baseInParams = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 0,
    endOpacity: 1,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 1,
    startAngle: -360,
    startOpacity: 0,
    xPos: 'center',
    yPos: 'center'
};
const baseOutParams = Object.assign(Object.assign({}, baseInParams), { easing: EaseIn.quad, endOpacity: 0, startOpacity: 1 });
const rotateInCenter = animation(baseRecipe$1, {
    params: Object.assign({}, baseInParams)
});
const rotateOutCenter = animation(baseRecipe$1, {
    params: Object.assign({}, baseOutParams)
});
const rotateInTop = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'top' })
});
const rotateOutTop = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'top' })
});
const rotateInRight = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right' })
});
const rotateOutRight = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right' })
});
const rotateInBottom = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'bottom' })
});
const rotateOutBottom = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'bottom' })
});
const rotateInLeft = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left' })
});
const rotateOutLeft = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left' })
});
const rotateInTr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'top' })
});
const rotateOutTr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'top' })
});
const rotateInBr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'right', yPos: 'bottom' })
});
const rotateOutBr = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'right', yPos: 'bottom' })
});
const rotateInBl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'bottom' })
});
const rotateOutBl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'bottom' })
});
const rotateInTl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { xPos: 'left', yPos: 'top' })
});
const rotateOutTl = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { xPos: 'left', yPos: 'top' })
});
const rotateInDiagonal1 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
const rotateOutDiagonal1 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
const rotateInDiagonal2 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
const rotateOutDiagonal2 = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
const rotateInHor = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
const rotateOutHor = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
const rotateInVer = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseInParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
});
const rotateOutVer = animation(baseRecipe$1, {
    params: Object.assign(Object.assign({}, baseOutParams), { rotateX: 1, rotateY: 0, rotateZ: 0 })
});

const baseRecipe$2 = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        }),
        style({
            offset: 0.1,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.2,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.3,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.4,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.5,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.6,
            transform: `rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})`
        }),
        style({
            offset: 0.7,
            transform: `rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})`
        }),
        style({
            offset: 0.8,
            transform: `rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})`
        }),
        style({
            offset: 0.9,
            transform: `rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})`
        }),
        style({
            offset: 1,
            transform: `rotate(0deg) translate{{direction}}(0)`,
            transformOrigin: `{{xPos}} {{yPos}}`
        })
    ]))
];
const baseParams$2 = {
    delay: '0s',
    direction: 'X',
    duration: '800ms',
    easing: EaseInOut.quad,
    endAngle: 0,
    endDistance: '8px',
    startAngle: 0,
    startDistance: '10px',
    xPos: 'center',
    yPos: 'center'
};
const shakeHor = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'X' })
});
const shakeVer = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y' })
});
const shakeTop = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
});
const shakeBottom = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
});
const shakeRight = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
});
const shakeLeft = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
});
const shakeCenter = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
});
const shakeTr = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
});
const shakeBr = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
});
const shakeBl = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
});
const shakeTl = animation(baseRecipe$2, {
    params: Object.assign(Object.assign({}, baseParams$2), { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
});

const heartbeatBase = [
    style({
        animationTimingFunction: `ease-out`,
        transform: `scale(1)`,
        transformOrigin: `center center`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            animationTimingFunction: `ease-in`,
            offset: 0.1,
            transform: `scale(0.91)`
        }),
        style({
            animationTimingFunction: `ease-out`,
            offset: 0.17,
            transform: `scale(0.98)`
        }),
        style({
            animationTimingFunction: `ease-in`,
            offset: 0.33,
            transform: `scale(0.87)`
        }),
        style({
            animationTimingFunction: `ease-out`,
            offset: 0.45,
            transform: `scale(1)`
        })
    ]))
];
const heartbeatParams = {
    delay: '0s',
    duration: '1.5s',
    easing: 'ease-in-out'
};
const pulsateBase = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            transform: `scale({{fromScale}})`
        }),
        style({
            offset: 0.5,
            transform: `scale({{toScale}})`
        }),
        style({
            offset: 1,
            transform: `scale({{fromScale}})`
        })
    ]))
];
const pulsateParams = {
    delay: '0s',
    duration: '.5s',
    easing: 'ease-in-out',
    fromScale: 1,
    toScale: 1.1
};
const blinkBase = [
    animate(`{{duration}} {{delay}} {{easing}}`, keyframes([
        style({
            offset: 0,
            opacity: .8,
            transform: `scale({{fromScale}})`
        }),
        style({
            offset: 0.8,
            opacity: 0,
            transform: `scale({{midScale}})`
        }),
        style({
            offset: 1,
            opacity: 0,
            transform: `scale({{toScale}})`
        })
    ]))
];
const blinkParams = {
    delay: '0s',
    duration: '.8s',
    easing: 'ease-in-out',
    fromScale: .2,
    midScale: 1.2,
    toScale: 2.2
};
const pulsateFwd = animation(pulsateBase, {
    params: Object.assign({}, pulsateParams)
});
const pulsateBck = animation(pulsateBase, {
    params: Object.assign(Object.assign({}, pulsateParams), { toScale: .9 })
});
const heartbeat = animation(heartbeatBase, {
    params: Object.assign({}, heartbeatParams)
});
const blink = animation(blinkBase, {
    params: Object.assign({}, blinkParams)
});

const base$1 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `scale{{direction}}({{fromScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `scale{{direction}}({{toScale}})`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const baseInParams$1 = {
    delay: '0s',
    direction: '',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromScale: .5,
    startOpacity: 0,
    toScale: 1,
    xPos: '50%',
    yPos: '50%'
};
const baseOutParams$1 = Object.assign(Object.assign({}, baseInParams$1), { easing: EaseOut.sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
const scaleInCenter = animation(base$1, { params: baseInParams$1 });
const scaleInBl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '100%' })
});
const scaleInVerCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4 })
});
const scaleInTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '0' })
});
const scaleInLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '50%' })
});
const scaleInVerTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
});
const scaleInTr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '0' })
});
const scaleInTl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '0', yPos: '0' })
});
const scaleInVerBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
});
const scaleInRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '50%' })
});
const scaleInHorCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4 })
});
const scaleInBr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '100%', yPos: '100%' })
});
const scaleInHorLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
});
const scaleInBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { xPos: '50%', yPos: '100%' })
});
const scaleInHorRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseInParams$1), { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
});
const scaleOutCenter = animation(base$1, { params: baseOutParams$1 });
const scaleOutBl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '100%' })
});
const scaleOutBr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '100%' })
});
const scaleOutVerCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3 })
});
const scaleOutVerTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
});
const scaleOutVerBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
});
const scaleOutTop = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '0' })
});
const scaleOutLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '50%' })
});
const scaleOutTr = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '0' })
});
const scaleOutTl = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '0', yPos: '0' })
});
const scaleOutRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '100%', yPos: '50%' })
});
const scaleOutBottom = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { xPos: '50%', yPos: '100%' })
});
const scaleOutHorCenter = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3 })
});
const scaleOutHorLeft = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
});
const scaleOutHorRight = animation(base$1, {
    params: Object.assign(Object.assign({}, baseOutParams$1), { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
});

const base$2 = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `{{fromPosition}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `{{toPosition}}`
    }))
];
const baseInParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromPosition: 'translateY(-500px)',
    startOpacity: 0,
    toPosition: 'translateY(0)'
};
const baseOutParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    endOpacity: 0,
    fromPosition: 'translateY(0)',
    startOpacity: 1,
    toPosition: 'translateY(-500px)'
};
const slideInTop = animation(base$2, { params: baseInParams$2 });
const slideInLeft = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInRight = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateY(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
const slideInTr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInTl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInBr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideInBl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseInParams$2), { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
const slideOutTop = animation(base$2, { params: baseOutParams$2 });
const slideOutRight = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(500px)' })
});
const slideOutBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseIn.quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(500px)'
    }
});
const slideOutLeft = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { toPosition: 'translateX(-500px)' })
});
const slideOutTr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
});
const slideOutBr = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
});
const slideOutBl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
});
const slideOutTl = animation(base$2, {
    params: Object.assign(Object.assign({}, baseOutParams$2), { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
});

const swingBase = [
    style({
        opacity: `{{startOpacity}}`,
        transform: `rotate{{direction}}({{startAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{endOpacity}}`,
        transform: `rotate{{direction}}({{endAngle}}deg)`,
        transformOrigin: `{{xPos}} {{yPos}}`
    }))
];
const swingParams = {
    delay: '0s',
    direction: 'X',
    duration: '.5s',
    easing: EaseOut.back,
    endAngle: 0,
    endOpacity: 1,
    startAngle: -100,
    startOpacity: 0,
    xPos: 'top',
    yPos: 'center'
};
const swingOutParams = Object.assign(Object.assign({}, swingParams), { duration: '.55s', easing: EaseIn.back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
const swingInTopFwd = animation(swingBase, {
    params: Object.assign({}, swingParams)
});
const swingInRightFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
});
const swingInBottomFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { startAngle: 100, xPos: 'bottom' })
});
const swingInLeftFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
});
const swingInTopBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: 70 })
});
const swingInRightBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
});
const swingInBottomBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { duration: '.6s', startAngle: -70, xPos: 'bottom' })
});
const swingInLeftBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingParams), { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
});
const swingOutTopFwd = animation(swingBase, {
    params: Object.assign({}, swingOutParams)
});
const swingOutRightFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', xPos: 'center', yPos: 'right' })
});
const swingOutBottomFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { endAngle: -70, xPos: 'bottom' })
});
const swingOutLefttFwd = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
});
const swingOutTopBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: -100 })
});
const swingOutRightBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
});
const swingOutBottomBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { duration: '.45s', endAngle: 100, xPos: 'bottom' })
});
const swingOutLeftBck = animation(swingBase, {
    params: Object.assign(Object.assign({}, swingOutParams), { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
});

const base$3 = [
    style({
        opacity: `{{ startOpacity }}`,
        height: `{{ startHeight }}`
    }),
    animate(`{{duration}} {{delay}} {{easing}}`, style({
        opacity: `{{ endOpacity }}`,
        height: `{{ endHeight }}`
    }))
];
const baseParams$3 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    startOpacity: 0,
    endOpacity: 1,
    startHeight: '',
    endHeight: ''
};
const growVerIn = animation(base$3, {
    params: Object.assign(Object.assign({}, baseParams$3), { easing: EaseOut.quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
});
const growVerOut = animation(base$3, {
    params: Object.assign(Object.assign({}, baseParams$3), { easing: EaseOut.quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
});

/**
 * Common service to be injected between components where those implementing common
 * ToggleView interface can register and toggle directives can call their methods.
 * TODO: Track currently active? Events?
 */
let IgxNavigationService = class IgxNavigationService {
    constructor() {
        this.navs = {};
    }
    add(id, navItem) {
        this.navs[id] = navItem;
    }
    remove(id) {
        delete this.navs[id];
    }
    get(id) {
        if (id) {
            return this.navs[id];
        }
    }
    toggle(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].toggle(...args);
        }
    }
    open(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].open(...args);
        }
    }
    close(id, ...args) {
        if (this.navs[id]) {
            return this.navs[id].close(...args);
        }
    }
};
IgxNavigationService.ɵfac = function IgxNavigationService_Factory(t) { return new (t || IgxNavigationService)(); };
IgxNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxNavigationService, factory: IgxNavigationService.ɵfac });

/**
 * Directive that can toggle targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavToggle="ID"> Toggle </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
let IgxNavigationToggleDirective = class IgxNavigationToggleDirective {
    constructor(nav) {
        this.state = nav;
    }
    toggleNavigationDrawer() {
        this.state.toggle(this.target, true);
    }
};
IgxNavigationToggleDirective.ɵfac = function IgxNavigationToggleDirective_Factory(t) { return new (t || IgxNavigationToggleDirective)(ɵngcc0.ɵɵdirectiveInject(IgxNavigationService)); };
IgxNavigationToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavigationToggleDirective, selectors: [["", "igxNavToggle", ""]], hostBindings: function IgxNavigationToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxNavigationToggleDirective_click_HostBindingHandler() { return ctx.toggleNavigationDrawer(); });
    } }, inputs: { target: ["igxNavToggle", "target"] } });
IgxNavigationToggleDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
__decorate([
    Input('igxNavToggle')
], IgxNavigationToggleDirective.prototype, "target", void 0);
__decorate([
    HostListener('click')
], IgxNavigationToggleDirective.prototype, "toggleNavigationDrawer", null);
/**
 * Directive that can close targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavClose="ID"> Close </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
let IgxNavigationCloseDirective = class IgxNavigationCloseDirective {
    constructor(nav) {
        this.state = nav;
    }
    closeNavigationDrawer() {
        this.state.close(this.target, true);
    }
};
IgxNavigationCloseDirective.ɵfac = function IgxNavigationCloseDirective_Factory(t) { return new (t || IgxNavigationCloseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxNavigationService)); };
IgxNavigationCloseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavigationCloseDirective, selectors: [["", "igxNavClose", ""]], hostBindings: function IgxNavigationCloseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxNavigationCloseDirective_click_HostBindingHandler() { return ctx.closeNavigationDrawer(); });
    } }, inputs: { target: ["igxNavClose", "target"] } });
IgxNavigationCloseDirective.ctorParameters = () => [
    { type: IgxNavigationService }
];
__decorate([
    Input('igxNavClose')
], IgxNavigationCloseDirective.prototype, "target", void 0);
__decorate([
    HostListener('click')
], IgxNavigationCloseDirective.prototype, "closeNavigationDrawer", null);
/**
 * @hidden
 */
let IgxNavigationModule = class IgxNavigationModule {
};
IgxNavigationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxNavigationModule });
IgxNavigationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxNavigationModule_Factory(t) { return new (t || IgxNavigationModule)(); }, providers: [IgxNavigationService] });

/**
 * @hidden
 */
function cloneArray(array, deep) {
    const arr = [];
    if (!array) {
        return arr;
    }
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 */
function cloneHierarchicalArray(array, childDataKey) {
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @param obj1 Object to merge into
 * @param obj2 Object to merge from
 * @returns Obj1 with merged cloned keys from Obj2
 * @hidden
 */
function mergeObjects(obj1, obj2) {
    if (!isObject(obj1)) {
        throw new Error(`Cannot merge into ${obj1}. First param must be an object.`);
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    for (const key of Object.keys(obj2)) {
        obj1[key] = cloneValue(obj2[key]);
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @param value value to clone
 * @returns Deep copy of provided value
 * @hidden
 */
function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @param value Value to check
 * @returns true if provided variable is Object
 * @hidden
 */
function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @param value Value to check
 * @returns true if provided variable is Date
 * @hidden
 */
function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * @param obj1
 * @param obj2
 * @returns: `boolean`
 * @hidden
 */
function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 */
function getNodeSizeViaRange(range, node) {
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 */
function getNodeSizeViaCanvas(canvas2dCtx, node) {
    const s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 */
function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 */
function isEdge() {
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 */
function isFirefox() {
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
let PlatformUtil = class PlatformUtil {
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
};
PlatformUtil.ɵfac = function PlatformUtil_Factory(t) { return new (t || PlatformUtil)(ɵngcc0.ɵɵinject(PLATFORM_ID)); };
PlatformUtil.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
PlatformUtil.ɵprov = ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(ɵɵinject(PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
PlatformUtil = __decorate([ __param(0, Inject(PLATFORM_ID))
], PlatformUtil);
/**
 * @hidden
 */
function isLeftClick(event) {
    return event.button === 0;
}
/** @hidden */
function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 */
function flatten(arr) {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
const HORIZONTAL_NAV_KEYS = new Set(['arrowleft', 'left', 'arrowright', 'right', 'home', 'end']);
const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'enter', 'f2', 'escape', 'esc', 'pagedown', 'pageup']);
const HEADER_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'escape', 'esc', 'l']);
/**
 * @hidden
 * @internal
 *
 * Creates a new ResizeObserver on `target` and returns it as an Observable.
 * Run the resizeObservable outside angular zone, because it patches the MutationObserver which causes an infinite loop.
 * Related issue: https://github.com/angular/angular/issues/31712
 */
function resizeObservable(target) {
    return new Observable((observer) => {
        const instance = new ResizeObserver((entries) => {
            observer.next(entries);
        });
        instance.observe(target);
        const unsubscribe = () => instance.disconnect();
        return unsubscribe;
    });
}
/**
 * @hidden
 * @internal
 *
 * Compares two maps.
 */
function compareMaps(map1, map2) {
    if (!map2) {
        return !map1 ? true : false;
    }
    if (map1.size !== map2.size) {
        return false;
    }
    let match = true;
    const keys = Array.from(map2.keys());
    for (const key of keys) {
        if (map1.has(key)) {
            match = map1.get(key) === map2.get(key);
        }
        else {
            match = false;
        }
        if (!match) {
            break;
        }
    }
    return match;
}

/**
 * Represents sorting expressions.
 */
var SortingDirection;
(function (SortingDirection) {
    SortingDirection[SortingDirection["None"] = 0] = "None";
    SortingDirection[SortingDirection["Asc"] = 1] = "Asc";
    SortingDirection[SortingDirection["Desc"] = 2] = "Desc";
})(SortingDirection || (SortingDirection = {}));

function isHierarchyMatch(h1, h2) {
    if (h1.length !== h2.length) {
        return false;
    }
    return h1.every((level, index) => {
        return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
    });
}
function getHierarchy(gRow) {
    const hierarchy = [];
    if (gRow !== undefined && gRow.expression) {
        hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
        while (gRow.groupParent) {
            gRow = gRow.groupParent;
            hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
        }
    }
    return hierarchy;
}

class DefaultSortingStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new this());
    }
    sort(data, fieldName, dir, ignoreCase, valueResolver) {
        const key = fieldName;
        const reverse = (dir === SortingDirection.Desc ? -1 : 1);
        const cmpFunc = (obj1, obj2) => {
            return this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver);
        };
        return this.arraySort(data, cmpFunc);
    }
    compareValues(a, b) {
        const an = (a === null || a === undefined);
        const bn = (b === null || b === undefined);
        if (an) {
            if (bn) {
                return 0;
            }
            return -1;
        }
        else if (bn) {
            return 1;
        }
        return a > b ? 1 : a < b ? -1 : 0;
    }
    compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver) {
        let a = valueResolver(obj1, key);
        let b = valueResolver(obj2, key);
        if (ignoreCase) {
            a = a && a.toLowerCase ? a.toLowerCase() : a;
            b = b && b.toLowerCase ? b.toLowerCase() : b;
        }
        return reverse * this.compareValues(a, b);
    }
    arraySort(data, compareFn) {
        return data.sort(compareFn);
    }
}
DefaultSortingStrategy._instance = null;
class NoopSortingStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopSortingStrategy());
    }
    sort(data, expressions) {
        return data;
    }
}
NoopSortingStrategy._instance = null;
class IgxSorting {
    sort(data, expressions) {
        return this.sortDataRecursive(data, expressions);
    }
    groupedRecordsByExpression(data, index, expression) {
        let i;
        let groupval;
        const res = [];
        const key = expression.fieldName;
        const len = data.length;
        res.push(data[index]);
        groupval = this.getFieldValue(data[index], key);
        index++;
        const comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (i = index; i < len; i++) {
            if (comparer(this.getFieldValue(data[i], key), groupval) === 0) {
                res.push(data[i]);
            }
            else {
                break;
            }
        }
        return res;
    }
    sortDataRecursive(data, expressions, expressionIndex = 0) {
        let i;
        let j;
        let expr;
        let gbData;
        let gbDataLen;
        const exprsLen = expressions.length;
        const dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    }
    groupDataRecursive(data, state, level, parent, metadata, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const expressions = state.expressions;
        const expansion = state.expansion;
        let i = 0;
        let result = [];
        while (i < data.length) {
            const group = this.groupedRecordsByExpression(data, i, expressions[level]);
            const groupRow = {
                expression: expressions[level],
                level,
                records: cloneArray(group),
                value: group[0][expressions[level].fieldName],
                groupParent: parent,
                groups: [],
                height: grid ? grid.renderedRowHeight : null
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            const hierarchy = getHierarchy(groupRow);
            const expandState = expansion.find((s) => isHierarchyMatch(s.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
            const expanded = expandState ? expandState.expanded : state.defaultExpanded;
            let recursiveResult;
            result.push(groupRow);
            metadata.push(null);
            fullResult.data.push(groupRow);
            fullResult.metadata.push(null);
            if (level < expressions.length - 1) {
                recursiveResult = this.groupDataRecursive(group, state, level + 1, groupRow, expanded ? metadata : [], grid, groupsRecords, fullResult);
                if (expanded) {
                    result = result.concat(recursiveResult);
                }
            }
            else {
                for (const groupItem of group) {
                    fullResult.metadata.push(groupRow);
                    fullResult.data.push(groupItem);
                }
                if (expanded) {
                    metadata.push(...fullResult.metadata.slice(fullResult.metadata.length - group.length));
                    result.push(...fullResult.data.slice(fullResult.data.length - group.length));
                }
            }
            i += group.length;
        }
        return result;
    }
    getFieldValue(obj, key) {
        return obj[key];
    }
}
class IgxDataRecordSorting extends IgxSorting {
    getFieldValue(obj, key) {
        return obj.data[key];
    }
}

class IgxGrouping extends IgxSorting {
    groupBy(data, state, grid, groupsRecords, fullResult = { data: [], metadata: [] }) {
        const metadata = [];
        const grouping = this.groupDataRecursive(data, state, 0, null, metadata, grid, groupsRecords, fullResult);
        return {
            data: grouping,
            metadata: metadata
        };
    }
}

var PagingError;
(function (PagingError) {
    PagingError[PagingError["None"] = 0] = "None";
    PagingError[PagingError["IncorrectPageIndex"] = 1] = "IncorrectPageIndex";
    PagingError[PagingError["IncorrectRecordsPerPage"] = 2] = "IncorrectRecordsPerPage";
})(PagingError || (PagingError = {}));

var FilteringLogic;
(function (FilteringLogic) {
    FilteringLogic[FilteringLogic["And"] = 0] = "And";
    FilteringLogic[FilteringLogic["Or"] = 1] = "Or";
})(FilteringLogic || (FilteringLogic = {}));

var FilteringExpressionsTreeType;
(function (FilteringExpressionsTreeType) {
    FilteringExpressionsTreeType[FilteringExpressionsTreeType["Regular"] = 0] = "Regular";
    FilteringExpressionsTreeType[FilteringExpressionsTreeType["Advanced"] = 1] = "Advanced";
})(FilteringExpressionsTreeType || (FilteringExpressionsTreeType = {}));
class FilteringExpressionsTree {
    constructor(operator, fieldName) {
        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         * @memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
    }
    /**
     * Checks if filtering expressions tree is empty.
     * @param expressionTree filtering expressions tree.
     */
    static empty(expressionTree) {
        return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
    }
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * @memberof FilteringExpressionsTree
     */
    find(fieldName) {
        const index = this.findIndex(fieldName);
        if (index > -1) {
            return this.filteringOperands[index];
        }
        return null;
    }
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * @memberof FilteringExpressionsTree
     */
    findIndex(fieldName) {
        let expr;
        for (let i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];
            if (expr instanceof FilteringExpressionsTree) {
                if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                    return i;
                }
            }
            else {
                if (expr.fieldName === fieldName) {
                    return i;
                }
            }
        }
        return -1;
    }
    isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {
        if (expressionsTree.fieldName === fieldName) {
            return true;
        }
        let expr;
        for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
            expr = expressionsTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            }
            else {
                return expr.fieldName === fieldName;
            }
        }
        return false;
    }
}

class NoopFilteringStrategy {
    constructor() { }
    static instance() {
        return this._instance || (this._instance = new NoopFilteringStrategy());
    }
    filter(data, expressionsTree, advancedExpressionsTree) {
        return data;
    }
}
NoopFilteringStrategy._instance = null;
class BaseFilteringStrategy {
    findMatchByExpression(rec, expr) {
        const cond = expr.condition;
        const val = this.getFieldValue(rec, expr.fieldName);
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    }
    matchRecord(rec, expressions) {
        if (expressions) {
            if (expressions instanceof FilteringExpressionsTree) {
                const expressionsTree = expressions;
                const operator = expressionsTree.operator;
                let matchOperand, operand;
                if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                    for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                        operand = expressionsTree.filteringOperands[i];
                        matchOperand = this.matchRecord(rec, operand);
                        // Return false if at least one operand does not match and the filtering logic is And
                        if (!matchOperand && operator === FilteringLogic.And) {
                            return false;
                        }
                        // Return true if at least one operand matches and the filtering logic is Or
                        if (matchOperand && operator === FilteringLogic.Or) {
                            return true;
                        }
                    }
                    return matchOperand;
                }
                return true;
            }
            else {
                const expression = expressions;
                return this.findMatchByExpression(rec, expression);
            }
        }
        return true;
    }
}
class FilteringStrategy extends BaseFilteringStrategy {
    constructor() { super(); }
    static instance() {
        return this._instace || (this._instace = new this());
    }
    filter(data, expressionsTree, advancedExpressionsTree) {
        let i;
        let rec;
        const len = data.length;
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = data[i];
            if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
                res.push(rec);
            }
        }
        return res;
    }
    getFieldValue(rec, fieldName) {
        return rec[fieldName];
    }
}
FilteringStrategy._instace = null;

var TransactionType;
(function (TransactionType) {
    TransactionType["ADD"] = "add";
    TransactionType["DELETE"] = "delete";
    TransactionType["UPDATE"] = "update";
})(TransactionType || (TransactionType = {}));

/**
 * @hidden
 */
var DataType;
(function (DataType) {
    DataType["String"] = "string";
    DataType["Number"] = "number";
    DataType["Boolean"] = "boolean";
    DataType["Date"] = "date";
})(DataType || (DataType = {}));
/**
 * @hidden
 */
class DataUtil {
    static sort(data, expressions, sorting = new IgxSorting()) {
        return sorting.sort(data, expressions);
    }
    static treeGridSort(hierarchicalData, expressions, sorting = new IgxDataRecordSorting(), parent) {
        let res = [];
        hierarchicalData.forEach((hr) => {
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, sorting, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, sorting);
        return res;
    }
    static cloneTreeGridRecord(hierarchicalRecord) {
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    static group(data, state, grid = null, groupsRecords = [], fullResult = { data: [], metadata: [] }) {
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    }
    static page(data, state) {
        if (!state) {
            return data;
        }
        const len = data.length;
        const index = state.index;
        const res = [];
        const recordsPerPage = state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    static filter(data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    }
    static correctPagingState(state, length) {
        const maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    }
    static getHierarchy(gRow) {
        return getHierarchy(gRow);
    }
    static isHierarchyMatch(h1, h2) {
        return isHierarchyMatch(h1, h2);
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            const rowId = primaryKey ? item[primaryKey] : item;
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    static parseValue(dataType, value) {
        if (dataType === DataType.Number) {
            value = parseFloat(value);
        }
        return value;
    }
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        let collection = data;
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}

/**
 * @hidden
 */
class ExportUtilities {
    static getKeysFromData(data) {
        const length = data.length;
        if (length === 0) {
            return [];
        }
        const dataEntry = data[0];
        const dataEntryMiddle = data[Math.floor(length / 2)];
        const dataEntryLast = data[length - 1];
        const keys1 = Object.keys(dataEntry);
        const keys2 = Object.keys(dataEntryMiddle);
        const keys3 = Object.keys(dataEntryLast);
        const keys = new Set(keys1.concat(keys2).concat(keys3));
        return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
    }
    static saveBlobToFile(blob, fileName) {
        const a = document.createElement('a');
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        }
        else {
            const url = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    }
    static stringToArrayBuffer(s) {
        const buf = new ArrayBuffer(s.length);
        const view = new Uint8Array(buf);
        for (let i = 0; i !== s.length; ++i) {
            /* tslint:disable no-bitwise */
            view[i] = s.charCodeAt(i) & 0xFF;
            /* tslint:enable no-bitwise */
        }
        return buf;
    }
    static isSpecialData(data) {
        const dataEntry = data[0];
        return (typeof dataEntry === 'string' ||
            typeof dataEntry === 'number' ||
            dataEntry instanceof Date);
    }
    static hasValue(value) {
        return value !== undefined && value !== null;
    }
    static isNullOrWhitespaces(value) {
        return value === undefined || value === null || !value.trim();
    }
}

/**
 * @hidden
 */
let GridBaseAPIService = class GridBaseAPIService {
    constructor() {
        this.destroyMap = new Map();
    }
    get_column_by_name(name) {
        return this.grid.columnList.find((col) => col.field === name);
    }
    get_summary_data() {
        const grid = this.grid;
        let data = grid.filteredData;
        if (data && grid.hasPinnedRecords) {
            data = grid._filteredUnpinnedData;
        }
        if (!data) {
            if (grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
                deletedRows.forEach(rowID => {
                    const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                    const index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            else {
                data = grid.data;
            }
        }
        return data;
    }
    /**
     * @hidden
     * @internal
     */
    getRowData(rowID) {
        const data = this.get_all_data(this.grid.transactions.enabled);
        const index = this.get_row_index_in_data(rowID);
        return data[index];
    }
    // TODO: Refactor
    escape_editMode() {
        this.grid.crudService.end();
    }
    // TODO: Refactor
    get_cell_inEditMode() {
        return this.grid.crudService.cell;
    }
    get_row_index_in_data(rowID) {
        const grid = this.grid;
        if (!grid) {
            return -1;
        }
        const data = this.get_all_data(grid.transactions.enabled);
        return grid.primaryKey ? data.findIndex(record => record[grid.primaryKey] === rowID) : data.indexOf(rowID);
    }
    get_row_by_key(rowSelector) {
        if (!this.grid) {
            return null;
        }
        const primaryKey = this.grid.primaryKey;
        if (primaryKey !== undefined && primaryKey !== null) {
            return this.grid.dataRowList.find((row) => row.rowData[primaryKey] === rowSelector);
        }
        else {
            return this.grid.dataRowList.find((row) => row.rowData === rowSelector);
        }
    }
    get_row_by_index(rowIndex) {
        return this.grid.rowList.find((row) => row.index === rowIndex);
    }
    get_cell_by_key(rowSelector, field) {
        const row = this.get_row_by_key(rowSelector);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.column.field === field);
        }
    }
    get_cell_by_index(rowIndex, columnIndex) {
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.columnIndex === columnIndex);
        }
    }
    get_cell_by_visible_index(rowIndex, columnIndex) {
        const row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find((cell) => cell.visibleColumnIndex === columnIndex);
        }
    }
    submit_value() {
        const cell = this.grid.crudService.cell;
        if (cell) {
            const args = this.update_cell(cell, cell.editValue);
            if (args.cancel) {
                return;
            }
            this.escape_editMode();
        }
    }
    update_cell(cell, value) {
        const data = this.get_all_data(this.grid.transactions.enabled);
        const index = this.get_row_index_in_data(cell.id.rowID);
        cell.editValue = value;
        const args = cell.createEditEventArgs();
        this.grid.onCellEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        // Cast to number after emit
        // TODO: Clean up this
        args.newValue = cell.castToNumber(args.newValue);
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.summaryService.clearSummaryCache(args);
        this.updateData(this.grid, cell.id.rowID, data[index], cell.rowData, { [cell.column.field]: args.newValue });
        if (this.grid.primaryKey === cell.column.field) {
            if (this.grid.selectionService.isRowSelected(cell.id.rowID)) {
                this.grid.selectionService.deselectRow(cell.id.rowID);
                this.grid.selectionService.selectRowById(args.newValue);
            }
            if (this.grid.hasSummarizedColumns) {
                this.grid.summaryService.removeSummaries(cell.id.rowID);
            }
        }
        if (!this.grid.rowEditable || !this.grid.crudService.row ||
            this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
            this.grid.summaryService.clearSummaryCache(args);
            this.grid._pipeTrigger++;
        }
        return args;
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    _update_row(row, value) {
        const grid = this.grid;
        const rowInEditMode = grid.crudService.row;
        row.newData = value ? value : grid.transactions.getAggregatedValue(row.id, true);
        if (rowInEditMode && row.id === rowInEditMode.id) {
            row.data = Object.assign(Object.assign({}, row.data), rowInEditMode.transactionState);
            // TODO: Workaround for updating a row in edit mode through the API
        }
        else if (this.grid.transactions.enabled) {
            const state = grid.transactions.getState(row.id);
            row.data = state ? Object.assign({}, row.data, state.value) : row.data;
        }
    }
    update_row(row, value) {
        const grid = this.grid;
        const selected = grid.selectionService.isRowSelected(row.id);
        const rowInEditMode = grid.crudService.row;
        const data = this.get_all_data(grid.transactions.enabled);
        const index = this.get_row_index_in_data(row.id);
        const hasSummarized = grid.hasSummarizedColumns;
        this._update_row(row, value);
        const args = row.createEditEventArgs();
        // If no valid row is found
        if (index === -1) {
            return args;
        }
        grid.onRowEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        if (rowInEditMode) {
            const hasChanges = grid.transactions.getState(args.rowID, true);
            grid.transactions.endPending(false);
            if (!hasChanges) {
                return args;
            }
        }
        if (!args.newValue) {
            return args;
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(args.rowID);
        }
        this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
        const newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
        if (selected) {
            grid.selectionService.deselectRow(row.id);
            grid.selectionService.selectRowById(newId);
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(newId);
        }
        grid._pipeTrigger++;
        return args;
    }
    update_row_in_array(value, rowID, index) {
        const grid = this.grid;
        grid.data[index] = value;
    }
    sort(expression) {
        if (expression.dir === SortingDirection.None) {
            this.remove_grouping_expression(expression.fieldName);
        }
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState], expression);
        this.grid.sortingExpressions = sortingState;
    }
    sort_multiple(expressions) {
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            if (each.dir === SortingDirection.None) {
                this.remove_grouping_expression(each.fieldName);
            }
            this.prepare_sorting_expression([sortingState], each);
        }
        this.grid.sortingExpressions = sortingState;
    }
    filter(fieldName, term, conditionOrExpressionsTree, ignoreCase) {
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        const fieldFilterIndex = filteringTree.findIndex(fieldName);
        if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
        }
        this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
        grid.filteringExpressionsTree = filteringTree;
    }
    filter_global(term, condition, ignoreCase) {
        if (!condition) {
            return;
        }
        const grid = this.grid;
        const filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        filteringTree.filteringOperands = [];
        for (const column of grid.columns) {
            this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
        }
        grid.filteringExpressionsTree = filteringTree;
    }
    clear_filter(fieldName) {
        const grid = this.grid;
        grid.endEdit(false);
        const filteringState = grid.filteringExpressionsTree;
        const index = filteringState.findIndex(fieldName);
        if (index > -1) {
            filteringState.filteringOperands.splice(index, 1);
        }
        else if (!fieldName) {
            filteringState.filteringOperands = [];
        }
        grid.filteringExpressionsTree = filteringState;
    }
    clear_sort(fieldName) {
        const sortingState = this.grid.sortingExpressions;
        const index = sortingState.findIndex((expr) => expr.fieldName === fieldName);
        if (index > -1) {
            sortingState.splice(index, 1);
            this.grid.sortingExpressions = sortingState;
        }
    }
    prepare_filtering_expression(filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex = -1) {
        let newExpressionsTree;
        const oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
        const expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            conditionOrExpressionsTree : null;
        const condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            null : conditionOrExpressionsTree;
        const newExpression = { fieldName, searchVal, condition, ignoreCase };
        if (oldExpressionsTreeIndex === -1) {
            // no expressions tree found for this field
            if (expressionsTree) {
                if (insertAtIndex > -1) {
                    filteringState.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                }
                else {
                    filteringState.filteringOperands.push(expressionsTree);
                }
            }
            else if (condition) {
                // create expressions tree for this field and add the new expression to it
                newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                newExpressionsTree.filteringOperands.push(newExpression);
                filteringState.filteringOperands.push(newExpressionsTree);
            }
        }
    }
    prepare_sorting_expression(stateCollections, expression) {
        if (expression.dir === SortingDirection.None) {
            stateCollections.forEach(state => {
                state.splice(state.findIndex((expr) => expr.fieldName === expression.fieldName), 1);
            });
            return;
        }
        /**
         * We need to make sure the states in each collection with same fields point to the same object reference.
         * If the different state collections provided have different sizes we need to get the largest one.
         * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
         */
        let maxCollection = stateCollections[0];
        for (let i = 1; i < stateCollections.length; i++) {
            if (maxCollection.length < stateCollections[i].length) {
                maxCollection = stateCollections[i];
            }
        }
        const maxExpr = maxCollection.find((expr) => expr.fieldName === expression.fieldName);
        stateCollections.forEach(collection => {
            const myExpr = collection.find((expr) => expr.fieldName === expression.fieldName);
            if (!myExpr && !maxExpr) {
                // Expression with this fieldName is missing from the current and the max collection.
                collection.push(expression);
            }
            else if (!myExpr && maxExpr) {
                // Expression with this fieldName is missing from the current and but the max collection has.
                collection.push(maxExpr);
                Object.assign(maxExpr, expression);
            }
            else {
                // The current collection has the expression so just update it.
                Object.assign(myExpr, expression);
            }
        });
    }
    remove_grouping_expression(fieldName) {
    }
    clear_groupby(name) {
    }
    should_apply_number_style(column) {
        return column.dataType === DataType.Number;
    }
    get_data() {
        const grid = this.grid;
        const data = grid.data ? grid.data : [];
        return data;
    }
    get_all_data(includeTransactions = false) {
        const grid = this.grid;
        let data = grid.data ? grid.data : [];
        data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
        return data;
    }
    get_filtered_data() {
        return this.grid.filteredData;
    }
    getSortStrategyPerColumn(fieldName) {
        return this.get_column_by_name(fieldName) ?
            this.get_column_by_name(fieldName).sortStrategy : undefined;
    }
    addRowToData(rowData) {
        // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
        // If there is a row in edit - > commit and close
        const grid = this.grid;
        if (grid.transactions.enabled) {
            const transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
            const transaction = { id: transactionId, type: TransactionType.ADD, newValue: rowData };
            grid.transactions.add(transaction);
        }
        else {
            grid.data.push(rowData);
        }
    }
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        const grid = this.grid;
        if (index !== -1) {
            if (grid.transactions.enabled) {
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                grid.transactions.add(transaction, grid.data[index]);
            }
            else {
                grid.data.splice(index, 1);
            }
        }
        else {
            const state = grid.transactions.getState(rowID);
            grid.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    deleteRowById(rowId) {
        let index;
        const grid = this.grid;
        const data = this.get_all_data();
        if (grid.primaryKey) {
            index = data.map((record) => record[grid.primaryKey]).indexOf(rowId);
        }
        else {
            index = data.indexOf(rowId);
        }
        const state = grid.transactions.getState(rowId);
        const hasRowInNonDeletedState = state && state.type !== TransactionType.DELETE;
        //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
        //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
        //  Otherwise just exit - there is nothing to delete
        if (index !== -1 || hasRowInNonDeletedState) {
            // Always exit edit when row is deleted
            grid.endEdit(true);
        }
        else {
            return;
        }
        //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
        grid.onRowDeleted.emit({ data: data[index] });
        this.deleteRowFromData(rowId, index);
        grid.selectionService.isRowSelected(rowId) ? grid.selectionService.deselectRow(rowId) : grid.selectionService.clearHeaderCBState();
        grid._pipeTrigger++;
        grid.notifyChanges();
        // Data needs to be recalculated if transactions are in place
        // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
        const dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
        grid.refreshSearch();
        if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
            grid.page--;
        }
    }
    get_row_id(rowData) {
        return this.grid.primaryKey ? rowData[this.grid.primaryKey] : rowData;
    }
    row_deleted_transaction(rowID) {
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if (!grid.transactions.enabled) {
            return false;
        }
        const state = grid.transactions.getState(rowID);
        if (state) {
            return state.type === TransactionType.DELETE;
        }
        return false;
    }
    atInexistingPage() {
        return this.grid.totalPages - 1 > this.grid.page;
    }
    get_row_expansion_state(record) {
        const grid = this.grid;
        const states = grid.expansionStates;
        const rowID = grid.primaryKey ? record[grid.primaryKey] : record;
        const expanded = states.get(rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return grid.getDefaultExpandState(record);
        }
    }
    set_row_expansion_state(rowID, expanded, event) {
        const grid = this.grid;
        const expandedStates = grid.expansionStates;
        if (!this.allow_expansion_state_change(rowID, expanded)) {
            return;
        }
        const args = {
            rowID: rowID,
            expanded: expanded,
            event: event,
            cancel: false
        };
        grid.onRowToggle.emit(args);
        if (args.cancel) {
            return;
        }
        expandedStates.set(rowID, expanded);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    get_rec_by_id(rowID) {
        return this.grid.primaryKey ? this.getRowData(rowID) : rowID;
    }
    allow_expansion_state_change(rowID, expanded) {
        return this.grid.expansionStates.get(rowID) !== expanded;
    }
    isToggleKey(key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    }
};
GridBaseAPIService.ɵfac = function GridBaseAPIService_Factory(t) { return new (t || GridBaseAPIService)(); };
GridBaseAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: GridBaseAPIService, factory: GridBaseAPIService.ɵfac });

/** @hidden */
class TreeGridFilteringStrategy extends BaseFilteringStrategy {
    filter(data, expressionsTree, advancedExpressionsTree) {
        return this.filterImpl(data, expressionsTree, advancedExpressionsTree, undefined);
    }
    filterImpl(data, expressionsTree, advancedExpressionsTree, parent) {
        let i;
        let rec;
        const len = data.length;
        const res = [];
        if ((FilteringExpressionsTree.empty(expressionsTree) && FilteringExpressionsTree.empty(advancedExpressionsTree)) || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = DataUtil.cloneTreeGridRecord(data[i]);
            rec.parent = parent;
            if (rec.children) {
                const filteredChildren = this.filterImpl(rec.children, expressionsTree, advancedExpressionsTree, rec);
                rec.children = filteredChildren.length > 0 ? filteredChildren : null;
            }
            if (this.matchRecord(rec, expressionsTree) && this.matchRecord(rec, advancedExpressionsTree)) {
                res.push(rec);
            }
            else if (rec.children && rec.children.length > 0) {
                rec.isFilteredOutParent = true;
                res.push(rec);
            }
        }
        return res;
    }
    getFieldValue(rec, fieldName) {
        const hierarchicalRecord = rec;
        return hierarchicalRecord.data[fieldName];
    }
}
/** @hidden */
let IgxTreeGridFilteringPipe = class IgxTreeGridFilteringPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(hierarchyData, expressionsTree, filterStrategy, advancedFilteringExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        const state = {
            expressionsTree: expressionsTree,
            advancedExpressionsTree: advancedFilteringExpressionsTree,
            strategy: new TreeGridFilteringStrategy()
        };
        if (filterStrategy) {
            state.strategy = filterStrategy;
        }
        this.resetFilteredOutProperty(grid.records);
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            grid.setFilterData(null, pinned);
            return hierarchyData;
        }
        const result = this.filter(hierarchyData, state);
        const filteredData = [];
        this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
        grid.setFilterData(filteredData, pinned);
        return result;
    }
    resetFilteredOutProperty(map) {
        const keys = Array.from(map.keys());
        for (let i = 0; i < keys.length; i++) {
            map.get(keys[i]).isFilteredOutParent = undefined;
        }
    }
    expandAllRecursive(grid, data, expandedStates, filteredData) {
        for (let i = 0; i < data.length; i++) {
            const rec = data[i];
            filteredData.push(rec.data);
            this.updateNonProcessedRecord(grid, rec);
            if (rec.children && rec.children.length > 0) {
                expandedStates.set(rec.rowID, true);
                this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
            }
        }
    }
    updateNonProcessedRecord(grid, record) {
        const rec = grid.records.get(record.rowID);
        rec.isFilteredOutParent = record.isFilteredOutParent;
    }
    filter(data, state) {
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    }
};
IgxTreeGridFilteringPipe.ɵfac = function IgxTreeGridFilteringPipe_Factory(t) { return new (t || IgxTreeGridFilteringPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridFilteringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridFiltering", type: IgxTreeGridFilteringPipe, pure: true });
IgxTreeGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

class IgxBaseExporter {
    constructor() {
        this.flatRecords = [];
        this._isTreeGrid = false;
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        /**
         * This event is emitted when a row is exported.
         * ```typescript
         * this.exporterService.onRowExport.subscribe((args: IRowExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxBaseExporter
         */
        this.onRowExport = new EventEmitter();
        /**
         * This event is emitted when a column is exported.
         * ```typescript
         * this.exporterService.onColumnExport.subscribe((args: IColumnExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxBaseExporter
         */
        this.onColumnExport = new EventEmitter();
    }
    /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     * @memberof IgxBaseExporter
     */
    export(grid, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        const columns = grid.columnList.toArray();
        this._columnList = new Array(columns.length);
        const hiddenColumns = [];
        let lastVisbleColumnIndex = -1;
        columns.forEach((column) => {
            const columnHeader = column.header !== '' ? column.header : column.field;
            const exportColumn = !column.hidden || options.ignoreColumnsVisibility;
            const index = options.ignoreColumnsOrder ? column.index : column.visibleIndex;
            const columnInfo = {
                header: columnHeader,
                field: column.field,
                skip: !exportColumn,
                formatter: column.formatter,
                skipFormatter: false
            };
            if (index !== -1) {
                this._columnList[index] = columnInfo;
                lastVisbleColumnIndex = Math.max(lastVisbleColumnIndex, index);
            }
            else {
                hiddenColumns.push(columnInfo);
            }
            if (column.pinned && exportColumn) {
                this._indexOfLastPinnedColumn++;
            }
        });
        // Append the hidden columns to the end of the list
        hiddenColumns.forEach((hiddenColumn) => {
            this._columnList[++lastVisbleColumnIndex] = hiddenColumn;
        });
        const data = this.prepareData(grid, options);
        this.exportData(data, options);
    }
    /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     * @memberof IgxBaseExporter
     */
    exportData(data, options) {
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        if (!this._columnList || this._columnList.length === 0) {
            const keys = ExportUtilities.getKeysFromData(data);
            this._columnList = keys.map((k) => ({ header: k, field: k, skip: false }));
        }
        let skippedPinnedColumnsCount = 0;
        let columnsWithoutHeaderCount = 1;
        this._columnList.forEach((column, index) => {
            if (!column.skip) {
                const columnExportArgs = {
                    header: ExportUtilities.isNullOrWhitespaces(column.header) ?
                        'Column' + columnsWithoutHeaderCount++ : column.header,
                    field: column.field,
                    columnIndex: index,
                    cancel: false,
                    skipFormatter: false
                };
                this.onColumnExport.emit(columnExportArgs);
                column.header = columnExportArgs.header;
                column.skip = columnExportArgs.cancel;
                column.skipFormatter = columnExportArgs.skipFormatter;
                if (column.skip && index <= this._indexOfLastPinnedColumn) {
                    skippedPinnedColumnsCount++;
                }
                if (this._sort && this._sort.fieldName === column.field) {
                    if (column.skip) {
                        this._sort = null;
                    }
                    else {
                        this._sort.fieldName = column.header;
                    }
                }
            }
        });
        this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
        const dataToExport = new Array();
        const isSpecialData = ExportUtilities.isSpecialData(data);
        data.forEach((row, index) => {
            this.exportRow(dataToExport, row, index, isSpecialData);
        });
        this.exportDataImplementation(dataToExport, options);
        this.resetDefaults();
    }
    exportRow(data, rowData, index, isSpecialData) {
        let row;
        if (!isSpecialData) {
            row = this._columnList.reduce((a, e) => {
                if (!e.skip) {
                    const rawValue = this._isTreeGrid ? rowData.data[e.field] : rowData[e.field];
                    a[e.header] = e.formatter && !e.skipFormatter ? e.formatter(rawValue) : rawValue;
                }
                return a;
            }, {});
        }
        else {
            row = this._isTreeGrid ? rowData.data : rowData;
        }
        const rowArgs = {
            rowData: row,
            rowIndex: index,
            cancel: false
        };
        this.onRowExport.emit(rowArgs);
        if (!rowArgs.cancel) {
            data.push({ rowData: rowArgs.rowData, originalRowData: rowData });
        }
    }
    prepareData(grid, options) {
        this.flatRecords = [];
        let rootRecords = grid.rootRecords;
        this._isTreeGrid = rootRecords !== undefined;
        if (this._isTreeGrid) {
            this.prepareHierarchicalData(rootRecords);
        }
        let data = this._isTreeGrid ? this.flatRecords : grid.data;
        if (((grid.filteringExpressionsTree &&
            grid.filteringExpressionsTree.filteringOperands.length > 0) ||
            (grid.advancedFilteringExpressionsTree &&
                grid.advancedFilteringExpressionsTree.filteringOperands.length > 0)) &&
            !options.ignoreFiltering) {
            const filteringState = {
                expressionsTree: grid.filteringExpressionsTree,
                advancedExpressionsTree: grid.advancedFilteringExpressionsTree,
                logic: grid.filteringLogic
            };
            if (this._isTreeGrid) {
                this.flatRecords = [];
                filteringState.strategy = (grid.filterStrategy) ? grid.filterStrategy : new TreeGridFilteringStrategy();
                rootRecords = filteringState.strategy.filter(rootRecords, filteringState.expressionsTree, filteringState.advancedExpressionsTree);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                filteringState.strategy = grid.filterStrategy;
                data = DataUtil.filter(data, filteringState);
            }
        }
        if (grid.sortingExpressions &&
            grid.sortingExpressions.length > 0 &&
            !options.ignoreSorting) {
            this._sort = cloneValue(grid.sortingExpressions[0]);
            if (this._isTreeGrid) {
                this.flatRecords = [];
                rootRecords = DataUtil.treeGridSort(rootRecords, grid.sortingExpressions, grid.sortStrategy);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                data = DataUtil.sort(data, grid.sortingExpressions, grid.sortStrategy);
            }
        }
        return data;
    }
    prepareHierarchicalData(records) {
        if (!records) {
            return;
        }
        for (let i = 0; i < records.length; i++) {
            const hierarchicalRecord = records[i];
            this.flatRecords.push(hierarchicalRecord);
            this.prepareHierarchicalData(hierarchicalRecord.children);
        }
    }
    resetDefaults() {
        this._columnList = [];
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.flatRecords = [];
    }
}

/**
 * @hidden
 */
class CharSeparatedValueData {
    constructor(_data, valueDelimiter) {
        this._data = _data;
        this._headerRecord = '';
        this._dataRecords = '';
        this._eor = '\r\n';
        this._escapeCharacters = ['\r', '\n', '\r\n'];
        this._delimiterLength = 1;
        this._isSpecialData = false;
        this.setDelimiter(valueDelimiter);
    }
    prepareData() {
        if (!this._data || this._data.length === 0) {
            return '';
        }
        const keys = ExportUtilities.getKeysFromData(this._data);
        if (keys.length === 0) {
            return '';
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
        this._dataRecords = this.processDataRecords(this._data, keys, this._escapeCharacters);
        return this._headerRecord + this._dataRecords;
    }
    processField(value, escapeChars) {
        let safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
        if (escapeChars.some((v) => safeValue.includes(v))) {
            safeValue = `"${safeValue}"`;
        }
        return safeValue + this._delimiter;
    }
    processHeaderRecord(keys, escapeChars) {
        let recordData = '';
        for (const keyName of keys) {
            recordData += this.processField(keyName, this._escapeCharacters);
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    }
    processRecord(record, keys, escapeChars) {
        let recordData = '';
        for (const keyName of keys) {
            const value = (record[keyName] !== undefined) ? record[keyName] : this._isSpecialData ? record : '';
            recordData += this.processField(value, this._escapeCharacters);
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    }
    processDataRecords(currentData, keys, escapeChars) {
        let dataRecords = '';
        for (const row of currentData) {
            dataRecords += this.processRecord(row, keys, escapeChars);
        }
        return dataRecords;
    }
    setDelimiter(value) {
        this._delimiter = value;
        this._delimiterLength = value.length;
    }
}

class IgxExporterOptionsBase {
    constructor(fileName, _fileExtension) {
        this._fileExtension = _fileExtension;
        /**
         * Specifies whether hidden columns should be exported.
         * ```typescript
         * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
         * this.exportOptions.ignoreColumnsVisibility = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsVisibility = false;
        /**
         * Specifies whether filtered out rows should be exported.
         * ```typescript
         * let ignoreFiltering = this.exportOptions.ignoreFiltering;
         * this.exportOptions.ignoreFiltering = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreFiltering = false;
        /**
         * Specifies if the exporter should ignore the current column order in the IgxGrid.
         * ```typescript
         * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
         * this.exportOptions.ignoreColumnsOrder = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsOrder = false;
        /**
         * Specifies whether the exported data should be sorted as in the provided IgxGrid.
         * ```typescript
         * let ignoreSorting = this.exportOptions.ignoreSorting;
         * this.exportOptions.ignoreSorting = true;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        this.ignoreSorting = false;
        this.setFileName(fileName);
    }
    setFileName(fileName) {
        this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
    }
    /**
     * Gets the file name which will be used for the exporting operation.
     * ```typescript
     * let fileName = this.exportOptions.fileName;
     * ```
     * @memberof IgxExporterOptionsBase
     */
    get fileName() {
        return this._fileName;
    }
    /**
     * Sets the file name which will be used for the exporting operation.
     * ```typescript
     * this.exportOptions.fileName = 'exportedData01';
     * ```
     * @memberof IgxExporterOptionsBase
     */
    set fileName(value) {
        this.setFileName(value);
    }
}

/**
 * Objects of this class are used to configure the CSV exporting process.
 */
class IgxCsvExporterOptions extends IgxExporterOptionsBase {
    constructor(fileName, fileType) {
        super(fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType));
        this.setFileType(fileType);
        this.setDelimiter();
    }
    static getExtensionFromFileType(fType) {
        let extension = '';
        switch (fType) {
            case CsvFileTypes.CSV:
                extension = '.csv';
                break;
            case CsvFileTypes.TSV:
                extension = '.tsv';
                break;
            case CsvFileTypes.TAB:
                extension = '.tab';
                break;
            default:
                throw Error('Unsupported CSV file type!');
        }
        return extension;
    }
    /**
     * Gets the value delimiter which will be used for the exporting operation.
     * ```typescript
     * let delimiter = this.exportOptions.valueDelimiter;
     * ```
     * @memberof IgxCsvExporterOptions
     */
    get valueDelimiter() {
        return this._valueDelimiter;
    }
    /**
     * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
     * ```typescript
     * this.exportOptions.valueDelimiter = '|';
     * ```
     * @memberof IgxCsvExporterOptions
     */
    set valueDelimiter(value) {
        this.setDelimiter(value);
    }
    /**
     * Gets the CSV export format.
     * ```typescript
     * let filetype = this.exportOptions.fileType;
     * ```
     * @memberof IgxCsvExporterOptions
     */
    get fileType() {
        return this._fileType;
    }
    /**
     * Sets the CSV export format.
     * ```typescript
     * this.exportOptions.fileType = CsvFileTypes.TAB;
     * ```
     * @memberof IgxCsvExporterOptions
     */
    set fileType(value) {
        this.setFileType(value);
    }
    setFileType(value) {
        if (value !== undefined && value !== null && value !== this._fileType) {
            this._fileType = value;
            const extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
            if (!this.fileName.endsWith(extension)) {
                const oldExt = '.' + this.fileName.split('.').pop();
                const newName = this.fileName.replace(oldExt, extension);
                this._fileExtension = extension;
                this.fileName = newName;
            }
        }
    }
    setDelimiter(value) {
        if (value !== undefined && value !== '' && value !== null) {
            this._valueDelimiter = value;
        }
        else {
            switch (this.fileType) {
                case CsvFileTypes.CSV:
                    this._valueDelimiter = ',';
                    break;
                case CsvFileTypes.TSV:
                case CsvFileTypes.TAB:
                    this._valueDelimiter = '\t';
                    break;
            }
        }
    }
}
/**
 * This enumeration is used to configure the default value separator
 * as well as the default file extension used when performing CSV exporting.
 */
var CsvFileTypes;
(function (CsvFileTypes) {
    /**
     * Character Separated Values, default separator is "comma", default file extension is .csv
     */
    CsvFileTypes[CsvFileTypes["CSV"] = 0] = "CSV";
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tsv
     */
    CsvFileTypes[CsvFileTypes["TSV"] = 1] = "TSV";
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tab
     */
    CsvFileTypes[CsvFileTypes["TAB"] = 2] = "TAB";
})(CsvFileTypes || (CsvFileTypes = {}));

/**
 * **Ignite UI for Angular CSV Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_csv.html)
 *
 * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
 * both raw data (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private csvExportService: IgxCsvExporterService) {
 * }
 *
 * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
 * this.csvExportService.exportData(this.localData, opt);
 * ```
 */
let IgxCsvExporterService = class IgxCsvExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxCsvExporterService
         */
        this.onExportEnded = new EventEmitter();
    }
    exportDataImplementation(data, options) {
        data = data.map((item) => item.rowData);
        const csvData = new CharSeparatedValueData(data, options.valueDelimiter);
        this._stringData = csvData.prepareData();
        this.saveFile(options);
        this.onExportEnded.emit({ csvData: this._stringData });
    }
    saveFile(options) {
        switch (options.fileType) {
            case CsvFileTypes.CSV:
                this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                break;
            case CsvFileTypes.TSV:
            case CsvFileTypes.TAB:
                this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                break;
        }
    }
    exportFile(data, fileName, fileType) {
        const blob = new Blob(['\ufeff', data], { type: fileType });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
};
IgxCsvExporterService.ɵfac = function IgxCsvExporterService_Factory(t) { return ɵIgxCsvExporterService_BaseFactory(t || IgxCsvExporterService); };
IgxCsvExporterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxCsvExporterService, factory: IgxCsvExporterService.ɵfac });
__decorate([
    Output()
], IgxCsvExporterService.prototype, "onExportEnded", void 0);

/**
 * @hidden
 */
var ExcelFolderTypes;
(function (ExcelFolderTypes) {
    ExcelFolderTypes[ExcelFolderTypes["RootExcelFolder"] = 0] = "RootExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["RootRelsExcelFolder"] = 1] = "RootRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["DocPropsExcelFolder"] = 2] = "DocPropsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["XLExcelFolder"] = 3] = "XLExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["XLRelsExcelFolder"] = 4] = "XLRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["ThemeExcelFolder"] = 5] = "ThemeExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["WorksheetsExcelFolder"] = 6] = "WorksheetsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["WorksheetsRelsExcelFolder"] = 7] = "WorksheetsRelsExcelFolder";
    ExcelFolderTypes[ExcelFolderTypes["TablesExcelFolder"] = 8] = "TablesExcelFolder";
})(ExcelFolderTypes || (ExcelFolderTypes = {}));
/**
 * @hidden
 */
var ExcelFileTypes;
(function (ExcelFileTypes) {
    ExcelFileTypes[ExcelFileTypes["RootRelsFile"] = 0] = "RootRelsFile";
    ExcelFileTypes[ExcelFileTypes["AppFile"] = 1] = "AppFile";
    ExcelFileTypes[ExcelFileTypes["CoreFile"] = 2] = "CoreFile";
    ExcelFileTypes[ExcelFileTypes["WorkbookRelsFile"] = 3] = "WorkbookRelsFile";
    ExcelFileTypes[ExcelFileTypes["ThemeFile"] = 4] = "ThemeFile";
    ExcelFileTypes[ExcelFileTypes["WorksheetFile"] = 5] = "WorksheetFile";
    ExcelFileTypes[ExcelFileTypes["StyleFile"] = 6] = "StyleFile";
    ExcelFileTypes[ExcelFileTypes["WorkbookFile"] = 7] = "WorkbookFile";
    ExcelFileTypes[ExcelFileTypes["ContentTypesFile"] = 8] = "ContentTypesFile";
    ExcelFileTypes[ExcelFileTypes["SharedStringsFile"] = 9] = "SharedStringsFile";
    ExcelFileTypes[ExcelFileTypes["WorksheetRelsFile"] = 10] = "WorksheetRelsFile";
    ExcelFileTypes[ExcelFileTypes["TablesFile"] = 11] = "TablesFile";
})(ExcelFileTypes || (ExcelFileTypes = {}));

/** @hidden */
class ExcelStrings {
    static getRels() {
        return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
    }
    static getApp() {
        return ExcelStrings.XML_STRING + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>';
    }
    static getCore() {
        return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
    }
    static getTheme() {
        return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック Light"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线 Light"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="游ゴシック"/><a:font script="Hang" typeface="맑은 고딕"/><a:font script="Hans" typeface="等线"/><a:font script="Hant" typeface="新細明體"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
    }
    static getStyles(hasNonStringValues) {
        const additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
        const cellXFCount = hasNonStringValues ? 2 : 1;
        return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
    }
    static getWorkbook() {
        return ExcelStrings.XML_STRING + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>';
    }
    static getWorksheetRels() {
        return ExcelStrings.XML_STRING + `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/></Relationships>`;
    }
    static getWorkbookRels(hasSharedStrings) {
        let retVal = ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>';
        if (hasSharedStrings) {
            retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
        }
        retVal += '</Relationships>';
        return retVal;
    }
    static getSheetXML(dimension, freezePane, cols, sheetData, hasTable, hasGroupedRows = false, outlineLevel = 0) {
        const tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
        const sheetOutlineProp = hasGroupedRows ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
        const sOutlineLevel = outlineLevel > 0 ? `outlineLevelRow="${outlineLevel}"` : '';
        // return ExcelStrings.XML_STRING +
        //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
        return `${ExcelStrings.XML_STRING}
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">
${sheetOutlineProp}
<dimension ref="${dimension}"/>
<sheetViews><sheetView tabSelected="1" workbookViewId="0">${freezePane}</sheetView></sheetViews>
<sheetFormatPr defaultRowHeight="15" ${sOutlineLevel} x14ac:dyDescent="0.25"/>
${cols}
${sheetData}
<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>
${tableParts}</worksheet>`;
    }
    static getSharedStringXML(count, uniqueCount, table) {
        return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
    }
    static getContentTypesXML(hasSharedStrings, hasTable) {
        let contentTypes = ExcelStrings.XML_STRING +
            `<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types\">
            <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
            <Default Extension="xml" ContentType="application/xml"/>
            <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
            <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>
            <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>
            <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
            <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
            <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>`;
        contentTypes += hasSharedStrings ?
            `	<Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>` : '';
        contentTypes += hasTable ?
            `<Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>` : '';
        contentTypes += `</Types>`;
        return contentTypes;
    }
    static getTablesXML(dimension, tableColumns, sort) {
        return `${ExcelStrings.XML_STRING}<table xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" id="1" name="Table1" displayName="Table1" ref="${dimension}" totalsRowShown="0">
    <autoFilter ref="${dimension}"/>${sort}${tableColumns}<tableStyleInfo name="TableStyleMedium2" showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>
</table>`;
    }
    /* tslint:enable max-line-length */
    static getExcelColumn(index) {
        // Returns the excel column name for given 0-based index
        // For example 27 should return "AB"
        let returnString = '';
        while (index >= 0) {
            const char = index % 26;
            returnString = String.fromCharCode(65 + char) + returnString;
            index = Math.floor(index / 26) - 1;
        }
        return returnString;
    }
}
/* tslint:disable max-line-length */
ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';

/**
 * @hidden
 */
class RootRelsFile {
    writeElement(folder, worksheetData) {
        folder.file('.rels', ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
class AppFile {
    writeElement(folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp());
    }
}
/**
 * @hidden
 */
class CoreFile {
    writeElement(folder, worksheetData) {
        folder.file('core.xml', ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
class ThemeFile {
    writeElement(folder, worksheetData) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
class WorksheetFile {
    writeElement(folder, worksheetData) {
        const sheetData = [];
        const cols = [];
        let dimension;
        const dictionary = worksheetData.dataDictionary;
        let freezePane = '';
        let maxOutlineLevel = 0;
        if (worksheetData.isEmpty) {
            sheetData.push('<sheetData/>');
            dimension = 'A1';
        }
        else {
            sheetData.push('<sheetData>');
            const height = worksheetData.options.rowHeight;
            const rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData.push(`<row r="1"${rowHeight}>`);
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const column = ExcelStrings.getExcelColumn(i) + 1;
                const value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData.push(`<c r="${column}" t="s"><v>${value}</v></c>`);
            }
            sheetData.push('</row>');
            for (let i = 1; i < worksheetData.rowCount; i++) {
                if (!worksheetData.isTreeGridData) {
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}>`);
                }
                else {
                    const rowData = worksheetData.data[i - 1].originalRowData;
                    const sCollapsed = (!rowData.expanded) ? '' : (rowData.expanded === true) ? '' : ` collapsed="1"`;
                    const sHidden = (rowData.parent && this.hasCollapsedParent(rowData)) ? ` hidden="1"` : '';
                    const rowOutlineLevel = rowData.level ? rowData.level : 0;
                    const sOutlineLevel = rowOutlineLevel > 0 ? ` outlineLevel="${rowOutlineLevel}"` : '';
                    maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                    sheetData.push(`<row r="${(i + 1)}"${rowHeight}${sOutlineLevel}${sCollapsed}${sHidden}>`);
                }
                for (let j = 0; j < worksheetData.columnCount; j++) {
                    const cellData = WorksheetFile.getCellData(worksheetData, i, j);
                    sheetData.push(cellData);
                }
                sheetData.push('</row>');
            }
            sheetData.push('</sheetData>');
            dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols.push('<cols>');
            for (let i = 0; i < worksheetData.columnCount; i++) {
                const width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                const widthInTwips = worksheetData.options.columnWidth ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                cols.push(`<col min="${(i + 1)}" max="${(i + 1)}" width="${widthInTwips}" customWidth="1"/>`);
            }
            cols.push('</cols>');
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                const frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                const firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                freezePane = `<pane xSplit="${frozenColumnCount}" topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
            }
        }
        const hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
        folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
    }
    hasCollapsedParent(rowData) {
        let result = !rowData.parent.expanded;
        while (rowData.parent) {
            result = result || !rowData.parent.expanded;
            rowData = rowData.parent;
        }
        return result;
    }
    /* tslint:disable member-ordering */
    static getCellData(worksheetData, row, column) {
        const dictionary = worksheetData.dataDictionary;
        const columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
        const columnHeader = worksheetData.keys[column];
        const rowData = worksheetData.data[row - 1].rowData;
        const cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];
        if (cellValue === undefined || cellValue === null) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else {
            const savedValue = dictionary.saveValue(cellValue, column, false);
            const isSavedAsString = savedValue !== -1;
            const value = isSavedAsString ? savedValue : cellValue;
            const type = isSavedAsString ? ` t="s"` : '';
            const format = isSavedAsString ? '' : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
    }
}
WorksheetFile.MIN_WIDTH = 8.34;
/**
 * @hidden
 */
class StyleFile {
    writeElement(folder, worksheetData) {
        folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
    }
}
/**
 * @hidden
 */
class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook());
    }
}
/**
 * @hidden
 */
class ContentTypesFile {
    writeElement(folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const dimension = 'A1:' + lastColumn;
        const values = worksheetData.keys;
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
class WorksheetRelsFile {
    writeElement(folder, worksheetData) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    }
}

/** @hidden */
class RootExcelFolder {
    get folderName() {
        return '';
    }
    childFiles(data) {
        return [ExcelFileTypes.ContentTypesFile];
    }
    childFolders(data) {
        return [
            ExcelFolderTypes.RootRelsExcelFolder,
            ExcelFolderTypes.DocPropsExcelFolder,
            ExcelFolderTypes.XLExcelFolder
        ];
    }
}
/** @hidden */
class RootRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles(data) {
        return [ExcelFileTypes.RootRelsFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class DocPropsExcelFolder {
    get folderName() {
        return 'docProps';
    }
    childFiles(data) {
        return [
            ExcelFileTypes.AppFile,
            ExcelFileTypes.CoreFile
        ];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class XLExcelFolder {
    get folderName() {
        return 'xl';
    }
    childFiles(data) {
        const retVal = [
            ExcelFileTypes.StyleFile,
            ExcelFileTypes.WorkbookFile
        ];
        if (!data.isEmpty) {
            retVal.push(ExcelFileTypes.SharedStringsFile);
        }
        return retVal;
    }
    childFolders(data) {
        const retVal = [
            ExcelFolderTypes.XLRelsExcelFolder,
            ExcelFolderTypes.ThemeExcelFolder,
            ExcelFolderTypes.WorksheetsExcelFolder
        ];
        if (!data.isEmpty && data.options.exportAsTable) {
            retVal.push(ExcelFolderTypes.TablesExcelFolder);
        }
        return retVal;
    }
}
/** @hidden */
class XLRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles(data) {
        return [ExcelFileTypes.WorkbookRelsFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class ThemeExcelFolder {
    get folderName() {
        return 'theme';
    }
    childFiles(data) {
        return [ExcelFileTypes.ThemeFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class WorksheetsExcelFolder {
    get folderName() {
        return 'worksheets';
    }
    childFiles(data) {
        return [ExcelFileTypes.WorksheetFile];
    }
    childFolders(data) {
        return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
    }
}
/** @hidden */
class TablesExcelFolder {
    get folderName() {
        return 'tables';
    }
    childFiles(data) {
        return [ExcelFileTypes.TablesFile];
    }
    childFolders(data) {
        return [];
    }
}
/** @hidden */
class WorksheetsRelsExcelFolder {
    get folderName() {
        return '_rels';
    }
    childFiles(data) {
        return [ExcelFileTypes.WorksheetRelsFile];
    }
    childFolders(data) {
        return [];
    }
}

/** @hidden */
class ExcelElementsFactory {
    static getExcelFolder(type) {
        switch (type) {
            case ExcelFolderTypes.RootExcelFolder:
                return new RootExcelFolder();
            case ExcelFolderTypes.RootRelsExcelFolder:
                return new RootRelsExcelFolder();
            case ExcelFolderTypes.DocPropsExcelFolder:
                return new DocPropsExcelFolder();
            case ExcelFolderTypes.XLExcelFolder:
                return new XLExcelFolder();
            case ExcelFolderTypes.XLRelsExcelFolder:
                return new XLRelsExcelFolder();
            case ExcelFolderTypes.ThemeExcelFolder:
                return new ThemeExcelFolder();
            case ExcelFolderTypes.WorksheetsExcelFolder:
                return new WorksheetsExcelFolder();
            case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                return new WorksheetsRelsExcelFolder();
            case ExcelFolderTypes.TablesExcelFolder:
                return new TablesExcelFolder();
            default:
                throw new Error('Unknown excel folder type!');
        }
    }
    static getExcelFile(type) {
        switch (type) {
            case ExcelFileTypes.RootRelsFile:
                return new RootRelsFile();
            case ExcelFileTypes.AppFile:
                return new AppFile();
            case ExcelFileTypes.CoreFile:
                return new CoreFile();
            case ExcelFileTypes.WorkbookRelsFile:
                return new WorkbookRelsFile();
            case ExcelFileTypes.ThemeFile:
                return new ThemeFile();
            case ExcelFileTypes.WorksheetFile:
                return new WorksheetFile();
            case ExcelFileTypes.StyleFile:
                return new StyleFile();
            case ExcelFileTypes.WorkbookFile:
                return new WorkbookFile();
            case ExcelFileTypes.ContentTypesFile:
                return new ContentTypesFile();
            case ExcelFileTypes.SharedStringsFile:
                return new SharedStringsFile();
            case ExcelFileTypes.WorksheetRelsFile:
                return new WorksheetRelsFile();
            case ExcelFileTypes.TablesFile:
                return new TablesFile();
            default:
                throw Error('Unknown excel file type!');
        }
    }
}

/** @hidden */
class WorksheetDataDictionary {
    constructor(columnCount, columnWidth) {
        this.hasNonStringValues = false;
        this._dictionary = {};
        this._widthsDictionary = {};
        this._counter = 0;
        this.dirtyKeyCollections();
        this._calculateColumnWidth = !columnWidth;
        this._columnWidths = new Array(columnCount);
        this._columnTypeInfo = new Array(columnCount);
        if (!this._calculateColumnWidth) {
            this._columnWidths.fill(columnWidth);
        }
        this.stringsCount = 0;
    }
    get columnWidths() {
        return this._columnWidths;
    }
    saveValue(value, column, isHeader) {
        if (this._columnTypeInfo[column] === undefined && isHeader === false) {
            this._columnTypeInfo[column] = typeof value === 'string' ||
                typeof value === 'boolean' ||
                value instanceof Date;
        }
        let sanitizedValue = '';
        const isSavedAsString = this._columnTypeInfo[column] || isHeader;
        if (isSavedAsString) {
            sanitizedValue = this.sanitizeValue(value);
            if (this._dictionary[sanitizedValue] === undefined) {
                this._dictionary[sanitizedValue] = this._counter++;
                this.dirtyKeyCollections();
            }
            this.stringsCount++;
        }
        else {
            this.hasNonStringValues = true;
        }
        if (this._calculateColumnWidth) {
            const width = this.getTextWidth(value);
            const maxWidth = Math.max(this._columnWidths[column] || 0, width);
            this._columnWidths[column] = maxWidth;
        }
        return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
    }
    getValue(value) {
        return this.getSanitizedValue(this.sanitizeValue(value));
    }
    getSanitizedValue(sanitizedValue) {
        return this._dictionary[sanitizedValue];
    }
    getKeys() {
        if (!this._keysAreValid) {
            this._keys = Object.keys(this._dictionary);
            this._keysAreValid = true;
        }
        return this._keys;
    }
    getTextWidth(value) {
        if (this._widthsDictionary[value] === undefined) {
            const context = this.getContext();
            const metrics = context.measureText(value);
            this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
        }
        return this._widthsDictionary[value];
    }
    getContext() {
        if (!this._context) {
            const canvas = document.createElement('canvas');
            this._context = canvas.getContext('2d');
            this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
        }
        return this._context;
    }
    sanitizeValue(value) {
        if (ExportUtilities.hasValue(value) === false) {
            return '';
        }
        else {
            const stringValue = String(value);
            return stringValue.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    }
    dirtyKeyCollections() {
        this._keysAreValid = false;
    }
}
WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
WorksheetDataDictionary.TEXT_PADDING = 5;

/** @hidden */
class WorksheetData {
    constructor(_data, options, indexOfLastPinnedColumn, sort, isTreeGridData = false) {
        this._data = _data;
        this.options = options;
        this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
        this.sort = sort;
        this.isTreeGridData = isTreeGridData;
        this.initializeData();
    }
    get data() {
        return this._data;
    }
    get columnCount() {
        return this._columnCount;
    }
    get rowCount() {
        return this._rowCount;
    }
    get isEmpty() {
        return !this.rowCount || !this._columnCount;
    }
    get keys() {
        return this._keys;
    }
    get isSpecialData() {
        return this._isSpecialData;
    }
    get dataDictionary() {
        return this._dataDictionary;
    }
    initializeData() {
        if (!this._data || this._data.length === 0) {
            return;
        }
        const actualData = this._data.map((item) => item.rowData);
        this._keys = ExportUtilities.getKeysFromData(actualData);
        if (this._keys.length === 0) {
            return;
        }
        this._isSpecialData = ExportUtilities.isSpecialData(actualData);
        this._columnCount = this._keys.length;
        this._rowCount = this._data.length + 1;
        this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth);
    }
}

var IgxExcelExporterService_1;
/**
 * **Ignite UI for Angular Excel Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
 *
 * The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from both raw data
 * (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private excelExportService: IgxExcelExporterService) {
 * }
 *
 * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
 * ```
 */
let IgxExcelExporterService = IgxExcelExporterService_1 = class IgxExcelExporterService extends IgxBaseExporter {
    constructor() {
        super(...arguments);
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * @memberof IgxExcelExporterService
         */
        this.onExportEnded = new EventEmitter();
    }
    static populateFolder(folder, zip, worksheetData) {
        for (const childFolder of folder.childFolders(worksheetData)) {
            const folderIntance = ExcelElementsFactory.getExcelFolder(childFolder);
            const zipFolder = zip.folder(folderIntance.folderName);
            IgxExcelExporterService_1.populateFolder(folderIntance, zipFolder, worksheetData);
        }
        for (const childFile of folder.childFiles(worksheetData)) {
            const fileInstance = ExcelElementsFactory.getExcelFile(childFile);
            fileInstance.writeElement(zip, worksheetData);
        }
    }
    exportDataImplementation(data, options) {
        if (this._isTreeGrid) {
            let maxLevel = 0;
            data.forEach((r) => {
                maxLevel = Math.max(maxLevel, r.originalRowData.level);
            });
            if (maxLevel > 7) {
                throw Error('Can create an outline of up to eight levels!');
            }
        }
        const worksheetData = new WorksheetData(data, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
        this._xlsx = new JSZip();
        const rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
        IgxExcelExporterService_1.populateFolder(rootFolder, this._xlsx, worksheetData);
        this._xlsx.generateAsync(IgxExcelExporterService_1.ZIP_OPTIONS).then((result) => {
            this.saveFile(result, options.fileName);
            this.onExportEnded.emit({ xlsx: this._xlsx });
        });
    }
    saveFile(data, fileName) {
        const blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
        });
        ExportUtilities.saveBlobToFile(blob, fileName);
    }
};
IgxExcelExporterService.ɵfac = function IgxExcelExporterService_Factory(t) { return ɵIgxExcelExporterService_BaseFactory(t || IgxExcelExporterService); };
IgxExcelExporterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxExcelExporterService, factory: IgxExcelExporterService.ɵfac });
IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
__decorate([
    Output()
], IgxExcelExporterService.prototype, "onExportEnded", void 0);

/**
 * Objects of this class are used to configure the Excel exporting process.
 */
class IgxExcelExporterOptions extends IgxExporterOptionsBase {
    constructor(fileName) {
        super(fileName, '.xlsx');
        /**
         * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
         * this option will always be considered as set to true.
         * ```typescript
         * let ignorePinning = this.exportOptions.ignorePinning;
         * this.exportOptions.ignorePinning = true;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        this.ignorePinning = false;
        /**
         * Specifies whether the exported data should be formatted as Excel table. (True by default)
         * ```typescript
         * let exportAsTable = this.exportOptions.exportAsTable;
         * this.exportOptions.exportAsTable = false;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        this.exportAsTable = true;
    }
    /**
     * Gets the width of the columns in the exported excel file.
     * ```typescript
     * let width = this.exportOptions.columnWidth;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    get columnWidth() {
        return this._columnWidth;
    }
    /**
     * Sets the width of the columns in the exported excel file. If left unspecified or 0,
     * the width of the largest string in the column will be used.
     * ```typescript
     * this.exportOptions.columnWidth = 55;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    set columnWidth(value) {
        if (value < 0) {
            throw Error('Invalid value for column width!');
        }
        this._columnWidth = value;
    }
    /**
     * Gets the height of the rows in the exported excel file.
     * ```typescript
     * let height = this.exportOptions.rowHeight;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    get rowHeight() {
        return this._rowHeight;
    }
    /**
     * Sets the height of the rows in the exported excel file. If left unspecified or 0,
     * the default height of the excel rows will be used.
     * ```typescript
     * this.exportOptions.rowHeight = 25;
     * ```
     * @memberof IgxExcelExporterOptions
     */
    set rowHeight(value) {
        if (value < 0) {
            throw Error('Invalid value for row height!');
        }
        this._rowHeight = value;
    }
}

var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = -1] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = 0] = "Right";
})(HorizontalAlignment || (HorizontalAlignment = {}));
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Top"] = -1] = "Top";
    VerticalAlignment[VerticalAlignment["Middle"] = -0.5] = "Middle";
    VerticalAlignment[VerticalAlignment["Bottom"] = 0] = "Bottom";
})(VerticalAlignment || (VerticalAlignment = {}));
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
/** @hidden */
class Util {
    /**
     * @hidden
     * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
     * if no target is provided
     * @param settings Overlay settings for which to calculate target rectangle
     */
    static getTargetRect(settings) {
        let targetRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        if (settings.target instanceof HTMLElement) {
            targetRect = settings.target.getBoundingClientRect();
        }
        else if (settings.target instanceof Point) {
            const targetPoint = settings.target;
            targetRect = {
                bottom: targetPoint.y,
                height: 0,
                left: targetPoint.x,
                right: targetPoint.x,
                top: targetPoint.y,
                width: 0
            };
        }
        return targetRect;
    }
    /** @hidden @internal */
    static getViewportRect(document) {
        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;
        const scrollPosition = Util.getViewportScrollPosition(document);
        return {
            top: scrollPosition.y,
            left: scrollPosition.x,
            right: scrollPosition.x + width,
            bottom: scrollPosition.y + height,
            width: width,
            height: height,
        };
    }
    /** @hidden @internal */
    static getViewportScrollPosition(document) {
        const documentElement = document.documentElement;
        const documentRect = documentElement.getBoundingClientRect();
        const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
        const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
        return new Point(horizontalScrollPosition, verticalScrollPosition);
    }
    /** @hidden @internal */
    static cloneInstance(object) {
        const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        clonedObj.settings = cloneValue(clonedObj.settings);
        return clonedObj;
    }
}

/**
 * Positions the element based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class GlobalPositionStrategy {
    constructor(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            verticalDirection: VerticalAlignment.Middle,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle,
            openAnimation: fadeIn,
            closeAnimation: fadeOut,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
        this.setPosition(contentElement, this.settings);
    }
    setPosition(contentElement, settings) {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                contentElement.parentElement.style.justifyContent = 'flex-start';
                break;
            case HorizontalAlignment.Center:
                contentElement.parentElement.style.justifyContent = 'center';
                break;
            case HorizontalAlignment.Right:
                contentElement.parentElement.style.justifyContent = 'flex-end';
                break;
            default:
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                contentElement.parentElement.style.alignItems = 'flex-start';
                break;
            case VerticalAlignment.Middle:
                contentElement.parentElement.style.alignItems = 'center';
                break;
            case VerticalAlignment.Bottom:
                contentElement.parentElement.style.alignItems = 'flex-end';
                break;
            default:
                break;
        }
    }
    /** @inheritdoc */
    clone() {
        return Util.cloneInstance(this);
    }
}

class ScrollStrategy {
    constructor(scrollContainer) { }
}

/**
 * Empty scroll strategy. Does nothing.
 */
class NoOpScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) { }
    /** @inheritdoc */
    attach() { }
    /** @inheritdoc */
    detach() { }
}

/**
 * @hidden
 */
function DeprecateMethod(message) {
    let isMessageShown = false;
    return function (target, key, descriptor) {
        if (descriptor && descriptor.value) {
            const originalMethod = descriptor.value;
            descriptor.value = function () {
                const targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(`${targetName}.${key}: ${message}`, isMessageShown);
                return originalMethod.call(this, arguments);
            };
            return descriptor;
        }
    };
}
/**
 * @hidden
 */
function DeprecateProperty(message) {
    return function (target, key) {
        let isMessageShown = false;
        const messageToDisplay = `${target.constructor.name}.${key}: ${message}`;
        // if the target already has the property defined
        const originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
        if (originalDescriptor) {
            let getter, setter;
            getter = originalDescriptor.get;
            setter = originalDescriptor.set;
            if (getter) {
                originalDescriptor.get = function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return getter.call(this);
                };
            }
            if (setter) {
                originalDescriptor.set = function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    setter.call(this, value);
                };
            }
            return originalDescriptor;
        }
        // the target doesn't contain a descriptor for that property, so create one
        // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
        const newKey = generateUniqueKey(target, key);
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            set: function (value) {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                this[newKey] = value;
            },
            get: function () {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                return this[newKey];
            }
        });
    };
}
/**
 * @hidden
 */
function generateUniqueKey(target, key) {
    let newKey = '_' + key;
    while (target.hasOwnProperty(newKey)) {
        newKey = '_' + newKey;
    }
    return newKey;
}
/**
 * @hidden
 */
function showMessage(message, isMessageShown) {
    if (!isMessageShown && isDevMode()) {
        console.warn(message);
    }
    return true;
}

let warningShown = false;
/**
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay_main.html)
 * The overlay service allows users to show components on overlay div above all other elements in the page.
 */
let IgxOverlayService = class IgxOverlayService {
    constructor(_factoryResolver, _appRef, _injector, builder, document, _zone) {
        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new Subject();
        this._defaultSettings = {
            positionStrategy: new GlobalPositionStrategy(),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: true,
            closeOnOutsideClick: true
        };
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the component is appended to the overlay, and before animations are started.
         * ```typescript
         * onAppended(event: OverlayEventArgs){
         *     const onAppended = event;
         * }
         * ```
         */
        this.onAppended = new EventEmitter();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */
        this.onAnimation = new EventEmitter();
        this.documentClicked = (ev) => {
            //  if we get to modal overlay just return - we should not close anything under it
            //  if we get to non-modal overlay do the next:
            //   1. Check it has close on outside click. If not go on to next overlay;
            //   2. If true check if click is on the element. If it is on the element we have closed
            //  already all previous non-modal with close on outside click elements, so we return. If
            //  not close the overlay and check next
            for (let i = this._overlayInfos.length; i--;) {
                const info = this._overlayInfos[i];
                if (info.settings.modal) {
                    return;
                }
                if (info.settings.closeOnOutsideClick) {
                    const target = ev.target;
                    //  if the click is on the element do not close this overlay
                    if (!info.elementRef.nativeElement.contains(target)) {
                        // if we should exclude position target check if the click is over it. If so do not close overlay
                        const positionTarget = info.settings.positionStrategy.settings.target;
                        let clickOnPositionTarget = false;
                        if (positionTarget) {
                            clickOnPositionTarget = positionTarget.contains(target);
                        }
                        if (!(info.settings.excludePositionTarget && clickOnPositionTarget)) {
                            //  if the click is outside click, but close animation has started do nothing
                            if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                                this._hide(info.id, ev);
                            }
                        }
                    }
                    else {
                        //  TODO: should we return here, or continue with next overlays
                        return;
                    }
                }
            }
        };
        /** @hidden */
        this.repositionAll = () => {
            for (let i = this._overlayInfos.length; i--;) {
                this.reposition(this._overlayInfos[i].id);
            }
        };
        this._document = this.document;
    }
    attach(component, settings, moduleRef) {
        let info;
        info = this.getOverlayInfo(component, moduleRef);
        //  if there is no info most probably wrong type component was provided and we just go out
        if (!info) {
            return null;
        }
        info.id = (this._componentId++).toString();
        settings = Object.assign({}, this._defaultSettings, settings);
        info.settings = settings;
        this._overlayInfos.push(info);
        return info.id;
    }
    show(compOrId, settings) {
        let info;
        let id;
        if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);
            if (!info) {
                console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                return null;
            }
        }
        else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return;
            }
            info.id = id;
        }
        settings = Object.assign({}, this._defaultSettings, info.settings, settings);
        info.settings = settings;
        this._show(info);
        return id;
    }
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     */
    hide(id) {
        this._hide(id);
    }
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     */
    hideAll() {
        // since overlays are removed on animation done, que all hides
        for (let i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
        }
    }
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     */
    reposition(id) {
        const overlayInfo = this.getOverlayById(id);
        if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
        }
        const contentElement = overlayInfo.elementRef.nativeElement.parentElement;
        const contentElementRect = contentElement.getBoundingClientRect();
        overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
        }, this._document, false);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     * ```typescript
     * this.overlay.setOffset(id, deltaX, deltaY);
     * ```
     */
    setOffset(id, deltaX, deltaY) {
        const info = this.getOverlayById(id);
        if (!info) {
            return;
        }
        info.transformX += deltaX;
        info.transformY += deltaY;
        const transformX = info.transformX;
        const transformY = info.transformY;
        const translate = `translate(${transformX}px, ${transformY}px)`;
        info.elementRef.nativeElement.parentElement.style.transform = translate;
    }
    _show(info) {
        const eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
        this.onOpening.emit(eventArgs);
        if (eventArgs.cancel) {
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            return;
        }
        //  if there is no close animation player, or there is one but it is not started yet we are in clear
        //  opening. Otherwise, if there is close animation player playing animation now we should not setup
        //  overlay this is already done
        if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
            const elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = { width: elementRect.width, height: elementRect.height };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);
            if (info.componentRef) {
                info.componentRef.changeDetectorRef.detectChanges();
            }
            this.onAppended.emit({ id: info.id, componentRef: info.componentRef });
            this.updateSize(info);
            if (this._overlayInfos.indexOf(info) === -1) {
                this._overlayInfos.push(info);
            }
            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
        }
        this.addOutsideClickListener(info);
        this.addResizeHandler(info.id);
        if (info.settings.modal) {
            this.setupModalWrapper(info);
        }
        if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
        }
        else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
        }
    }
    _hide(id, event) {
        const info = this.getOverlayById(id);
        if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
        }
        const eventArgs = { id, componentRef: info.componentRef, cancel: false, event };
        this.onClosing.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        //  TODO: synchronize where these are added/attached and where removed/detached
        info.settings.scrollStrategy.detach();
        this.removeOutsideClickListener(info);
        this.removeResizeHandler(info.id);
        const child = info.elementRef.nativeElement;
        if (info.settings.modal) {
            const parent = child.parentNode.parentNode;
            this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
            parent.classList.remove('igx-overlay__wrapper--modal');
            parent.classList.add('igx-overlay__wrapper');
        }
        if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info);
        }
        else {
            this.onCloseDone(info);
        }
    }
    getOverlayInfo(component, moduleRef) {
        const info = { ngZone: this._zone, transformX: 0, transformY: 0 };
        if (component instanceof ElementRef) {
            info.elementRef = component;
        }
        else {
            let dynamicFactory;
            const factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
            try {
                dynamicFactory = factoryResolver.resolveComponentFactory(component);
            }
            catch (error) {
                console.error(error);
                return null;
            }
            const injector = moduleRef ? moduleRef.injector : this._injector;
            const dynamicComponent = dynamicFactory.create(injector);
            this._appRef.attachView(dynamicComponent.hostView);
            // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
            const element = dynamicComponent.location.nativeElement;
            info.elementRef = { nativeElement: element };
            info.componentRef = dynamicComponent;
        }
        return info;
    }
    placeElementHook(element) {
        if (!element.parentElement) {
            return null;
        }
        const hook = this._document.createElement('div');
        element.parentElement.insertBefore(hook, element);
        return hook;
    }
    moveElementToOverlay(info) {
        const wrapperElement = this.getWrapperElement();
        const contentElement = this.getContentElement(wrapperElement, info.settings.modal);
        this.getOverlayElement(info).appendChild(wrapperElement);
        contentElement.appendChild(info.elementRef.nativeElement);
    }
    getWrapperElement() {
        const wrapper = this._document.createElement('div');
        wrapper.classList.add('igx-overlay__wrapper');
        return wrapper;
    }
    getContentElement(wrapperElement, modal) {
        const content = this._document.createElement('div');
        if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', (ev) => {
                ev.stopPropagation();
            });
        }
        else {
            content.classList.add('igx-overlay__content');
        }
        content.addEventListener('scroll', (ev) => {
            ev.stopPropagation();
        });
        //  hide element to eliminate flickering. Show the element exactly before animation starts
        content.style.visibility = 'hidden';
        wrapperElement.appendChild(content);
        return content;
    }
    getOverlayElement(info) {
        if (info.settings.outlet) {
            return info.settings.outlet.nativeElement;
        }
        if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');
            this._overlayElement.classList.add('igx-overlay');
            this._document.body.appendChild(this._overlayElement);
        }
        return this._overlayElement;
    }
    updateSize(info) {
        if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
        }
        // set content div width only if element to show has width
        if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
        }
    }
    setupModalWrapper(info) {
        const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
        fromEvent(wrapperElement, 'keydown').pipe(filter((ev) => ev.key === 'Escape' || ev.key === 'Esc'), takeUntil(this.destroy$)).subscribe(() => this.hide(info.id));
        wrapperElement.classList.remove('igx-overlay__wrapper');
        this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
        wrapperElement.classList.add('igx-overlay__wrapper--modal');
    }
    onCloseDone(info) {
        this.cleanUp(info);
        this.onClosed.emit({ id: info.id, componentRef: info.componentRef });
    }
    cleanUp(info) {
        const child = info.elementRef.nativeElement;
        const outlet = this.getOverlayElement(info);
        if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
        }
        outlet.removeChild(child.parentNode.parentNode);
        if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);
            info.componentRef.destroy();
        }
        if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
        }
        const index = this._overlayInfos.indexOf(info);
        this._overlayInfos.splice(index, 1);
        // this._overlayElement.parentElement check just for tests that manually delete the element
        if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
            this._overlayElement.parentElement.removeChild(this._overlayElement);
            this._overlayElement = null;
        }
    }
    playOpenAnimation(info) {
        if (!info.openAnimationPlayer) {
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            const innerRenderer = info.openAnimationPlayer._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(() => {
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                if (info.openAnimationPlayer) {
                    info.openAnimationPlayer.reset();
                    info.openAnimationPlayer = null;
                }
                if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                    info.closeAnimationPlayer.reset();
                }
            });
        }
        //  if there is opening animation already started do nothing
        if (info.openAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is closing animation already started start open animation from where close one has reached
        //  and remove close animation
        if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            const position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
        //  to eliminate flickering show the element just before animation start
        info.elementRef.nativeElement.parentElement.style.visibility = '';
        info.openAnimationPlayer.play();
    }
    playCloseAnimation(info) {
        if (!info.closeAnimationPlayer) {
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            const innerRenderer = info.closeAnimationPlayer._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(() => {
                if (info.closeAnimationPlayer) {
                    info.closeAnimationPlayer.reset();
                    info.closeAnimationPlayer = null;
                }
                if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                    info.openAnimationPlayer.reset();
                }
                this.onCloseDone(info);
            });
        }
        //  if there is closing animation already started do nothing
        if (info.closeAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is opening animation already started start close animation from where open one has reached
        //  and remove open animation
        if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            const position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
        info.closeAnimationPlayer.play();
    }
    //  TODO: check if applyAnimationParams will work with complex animations
    applyAnimationParams(wrapperElement, animationOptions) {
        if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
        }
        if (animationOptions.type === 10 /* AnimateRef */) {
            animationOptions = animationOptions.animation;
        }
        if (!animationOptions.options || !animationOptions.options.params) {
            return;
        }
        const params = animationOptions.options.params;
        if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
        }
        if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
        }
    }
    /** @hidden @internal */
    getOverlayById(id) {
        if (!id) {
            return null;
        }
        const info = this._overlayInfos.find(e => e.id === id);
        return info;
    }
    addOutsideClickListener(info) {
        if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
                fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe((e) => this._hide(info.id, e));
            }
            else if (
            //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal).length -
                this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal &&
                    x.closeAnimationPlayer &&
                    x.closeAnimationPlayer.hasStarted()).length === 1) {
                this._document.addEventListener('click', this.documentClicked, true);
            }
        }
    }
    removeOutsideClickListener(info) {
        if (info.settings.modal === false) {
            let shouldRemoveClickEventListener = true;
            this._overlayInfos.forEach(o => {
                if (o.settings.modal === false && o.id !== info.id) {
                    shouldRemoveClickEventListener = false;
                }
            });
            if (shouldRemoveClickEventListener) {
                this._document.removeEventListener('click', this.documentClicked, true);
            }
        }
    }
    addResizeHandler(id) {
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
        }
    }
    removeResizeHandler(id) {
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
};
IgxOverlayService.ɵfac = function IgxOverlayService_Factory(t) { return new (t || IgxOverlayService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
IgxOverlayService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: AnimationBuilder },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
IgxOverlayService.ɵprov = ɵɵdefineInjectable({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(ɵɵinject(ComponentFactoryResolver), ɵɵinject(ApplicationRef), ɵɵinject(INJECTOR), ɵɵinject(AnimationBuilder), ɵɵinject(DOCUMENT), ɵɵinject(NgZone)); }, token: IgxOverlayService, providedIn: "root" });
IgxOverlayService = __decorate([ __param(4, Inject(DOCUMENT))
], IgxOverlayService);

/**
 * Positions the element inside the containing outlet based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
class ContainerPositionStrategy extends GlobalPositionStrategy {
    constructor(settings) {
        super(settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex-container');
        this.setPosition(contentElement, this.settings);
    }
}

/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
class ConnectedPositioningStrategy {
    constructor(settings) {
        this._defaultSettings = {
            // default Point(0, 0) in getPointFromPositionsSettings
            target: null,
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: scaleInVerTop,
            closeAnimation: scaleOutVerTop,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /**
     * Obtains the ClientRect objects for the required elements - target and element to position
     * @returns target and element ClientRect objects
     */
    calculateElementRectangles(contentElement) {
        return {
            targetRect: Util.getTargetRect(this.settings),
            elementRect: contentElement.getBoundingClientRect()
        };
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        const rects = this.calculateElementRectangles(contentElement);
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, {});
    }
    /**
     * @inheritdoc
     * Creates clone of this position strategy
     * @returns clone of this position strategy
     */
    clone() {
        return Util.cloneInstance(this);
    }
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @param element Element to position
     * @param targetRect Bounding rectangle of strategy target
     * @param elementRect Bounding rectangle of the element
     */
    setStyle(element, targetRect, elementRect, connectedFit) {
        const horizontalOffset = connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0;
        const verticalOffset = connectedFit.verticalOffset ? connectedFit.verticalOffset : 0;
        const startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint + horizontalOffset,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint + verticalOffset
        };
        const wrapperRect = element.parentElement.getBoundingClientRect();
        //  clean up styles - if auto position strategy is chosen we may pass here several times
        element.style.right = '';
        element.style.left = '';
        element.style.bottom = '';
        element.style.top = '';
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                element.style.right = `${Math.round(wrapperRect.right - startPoint.x)}px`;
                break;
            case HorizontalAlignment.Center:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2)}px`;
                break;
            case HorizontalAlignment.Right:
                element.style.left = `${Math.round(startPoint.x - wrapperRect.left)}px`;
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                element.style.bottom = `${Math.round(wrapperRect.bottom - startPoint.y)}px`;
                break;
            case VerticalAlignment.Middle:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2)}px`;
                break;
            case VerticalAlignment.Bottom:
                element.style.top = `${Math.round(startPoint.y - wrapperRect.top)}px`;
                break;
        }
    }
}

class BaseFitPositionStrategy extends ConnectedPositioningStrategy {
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        const rects = super.calculateElementRectangles(contentElement);
        const connectedFit = {};
        if (initialCall) {
            connectedFit.targetRect = rects.targetRect;
            connectedFit.contentElementRect = rects.elementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (this.shouldFitInViewPort(connectedFit)) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, rects.targetRect, rects.elementRect, connectedFit);
    }
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @param connectedFit connectedFit to update
     */
    updateViewPortFit(connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection, connectedFit.horizontalOffset ? connectedFit.horizontalOffset : 0);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal = {
            back: Math.round(connectedFit.left),
            forward: Math.round(connectedFit.viewPortRect.width - connectedFit.right)
        };
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection, connectedFit.verticalOffset ? connectedFit.verticalOffset : 0);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical = {
            back: Math.round(connectedFit.top),
            forward: Math.round(connectedFit.viewPortRect.height - connectedFit.bottom)
        };
    }
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    calculateLeft(targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction + offset;
    }
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    calculateTop(targetRect, elementRect, startPoint, direction, offset) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction + offset;
    }
    /**
     * Returns whether the element should fit in viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     */
    shouldFitInViewPort(connectedFit) {
        return connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0 ||
            connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0;
    }
}

/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
class AutoPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                const horizontalPush = this.horizontalPush(connectedFit);
                transformString.push(`translateX(${horizontalPush}px)`);
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                const verticalPush = this.verticalPush(connectedFit);
                transformString.push(`translateY(${verticalPush}px)`);
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipHorizontal(connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        const flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        const leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    }
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    canFlipVertical(connectedFit) {
        const flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        const flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        const topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection, 0);
        const bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipHorizontal() {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    }
    /**
     * Flips direction and start point of the position settings
     */
    flipVertical() {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    }
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    horizontalPush(connectedFit) {
        const leftExtend = connectedFit.left;
        const rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    }
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    verticalPush(connectedFit) {
        const topExtend = connectedFit.top;
        const bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    }
}

/**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
class ElasticPositionStrategy extends BaseFitPositionStrategy {
    /** @inheritdoc */
    fitInViewport(element, connectedFit) {
        element.classList.add('igx-overlay__content--elastic');
        const transformString = [];
        if (connectedFit.fitHorizontal.back < 0 || connectedFit.fitHorizontal.forward < 0) {
            const maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            const leftExtend = Math.max(0, -connectedFit.fitHorizontal.back);
            const rightExtend = Math.max(0, -connectedFit.fitHorizontal.forward);
            const reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = `${connectedFit.contentElementRect.width - reduction}px`;
            //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned
            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
                //  the amount of translation depends on whether element goes off the screen to the left,
                //  to the right or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between left and right extend
                //  taken from the reduction
                const translation = leftExtend * reduction / (leftExtend + rightExtend);
                if (translation > 0) {
                    transformString.push(`translateX(${translation}px)`);
                }
            }
        }
        if (connectedFit.fitVertical.back < 0 || connectedFit.fitVertical.forward < 0) {
            const maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            const topExtend = Math.max(0, -connectedFit.fitVertical.back);
            const bottomExtend = Math.max(0, -connectedFit.fitVertical.forward);
            const reduction = Math.min(maxReduction, topExtend + bottomExtend);
            element.style.height = `${connectedFit.contentElementRect.height - reduction}px`;
            //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned
            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
                //  the amount of translation depends on whether element goes off the screen to the top,
                //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between top and bottom extend
                //  taken from the reduction
                const translation = topExtend * reduction / (topExtend + bottomExtend);
                if (translation > 0) {
                    transformString.push(`translateY(${translation}px)`);
                }
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
}

/**
 * On scroll reposition the overlay content.
 */
class AbsoluteScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (e) => {
            const overlayInfo = this._overlayService.getOverlayById(this._id);
            if (!overlayInfo) {
                return;
            }
            if (!overlayInfo.elementRef.nativeElement.contains(e.target)) {
                this._overlayService.reposition(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._zone = overlayService.getOverlayById(id).ngZone;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        if (this._zone) {
            this._zone.runOutsideAngular(() => {
                this.addScrollEventListener();
            });
        }
        else {
            this.addScrollEventListener();
        }
    }
    /** @inheritdoc */
    detach() {
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll, true);
        }
        this._initialized = false;
    }
    addScrollEventListener() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.addEventListener('scroll', this.onScroll, true);
        }
    }
}

/**
 * Prevents scrolling while the overlay content is shown.
 */
class BlockScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            ev.preventDefault();
            if (!this._sourceElement || this._sourceElement !== ev.target) {
                this._sourceElement = ev.target;
                this._initialScrollTop = this._sourceElement.scrollTop;
                this._initialScrollLeft = this._sourceElement.scrollLeft;
            }
            this._sourceElement.scrollTop = this._initialScrollTop;
            this._sourceElement.scrollLeft = this._initialScrollLeft;
        };
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._document = document;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        this._document.addEventListener('scroll', this.onScroll, true);
    }
    /** @inheritdoc */
    detach() {
        this._document.removeEventListener('scroll', this.onScroll, true);
        this._sourceElement = null;
        this._initialScrollTop = 0;
        this._initialScrollLeft = 0;
        this._initialized = false;
    }
}

/**
 * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
 */
class CloseScrollStrategy extends ScrollStrategy {
    constructor(scrollContainer) {
        super(scrollContainer);
        this._initialized = false;
        this.onScroll = (ev) => {
            if (!this._sourceElement) {
                return;
            }
            this.cumulativeScrollTop += this._sourceElement.scrollTop;
            this.cumulativeScrollLeft += this._sourceElement.scrollLeft;
            if (Math.abs(this.cumulativeScrollTop - this.initialScrollTop) > this._threshold ||
                Math.abs(this.cumulativeScrollLeft - this.initialScrollLeft) > this._threshold) {
                this._document.removeEventListener('scroll', this.onScroll, true);
                this._overlayService.hide(this._id);
            }
        };
        this._scrollContainer = scrollContainer;
        this._threshold = 10;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
    }
    /** @inheritdoc */
    initialize(document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._initialized = true;
    }
    /** @inheritdoc */
    attach() {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll);
            this._sourceElement = this._scrollContainer;
        }
        else {
            this._document.addEventListener('scroll', this.onScroll);
            if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                this._sourceElement = document.documentElement;
            }
            else if (document.body.scrollHeight > document.body.clientHeight) {
                this._sourceElement = document.body;
            }
        }
        if (!this._sourceElement) {
            return;
        }
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = this._sourceElement.scrollTop;
        this.initialScrollLeft = this._sourceElement.scrollLeft;
    }
    /** @inheritdoc */
    detach() {
        // TODO: check why event listener removes only on first call and remains on each next!!!
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll);
        }
        this._sourceElement = null;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = 0;
        this.initialScrollLeft = 0;
        this._initialized = false;
    }
}

// Export scroll strategies

let IgxBaseTransactionService = class IgxBaseTransactionService {
    constructor() {
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        /**
         * @inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
    }
    /**
     * @inheritdoc
     */
    get canRedo() {
        return false;
    }
    /**
     * @inheritdoc
     */
    get canUndo() {
        return false;
    }
    /**
     * @inheritdoc
     */
    get enabled() {
        return this._isPending;
    }
    /**
     * @inheritdoc
     */
    add(transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    }
    /**
     * @inheritdoc
     */
    getTransactionLog(id) { return []; }
    /**
     * @inheritdoc
     */
    undo() { }
    /**
     * @inheritdoc
     */
    redo() { }
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._pendingStates.forEach((state, key) => {
            const value = mergeChanges ? this.getAggregatedValue(key, mergeChanges) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * @inheritdoc
     */
    getState(id) {
        return this._pendingStates.get(id);
    }
    /**
     * @inheritdoc
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._pendingStates.get(id);
        if (!state) {
            return null;
        }
        if (mergeChanges) {
            return this.updateValue(state);
        }
        return state.value;
    }
    /**
     * @inheritdoc
     */
    commit(data, id) { }
    /**
     * @inheritdoc
     */
    clear(id) {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * @inheritdoc
     */
    startPending() {
        this._isPending = true;
    }
    /**
     * @inheritdoc
     */
    endPending(commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        if (state) {
            if (isObject(state.value)) {
                mergeObjects(state.value, transaction.newValue);
            }
            else {
                state.value = transaction.newValue;
            }
        }
        else {
            state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
    }
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @param state State to update value for
     * @returns updated value including all the changes in provided state
     */
    updateValue(state) {
        return this.mergeValues(state.recordRef, state.value);
    }
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @param first Value to merge into
     * @param second Value to merge
     */
    mergeValues(first, second) {
        let result;
        if (isObject(first) || isObject(second)) {
            result = mergeObjects(mergeObjects({}, first), second);
        }
        else {
            result = second ? second : first;
        }
        return result;
    }
};
IgxBaseTransactionService.ɵfac = function IgxBaseTransactionService_Factory(t) { return new (t || IgxBaseTransactionService)(); };
IgxBaseTransactionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxBaseTransactionService, factory: IgxBaseTransactionService.ɵfac });

let IgxTransactionService = class IgxTransactionService extends IgxBaseTransactionService {
    constructor() {
        super(...arguments);
        this._transactions = [];
        this._redoStack = [];
        this._undoStack = [];
        this._states = new Map();
        /**
         * @inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
    }
    /**
     * @inheritdoc
     */
    get canUndo() {
        return this._undoStack.length > 0;
    }
    /**
     * @inheritdoc
     */
    get canRedo() {
        return this._redoStack.length > 0;
    }
    /**
     * @inheritdoc
     */
    add(transaction, recordRef) {
        const states = this._isPending ? this._pendingStates : this._states;
        this.verifyAddedTransaction(states, transaction, recordRef);
        this.addTransaction(transaction, states, recordRef);
    }
    addTransaction(transaction, states, recordRef) {
        this.updateState(states, transaction, recordRef);
        const transactions = this._isPending ? this._pendingTransactions : this._transactions;
        transactions.push(transaction);
        if (!this._isPending) {
            this._undoStack.push([{ transaction, recordRef }]);
            this._redoStack = [];
            this.onStateUpdate.emit();
        }
    }
    /**
     * @inheritdoc
     */
    getTransactionLog(id) {
        if (id !== undefined) {
            return this._transactions.filter(t => t.id === id);
        }
        return [...this._transactions];
    }
    /**
     * @inheritdoc
     */
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : state.value;
            result.push({ id: key, newValue: value, type: state.type });
        });
        return result;
    }
    /**
     * @inheritdoc
     */
    getState(id, pending = false) {
        return pending ? this._pendingStates.get(id) : this._states.get(id);
    }
    /**
     * @inheritdoc
     */
    get enabled() {
        return true;
    }
    /**
     * @inheritdoc
     */
    getAggregatedValue(id, mergeChanges) {
        const state = this._states.get(id);
        const pendingState = super.getState(id);
        //  if there is no state and there is no pending state return null
        if (!state && !pendingState) {
            return null;
        }
        const pendingChange = super.getAggregatedValue(id, false);
        const change = state && state.value;
        let aggregatedValue = this.mergeValues(change, pendingChange);
        if (mergeChanges) {
            const originalValue = state ? state.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
        }
        return aggregatedValue;
    }
    /**
     * @inheritdoc
     */
    endPending(commit) {
        this._isPending = false;
        if (commit) {
            const actions = [];
            // don't use addTransaction due to custom undo handling
            for (const transaction of this._pendingTransactions) {
                const pendingState = this._pendingStates.get(transaction.id);
                this._transactions.push(transaction);
                this.updateState(this._states, transaction, pendingState.recordRef);
                actions.push({ transaction, recordRef: pendingState.recordRef });
            }
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit();
        }
        super.endPending(commit);
    }
    /**
     * @inheritdoc
     */
    commit(data, id) {
        if (id !== undefined) {
            const state = this.getState(id);
            if (state) {
                this.updateRecord(data, state);
            }
        }
        else {
            this._states.forEach((s) => {
                this.updateRecord(data, s);
            });
        }
        this.clear(id);
    }
    /**
     * @inheritdoc
     */
    clear(id) {
        if (id !== undefined) {
            this._transactions = this._transactions.filter(t => t.id !== id);
            this._states.delete(id);
            //  Undo stack is an array of actions. Each action is array of transaction like objects
            //  We are going trough all the actions. For each action we are filtering out transactions
            //  with provided id. Finally if any action ends up as empty array we are removing it from
            //  undo stack
            this._undoStack = this._undoStack.map(a => a.filter(t => t.transaction.id !== id)).filter(a => a.length > 0);
        }
        else {
            this._transactions = [];
            this._states.clear();
            this._undoStack = [];
        }
        this._redoStack = [];
        this.onStateUpdate.emit();
    }
    /**
     * @inheritdoc
     */
    undo() {
        if (this._undoStack.length <= 0) {
            return;
        }
        const lastActions = this._undoStack.pop();
        this._transactions.splice(this._transactions.length - lastActions.length);
        this._redoStack.push(lastActions);
        this._states.clear();
        for (const currentActions of this._undoStack) {
            for (const transaction of currentActions) {
                this.updateState(this._states, transaction.transaction, transaction.recordRef);
            }
        }
        this.onStateUpdate.emit();
    }
    /**
     * @inheritdoc
     */
    redo() {
        if (this._redoStack.length > 0) {
            let actions;
            actions = this._redoStack.pop();
            for (const action of actions) {
                this.updateState(this._states, action.transaction, action.recordRef);
                this._transactions.push(action.transaction);
            }
            this._undoStack.push(actions);
            this.onStateUpdate.emit();
        }
    }
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @param transaction Transaction to be verified
     */
    verifyAddedTransaction(states, transaction, recordRef) {
        const state = states.get(transaction.id);
        switch (transaction.type) {
            case TransactionType.ADD:
                if (state) {
                    //  cannot add same item twice
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already added.`);
                }
                break;
            case TransactionType.DELETE:
            case TransactionType.UPDATE:
                if (state && state.type === TransactionType.DELETE) {
                    //  cannot delete or update deleted items
                    throw new Error(`Cannot add this transaction. Transaction with id: ${transaction.id} has been already deleted.`);
                }
                if (!state && !recordRef && !this._isPending) {
                    //  cannot initially add transaction or delete item with no recordRef
                    throw new Error(`Cannot add this transaction. This is first transaction of type ${transaction.type} ` +
                        `for id ${transaction.id}. For first transaction of this type recordRef is mandatory.`);
                }
                break;
        }
    }
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    updateState(states, transaction, recordRef) {
        let state = states.get(transaction.id);
        //  if TransactionType is ADD simply add transaction to states;
        //  if TransactionType is DELETE:
        //    - if there is state with this id of type ADD remove it from the states;
        //    - if there is state with this id of type UPDATE change its type to DELETE;
        //    - if there is no state with this id add transaction to states;
        //  if TransactionType is UPDATE:
        //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
        //    - if there is state with this id of type UPDATE merge new value into state new value
        //    - if there is state with this id and state type is DELETE change its type to UPDATE
        //    - if there is no state with this id add transaction to states;
        if (state) {
            switch (transaction.type) {
                case TransactionType.DELETE:
                    if (state.type === TransactionType.ADD) {
                        states.delete(transaction.id);
                    }
                    else if (state.type === TransactionType.UPDATE) {
                        state.value = transaction.newValue;
                        state.type = TransactionType.DELETE;
                    }
                    break;
                case TransactionType.UPDATE:
                    if (isObject(state.value)) {
                        if (state.type === TransactionType.ADD) {
                            state.value = this.mergeValues(state.value, transaction.newValue);
                        }
                        if (state.type === TransactionType.UPDATE) {
                            mergeObjects(state.value, transaction.newValue);
                        }
                    }
                    else {
                        state.value = transaction.newValue;
                    }
            }
        }
        else {
            state = { value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type };
            states.set(transaction.id, state);
        }
        //  should not clean pending state. This will happen automatically on endPending call
        if (!this._isPending) {
            this.cleanState(transaction.id, states);
        }
    }
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @param state State to clean
     */
    cleanState(id, states) {
        const state = states.get(id);
        //  do nothing if
        //  there is no state, or
        //  there is no state value (e.g. DELETED transaction), or
        //  there is no recordRef (e.g. ADDED transaction)
        if (state && state.value && state.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state.recordRef)) {
                for (const key of Object.keys(state.value)) {
                    if (JSON.stringify(state.recordRef[key]) === JSON.stringify(state.value[key])) {
                        delete state.value[key];
                    }
                }
                //  if state's value is empty remove the state from the states, only if state is not DELETE type
                if (state.type !== TransactionType.DELETE && Object.keys(state.value).length === 0) {
                    states.delete(id);
                }
            }
            else {
                if (state.recordRef === state.value) {
                    states.delete(id);
                }
            }
        }
    }
    /**
     * Updates state related record in the provided data
     * @param data Data source to update
     * @param state State to update data from
     */
    updateRecord(data, state) {
        const index = data.findIndex(i => JSON.stringify(i) === JSON.stringify(state.recordRef || {}));
        switch (state.type) {
            case TransactionType.ADD:
                data.push(state.value);
                break;
            case TransactionType.DELETE:
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
                break;
            case TransactionType.UPDATE:
                if (0 <= index && index < data.length) {
                    data[index] = this.updateValue(state);
                }
                break;
        }
    }
};
IgxTransactionService.ɵfac = function IgxTransactionService_Factory(t) { return ɵIgxTransactionService_BaseFactory(t || IgxTransactionService); };
IgxTransactionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxTransactionService, factory: IgxTransactionService.ɵfac });

/** @experimental @hidden */
let IgxHierarchicalTransactionService = class IgxHierarchicalTransactionService extends IgxTransactionService {
    getAggregatedChanges(mergeChanges) {
        const result = [];
        this._states.forEach((state, key) => {
            const value = mergeChanges ? this.mergeValues(state.recordRef, state.value) : cloneValue(state.value);
            this.clearArraysFromObject(value);
            result.push({ id: key, path: state.path, newValue: value, type: state.type });
        });
        return result;
    }
    updateState(states, transaction, recordRef) {
        super.updateState(states, transaction, recordRef);
        //  if transaction has no path, e.g. flat data source, get out
        if (!transaction.path) {
            return;
        }
        const currentState = states.get(transaction.id);
        if (currentState) {
            currentState.path = transaction.path;
        }
        //  if transaction has path, Hierarchical data source, and it is DELETE
        //  type transaction for all child rows remove ADD states and update
        //  transaction type and value of UPDATE states
        if (transaction.type === TransactionType.DELETE) {
            states.forEach((v, k) => {
                if (v.path && v.path.indexOf(transaction.id) !== -1) {
                    switch (v.type) {
                        case TransactionType.ADD:
                            states.delete(k);
                            break;
                        case TransactionType.UPDATE:
                            states.get(k).type = TransactionType.DELETE;
                            states.get(k).value = null;
                    }
                }
            });
        }
    }
    /**
     * Applies all transactions over the provided data
     * @param data Data source to update
     * @param primaryKey Primary key of the hierarchical data
     * @param childDataKey Kye of child data collection
     * @param id Optional record id to commit transactions for
     */
    commit(data, primaryKey, childDataKey, id) {
        if (childDataKey !== undefined) {
            let transactions = this.getAggregatedChanges(true);
            if (id !== undefined) {
                transactions = transactions.filter(t => t.id === id);
            }
            DataUtil.mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, true);
        }
        else {
            super.commit(data, id);
        }
        this.clear(id);
    }
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    clearArraysFromObject(obj) {
        if (obj) {
            for (const prop of Object.keys(obj)) {
                if (Array.isArray(obj[prop])) {
                    delete obj[prop];
                }
            }
        }
    }
};
IgxHierarchicalTransactionService.ɵfac = function IgxHierarchicalTransactionService_Factory(t) { return ɵIgxHierarchicalTransactionService_BaseFactory(t || IgxHierarchicalTransactionService); };
IgxHierarchicalTransactionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxHierarchicalTransactionService, factory: IgxHierarchicalTransactionService.ɵfac });

// Export services

let IgxToggleDirective = class IgxToggleDirective {
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        this._collapsed = true;
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onAppended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.onAppended = new EventEmitter();
        this.overlayClosed = () => {
            this._collapsed = true;
            this.cdr.detectChanges();
            delete this._overlayId;
            this.unsubscribe();
            this.onClosed.emit();
        };
    }
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        const openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.unsubscribe();
        this._overlayAppendedSub = this.overlayService.onAppended.pipe(...this._overlaySubFilter).subscribe(() => {
            this.onAppended.emit();
        });
        this._overlayOpenedSub = this.overlayService.onOpened.pipe(...this._overlaySubFilter).subscribe(() => {
            this.onOpened.emit();
        });
        this._overlayClosingSub = this.overlayService
            .onClosing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const eventArgs = { cancel: false, event: e.event };
            this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService.onClosed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close() {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer : false;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount
     */
    setOffset(deltaX, deltaY) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
};
IgxToggleDirective.ɵfac = function IgxToggleDirective_Factory(t) { return new (t || IgxToggleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxToggleDirective, selectors: [["", "igxToggle", ""]], hostVars: 5, hostBindings: function IgxToggleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.hiddenClass);
        ɵngcc0.ɵɵclassProp("igx-toggle--hidden", ctx.hiddenClass)("igx-toggle", ctx.defaultClass);
    } }, inputs: { id: "id" }, outputs: { onOpened: "onOpened", onOpening: "onOpening", onClosed: "onClosed", onClosing: "onClosing", onAppended: "onAppended" }, exportAs: ["toggle"] });
IgxToggleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    Output()
], IgxToggleDirective.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onOpening", void 0);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onClosed", void 0);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onClosing", void 0);
__decorate([
    Input()
], IgxToggleDirective.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-toggle--hidden'),
    HostBinding('attr.aria-hidden')
], IgxToggleDirective.prototype, "hiddenClass", null);
__decorate([
    HostBinding('class.igx-toggle')
], IgxToggleDirective.prototype, "defaultClass", null);
__decorate([
    Output()
], IgxToggleDirective.prototype, "onAppended", void 0);
IgxToggleDirective = __decorate([ __param(2, Inject(IgxOverlayService)),
    __param(3, Optional())
], IgxToggleDirective);
let IgxToggleActionDirective = class IgxToggleActionDirective {
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludePositionTarget: true
        };
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
};
IgxToggleActionDirective.ɵfac = function IgxToggleActionDirective_Factory(t) { return new (t || IgxToggleActionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxToggleActionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxToggleActionDirective, selectors: [["", "igxToggleAction", ""]], hostBindings: function IgxToggleActionDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxToggleActionDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { target: ["igxToggleAction", "target"], overlaySettings: "overlaySettings", outlet: ["igxToggleOutlet", "outlet"] }, exportAs: ["toggle-action"] });
IgxToggleActionDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    Input()
], IgxToggleActionDirective.prototype, "overlaySettings", void 0);
__decorate([
    Input('igxToggleOutlet')
], IgxToggleActionDirective.prototype, "outlet", void 0);
__decorate([
    Input('igxToggleAction')
], IgxToggleActionDirective.prototype, "target", null);
__decorate([
    HostListener('click')
], IgxToggleActionDirective.prototype, "onClick", null);
IgxToggleActionDirective = __decorate([ __param(1, Optional())
], IgxToggleActionDirective);
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
let IgxOverlayOutletDirective = class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
};
IgxOverlayOutletDirective.ɵfac = function IgxOverlayOutletDirective_Factory(t) { return new (t || IgxOverlayOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxOverlayOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxOverlayOutletDirective, selectors: [["", "igxOverlayOutlet", ""]], exportAs: ["overlay-outlet"] });
IgxOverlayOutletDirective.ctorParameters = () => [
    { type: ElementRef }
];
/**
 * @hidden
 */
let IgxToggleModule = class IgxToggleModule {
};
IgxToggleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxToggleModule });
IgxToggleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxToggleModule_Factory(t) { return new (t || IgxToggleModule)(); }, providers: [IgxNavigationService] });

/** @hidden */
var Navigate;
(function (Navigate) {
    Navigate[Navigate["Up"] = -1] = "Up";
    Navigate[Navigate["Down"] = 1] = "Down";
})(Navigate || (Navigate = {}));
/** Key actions that have designated handlers in IgxDropDownComponent */
var DropDownActionKey;
(function (DropDownActionKey) {
    DropDownActionKey["ESCAPE"] = "escape";
    DropDownActionKey["ENTER"] = "enter";
    DropDownActionKey["SPACE"] = "space";
})(DropDownActionKey || (DropDownActionKey = {}));
const IGX_DROPDOWN_BASE = new InjectionToken('IgxDropDownBaseToken');

/** @hidden */
let IgxSelectionAPIService = class IgxSelectionAPIService {
    constructor() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     * @param componentID ID of the component.
     */
    get(componentID) {
        return this.selection.get(componentID);
    }
    /**
     * Set new component selection.
     * @param componentID ID of the component.
     * @param newSelection The new component selection to be set.
     */
    set(componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    }
    /**
     * Clears selection for component.
     * @param componentID ID of the component.
     */
    clear(componentID) {
        this.selection.set(componentID, this.get_empty());
    }
    /**
     * Get current component selection length.
     * @param componentID ID of the component.
     */
    size(componentID) {
        const sel = this.get(componentID);
        return sel ? sel.size : 0;
    }
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @returns Selection after the new item is added.
     */
    add_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     *
     * @returns Selection after the new items are added.
     */
    add_items(componentID, itemIDs, clearSelection) {
        let selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach((item) => selection = this.add_item(componentID, item, selection));
        return selection;
    }
    /**
     * Add item to the current component selection.
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     */
    select_item(componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    }
    /**
     * Add items to the current component selection.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     */
    select_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    }
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @returns Selection after the item is removed.
     */
    delete_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the items to remove from component selection.
     *
     * @returns Selection after the items are removed.
     */
    delete_items(componentID, itemIDs) {
        let selection;
        itemIDs.forEach((deselectedItem) => selection = this.delete_item(componentID, deselectedItem, selection));
        return selection;
    }
    /**
     * Remove item from the current component selection.
     * @param componentID ID of the component, which we remove item from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     */
    deselect_item(componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    }
    /**
     * Remove items to the current component selection.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     */
    deselect_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    }
    /**
     * Check if the item is selected in the component selection.
     * @param componentID ID of the component.
     * @param itemID ID of the item to search.
     *
     * @returns If item is selected.
     */
    is_item_selected(componentID, itemID) {
        const sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    }
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param componentID ID of the component.
     *
     * @returns First element in the set.
     */
    first_item(componentID) {
        const sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    }
    /**
     * Returns whether all items are selected.
     * @param componentID ID of the component.
     * @param dataCount: number Number of items in the data.
     *
     * @returns If all items are selected.
     */
    are_all_selected(componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    }
    /**
     * Returns whether any of the items is selected.
     * @param componentID ID of the component.
     * @param data Entire data array.
     *
     * @returns If there is any item selected.
     */
    are_none_selected(componentID) {
        return this.size(componentID) === 0;
    }
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param data Entire data array.
     * @param primaryKey Data primary key.
     *
     * @returns Array of identifiers, either primary key values or the entire data array.
     */
    get_all_ids(data, primaryKey) {
        // If primaryKey is 0, this should still map to the property
        return primaryKey !== undefined && primaryKey !== null ? data.map((x) => x[primaryKey]) : data;
    }
    /**
     * Returns empty selection collection.
     * @returns empty set.
     */
    get_empty() {
        return new Set();
    }
};
IgxSelectionAPIService.ɵfac = function IgxSelectionAPIService_Factory(t) { return new (t || IgxSelectionAPIService)(); };
IgxSelectionAPIService.ɵprov = ɵɵdefineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });

let NEXT_ID = 0;
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
let IgxDropDownGroupComponent = class IgxDropDownGroupComponent {
    constructor() {
        this._id = NEXT_ID++;
        /**
         * @hidden @internal
         */
        this.role = 'group';
        /** @hidden @internal */
        this.groupClass = true;
        /**
         * Sets/gets if the item group is disabled
         *
         * ```typescript
         * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
         * // get
         * ...
         * const groupState: boolean = myDropDownGroup.disabled;
         * ...
         * //set
         * ...
         * myDropDownGroup,disabled = false;
         * ...
         * ```
         *
         * ```html
         * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
         *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
         *         {{ item.text }}
         *     </igx-drop-down-item>
         * </igx-drop-down-item-group>
         * ```
         *
         * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
         */
        this.disabled = false;
    }
    /**
     * @hidden @internal
     */
    get labelId() {
        return `igx-item-group-label-${this._id}`;
    }
    get labelledBy() {
        return this.labelId;
    }
};
IgxDropDownGroupComponent.ɵfac = function IgxDropDownGroupComponent_Factory(t) { return new (t || IgxDropDownGroupComponent)(); };
IgxDropDownGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDropDownGroupComponent, selectors: [["igx-drop-down-item-group"]], hostVars: 7, hostBindings: function IgxDropDownGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-disabled", ctx.disabled)("aria-labelledby", ctx.labelledBy);
        ɵngcc0.ɵɵclassProp("igx-drop-down__group", ctx.groupClass)("igx-drop-down__group--disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", label: "label" }, ngContentSelectors: _c1, decls: 3, vars: 2, consts: [[3, "id"]], template: function IgxDropDownGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c0);
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("id", ctx.labelId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
    } }, encapsulation: 2 });
__decorate([
    HostBinding(`attr.aria-labelledby`)
], IgxDropDownGroupComponent.prototype, "labelledBy", null);
__decorate([
    HostBinding('attr.role')
], IgxDropDownGroupComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-drop-down__group')
], IgxDropDownGroupComponent.prototype, "groupClass", void 0);
__decorate([
    Input(),
    HostBinding(`attr.aria-disabled`),
    HostBinding('class.igx-drop-down__group--disabled')
], IgxDropDownGroupComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxDropDownGroupComponent.prototype, "label", void 0);

let NEXT_ID$1 = 0;
let warningShown$1 = false;
/**
 * An abstract class defining a drop-down item:
 * With properties / styles for selection, highlight, height
 * Bindable property for passing data (`value: any`)
 * Parent component (has to be used under a parent with type `IDropDownBase`)
 * Method for handling click on Host()
 */
let IgxDropDownItemBaseDirective = class IgxDropDownItemBaseDirective {
    constructor(dropDown, elementRef, group, selection) {
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.group = group;
        this.selection = selection;
        /**
         * @hidden
         */
        this._focused = false;
        this._selected = false;
        this._index = null;
        this._disabled = false;
        /**
         * Sets/gets the `id` of the item.
         * ```html
         * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
         * ```
         * ```typescript
         * let itemId =  this.item.id;
         * ```
         * @memberof IgxSelectItemComponent
         */
        this.id = `igx-drop-down-item-${NEXT_ID$1++}`;
        /**
         * @hidden
         */
        this.selectedChange = new EventEmitter();
        /**
         * Gets/sets the `role` attribute of the item. Default is 'option'.
         *
         * ```html
         *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
         * ```
         */
        this.role = 'option';
    }
    get hasIndex() {
        return this._index !== null && this._index !== undefined;
    }
    /**
     * @hidden @internal
     */
    get itemID() {
        return this;
    }
    /**
     * The data index of the dropdown item.
     *
     * ```typescript
     * // get the data index of the selected dropdown item
     * let selectedItemIndex = this.dropdown.selectedItem.index
     * ```
     */
    get index() {
        if (this._index === null) {
            warningShown$1 = showMessage('IgxDropDownItemBaseDirective: Automatic index is deprecated.' +
                'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
            return this.itemIndex;
        }
        return this._index;
    }
    set index(value) {
        this._index = value;
    }
    /**
     * @hidden @internal
     */
    get itemStyle() {
        return !this.isHeader;
    }
    /**
     * @hidden @internal
     */
    get itemStyleCosy() {
        return this.dropDown.displayDensity === 'cosy' && !this.isHeader;
    }
    /**
     * @hidden @internal
     */
    get itemStyleCompact() {
        return this.dropDown.displayDensity === 'compact' && !this.isHeader;
    }
    /**
     * Sets/Gets if the item is the currently selected one in the dropdown
     *
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-drop-down-item [(selected)]='model.isSelected'></igx-drop-down-item>
     * ```
     */
    get selected() {
        return this._selected;
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * Sets/gets if the given item is focused
     * ```typescript
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let isMyItemFocused = mySelectedItem.focused;
     * ```
     */
    get focused() {
        return this.isSelectable && this._focused;
    }
    /**
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @hidden @internal
     */
    get headerClassCosy() {
        return this.isHeader && this.dropDown.displayDensity === 'cosy';
    }
    /**
     * @hidden @internal
     */
    get headerClassCompact() {
        return this.isHeader && this.dropDown.displayDensity === 'compact';
    }
    /**
     * Sets/gets if the given item is disabled
     *
     * ```typescript
     *  // get
     *  let mySelectedItem = this.dropdown.selectedItem;
     *  let myItemIsDisabled = mySelectedItem.disabled;
     * ```
     *
     * ```html
     *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
     *      <div>
     *          {{item.field}}
     *      </div>
     *  </igx-drop-down-item>
     * ```
     * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
     */
    get disabled() {
        return this.group ? this.group.disabled || this._disabled : this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * Gets item index
     * @hidden @internal
     */
    get itemIndex() {
        return this.dropDown.items.indexOf(this);
    }
    /**
     * Gets item element height
     * @hidden @internal
     */
    get elementHeight() {
        return this.elementRef.nativeElement.clientHeight;
    }
    /**
     * Get item html element
     * @hidden @internal
     */
    get element() {
        return this.elementRef;
    }
    ngDoCheck() {
        if (this._selected) {
            const dropDownSelectedItem = this.dropDown.selectedItem;
            if (!dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
            else if (this.hasIndex
                ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                this !== dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
        }
    }
    /** Returns true if the items is not a header or disabled  */
    get isSelectable() {
        return !(this.disabled || this.isHeader);
    }
    /** If `allowItemsFocus` is enabled, keep the browser focus on the active item */
    ensureItemFocus() {
        if (this.dropDown.allowItemsFocus) {
            const focusedItem = this.dropDown.items.find((item) => item.focused);
            if (!focusedItem) {
                return;
            }
            focusedItem.element.nativeElement.focus({ preventScroll: true });
        }
    }
    /**
     * @hidden
     * @internal
     */
    clicked(event) {
    }
};
IgxDropDownItemBaseDirective.ɵfac = function IgxDropDownItemBaseDirective_Factory(t) { return new (t || IgxDropDownItemBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxDropDownGroupComponent, 8), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService, 8)); };
IgxDropDownItemBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDownItemBaseDirective, selectors: [["", "igxDropDownItemBase", ""]], hostVars: 22, hostBindings: function IgxDropDownItemBaseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxDropDownItemBaseDirective_click_HostBindingHandler($event) { return ctx.clicked($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-selected", ctx.selected)("aria-disabled", ctx.disabled);
        ɵngcc0.ɵɵclassProp("igx-drop-down__item", ctx.itemStyle)("igx-drop-down__item--cosy", ctx.itemStyleCosy)("igx-drop-down__item--compact", ctx.itemStyleCompact)("igx-drop-down__item--selected", ctx.selected)("igx-drop-down__item--focused", ctx.focused)("igx-drop-down__header--cosy", ctx.headerClassCosy)("igx-drop-down__header--compact", ctx.headerClassCompact)("igx-drop-down__item--disabled", ctx.disabled)("igx-drop-down__header", ctx.isHeader);
    } }, inputs: { id: "id", role: "role", index: "index", selected: "selected", disabled: "disabled", value: "value", isHeader: "isHeader" }, outputs: { selectedChange: "selectedChange" } });
IgxDropDownItemBaseDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
    { type: ElementRef },
    { type: IgxDropDownGroupComponent, decorators: [{ type: Optional }] },
    { type: IgxSelectionAPIService, decorators: [{ type: Optional }, { type: Inject, args: [IgxSelectionAPIService,] }] }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxDropDownItemBaseDirective.prototype, "id", void 0);
__decorate([
    Input()
], IgxDropDownItemBaseDirective.prototype, "index", null);
__decorate([
    Input()
], IgxDropDownItemBaseDirective.prototype, "value", void 0);
__decorate([
    HostBinding('class.igx-drop-down__item')
], IgxDropDownItemBaseDirective.prototype, "itemStyle", null);
__decorate([
    HostBinding('class.igx-drop-down__item--cosy')
], IgxDropDownItemBaseDirective.prototype, "itemStyleCosy", null);
__decorate([
    HostBinding('class.igx-drop-down__item--compact')
], IgxDropDownItemBaseDirective.prototype, "itemStyleCompact", null);
__decorate([
    Input(),
    HostBinding('attr.aria-selected'),
    HostBinding('class.igx-drop-down__item--selected')
], IgxDropDownItemBaseDirective.prototype, "selected", null);
__decorate([
    Output()
], IgxDropDownItemBaseDirective.prototype, "selectedChange", void 0);
__decorate([
    HostBinding('class.igx-drop-down__item--focused')
], IgxDropDownItemBaseDirective.prototype, "focused", null);
__decorate([
    Input(),
    HostBinding('class.igx-drop-down__header')
], IgxDropDownItemBaseDirective.prototype, "isHeader", void 0);
__decorate([
    HostBinding('class.igx-drop-down__header--cosy')
], IgxDropDownItemBaseDirective.prototype, "headerClassCosy", null);
__decorate([
    HostBinding('class.igx-drop-down__header--compact')
], IgxDropDownItemBaseDirective.prototype, "headerClassCompact", null);
__decorate([
    Input(),
    HostBinding('attr.aria-disabled'),
    HostBinding('class.igx-drop-down__item--disabled')
], IgxDropDownItemBaseDirective.prototype, "disabled", null);
__decorate([
    Input(),
    HostBinding('attr.role')
], IgxDropDownItemBaseDirective.prototype, "role", void 0);
__decorate([
    HostListener('click', ['$event'])
], IgxDropDownItemBaseDirective.prototype, "clicked", null);
IgxDropDownItemBaseDirective = __decorate([ __param(0, Inject(IGX_DROPDOWN_BASE)),
    __param(2, Optional()),
    __param(3, Optional()), __param(3, Inject(IgxSelectionAPIService))
], IgxDropDownItemBaseDirective);

/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
let IgxDropDownItemComponent = class IgxDropDownItemComponent extends IgxDropDownItemBaseDirective {
    /**
     * @inheritdoc
     */
    get focused() {
        let focusedState = this._focused;
        if (this.hasIndex) {
            const focusedItem = this.selection.first_item(`${this.dropDown.id}-active`);
            const focusedIndex = focusedItem ? focusedItem.index : -1;
            focusedState = this._index === focusedIndex;
        }
        return this.isSelectable && focusedState;
    }
    /**
     * @inheritdoc
     */
    set focused(value) {
        this._focused = value;
    }
    /**
     * @inheritdoc
     */
    get selected() {
        if (this.hasIndex) {
            const item = this.selection.first_item(`${this.dropDown.id}`);
            return item ? item.index === this._index && item.value === this.value : false;
        }
        return this._selected;
    }
    /**
     * @inheritdoc
     */
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
        this.selectedChange.emit(this._selected);
    }
    /**
     * @hidden @internal
     */
    get setTabIndex() {
        const shouldSetTabIndex = this.dropDown.allowItemsFocus && this.isSelectable;
        if (shouldSetTabIndex) {
            return 0;
        }
        else {
            return null;
        }
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        if (!this.isSelectable) {
            this.ensureItemFocus();
            return;
        }
        if (this.selection) {
            this.dropDown.selectItem(this, event);
        }
    }
};
IgxDropDownItemComponent.ɵfac = function IgxDropDownItemComponent_Factory(t) { return ɵIgxDropDownItemComponent_BaseFactory(t || IgxDropDownItemComponent); };
IgxDropDownItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDropDownItemComponent, selectors: [["igx-drop-down-item"]], hostVars: 1, hostBindings: function IgxDropDownItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.setTabIndex);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxDropDownItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('attr.tabindex')
], IgxDropDownItemComponent.prototype, "setTabIndex", null);

/**
 * Defines the posible values of the components' display density.
 */
var DisplayDensity;
(function (DisplayDensity) {
    DisplayDensity["comfortable"] = "comfortable";
    DisplayDensity["cosy"] = "cosy";
    DisplayDensity["compact"] = "compact";
})(DisplayDensity || (DisplayDensity = {}));
/**
 * Defines the DisplayDensity DI token.
 */
const DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
let DisplayDensityBase = 
// tslint:disable-next-line: directive-class-suffix
class DisplayDensityBase {
    constructor(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    /**
     * Returns the theme of the component.
     * The default theme is `comfortable`.
     * Available options are `comfortable`, `cosy`, `compact`.
     * ```typescript
     * let componentTheme = this.component.displayDensity;
     * ```
     */
    get displayDensity() {
        return this._displayDensity ||
            ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
    }
    /**
     * Sets the theme of the component.
     */
    set displayDensity(val) {
        const currentDisplayDensity = this._displayDensity;
        this._displayDensity = val;
        if (currentDisplayDensity !== this._displayDensity) {
            const densityChangedArgs = {
                oldDensity: currentDisplayDensity,
                newDensity: this._displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.initialDensity = this._displayDensity;
    }
    ngDoCheck() {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            const densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    }
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     */
    getComponentDensityClass(baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return `${baseStyleClass}--${DisplayDensity.cosy}`;
            case DisplayDensity.compact:
                return `${baseStyleClass}--${DisplayDensity.compact}`;
            default:
                return baseStyleClass;
        }
    }
};
DisplayDensityBase.ɵfac = function DisplayDensityBase_Factory(t) { return new (t || DisplayDensityBase)(ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
DisplayDensityBase.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DisplayDensityBase, selectors: [["", "igxDisplayDensityBase", ""]], inputs: { displayDensity: "displayDensity" }, outputs: { onDensityChanged: "onDensityChanged" } });
DisplayDensityBase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    Input()
], DisplayDensityBase.prototype, "displayDensity", null);
__decorate([
    Output()
], DisplayDensityBase.prototype, "onDensityChanged", void 0);
DisplayDensityBase = __decorate([ __param(0, Optional()), __param(0, Inject(DisplayDensityToken))
], DisplayDensityBase);
let IgxDisplayDensityModule = class IgxDisplayDensityModule {
};
IgxDisplayDensityModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDisplayDensityModule });
IgxDisplayDensityModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDisplayDensityModule_Factory(t) { return new (t || IgxDisplayDensityModule)(); } });

let NEXT_ID$2 = 0;
/**
 * An abstract class, defining a drop-down component, with:
 * Properties for display styles and classes
 * A collection items of type `IgxDropDownItemBaseDirective`
 * Properties and methods for navigating (highlighting/focusing) items from the collection
 * Properties and methods for selecting items from the collection
 */
let IgxDropDownBaseDirective = class IgxDropDownBaseDirective extends DisplayDensityBase {
    constructor(elementRef, cdr, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._displayDensityOptions = _displayDensityOptions;
        this._focusedItem = null;
        this._id = `igx-drop-down-${NEXT_ID$2++}`;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */
        this.maxHeight = null;
        /**
         * @hidden @internal
         */
        this.cssClass = true;
    }
    /**
     * @hidden @internal
     * Get dropdown's html element of its scroll container
     */
    get scrollContainer() {
        return this.element;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Get all header items
     *
     * ```typescript
     * let myDropDownHeaderItems = this.dropdown.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Get dropdown html element
     *
     * ```typescript
     * let myDropDownElement = this.dropdown.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
                this.selectItem(this.focusedItem, event);
                break;
            case DropDownActionKey.ESCAPE:
        }
    }
    /**
     * Emits onSelection with the target item & event
     * @hidden @internal
     * @param newSelection the item selected
     * @param event the event that triggered the call
     */
    selectItem(newSelection, event) {
        this.onSelection.emit({
            newSelection,
            oldSelection: null,
            cancel: false
        });
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        return this._focusedItem;
    }
    /**
     * @hidden @internal
     */
    set focusedItem(item) {
        this._focusedItem = item;
    }
    navigate(direction, currentIndex) {
        let index = -1;
        if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
        }
        const newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    }
    getNearestSiblingFocusableItemIndex(startIndex, direction) {
        let index = startIndex;
        const items = this.items;
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        if (index >= 0 && index < items.length) {
            return index;
        }
        else {
            return -1;
        }
    }
    /**
     * Navigates to the item on the specified index
     * @param newIndex number - the index of the item in the `items` collection
     */
    navigateItem(newIndex) {
        if (newIndex !== -1) {
            const oldItem = this._focusedItem;
            const newItem = this.items[newIndex];
            if (oldItem) {
                oldItem.focused = false;
            }
            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
        }
    }
    /**
     * @hidden @internal
     */
    navigateFirst() {
        this.navigate(Navigate.Down, -1);
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        this.navigate(Navigate.Up, this.items.length);
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        this.navigate(Navigate.Down);
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        this.navigate(Navigate.Up);
    }
    scrollToHiddenItem(newItem) {
        const elementRect = newItem.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
        }
    }
};
IgxDropDownBaseDirective.ɵfac = function IgxDropDownBaseDirective_Factory(t) { return new (t || IgxDropDownBaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxDropDownBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDownBaseDirective, selectors: [["", "igxDropDownBase", ""]], hostVars: 4, hostBindings: function IgxDropDownBaseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵclassProp("igx-drop-down", ctx.cssClass);
    } }, inputs: { maxHeight: "maxHeight", width: "width", height: "height", id: "id" }, outputs: { onSelection: "onSelection" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxDropDownBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    Output()
], IgxDropDownBaseDirective.prototype, "onSelection", void 0);
__decorate([
    Input()
], IgxDropDownBaseDirective.prototype, "width", void 0);
__decorate([
    Input()
], IgxDropDownBaseDirective.prototype, "height", void 0);
__decorate([
    Input()
], IgxDropDownBaseDirective.prototype, "id", void 0);
__decorate([
    Input(),
    HostBinding('style.maxHeight')
], IgxDropDownBaseDirective.prototype, "maxHeight", void 0);
__decorate([
    HostBinding('class.igx-drop-down')
], IgxDropDownBaseDirective.prototype, "cssClass", void 0);
IgxDropDownBaseDirective = __decorate([ __param(2, Optional()), __param(2, Inject(DisplayDensityToken))
], IgxDropDownBaseDirective);

let DisplayContainerComponent = class DisplayContainerComponent {
    constructor(cdr, _viewContainer) {
        this.cdr = cdr;
        this._viewContainer = _viewContainer;
        this.cssClass = 'igx-display-container';
        this.notVirtual = true;
    }
};
DisplayContainerComponent.ɵfac = function DisplayContainerComponent_Factory(t) { return new (t || DisplayContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
DisplayContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DisplayContainerComponent, selectors: [["igx-display-container"]], viewQuery: function DisplayContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c3, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._vcr = _t.first);
    } }, hostVars: 4, hostBindings: function DisplayContainerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClass);
        ɵngcc0.ɵɵclassProp("igx-display-container--inactive", ctx.notVirtual);
    } }, decls: 2, vars: 2, consts: [["igxScrollInertia", "", 3, "IgxScrollInertiaScrollContainer", "IgxScrollInertiaDirection"], ["display_container", ""]], template: function DisplayContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, DisplayContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("IgxScrollInertiaScrollContainer", ctx.scrollContainer)("IgxScrollInertiaDirection", ctx.scrollDirection);
    } }, directives: function () { return [IgxScrollInertiaDirective]; }, encapsulation: 2 });
DisplayContainerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ViewContainerRef }
];
__decorate([
    ViewChild('display_container', { read: ViewContainerRef, static: true })
], DisplayContainerComponent.prototype, "_vcr", void 0);
__decorate([
    HostBinding('class')
], DisplayContainerComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-display-container--inactive')
], DisplayContainerComponent.prototype, "notVirtual", void 0);

let VirtualHelperBaseDirective = class VirtualHelperBaseDirective {
    constructor(elementRef, cdr) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.scrollAmount = 0;
        this._size = 0;
        this._afterViewInit = false;
    }
    ngAfterViewInit() {
        this._afterViewInit = true;
    }
    onScroll(event) {
        this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    ngOnDestroy() {
        this.destroyed = true;
    }
    set size(value) {
        if (this.destroyed) {
            return;
        }
        this._size = value;
        if (this._afterViewInit) {
            this.cdr.detectChanges();
        }
    }
    get size() {
        return this._size;
    }
};
VirtualHelperBaseDirective.ɵfac = function VirtualHelperBaseDirective_Factory(t) { return new (t || VirtualHelperBaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
VirtualHelperBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: VirtualHelperBaseDirective, selectors: [["", "igxVirtualHelperBase", ""]], hostBindings: function VirtualHelperBaseDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function VirtualHelperBaseDirective_scroll_HostBindingHandler($event) { return ctx.onScroll($event); });
    } } });
VirtualHelperBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    HostListener('scroll', ['$event'])
], VirtualHelperBaseDirective.prototype, "onScroll", null);

/**
 * @hidden
 */
let HVirtualHelperComponent = class HVirtualHelperComponent extends VirtualHelperBaseDirective {
    constructor(elementRef, cdr) {
        super(elementRef, cdr);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.cssClasses = 'igx-vhelper--horizontal';
    }
};
HVirtualHelperComponent.ɵfac = function HVirtualHelperComponent_Factory(t) { return new (t || HVirtualHelperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
HVirtualHelperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: HVirtualHelperComponent, selectors: [["igx-horizontal-virtual-helper"]], viewQuery: function HVirtualHelperComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c4, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._vcr = _t.first);
    } }, hostVars: 2, hostBindings: function HVirtualHelperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
    } }, inputs: { width: "width" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [[1, "igx-vhelper__placeholder-content"], ["horizontal_container", ""]], template: function HVirtualHelperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.size, "px");
    } }, encapsulation: 2 });
HVirtualHelperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    ViewChild('horizontal_container', { read: ViewContainerRef, static: true })
], HVirtualHelperComponent.prototype, "_vcr", void 0);
__decorate([
    Input()
], HVirtualHelperComponent.prototype, "width", void 0);
__decorate([
    HostBinding('class')
], HVirtualHelperComponent.prototype, "cssClasses", void 0);

let VirtualHelperComponent = class VirtualHelperComponent extends VirtualHelperBaseDirective {
    constructor(elementRef, cdr) {
        super(elementRef, cdr);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.cssClasses = 'igx-vhelper--vertical';
    }
    ngOnInit() {
        this.scrollWidth = this.getScrollWidth();
    }
    getScrollWidth() {
        const div = document.createElement('div');
        const style = div.style;
        style.width = '100px';
        style.height = '100px';
        style.position = 'absolute';
        style.top = '-10000px';
        style.top = '-10000px';
        style.overflow = 'scroll';
        document.body.appendChild(div);
        const scrollWidth = div.offsetWidth - div.clientWidth;
        document.body.removeChild(div);
        return scrollWidth ? scrollWidth + 1 : 0;
    }
};
VirtualHelperComponent.ɵfac = function VirtualHelperComponent_Factory(t) { return new (t || VirtualHelperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
VirtualHelperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: VirtualHelperComponent, selectors: [["igx-virtual-helper"]], viewQuery: function VirtualHelperComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c5, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._vcr = _t.first);
    } }, hostVars: 5, hostBindings: function VirtualHelperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("scrollTop", ctx.scrollTop);
        ɵngcc0.ɵɵclassMap(ctx.cssClasses);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
    } }, inputs: { itemsLength: "itemsLength" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [[1, "igx-vhelper__placeholder-content"], ["container", ""]], template: function VirtualHelperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.size, "px");
    } }, encapsulation: 2 });
VirtualHelperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    HostBinding('scrollTop')
], VirtualHelperComponent.prototype, "scrollTop", void 0);
__decorate([
    HostBinding('style.width.px')
], VirtualHelperComponent.prototype, "scrollWidth", void 0);
__decorate([
    ViewChild('container', { read: ViewContainerRef, static: true })
], VirtualHelperComponent.prototype, "_vcr", void 0);
__decorate([
    Input()
], VirtualHelperComponent.prototype, "itemsLength", void 0);
__decorate([
    HostBinding('class')
], VirtualHelperComponent.prototype, "cssClasses", void 0);

/**
 * @hidden
 */
let IgxScrollInertiaDirective = class IgxScrollInertiaDirective {
    constructor(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
    }
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            this.parentElement = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
            const targetElem = this.parentElement;
            targetElem.addEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.addEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.addEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.addEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.addEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.addEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.addEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.addEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     */
    onWheel(evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        let scrollDeltaX;
        let scrollDeltaY;
        const scrollStep = this.wheelStep;
        const minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX / 120;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaX = this.calcAxisCoords(evt.deltaX, -1, 1);
        }
        /** Get delta for the Y axis */
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY / 120;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaY = this.calcAxisCoords(evt.deltaY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            const curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            const maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt, true);
        }
    }
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    preventParentScroll(evt, preventDefault) {
        const curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        const maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            if (preventDefault) {
                evt.preventDefault();
            }
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    }
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    onTouchStart(event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        const touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    onTouchMove(event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touch = event.touches[0];
        const destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        const destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        const timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            const speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            const speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        let scrolledXY; // Object: {x, y}
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, true);
        }
    }
    onTouchEnd(event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        let speedX = 0;
        let speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (let i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event, false);
        }
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     */
    onPointerDown(event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.parentElement;
        }
        this._gestureObject.addPointer(this._pointer);
    }
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     */
    onPointerUp(event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    }
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     */
    onMSGestureStart(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    }
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     */
    onMSGestureChange(event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        const touchPos = event, destX = this._startX + this._touchStartX - touchPos.screenX, destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    }
    calcAxisCoords(target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    }
    _scrollTo(destX, destY) {
        const curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        const curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // TODO Trigger scrolling event?
        const scrolledX = this._scrollToX(destX);
        const scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    }
    _scrollToX(dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    }
    _scrollToY(dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    }
    _inertiaInit(speedX, speedY) {
        const stepModifer = this.inertiaStep, inertiaDuration = this.inertiaDuration;
        let x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        const inertiaStep = () => {
            if (x > 6) {
                cancelAnimationFrame(this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * this.inertiaDeltaY) {
                    this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * this.inertiaDeltaX) {
                    this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            this._scrollTo(this._nextX, this._nextY);
            this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    }
    ngOnDestroy() {
        this._zone.runOutsideAngular(() => {
            const targetElem = this.parentElement;
            targetElem.removeEventListener('wheel', (evt) => { this.onWheel(evt); });
            targetElem.removeEventListener('touchstart', (evt) => { this.onTouchStart(evt); });
            targetElem.removeEventListener('touchmove', (evt) => { this.onTouchMove(evt); });
            targetElem.removeEventListener('touchend', (evt) => { this.onTouchEnd(evt); });
            targetElem.removeEventListener('pointerdown', (evt) => { this.onPointerDown(evt); });
            targetElem.removeEventListener('pointerup', (evt) => { this.onPointerUp(evt); });
            targetElem.removeEventListener('MSGestureStart', (evt) => { this.onMSGestureStart(evt); });
            targetElem.removeEventListener('MSGestureChange', (evt) => { this.onMSGestureChange(evt); });
        });
    }
};
IgxScrollInertiaDirective.ɵfac = function IgxScrollInertiaDirective_Factory(t) { return new (t || IgxScrollInertiaDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxScrollInertiaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxScrollInertiaDirective, selectors: [["", "igxScrollInertia", ""]], inputs: { wheelStep: "wheelStep", inertiaStep: "inertiaStep", swipeToleranceX: "swipeToleranceX", inertiaDeltaY: "inertiaDeltaY", inertiaDeltaX: "inertiaDeltaX", inertiaDuration: "inertiaDuration", IgxScrollInertiaDirection: "IgxScrollInertiaDirection", IgxScrollInertiaScrollContainer: "IgxScrollInertiaScrollContainer" } });
IgxScrollInertiaDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "IgxScrollInertiaDirection", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "IgxScrollInertiaScrollContainer", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "wheelStep", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaStep", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "swipeToleranceX", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaDeltaY", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaDeltaX", void 0);
__decorate([
    Input()
], IgxScrollInertiaDirective.prototype, "inertiaDuration", void 0);
/**
 * @hidden
 */
let IgxScrollInertiaModule = class IgxScrollInertiaModule {
};
IgxScrollInertiaModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxScrollInertiaModule });
IgxScrollInertiaModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxScrollInertiaModule_Factory(t) { return new (t || IgxScrollInertiaModule)(); }, imports: [[CommonModule]] });

let IgxForOfSyncService = class IgxForOfSyncService {
    constructor() {
        this._master = new Map();
    }
    /**
     * @hidden
     */
    isMaster(directive) {
        return this._master.get(directive.igxForScrollOrientation) === directive;
    }
    /**
     * @hidden
     */
    setMaster(directive, forced = false) {
        const orientation = directive.igxForScrollOrientation;
        if (orientation && (forced || !this._master.has(orientation))) {
            this._master.set(orientation, directive);
        }
    }
    /**
     * @hidden
     */
    resetMaster() {
        this._master.clear();
    }
    /**
     * @hidden
     */
    sizesCache(dir) {
        return this._master.get(dir).sizesCache;
    }
    /**
     * @hidden
     */
    chunkSize(dir) {
        return this._master.get(dir).state.chunkSize;
    }
};
IgxForOfSyncService.ɵfac = function IgxForOfSyncService_Factory(t) { return new (t || IgxForOfSyncService)(); };
IgxForOfSyncService.ɵprov = ɵɵdefineInjectable({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
let IgxForOfScrollSyncService = class IgxForOfScrollSyncService {
    constructor() {
        this._masterScroll = new Map();
    }
    setScrollMaster(dir, scroll) {
        this._masterScroll.set(dir, scroll);
    }
    getScrollMaster(dir) {
        return this._masterScroll.get(dir);
    }
};
IgxForOfScrollSyncService.ɵfac = function IgxForOfScrollSyncService_Factory(t) { return new (t || IgxForOfScrollSyncService)(); };
IgxForOfScrollSyncService.ɵprov = ɵɵdefineInjectable({ factory: function IgxForOfScrollSyncService_Factory() { return new IgxForOfScrollSyncService(); }, token: IgxForOfScrollSyncService, providedIn: "root" });

/**
 *  @publicApi
 */
class IgxForOfContext {
    constructor($implicit, index, count) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     */
    get first() { return this.index === 0; }
    /**
     * A function that returns whether the element is the last or not
     */
    get last() { return this.index === this.count - 1; }
    /**
     * A function that returns whether the element is even or not
     */
    get even() { return this.index % 2 === 0; }
    /**
     * A function that returns whether the element is odd or not
     */
    get odd() { return !this.even; }
}
let IgxForOfDirective = class IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        /**
         * An @Input property that specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */
        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.onScrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.onContentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /** Height that is being virtualized. */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollTop = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * Similar to the property totalItemCount, but this will allow setting the data count into the template.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
     *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     */
    get igxForTotalItemCount() {
        return this.totalItemCount;
    }
    set igxForTotalItemCount(value) {
        this.totalItemCount = value;
    }
    get displayContainer() {
        return this.dc.instance._viewContainer.element.nativeElement;
    }
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    get sizesCache() {
        return this._sizesCache;
    }
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    /**
     * @hidden
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    /**
     * @hidden
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => this.scrollComponent.nativeElement.removeEventListener('scroll', this.func));
        }
        else {
            this._zone.runOutsideAngular(() => this.scrollComponent.nativeElement.removeEventListener('scroll', this.verticalScrollHandler));
        }
    }
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        let totalSize = 0;
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        const dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            totalSize = this.initSizesCache(this.igxForOf);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache, 0), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            const factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.scrollComponent = vc.createComponent(factory).instance;
            this._maxHeight = this._calcMaxBrowserHeight();
            this.scrollComponent.size = this.igxForOf ? this._calcHeight() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            const destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(destructor, filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, { leading: true, trailing: true }))
                .subscribe(() => {
                this._zone.runTask(() => {
                    this.updateSizes();
                });
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => { this.onHScroll(evt); };
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                const hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.scrollComponent = vc.createComponent(hvFactory).instance;
                this.scrollComponent.size = totalSize;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateHScrollOffset();
        }
    }
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new ResizeObserver(() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        const forOf = 'igxForOf';
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    this.onDataChanged.emit();
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    addScrollTop(addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        const originalVirtScrollTop = this._virtScrollTop;
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.scrollPosition += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && this.scrollPosition === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param index
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition = nextScroll;
        }
        else {
            const maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.scrollPosition = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    scrollNext() {
        const scr = Math.ceil(this.scrollPosition);
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    scrollNextPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    scrollPrevPage() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.scrollPosition -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            const containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    }
    /**
     * @hidden
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    getItemCountInView() {
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    getScroll() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    getScrollbarWidth() {
        return this.scrollComponent ? this.scrollComponent.scrollWidth : 0;
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    getScrollForIndex(index, bottom) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    updateSizes() {
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        this.onContentSizeChange.emit();
    }
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    recalcUpdateSizes() {
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const diffs = [];
        let totalDiff = 0;
        const l = this._embeddedViews.length;
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);
        for (let i = 0; i < l; i++) {
            const rNode = rNodes[i];
            if (rNode) {
                const h = rNode.offsetHeight || parseInt(this.igxForItemSize, 10);
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                const oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                const newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                const totalWidth = parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10) + totalDiff;
                this.scrollComponent.nativeElement.children[0].style.width = totalWidth + 'px';
            }
            const reducer = (acc, val) => acc + val;
            if (this.igxForScrollOrientation === 'vertical') {
                const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                const hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.scrollComponent.destroyed) {
                    this.scrollComponent.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    const containerSize = parseInt(this.igxForContainerSize, 10);
                    const maxVirtScrollTop = this._virtHeight - containerSize;
                    this._bScrollInternal = true;
                    this._virtScrollTop = maxVirtScrollTop;
                    this.scrollPosition = maxVirtScrollTop;
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    if (sumDiffs !== 0) {
                        this.addScrollTop(sumDiffs);
                    }
                    this._adjustToIndex = null;
                }
            }
        }
    }
    /**
     * @hidden
     */
    fixedUpdateAllElements(inScrollTop) {
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        const prevStart = this.state.startIndex;
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                // recalculate and apply page size.
                if (diff && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    diff > 0 ? this.moveApplyScrollNext(prevStart) : this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    moveApplyScrollNext(prevIndex) {
        const start = prevIndex + this.state.chunkSize;
        const end = start + this.state.startIndex - prevIndex;
        const container = this.dc.instance._vcr;
        for (let i = start; i < end && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews.shift();
            this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                || embView.rootNodes[0].nextElementSibling);
            const view = container.detach(0);
            this.updateTemplateContext(embView.context, i);
            container.insert(view);
            this._embeddedViews.push(embView);
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    moveApplyScrollPrev(prevIndex) {
        const container = this.dc.instance._vcr;
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            const embView = this._embeddedViews.pop();
            this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                || embView.rootNodes[0].nextElementSibling);
            const view = container.detach(container.length - 1);
            this.updateTemplateContext(embView.context, i);
            container.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    }
    /**
     * @hidden
     */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * Function which updates the passed context of an embedded view with the provided index
     * from the view container.
     * Often, called while handling a scroll event.
     */
    updateTemplateContext(context, index = 0) {
        context.$implicit = this.igxForOf[index];
        context.index = this.getContextIndex(this.igxForOf[index]);
        context.count = this.igxForOf.length;
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    fixedApplyScroll() {
        let j = 0;
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews[j++];
            this.updateTemplateContext(embView.context, i);
        }
    }
    /**
     * @hidden
     * @internal
     *
     * Clears focus inside the virtualized container on small scroll swaps.
     */
    scrollFocus(node) {
        const activeElement = document.activeElement;
        // Remove focus in case the the active element is inside the view container.
        // Otherwise we hit an exception while doing the 'small' scrolls swapping.
        // For more information:
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
        if (node && node.contains(document.activeElement)) {
            activeElement.blur();
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        const prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(event.target.scrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     */
    get igxForTrackBy() { return this._trackByFn; }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     */
    set igxForTrackBy(fn) { this._trackByFn = fn; }
    /**
     * @hidden
     */
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex = this.state.startIndex;
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     */
    _calcMaxBrowserHeight() {
        const div = document.createElement('div');
        const style = div.style;
        style.position = 'absolute';
        style.top = '9999999999999999px';
        document.body.appendChild(div);
        const size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    _calculateChunkSize() {
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     */
    getElement(viewref, nodeName) {
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     */
    initSizesCache(items) {
        let totalSize = 0;
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        const newHeight = this.initSizesCache(this.igxForOf);
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
        }
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        let i = 0;
        let length = 0;
        let maxLength = 0;
        const arr = [];
        let sum = 0;
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            const size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        const prevItem = this.igxForOf[prevIndex];
                        const prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     */
    getIndexAt(left, set, index) {
        let start = 0;
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            const midIdx = Math.floor((start + end) / 2);
            const midLeft = set[midIdx];
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    _recalcScrollBarSize() {
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        const scrollable = this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            const totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
                // Need to reset the scrollAmount value here, because horizontalScrollBar is hidden, therefore
                // onScroll event handler for VirtualHelperBaseDirective will not be called
                this.scrollComponent.scrollAmount = 0;
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = this._calcHeight();
            if (this.scrollComponent.size <= parseInt(this.igxForContainerSize, 10)) {
                this.scrollPosition = 0;
                // Need to reset the scrollAmount value here, because verticalScrollBar is hidden, therefore
                // onScroll event handler for VirtualHelperBaseDirective will not be called
                this.scrollComponent.scrollAmount = 0;
            }
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.onScrollbarVisibilityChanged.emit();
        }
    }
    _calcHeight() {
        let height;
        if (this.heightCache) {
            height = this.heightCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    }
    _recalcOnContainerChange(changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.igxForScrollOrientation === 'horizontal') {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            const scrollOffset = this.fixedUpdateAllElements(this.scrollPosition);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    removeLastElem() {
        const oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => {
            this.cdr.markForCheck();
        });
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    applyChunkSizeChange() {
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    _updateScrollOffset() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    }
    _updateVScrollOffset() {
        let scrollOffset = 0;
        let currentScrollTop = this.scrollPosition;
        if (this._virtHeightRatio !== 1) {
            this._calcVirtualScrollTop(this.scrollPosition);
            currentScrollTop = this._virtScrollTop;
        }
        const vScroll = this.scrollComponent.nativeElement;
        scrollOffset = vScroll && this.scrollComponent.size ?
            currentScrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    }
    _calcVirtualScrollTop(scrollTop) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxRealScrollTop = this.scrollComponent.size - containerSize;
        const realPercentScrolled = maxRealScrollTop !== 0 ? scrollTop / maxRealScrollTop : 0;
        const maxVirtScrollTop = this._virtHeight - containerSize;
        this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
    }
    _updateHScrollOffset() {
        let scrollOffset = 0;
        scrollOffset = this.scrollComponent.nativeElement &&
            this.scrollComponent.size ?
            this.scrollPosition - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    _getItemSize(item, dimension) {
        const dim = item[dimension];
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
};
IgxForOfDirective.ɵfac = function IgxForOfDirective_Factory(t) { return new (t || IgxForOfDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxForOfScrollSyncService)); };
IgxForOfDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxForOfDirective, selectors: [["", "igxFor", "", "igxForOf", ""]], inputs: { igxForScrollOrientation: "igxForScrollOrientation", igxForTotalItemCount: "igxForTotalItemCount", igxForSizePropName: "igxForSizePropName", igxForOf: "igxForOf", igxForTrackBy: "igxForTrackBy", igxForScrollContainer: "igxForScrollContainer", igxForContainerSize: "igxForContainerSize", igxForItemSize: "igxForItemSize" }, outputs: { onChunkLoad: "onChunkLoad", onScrollbarVisibilityChanged: "onScrollbarVisibilityChanged", onContentSizeChange: "onContentSizeChange", onDataChanged: "onDataChanged", onBeforeViewDestroyed: "onBeforeViewDestroyed", onChunkPreload: "onChunkPreload" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService }
];
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForOf", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForSizePropName", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForScrollOrientation", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForScrollContainer", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForContainerSize", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForItemSize", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForTotalItemCount", null);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onChunkLoad", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onScrollbarVisibilityChanged", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onContentSizeChange", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onDataChanged", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onBeforeViewDestroyed", void 0);
__decorate([
    Output()
], IgxForOfDirective.prototype, "onChunkPreload", void 0);
__decorate([
    Input()
], IgxForOfDirective.prototype, "igxForTrackBy", null);
function getTypeNameForDebugging(type) {
    const name = 'name';
    return type[name] || typeof type;
}
let IgxGridForOfDirective = class IgxGridForOfDirective extends IgxForOfDirective {
    constructor(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, resolver, cdr, _zone, syncScrollService);
        this.syncScrollService = syncScrollService;
        this.syncService = syncService;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.onDataChanging = new EventEmitter();
    }
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    get igxGridForOf() {
        return this.igxForOf;
    }
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    ngOnChanges(changes) {
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get sizesCache() {
        if (this.syncService.isMaster(this)) {
            return this._sizesCache;
        }
        return this.syncService.sizesCache(this.igxForScrollOrientation);
    }
    /**
     * @hidden
     * @internal
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get itemsDimension() {
        return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
    }
    getItemSize(item) {
        let size = 0;
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    initSizesCache(items) {
        if (!this.syncService.isMaster(this)) {
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        let totalSize = 0;
        let size = 0;
        let i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache(changes = null) {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce((acc, val) => acc + val) : 0;
        let newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            newHeight = this.initSizesCache(this.igxForOf);
        }
        const diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            // TODO: This code can be removed. However tests need to be rewritten in a way that they wait for ResizeObserved to complete.
            // So leaving as is for the moment.
            requestAnimationFrame(() => {
                this.recalcUpdateSizes();
                const offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (this.scrollPosition !== 0) {
                    this.scrollPosition = this.sizesCache[this.state.startIndex] - offset;
                }
                else {
                    this._updateScrollOffset();
                }
            });
        }
    }
    handleCacheChanges(changes) {
        const identityChanges = [];
        const newHeightCache = [];
        const newSizesCache = [];
        newSizesCache.push(0);
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    /**
     * @hidden
     * @internal
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                const args = {
                    containerSize: this.igxForContainerSize
                };
                this.onDataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    }
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollTop(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first$1()).subscribe(() => {
            this.recalcUpdateSizes();
        });
        this.cdr.markForCheck();
    }
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.scrollComponent || !parseInt(this.scrollComponent.nativeElement.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    }
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex;
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
        }
    }
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        if (this.syncService.isMaster(this)) {
            return super._calcMaxChunkSize();
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    }
};
IgxGridForOfDirective.ɵfac = function IgxGridForOfDirective_Factory(t) { return new (t || IgxGridForOfDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxForOfScrollSyncService), ɵngcc0.ɵɵdirectiveInject(IgxForOfSyncService)); };
IgxGridForOfDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridForOfDirective, selectors: [["", "igxGridFor", "", "igxGridForOf", ""]], inputs: { igxGridForOf: "igxGridForOf" }, outputs: { onDataChanging: "onDataChanging" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
IgxGridForOfDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxForOfScrollSyncService },
    { type: IgxForOfSyncService }
];
__decorate([
    Input()
], IgxGridForOfDirective.prototype, "igxGridForOf", null);
__decorate([
    Output()
], IgxGridForOfDirective.prototype, "onDataChanging", void 0);
/**
 * @hidden
 */
let IgxForOfModule = class IgxForOfModule {
};
IgxForOfModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxForOfModule });
IgxForOfModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxForOfModule_Factory(t) { return new (t || IgxForOfModule)(); }, imports: [[IgxScrollInertiaModule, CommonModule]] });

var IgxDropDownComponent_1;
/**
 * **Ignite UI for Angular DropDown** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop_down.html)
 *
 * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
 * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
 *
 * Example:
 * ```html
 * <igx-drop-down>
 *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
 *     {{ item.value }}
 *   </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
let IgxDropDownComponent = IgxDropDownComponent_1 = class IgxDropDownComponent extends IgxDropDownBaseDirective {
    constructor(elementRef, cdr, selection, _displayDensityOptions) {
        super(elementRef, cdr, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this.destroy$ = new Subject();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Gets/sets whether items take focus. Disabled by default.
         * When enabled, drop down items gain tab index and are focused when active -
         * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
         *
         * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
         * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
         *
         * ```typescript
         * // get
         * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
         * ```
         */
        this.allowItemsFocus = false;
    }
    /**
     * @hidden @internal
     */
    get focusedItem() {
        if (this.virtDir) {
            return this._focusedItem && this._focusedItem.index !== -1 ?
                (this.children.find(e => e.index === this._focusedItem.index) || null) :
                null;
        }
        return this._focusedItem;
    }
    set focusedItem(value) {
        if (!value) {
            this.selection.clear(`${this.id}-active`);
            this._focusedItem = null;
            return;
        }
        this._focusedItem = value;
        if (this.virtDir) {
            this._focusedItem = {
                value: value.value,
                index: value.index
            };
        }
        this.selection.set(`${this.id}-active`, new Set([this._focusedItem]));
    }
    get id() {
        return this._id;
    }
    set id(value) {
        this.selection.set(value, this.selection.get(this.id));
        this.selection.clear(this.id);
        this.selection.set(value, this.selection.get(`${this.id}-active`));
        this.selection.clear(`${this.id}-active`);
        this._id = value;
    }
    /** Id of the internal listbox of the drop down */
    get listId() {
        return this.id + '-list';
    }
    /**
     * Get currently selected item
     *
     * ```typescript
     * let currentItem = this.dropdown.selectedItem;
     * ```
     */
    get selectedItem() {
        const selectedItem = this.selection.first_item(this.id);
        if (selectedItem) {
            return selectedItem;
        }
        return null;
    }
    /**
     * Gets if the dropdown is collapsed
     *
     * ```typescript
     * let isCollapsed = this.dropdown.collapsed;
     * ```
     */
    get collapsed() {
        return this.toggleDirective.collapsed;
    }
    /** @hidden @internal */
    get scrollContainer() {
        return this.scrollContainerRef.nativeElement;
    }
    get collectionLength() {
        if (this.virtDir) {
            return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
        }
    }
    /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     */
    open(overlaySettings) {
        this.toggleDirective.open(overlaySettings);
        this.updateScrollPosition();
    }
    /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     */
    close() {
        this.toggleDirective.close();
    }
    /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     */
    toggle(overlaySettings) {
        if (this.collapsed || this.toggleDirective.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /**
     * Select an item by index
     * @param index of the item to select; If the drop down uses *igxFor, pass the index in data
     */
    setSelectedItem(index) {
        if (index < 0 || index >= this.items.length) {
            return;
        }
        let newSelection;
        if (this.virtDir) {
            newSelection = {
                value: this.virtDir.igxForOf[index],
                index
            };
        }
        else {
            newSelection = this.items[index];
        }
        this.selectItem(newSelection);
    }
    /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     * @param newIndex number
     */
    navigateItem(index) {
        if (this.virtDir) {
            if (index === -1 || index >= this.collectionLength) {
                return;
            }
            const direction = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
            const subRequired = this.isIndexOutOfBounds(index, direction);
            this.focusedItem = {
                value: this.virtDir.igxForOf[index],
                index: index
            };
            if (subRequired) {
                this.virtDir.scrollTo(index);
            }
            if (subRequired) {
                this.virtDir.onChunkLoad.pipe(take(1)).subscribe(() => {
                    this.skipHeader(direction);
                });
            }
            else {
                this.skipHeader(direction);
            }
        }
        else {
            super.navigateItem(index);
        }
        if (this.allowItemsFocus && this.focusedItem) {
            this.focusedItem.element.nativeElement.focus();
            this.cdr.markForCheck();
        }
    }
    isIndexOutOfBounds(index, direction) {
        const virtState = this.virtDir.state;
        const currentPosition = this.virtDir.getScroll().scrollTop;
        const itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
        const indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
        const scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
        const subRequired = indexOutOfChunk || scrollNeeded;
        return subRequired;
    }
    skipHeader(direction) {
        if (!this.focusedItem) {
            return;
        }
        if (this.focusedItem.isHeader || this.focusedItem.disabled) {
            if (direction === Navigate.Up) {
                this.navigatePrev();
            }
            else {
                this.navigateNext();
            }
        }
    }
    /**
     * @hidden @internal
     */
    updateScrollPosition() {
        if (!this.virtDir) {
            return;
        }
        if (!this.selectedItem) {
            this.virtDir.scrollTo(0);
            return;
        }
        let targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
        const itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
        targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
        this.virtDir.getScroll().scrollTop = targetScroll;
    }
    /**
     * @hidden @internal
     */
    onToggleOpening(e) {
        this.onOpening.emit(e);
        if (e.cancel) {
            return;
        }
        if (this.virtDir) {
            this.virtDir.scrollPosition = this._scrollPosition;
        }
    }
    /**
     * @hidden @internal
     */
    onToggleContentAppended() {
        if (!this.virtDir && this.selectedItem) {
            this.scrollToItem(this.selectedItem);
        }
    }
    /**
     * @hidden @internal
     */
    onToggleOpened() {
        if (this.selectedItem) {
            this.focusedItem = this.selectedItem;
            this._focusedItem.focused = true;
        }
        else if (this.allowItemsFocus) {
            this.navigateFirst();
        }
        this.onOpened.emit();
    }
    /**
     * @hidden @internal
     */
    onToggleClosing(e) {
        this.onClosing.emit(e);
        if (this.virtDir) {
            this._scrollPosition = this.virtDir.scrollPosition;
        }
    }
    /**
     * @hidden @internal
     */
    onToggleClosed() {
        if (this._focusedItem) {
            this._focusedItem.focused = false;
        }
        this.onClosed.emit();
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
        this.selection.clear(`${this.id}-active`);
    }
    scrollToItem(item) {
        const itemPosition = this.calculateScrollPosition(item);
        //  in IE11 setting sctrollTop is somehow slow and forces dropdown
        //  to appear on screen before animation start. As a result dropdown
        //  flickers badly. This is why we set scrollTop just a little later
        //  allowing animation to start and prevent dropdown flickering
        if (isIE()) {
            setTimeout(() => {
                this.scrollContainer.scrollTop = (itemPosition);
            }, 1);
        }
        else {
            this.scrollContainer.scrollTop = (itemPosition);
        }
    }
    /** @hidden @internal */
    calculateScrollPosition(item) {
        if (!item) {
            return 0;
        }
        const elementRect = item.element.nativeElement.getBoundingClientRect();
        const parentRect = this.scrollContainer.getBoundingClientRect();
        const scrollDelta = parentRect.top - elementRect.top;
        let scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = this.scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += item.elementHeight / 2;
        return Math.floor(scrollPosition);
    }
    /**
     * @hidden @internal
     */
    // temp workaround until fix --> https://github.com/angular/angular/issues/34992
    ngOnChanges(changes) {
        if (changes.id) {
            this.toggleDirective.id = changes.id.currentValue;
        }
    }
    ngAfterViewInit() {
        if (this.virtDir) {
            this.virtDir.igxForItemSize = 28;
        }
    }
    /** Keydown Handler */
    onItemActionKey(key, event) {
        super.onItemActionKey(key, event);
        this.close();
    }
    /**
     * Virtual scroll implementation
     * @hidden @internal
     */
    navigateFirst() {
        if (this.virtDir) {
            this.navigateItem(0);
        }
        else {
            super.navigateFirst();
        }
    }
    /**
     * @hidden @internal
     */
    navigateLast() {
        if (this.virtDir) {
            this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
        }
        else {
            super.navigateLast();
        }
    }
    /**
     * @hidden @internal
     */
    navigateNext() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden @internal
     */
    navigatePrev() {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     * @hidden
     * @internal
     * @param newSelection
     * @param event
     */
    selectItem(newSelection, event) {
        const oldSelection = this.selectedItem;
        if (!newSelection) {
            newSelection = this.focusedItem;
        }
        if (newSelection === null) {
            return;
        }
        if (newSelection instanceof IgxDropDownItemBaseDirective && newSelection.isHeader) {
            return;
        }
        if (this.virtDir) {
            newSelection = {
                value: newSelection.value,
                index: newSelection.index
            };
        }
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (!args.cancel) {
            if (this.isSelectionValid(args.newSelection)) {
                this.selection.set(this.id, new Set([args.newSelection]));
                if (!this.virtDir) {
                    if (oldSelection) {
                        oldSelection.selected = false;
                    }
                    if (args.newSelection) {
                        args.newSelection.selected = true;
                    }
                }
                if (event) {
                    this.toggleDirective.close();
                }
            }
            else {
                throw new Error('Please provide a valid drop-down item for the selection!');
            }
        }
    }
    /**
     * Clears the selection of the dropdown
     * ```typescript
     * this.dropdown.clearSelection();
     * ```
     */
    clearSelection() {
        const oldSelection = this.selectedItem;
        const newSelection = null;
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (this.selectedItem && !args.cancel) {
            this.selectedItem.selected = false;
            this.selection.clear(this.id);
        }
    }
    /**
     * Checks whether the selection is valid
     * `null` - the selection should be emptied
     * Virtual? - the selection should at least have and `index` and `value` property
     * Non-virtual? - the selection should be a valid drop-down item and **not** be a header
     */
    isSelectionValid(selection) {
        return selection === null
            || (this.virtDir && selection.hasOwnProperty('value') && selection.hasOwnProperty('index'))
            || (selection instanceof IgxDropDownItemComponent && !selection.isHeader);
    }
};
IgxDropDownComponent.ɵfac = function IgxDropDownComponent_Factory(t) { return new (t || IgxDropDownComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxDropDownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDropDownComponent, selectors: [["igx-drop-down"]], contentQueries: function IgxDropDownComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxForOfDirective, true, IgxForOfDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDropDownItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, viewQuery: function IgxDropDownComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵstaticViewQuery(_c6, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollContainerRef = _t.first);
    } }, inputs: { allowItemsFocus: "allowItemsFocus", id: "id" }, outputs: { onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c2, decls: 4, vars: 8, consts: [["igxToggle", "", 1, "igx-drop-down__list", 3, "onOpening", "onOpened", "onAppended", "onClosing", "onClosed"], ["role", "listbox", 1, "igx-drop-down__list-scroll"], ["scrollContainer", ""], [4, "ngIf"]], template: function IgxDropDownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("onOpening", function IgxDropDownComponent_Template_div_onOpening_0_listener($event) { return ctx.onToggleOpening($event); })("onOpened", function IgxDropDownComponent_Template_div_onOpened_0_listener() { return ctx.onToggleOpened(); })("onAppended", function IgxDropDownComponent_Template_div_onAppended_0_listener() { return ctx.onToggleContentAppended(); })("onClosing", function IgxDropDownComponent_Template_div_onClosing_0_listener($event) { return ctx.onToggleClosing($event); })("onClosed", function IgxDropDownComponent_Template_div_onClosed_0_listener() { return ctx.onToggleClosed(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, IgxDropDownComponent_ng_container_3_Template, 2, 0, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.height)("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵattribute("id", ctx.listId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
    } }, directives: [IgxToggleDirective, ɵngcc2.NgIf], encapsulation: 2 });
IgxDropDownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    ContentChild(IgxForOfDirective, { read: IgxForOfDirective })
], IgxDropDownComponent.prototype, "virtDir", void 0);
__decorate([
    ViewChild(IgxToggleDirective, { static: true })
], IgxDropDownComponent.prototype, "toggleDirective", void 0);
__decorate([
    ViewChild('scrollContainer', { static: true })
], IgxDropDownComponent.prototype, "scrollContainerRef", void 0);
__decorate([
    ContentChildren(forwardRef(() => IgxDropDownItemComponent), { descendants: true })
], IgxDropDownComponent.prototype, "children", void 0);
__decorate([
    Output()
], IgxDropDownComponent.prototype, "onOpening", void 0);
__decorate([
    Output()
], IgxDropDownComponent.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxDropDownComponent.prototype, "onClosing", void 0);
__decorate([
    Output()
], IgxDropDownComponent.prototype, "onClosed", void 0);
__decorate([
    Input()
], IgxDropDownComponent.prototype, "allowItemsFocus", void 0);
__decorate([
    Input()
], IgxDropDownComponent.prototype, "id", null);
IgxDropDownComponent = IgxDropDownComponent_1 = __decorate([ __param(3, Optional()), __param(3, Inject(DisplayDensityToken))
], IgxDropDownComponent);

/**
 * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBaseDirective component
 */
let IgxDropDownItemNavigationDirective = class IgxDropDownItemNavigationDirective {
    constructor(dropdown) {
        this.dropdown = dropdown;
        this._target = null;
    }
    /**
     * Gets the target of the navigation directive;
     *
     * ```typescript
     * // Get
     * export class MyComponent {
     *  ...
     *  @ContentChild(IgxDropDownNavigationDirective)
     *  navDirective: IgxDropDownNavigationDirective = null
     *  ...
     *  const navTarget: IgxDropDownBaseDirective = navDirective.navTarget
     * }
     * ```
     */
    get target() {
        return this._target;
    }
    /**
     * Sets the target of the navigation directive;
     * If no valid target is passed, it falls back to the drop down context
     *
     * ```html
     * <!-- Set -->
     * <input [igxDropDownItemNavigation]="dropdown" />
     * ...
     * <igx-drop-down #dropdown>
     * ...
     * </igx-drop-down>
     * ```
     */
    set target(target) {
        this._target = target ? target : this.dropdown;
    }
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     */
    handleKeyDown(event) {
        if (event) {
            const key = event.key.toLowerCase();
            if (!this.target.collapsed) { // If dropdown is opened
                const navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                    'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
            }
            else { // If dropdown is closed, do nothing
                return;
            }
            switch (key) {
                case 'esc':
                case 'escape':
                    this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                    break;
                case 'enter':
                    this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                    break;
                case 'space':
                case 'spacebar':
                case ' ':
                    this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                    break;
                case 'arrowup':
                case 'up':
                    this.onArrowUpKeyDown();
                    break;
                case 'arrowdown':
                case 'down':
                    this.onArrowDownKeyDown();
                    break;
                case 'home':
                    this.onHomeKeyDown();
                    break;
                case 'end':
                    this.onEndKeyDown();
                    break;
                default:
                    return;
            }
        }
    }
    /**
     * Navigates to previous item
     */
    onArrowDownKeyDown() {
        this.target.navigateNext();
    }
    /**
     * Navigates to previous item
     */
    onArrowUpKeyDown() {
        this.target.navigatePrev();
    }
    /**
     * Navigates to target's last item
     */
    onEndKeyDown() {
        this.target.navigateLast();
    }
    /**
     * Navigates to target's first item
     */
    onHomeKeyDown() {
        this.target.navigateFirst();
    }
};
IgxDropDownItemNavigationDirective.ɵfac = function IgxDropDownItemNavigationDirective_Factory(t) { return new (t || IgxDropDownItemNavigationDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE, 10)); };
IgxDropDownItemNavigationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDownItemNavigationDirective, selectors: [["", "igxDropDownItemNavigation", ""]], hostBindings: function IgxDropDownItemNavigationDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxDropDownItemNavigationDirective_keydown_HostBindingHandler($event) { return ctx.handleKeyDown($event); });
    } }, inputs: { target: ["igxDropDownItemNavigation", "target"] } });
IgxDropDownItemNavigationDirective.ctorParameters = () => [
    { type: IgxDropDownBaseDirective, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [IGX_DROPDOWN_BASE,] }] }
];
__decorate([
    Input('igxDropDownItemNavigation')
], IgxDropDownItemNavigationDirective.prototype, "target", null);
__decorate([
    HostListener('keydown', ['$event'])
], IgxDropDownItemNavigationDirective.prototype, "handleKeyDown", null);
IgxDropDownItemNavigationDirective = __decorate([ __param(0, Self()), __param(0, Optional()), __param(0, Inject(IGX_DROPDOWN_BASE))
], IgxDropDownItemNavigationDirective);

/**
 * @hidden
 */
let IgxDropDownModule = class IgxDropDownModule {
};
IgxDropDownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDropDownModule });
IgxDropDownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDropDownModule_Factory(t) { return new (t || IgxDropDownModule)(); }, imports: [[
            CommonModule,
            IgxToggleModule
        ]] });

var IgxHintPosition;
(function (IgxHintPosition) {
    IgxHintPosition[IgxHintPosition["START"] = 0] = "START";
    IgxHintPosition[IgxHintPosition["END"] = 1] = "END";
})(IgxHintPosition || (IgxHintPosition = {}));
let IgxHintDirective = class IgxHintDirective {
    constructor(_element) {
        this._element = _element;
        this._position = IgxHintPosition.START;
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         * @memberof IgxHintDirective
         */
        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         * @memberof IgxHintDirective
         */
        this.isPositionEnd = false;
    }
    /**
     * Sets the position of the hint.
     * ```html
     * <igx-input-group>
     *  <input igxInput type="text"/>
     *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
     * </igx-input-group>
     * ```
     * @memberof IgxHintDirective
     */
    set position(value) {
        const position = IgxHintPosition[value.toUpperCase()];
        if (position !== undefined) {
            this._position = position;
            this._applyPosition(this._position);
        }
    }
    /**
     * Gets the position of the hint.
     * ```typescript
     * @ViewChild('hint', {read: IgxHintDirective})
     * public igxHint: IgxHintDirective;
     * let hintPosition =  this.igxHint.position;
     * ```
     * @memberof IgxHintDirective
     */
    get position() {
        return this._position.toString();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._applyPosition(this._position);
    }
    _applyPosition(position) {
        this.isPositionStart = this.isPositionEnd = false;
        switch (position) {
            case IgxHintPosition.START:
                this.isPositionStart = true;
                break;
            case IgxHintPosition.END:
                this.isPositionEnd = true;
                break;
            default: break;
        }
    }
};
IgxHintDirective.ɵfac = function IgxHintDirective_Factory(t) { return new (t || IgxHintDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxHintDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHintDirective, selectors: [["igx-hint"], ["", "igxHint", ""]], hostVars: 4, hostBindings: function IgxHintDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-input-group__hint-item--start", ctx.isPositionStart)("igx-input-group__hint-item--end", ctx.isPositionEnd);
    } }, inputs: { position: "position" } });
IgxHintDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('class.igx-input-group__hint-item--start')
], IgxHintDirective.prototype, "isPositionStart", void 0);
__decorate([
    HostBinding('class.igx-input-group__hint-item--end')
], IgxHintDirective.prototype, "isPositionEnd", void 0);
__decorate([
    Input('position')
], IgxHintDirective.prototype, "position", null);

/** @hidden */
class IgxInputGroupBase {
}

const nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];
var IgxInputState;
(function (IgxInputState) {
    IgxInputState[IgxInputState["INITIAL"] = 0] = "INITIAL";
    IgxInputState[IgxInputState["VALID"] = 1] = "VALID";
    IgxInputState[IgxInputState["INVALID"] = 2] = "INVALID";
})(IgxInputState || (IgxInputState = {}));
/**
 * The `igxInput` directive creates single- or multiline text elements, covering common scenarios when dealing with form inputs.
 *
 * @igxModule IgxInputGroupModule
 *
 * @igxParent Data Entry & Display
 *
 * @igxTheme igx-input-group-theme
 *
 * @igxKeywords input, input group, form, field, validation
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <input-group>
 *  <label for="address">Address</label>
 *  <input igxInput name="address" type="text" [(ngModel)]="customer.address">
 * </input-group>
 * ```
 */
let IgxInputDirective = class IgxInputDirective {
    constructor(inputGroup, ngModel, formControl, element, cdr) {
        this.inputGroup = inputGroup;
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.element = element;
        this.cdr = cdr;
        this._valid = IgxInputState.INITIAL;
        /**
         * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.igxInput.isInput = true;
         * ```
         *
         * @example
         * ```typescript
         * let isCLassAdded = this.igxInput.isInput;
         * ```
         */
        this.isInput = false;
        /**
         * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.igxInput.isTextArea = true;
         * ```
         *
         * @example
         * ```typescript
         * let isCLassAdded = this.igxInput.isTextArea;
         * ```
         */
        this.isTextArea = false;
    }
    get ngControl() {
        return this.ngModel ? this.ngModel : this.formControl;
    }
    /**
     * Sets the `value` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [value]="'IgxInput Value'">
     * </input-group>
     * ```
     */
    set value(value) {
        this.nativeElement.value = value;
        this.checkValidity();
    }
    /**
     * Gets the `value` property.
     *
     * @example
     * ```typescript
     * @ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let inputValue = this.igxInput.value;
     * ```
     */
    get value() {
        return this.nativeElement.value;
    }
    /**
     * Sets the `disabled` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [disabled]="true">
     * </input-group>
     * ```
     */
    set disabled(value) {
        this.nativeElement.disabled = value;
        this.inputGroup.disabled = value;
    }
    /**
     * Gets the `disabled` property
     *
     * @example
     * ```typescript
     * @ViewChild('igxInput', {read: IgxInputDirective})
     *  public igxInput: IgxInputDirective;
     * let isDisabled = this.igxInput.disabled;
     * ```
     */
    get disabled() {
        return this.nativeElement.hasAttribute('disabled');
    }
    /**
     * Sets the `required` property.
     *
     * @example
     * ```html
     * <input-group>
     *  <input igxInput #igxInput [required]="true">
     * </input-group>
     * ```
     */
    set required(value) {
        if (typeof value === 'boolean') {
            this.nativeElement.required = this.inputGroup.isRequired = value;
            if (value && !this.nativeElement.checkValidity()) {
                this._valid = IgxInputState.INVALID;
            }
            else {
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /**
     * Gets whether the igxInput is required.
     *
     * @example
     * ```typescript
     * let isRequired = this.igxInput.required;
     * ```
     */
    get required() {
        return this.nativeElement.hasAttribute('required');
    }
    /**
     * @hidden
     * @internal
     */
    onFocus(event) {
        this.inputGroup.isFocused = true;
    }
    /**
     * @param event The event to invoke the handler
     *
     * @hidden
     * @internal
     */
    onBlur(event) {
        this.inputGroup.isFocused = false;
        this._valid = IgxInputState.INITIAL;
        if (this.ngControl) {
            if (!this.ngControl.valid) {
                this._valid = IgxInputState.INVALID;
            }
        }
        else if (this._hasValidators() && !this.nativeElement.checkValidity()) {
            this._valid = IgxInputState.INVALID;
        }
    }
    /**
     * @hidden
     * @internal
     */
    onInput() {
        this.checkValidity();
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
        this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');
        this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
        // Make sure we do not invalidate the input on init
        if (!this.ngControl) {
            this._valid = IgxInputState.INITIAL;
        }
        // Also check the control's validators for required
        if (!this.inputGroup.isRequired && this.ngControl && this.ngControl.control.validator) {
            const validation = this.ngControl.control.validator({});
            this.inputGroup.isRequired = validation && validation.required;
        }
        const elTag = this.nativeElement.tagName.toLowerCase();
        if (elTag === 'textarea') {
            this.isTextArea = true;
        }
        else {
            this.isInput = true;
        }
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /**
     * Sets a focus on the igxInput.
     *
     * @example
     * ```typescript
     * this.igxInput.focus();
     * ```
     */
    focus() {
        this.nativeElement.focus();
    }
    /**
     * Gets the `nativeElement` of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputNativeElement = this.igxInput.nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    onStatusChanged() {
        // Enable/Disable control based on ngControl #7086
        if (this.disabled !== this.ngControl.disabled) {
            this.disabled = this.ngControl.disabled;
        }
        if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
            if (this.ngControl.control.touched || this.ngControl.control.dirty) {
                //  TODO: check the logic when control is touched or dirty
                if (this.inputGroup.isFocused) {
                    // the user is still typing in the control
                    this._valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
                }
                else {
                    // the user had touched the control previously but now the value is changing due to changes in the form
                    this._valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
                }
            }
            else {
                //  if control is untouched and pristine its state is initial. This is when user did not interact
                //  with the input or when form/control is reset
                this._valid = IgxInputState.INITIAL;
            }
        }
    }
    /**
     * Gets whether the igxInput has a placeholder.
     *
     * @example
     * ```typescript
     * let hasPlaceholder = this.igxInput.hasPlaceholder;
     * ```
     */
    get hasPlaceholder() {
        return this.nativeElement.hasAttribute('placeholder');
    }
    /**
     * Gets the placeholder element of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputPlaceholder = this.igxInput.placeholder;
     * ```
     */
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /**
     * @returns An indicator of whether the input has validator attributes or not
     *
     * @hidden
     * @internal
     */
    _hasValidators() {
        for (const nativeValidationAttribute of nativeValidationAttributes) {
            if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                return true;
            }
        }
        return !!this.ngControl && (!!this.ngControl.control.validator || !!this.ngControl.control.asyncValidator);
    }
    /**
     * Gets whether the igxInput is focused.
     *
     * @example
     * ```typescript
     * let isFocused = this.igxInput.focused;
     * ```
     */
    get focused() {
        return this.inputGroup.isFocused;
    }
    /**
     * Gets the state of the igxInput.
     *
     * @example
     * ```typescript
     * let igxInputState = this.igxInput.valid;
     * ```
     */
    get valid() {
        return this._valid;
    }
    /**
     * Gets whether the igxInput is valid.
     *
     * @example
     * ```typescript
     * let valid = this.igxInput.isValid;
     * ```
     */
    get isValid() {
        return this.valid !== IgxInputState.INVALID;
    }
    /**
     * Sets the state of the igxInput.
     *
     * @example
     * ```typescript
     * this.igxInput.valid = IgxInputState.INVALID;
     * ```
     */
    set valid(value) {
        this._valid = value;
    }
    /**
     * A function to assign a validity property of an input.
     *
     * @hidden
     * @internal
     */
    checkValidity() {
        if (!this.ngControl && this._hasValidators()) {
            this._valid = this.nativeElement.checkValidity() ? IgxInputState.VALID : IgxInputState.INVALID;
        }
    }
};
IgxInputDirective.ɵfac = function IgxInputDirective_Factory(t) { return new (t || IgxInputDirective)(ɵngcc0.ɵɵdirectiveInject(IgxInputGroupBase), ɵngcc0.ɵɵdirectiveInject(NgModel, 10), ɵngcc0.ɵɵdirectiveInject(FormControlName, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxInputDirective, selectors: [["", "igxInput", ""]], hostVars: 4, hostBindings: function IgxInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function IgxInputDirective_focus_HostBindingHandler($event) { return ctx.onFocus($event); })("blur", function IgxInputDirective_blur_HostBindingHandler($event) { return ctx.onBlur($event); })("input", function IgxInputDirective_input_HostBindingHandler() { return ctx.onInput(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-input-group__input", ctx.isInput)("igx-input-group__textarea", ctx.isTextArea);
    } }, inputs: { value: "value", disabled: "disabled", required: "required" }, exportAs: ["igxInput"] });
IgxInputDirective.ctorParameters = () => [
    { type: IgxInputGroupBase },
    { type: NgModel, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgModel,] }] },
    { type: FormControlName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormControlName,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxInputDirective.prototype, "value", null);
__decorate([
    Input()
], IgxInputDirective.prototype, "disabled", null);
__decorate([
    Input()
], IgxInputDirective.prototype, "required", null);
__decorate([
    HostBinding('class.igx-input-group__input')
], IgxInputDirective.prototype, "isInput", void 0);
__decorate([
    HostBinding('class.igx-input-group__textarea')
], IgxInputDirective.prototype, "isTextArea", void 0);
__decorate([
    HostListener('focus', ['$event'])
], IgxInputDirective.prototype, "onFocus", null);
__decorate([
    HostListener('blur', ['$event'])
], IgxInputDirective.prototype, "onBlur", null);
__decorate([
    HostListener('input')
], IgxInputDirective.prototype, "onInput", null);
IgxInputDirective = __decorate([ __param(1, Optional()), __param(1, Self()), __param(1, Inject(NgModel)),
    __param(2, Optional()), __param(2, Self()), __param(2, Inject(FormControlName))
], IgxInputDirective);

let NEXT_ID$3 = 0;
let IgxLabelDirective = class IgxLabelDirective {
    constructor() {
        this.defaultClass = true;
        /**
         * @hidden
         */
        this.id = `igx-label-${NEXT_ID$3++}`;
    }
};
IgxLabelDirective.ɵfac = function IgxLabelDirective_Factory(t) { return new (t || IgxLabelDirective)(); };
IgxLabelDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxLabelDirective, selectors: [["", "igxLabel", ""]], hostVars: 3, hostBindings: function IgxLabelDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-input-group__label", ctx.defaultClass);
    } }, inputs: { id: "id" } });
__decorate([
    HostBinding('class.igx-input-group__label')
], IgxLabelDirective.prototype, "defaultClass", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxLabelDirective.prototype, "id", void 0);

/**
 * @hidden
 */
let IgxPrefixDirective = class IgxPrefixDirective {
};
IgxPrefixDirective.ɵfac = function IgxPrefixDirective_Factory(t) { return new (t || IgxPrefixDirective)(); };
IgxPrefixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxPrefixDirective, selectors: [["igx-prefix"], ["", "igxPrefix", ""]] });
/**
 * @hidden
 */
let IgxPrefixModule = class IgxPrefixModule {
};
IgxPrefixModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxPrefixModule });
IgxPrefixModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxPrefixModule_Factory(t) { return new (t || IgxPrefixModule)(); } });

/**
 * @hidden
 */
let IgxSuffixDirective = class IgxSuffixDirective {
};
IgxSuffixDirective.ɵfac = function IgxSuffixDirective_Factory(t) { return new (t || IgxSuffixDirective)(); };
IgxSuffixDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSuffixDirective, selectors: [["igx-suffix"], ["", "igxSuffix", ""]] });
/**
 * @hidden
 */
let IgxSuffixModule = class IgxSuffixModule {
};
IgxSuffixModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSuffixModule });
IgxSuffixModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSuffixModule_Factory(t) { return new (t || IgxSuffixModule)(); } });

var IgxInputGroupComponent_1;
let NEXT_ID$4 = 0;
var IgxInputGroupType;
(function (IgxInputGroupType) {
    IgxInputGroupType[IgxInputGroupType["LINE"] = 0] = "LINE";
    IgxInputGroupType[IgxInputGroupType["BOX"] = 1] = "BOX";
    IgxInputGroupType[IgxInputGroupType["BORDER"] = 2] = "BORDER";
    IgxInputGroupType[IgxInputGroupType["FLUENT"] = 3] = "FLUENT";
    IgxInputGroupType[IgxInputGroupType["BOOTSTRAP"] = 4] = "BOOTSTRAP";
    IgxInputGroupType[IgxInputGroupType["SEARCH"] = 5] = "SEARCH";
    IgxInputGroupType[IgxInputGroupType["FLUENT_SEARCH"] = 6] = "FLUENT_SEARCH";
})(IgxInputGroupType || (IgxInputGroupType = {}));
let IgxInputGroupComponent = IgxInputGroupComponent_1 = class IgxInputGroupComponent extends DisplayDensityBase {
    constructor(_element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._element = _element;
        this._displayDensityOptions = _displayDensityOptions;
        this._type = IgxInputGroupType.LINE;
        this._filled = false;
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-input-group [id]="'igx-input-group-55'"></igx-input-group>
         * ```
         */
        this.id = `igx-input-group-${NEXT_ID$4++}`;
        /**
         * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
         * By default applied the class is applied.
         * ```typescript
         *  @ViewChild("MyInputGroup")
         *  public inputGroup: IgxInputGroupComponent;
         *  ngAfterViewInit(){
         *  this.inputGroup.defaultClass = false;
         * ```
         * }
         */
        this.defaultClass = true;
        /** @hidden */
        this.hasPlaceholder = false;
        /** @hidden */
        this.isRequired = false;
        /** @hidden */
        this.isFocused = false;
        /** @hidden */
        this.isBox = false;
        /** @hidden */
        this.isBorder = false;
        /** @hidden */
        this.isSearch = false;
        /** @hidden */
        this.isFluentSearch = false;
        /** @hidden */
        this.isFluent = false;
        /** @hidden */
        this.isBootstrap = false;
        /**
         * An @Input property that disables the `IgxInputGroupComponent`.
         * ```html
         * <igx-input-group [disabled]="'true'"></igx-input-group>
         * ```
         */
        this.disabled = false;
        /**
         * Prevents automatically focusing the input when clicking on other elements in the input group (e.g. prefix or suffix).
         * @remarks Automatic focus causes software keyboard to show on mobile devices.
         *
         * @example
         * ```html
         * <igx-input-group [suppressInputAutofocus]="true"></igx-input-group>
         * ```
         */
        this.suppressInputAutofocus = false;
        /** @hidden */
        this.hasWarning = false;
        this.element = _element;
    }
    /** @hidden */
    get validClass() {
        return this.input.valid === IgxInputState.VALID;
    }
    /** @hidden */
    get invalidClass() {
        return this.input.valid === IgxInputState.INVALID;
    }
    /** @hidden */
    get isFilled() {
        return this._filled || (this.input && this.input.value);
    }
    /** @hidden */
    get isDisplayDensityCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    /** @hidden */
    get isDisplayDensityComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /** @hidden */
    get isDisplayDensityCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    /** @hidden */
    onClick(event) {
        if (!this.isFocused && event.target !== this.input.nativeElement && !this.suppressInputAutofocus) {
            this.input.focus();
        }
    }
    /** @hidden */
    onPointerDown(event) {
        if (this.isFocused && event.target !== this.input.nativeElement) {
            event.preventDefault();
        }
    }
    /**
     * An @Input property that sets how the input will be styled.
     * The allowed values are `line`, `box`, `border`, `fluent`, `search` and `fluentSearch`. The default is `line`.
     * ```html
     * <igx-input-group [type]="'search'">
     * ```
     */
    set type(value) {
        const type = IgxInputGroupType[value.toUpperCase()];
        if (type !== undefined) {
            this.isBox = this.isBootstrap = this.isFluent = this.isFluentSearch = this.isBorder = this.isSearch = false;
            switch (type) {
                case IgxInputGroupType.BOX:
                    this.isBox = true;
                    break;
                case IgxInputGroupType.BORDER:
                    this.isBorder = true;
                    break;
                case IgxInputGroupType.FLUENT:
                    this.isFluent = true;
                    break;
                case IgxInputGroupType.FLUENT_SEARCH:
                    this.isFluentSearch = true;
                    break;
                case IgxInputGroupType.SEARCH:
                    this.isSearch = true;
                    break;
                case IgxInputGroupType.BOOTSTRAP:
                    this.isBootstrap = true;
                    break;
                default: break;
            }
            this._type = type;
        }
    }
    /**
     * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
     * Values are `line` - 0, `box` - 1, `border` - 2,  `fluent` - 3 `fluentSearch` - 4 and `search` - 5. The default is `line`.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputType = this.inputGroup.type;
     * }
     * ```
     */
    get type() {
        return this._type.toString();
    }
    /**
     * @hidden
     * @deprecated Use 'suppressInputAutofocus' instead.
     */
    get supressInputAutofocus() {
        return this.suppressInputAutofocus;
    }
    /**
     * @hidden
     * @deprecated Use 'suppressInputAutofocus' instead.
     */
    set supressInputAutofocus(value) {
        this.suppressInputAutofocus = value;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has hints.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputHints = this.inputGroup.hasHints;
     * }
     * ```
     */
    get hasHints() {
        return this.hints.length > 0;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` has border.
     * ```typescript
     * @ViewChild("MyInputGroup")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let inputBorder = this.inputGroup.hasBorder;
     * }
     * ```
     */
    get hasBorder() {
        return this._type === IgxInputGroupType.LINE ||
            this._type === IgxInputGroupType.BOX;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is line.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeLine = this.inputGroup.isTypeLine;
     * }
     * ```
     */
    get isTypeLine() {
        return this._type === IgxInputGroupType.LINE;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is box.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBox = this.inputGroup.isTypeBox;
     * }
     * ```
     */
    get isTypeBox() {
        return this._type === IgxInputGroupType.BOX;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is border.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBorder = this.inputGroup.isTypeBorder;
     * }
     * ```
     */
    get isTypeBorder() {
        return this._type === IgxInputGroupType.BORDER;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is Fluent.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeFluent = this.inputGroup.isTypeFluent;
     * }
     * ```
     */
    get isTypeFluent() {
        return this._type === IgxInputGroupType.FLUENT;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is Bootstrap.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeBootstrap = this.inputGroup.isTypeBootstrap;
     * }
     * ```
     */
    get isTypeBootstrap() {
        return this._type === IgxInputGroupType.BOOTSTRAP;
    }
    /** @hidden */
    get isNotMaterial() {
        return this._type === IgxInputGroupType.FLUENT || this._type === IgxInputGroupType.BOOTSTRAP;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is search.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeSearch = this.inputGroup.isTypeSearch;
     * }
     * ```
     */
    get isTypeSearch() {
        return this._type === IgxInputGroupType.SEARCH;
    }
    /**
     * Returns whether the `IgxInputGroupComponent` type is fluentSearch.
     * ```typescript
     * @ViewChild("MyInputGroup1")
     * public inputGroup: IgxInputGroupComponent;
     * ngAfterViewInit(){
     *    let isTypeFluentSearch = this.inputGroup.isTypeFluentSearch;
     * }
     * ```
     */
    get isTypeFluentSearch() {
        return this._type === IgxInputGroupType.FLUENT_SEARCH;
    }
    /** @hidden */
    get filled() {
        return this._filled;
    }
    /** @hidden */
    set filled(val) {
        this._filled = val;
    }
};
IgxInputGroupComponent.ɵfac = function IgxInputGroupComponent_Factory(t) { return new (t || IgxInputGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxInputGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxInputGroupComponent, selectors: [["igx-input-group"]], contentQueries: function IgxInputGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxInputDirective, true, IgxInputDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHintDirective, false, IgxHintDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hints = _t);
    } }, hostVars: 37, hostBindings: function IgxInputGroupComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxInputGroupComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("pointerdown", function IgxInputGroupComponent_pointerdown_HostBindingHandler($event) { return ctx.onPointerDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-input-group", ctx.defaultClass)("igx-input-group--placeholder", ctx.hasPlaceholder)("igx-input-group--required", ctx.isRequired)("igx-input-group--focused", ctx.isFocused)("igx-input-group--box", ctx.isBox)("igx-input-group--border", ctx.isBorder)("igx-input-group--search", ctx.isSearch)("igx-input-group--fluent-search", ctx.isFluentSearch)("igx-input-group--fluent", ctx.isFluent)("igx-input-group--bootstrap", ctx.isBootstrap)("igx-input-group--disabled", ctx.disabled)("igx-input-group--warning", ctx.hasWarning)("igx-input-group--valid", ctx.validClass)("igx-input-group--invalid", ctx.invalidClass)("igx-input-group--filled", ctx.isFilled)("igx-input-group--cosy", ctx.isDisplayDensityCosy)("igx-input-group--comfortable", ctx.isDisplayDensityComfortable)("igx-input-group--compact", ctx.isDisplayDensityCompact);
    } }, inputs: { id: "id", disabled: "disabled", suppressInputAutofocus: "suppressInputAutofocus", type: "type", supressInputAutofocus: "supressInputAutofocus" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 11, vars: 2, consts: [["class", "igx-input-group__wrapper", 4, "ngIf", "ngIfElse"], [1, "igx-input-group__hint"], ["label", ""], ["input", ""], ["inputBundle", ""], ["bundle", ""], [1, "igx-input-group__wrapper"], [4, "ngTemplateOutlet"], [4, "ngIf"], [1, "igx-input-group__bundle"], ["class", "igx-input-group__bundle-main", 4, "ngIf", "ngIfElse"], ["class", "igx-input-group__border", 4, "ngIf"], [1, "igx-input-group__bundle-main"], [1, "igx-input-group__border"]], template: function IgxInputGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, IgxInputGroupComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, IgxInputGroupComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxInputGroupComponent_ng_template_5_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxInputGroupComponent_ng_template_7_Template, 2, 2, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxInputGroupComponent_ng_template_9_Template, 6, 4, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r13 = ɵngcc0.ɵɵreference(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTypeBox)("ngIfElse", _r13);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxInputGroupComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxInputGroupComponent.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-input-group')
], IgxInputGroupComponent.prototype, "defaultClass", void 0);
__decorate([
    HostBinding('class.igx-input-group--placeholder')
], IgxInputGroupComponent.prototype, "hasPlaceholder", void 0);
__decorate([
    HostBinding('class.igx-input-group--required')
], IgxInputGroupComponent.prototype, "isRequired", void 0);
__decorate([
    HostBinding('class.igx-input-group--focused')
], IgxInputGroupComponent.prototype, "isFocused", void 0);
__decorate([
    HostBinding('class.igx-input-group--box')
], IgxInputGroupComponent.prototype, "isBox", void 0);
__decorate([
    HostBinding('class.igx-input-group--border')
], IgxInputGroupComponent.prototype, "isBorder", void 0);
__decorate([
    HostBinding('class.igx-input-group--search')
], IgxInputGroupComponent.prototype, "isSearch", void 0);
__decorate([
    HostBinding('class.igx-input-group--fluent-search')
], IgxInputGroupComponent.prototype, "isFluentSearch", void 0);
__decorate([
    HostBinding('class.igx-input-group--fluent')
], IgxInputGroupComponent.prototype, "isFluent", void 0);
__decorate([
    HostBinding('class.igx-input-group--bootstrap')
], IgxInputGroupComponent.prototype, "isBootstrap", void 0);
__decorate([
    HostBinding('class.igx-input-group--disabled'),
    Input()
], IgxInputGroupComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxInputGroupComponent.prototype, "suppressInputAutofocus", void 0);
__decorate([
    HostBinding('class.igx-input-group--valid')
], IgxInputGroupComponent.prototype, "validClass", null);
__decorate([
    HostBinding('class.igx-input-group--invalid')
], IgxInputGroupComponent.prototype, "invalidClass", null);
__decorate([
    HostBinding('class.igx-input-group--warning')
], IgxInputGroupComponent.prototype, "hasWarning", void 0);
__decorate([
    HostBinding('class.igx-input-group--filled')
], IgxInputGroupComponent.prototype, "isFilled", null);
__decorate([
    HostBinding('class.igx-input-group--cosy')
], IgxInputGroupComponent.prototype, "isDisplayDensityCosy", null);
__decorate([
    HostBinding('class.igx-input-group--comfortable')
], IgxInputGroupComponent.prototype, "isDisplayDensityComfortable", null);
__decorate([
    HostBinding('class.igx-input-group--compact')
], IgxInputGroupComponent.prototype, "isDisplayDensityCompact", null);
__decorate([
    ContentChildren(IgxHintDirective, { read: IgxHintDirective })
], IgxInputGroupComponent.prototype, "hints", void 0);
__decorate([
    ContentChild(IgxInputDirective, { read: IgxInputDirective, static: true })
], IgxInputGroupComponent.prototype, "input", void 0);
__decorate([
    HostListener('click', ['$event'])
], IgxInputGroupComponent.prototype, "onClick", null);
__decorate([
    HostListener('pointerdown', ['$event'])
], IgxInputGroupComponent.prototype, "onPointerDown", null);
__decorate([
    Input('type')
], IgxInputGroupComponent.prototype, "type", null);
__decorate([
    DeprecateProperty(`Deprecated. Use 'suppressInputAutofocus' instead.`),
    Input()
], IgxInputGroupComponent.prototype, "supressInputAutofocus", null);
IgxInputGroupComponent = IgxInputGroupComponent_1 = __decorate([ __param(1, Optional()), __param(1, Inject(DisplayDensityToken))
], IgxInputGroupComponent);
/** @hidden */
let IgxInputGroupModule = class IgxInputGroupModule {
};
IgxInputGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxInputGroupModule });
IgxInputGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxInputGroupModule_Factory(t) { return new (t || IgxInputGroupModule)(); }, imports: [[
            CommonModule,
            IgxPrefixModule,
            IgxSuffixModule
        ],
        IgxPrefixModule,
        IgxSuffixModule] });

/**
 * **Ignite UI for Angular Autocomplete** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
 *
 * The igxAutocomplete directive provides a way to enhance a text input
 * by showing a drop down of suggested options, provided by the developer.
 *
 * Example:
 * ```html
 * <input type="text" [igxAutocomplete]="townsPanel" />
 * <igx-drop-down #townsPanel>
 *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
 *         {{town}}
 *     </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
let IgxAutocompleteDirective = class IgxAutocompleteDirective extends IgxDropDownItemNavigationDirective {
    constructor(ngModel, formControl, group, elementRef, cdr) {
        super(null);
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.group = group;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.defaultSettings = {
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy({ target: this.parentElement }),
            excludePositionTarget: true
        };
        this.dropDownOpened$ = new Subject();
        /**
         * Enables/disables autocomplete component
         *
         * ```typescript
         * // get
         * let disabled = this.autocomplete.disabled;
         * ```
         * ```html
         * <!--set-->
         * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
         * ```
         * ```typescript
         * // set
         * public disabled = true;
         * ```
         */
        this.disabled = false;
        /**
         * Emitted after item from the drop down is selected
         *
         * ```html
         * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
         * ```
         */
        this.onItemSelected = new EventEmitter();
        /** @hidden @internal */
        this.autofill = 'off';
        /** @hidden  @internal */
        this.role = 'combobox';
        this.select = (value) => {
            if (!value.newSelection) {
                return;
            }
            value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
            const newValue = value.newSelection.value;
            const args = { value: newValue, cancel: false };
            this.onItemSelected.emit(args);
            if (args.cancel) {
                return;
            }
            this.close();
            this.nativeElement.focus();
            // Update model after the input is re-focused, in order to have proper valid styling.
            // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
            this.model ? this.model.control.setValue(newValue) : this.nativeElement.value = newValue;
        };
        this.highlightFirstItem = () => {
            if (this.target.focusedItem) {
                this.target.focusedItem.focused = false;
                this.target.focusedItem = null;
            }
            this.target.navigateFirst();
            this.cdr.detectChanges();
        };
    }
    get model() {
        return this.ngModel || this.formControl;
    }
    /** @hidden @internal */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /** @hidden @internal */
    get parentElement() {
        return this.group ? this.group.element.nativeElement : this.nativeElement;
    }
    get settings() {
        const settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
        if (!settings.positionStrategy.settings.target) {
            const positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.parentElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
    /** @hidden  @internal */
    get ariaExpanded() {
        return !this.collapsed;
    }
    /** @hidden  @internal */
    get hasPopUp() {
        return 'listbox';
    }
    /** @hidden  @internal */
    get ariaOwns() {
        return this.target.listId;
    }
    /** @hidden  @internal */
    get ariaActiveDescendant() {
        return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
    }
    /** @hidden  @internal */
    get ariaAutocomplete() {
        return 'list';
    }
    /** @hidden  @internal */
    onInput() {
        this.open();
    }
    /** @hidden  @internal */
    onArrowDown(event) {
        event.preventDefault();
        this.open();
    }
    /** @hidden  @internal */
    onTab() {
        this.close();
    }
    /** @hidden  @internal */
    handleKeyDown(event) {
        if (!this.collapsed) {
            switch (event.key.toLowerCase()) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'home':
                case 'end':
                    return;
                default:
                    super.handleKeyDown(event);
            }
        }
    }
    /** @hidden  @internal */
    onArrowDownKeyDown() {
        super.onArrowDownKeyDown();
    }
    /** @hidden  @internal */
    onArrowUpKeyDown() {
        super.onArrowUpKeyDown();
    }
    /** @hidden  @internal */
    onEndKeyDown() {
        super.onEndKeyDown();
    }
    /** @hidden  @internal */
    onHomeKeyDown() {
        super.onHomeKeyDown();
    }
    /**
     * Closes autocomplete drop down
     */
    close() {
        if (this.collapsed) {
            return;
        }
        this.target.close();
        this.dropDownOpened$.next();
    }
    /**
     * Opens autocomplete drop down
     */
    open() {
        if (this.disabled || !this.collapsed) {
            return;
        }
        // if no drop-down width is set, the drop-down will be as wide as the autocomplete input;
        this.target.width = this.target.width || (this.parentElement.clientWidth + 'px');
        this.target.open(this.settings);
        this.target.onSelection.pipe(takeUntil(this.dropDownOpened$)).subscribe(this.select);
        this.target.onOpened.pipe(first$1()).subscribe(this.highlightFirstItem);
        this.target.children.changes.pipe(takeUntil(this.dropDownOpened$)).subscribe(this.highlightFirstItem);
    }
    get collapsed() {
        return this.target ? this.target.collapsed : true;
    }
    /** @hidden */
    ngOnDestroy() {
        this.dropDownOpened$.complete();
    }
};
IgxAutocompleteDirective.ɵfac = function IgxAutocompleteDirective_Factory(t) { return new (t || IgxAutocompleteDirective)(ɵngcc0.ɵɵdirectiveInject(NgModel, 10), ɵngcc0.ɵɵdirectiveInject(FormControlName, 10), ɵngcc0.ɵɵdirectiveInject(IgxInputGroupComponent, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxAutocompleteDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxAutocompleteDirective, selectors: [["", "igxAutocomplete", ""]], hostVars: 7, hostBindings: function IgxAutocompleteDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function IgxAutocompleteDirective_input_HostBindingHandler() { return ctx.onInput(); })("keydown.ArrowDown", function IgxAutocompleteDirective_keydown_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Alt.ArrowDown", function IgxAutocompleteDirective_keydown_Alt_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.ArrowUp", function IgxAutocompleteDirective_keydown_ArrowUp_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Alt.ArrowUp", function IgxAutocompleteDirective_keydown_Alt_ArrowUp_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Tab", function IgxAutocompleteDirective_keydown_Tab_HostBindingHandler() { return ctx.onTab(); })("keydown.Shift.Tab", function IgxAutocompleteDirective_keydown_Shift_Tab_HostBindingHandler() { return ctx.onTab(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("autocomplete", ctx.autofill)("role", ctx.role)("aria-expanded", ctx.ariaExpanded)("aria-haspopup", ctx.hasPopUp)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant)("aria-autocomplete", ctx.ariaAutocomplete);
    } }, inputs: { disabled: ["igxAutocompleteDisabled", "disabled"], target: ["igxAutocomplete", "target"], autocompleteSettings: ["igxAutocompleteSettings", "autocompleteSettings"] }, outputs: { onItemSelected: "onItemSelected" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxAutocompleteDirective.ctorParameters = () => [
    { type: NgModel, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [NgModel,] }] },
    { type: FormControlName, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [FormControlName,] }] },
    { type: IgxInputGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input('igxAutocomplete')
], IgxAutocompleteDirective.prototype, "target", void 0);
__decorate([
    Input('igxAutocompleteDisabled')
], IgxAutocompleteDirective.prototype, "disabled", void 0);
__decorate([
    Input('igxAutocompleteSettings')
], IgxAutocompleteDirective.prototype, "autocompleteSettings", void 0);
__decorate([
    Output()
], IgxAutocompleteDirective.prototype, "onItemSelected", void 0);
__decorate([
    HostBinding('attr.autocomplete')
], IgxAutocompleteDirective.prototype, "autofill", void 0);
__decorate([
    HostBinding('attr.role')
], IgxAutocompleteDirective.prototype, "role", void 0);
__decorate([
    HostBinding('attr.aria-expanded')
], IgxAutocompleteDirective.prototype, "ariaExpanded", null);
__decorate([
    HostBinding('attr.aria-haspopup')
], IgxAutocompleteDirective.prototype, "hasPopUp", null);
__decorate([
    HostBinding('attr.aria-owns')
], IgxAutocompleteDirective.prototype, "ariaOwns", null);
__decorate([
    HostBinding('attr.aria-activedescendant')
], IgxAutocompleteDirective.prototype, "ariaActiveDescendant", null);
__decorate([
    HostBinding('attr.aria-autocomplete')
], IgxAutocompleteDirective.prototype, "ariaAutocomplete", null);
__decorate([
    HostListener('input')
], IgxAutocompleteDirective.prototype, "onInput", null);
__decorate([
    HostListener('keydown.ArrowDown', ['$event']),
    HostListener('keydown.Alt.ArrowDown', ['$event']),
    HostListener('keydown.ArrowUp', ['$event']),
    HostListener('keydown.Alt.ArrowUp', ['$event'])
], IgxAutocompleteDirective.prototype, "onArrowDown", null);
__decorate([
    HostListener('keydown.Tab'),
    HostListener('keydown.Shift.Tab')
], IgxAutocompleteDirective.prototype, "onTab", null);
IgxAutocompleteDirective = __decorate([ __param(0, Self()), __param(0, Optional()), __param(0, Inject(NgModel)),
    __param(1, Self()), __param(1, Optional()), __param(1, Inject(FormControlName)),
    __param(2, Optional())
], IgxAutocompleteDirective);
/** @hidden */
let IgxAutocompleteModule = class IgxAutocompleteModule {
};
IgxAutocompleteModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxAutocompleteModule });
IgxAutocompleteModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxAutocompleteModule_Factory(t) { return new (t || IgxAutocompleteModule)(); }, imports: [[IgxDropDownModule, CommonModule]] });

/**
 * The Button directive provides the Ignite UI Button functionality to every component that's intended to be used as a button.
 *
 * @igxModule IgxButtonModule
 *
 * @igxParent Data Entry & Display
 *
 * @igxTheme igx-button-theme
 *
 * @igxKeywords button, span, div, click
 *
 * @remarks
 * The Ignite UI Button directive is intended to be used by any button, span or div and turn it into a fully functional button.
 *
 * @example
 * ```html
 * <button igxButton="outlined">A Button</button>
 * ```
 */
let IgxButtonDirective = class IgxButtonDirective extends DisplayDensityBase {
    constructor(element, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * @internal
         */
        this._defaultType = 'flat';
        /**
         * @hidden
         * @internal
         */
        this._cssClassPrefix = 'igx-button';
        /**
         * Called when the button is clicked.
         */
        this.buttonClick = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         *
         * @example
         * ```typescript
         * this.button.role = 'navbutton';
         * let buttonRole = this.button.role;
         * ```
         */
        this.role = 'button';
        /**
         * Gets or sets whether the button is selected.
         * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
         *
         * @example
         * ```html
         * <button igxButton="flat" [selected]="button.selected"></button>
         * ```
         */
        this.selected = false;
    }
    /**
     * Returns the underlying DOM element.
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Sets the type of the button.
     *
     * @example
     * ```html
     * <button igxButton="icon"></button>
     * ```
     */
    set type(value) {
        const newValue = value ? value : this._defaultType;
        if (this._type !== newValue) {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
            this._type = newValue;
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--${this._type}`);
        }
    }
    /**
     * Sets the button text color.
     *
     * @example
     * ```html
     * <button igxButton="gradient" igxButtonColor="blue"></button>
     * ```
     */
    set color(value) {
        this._color = value || this.nativeElement.style.color;
        this._renderer.setStyle(this.nativeElement, 'color', this._color);
    }
    /**
     * Sets the background color of the button.
     *
     * @example
     *  ```html
     * <button igxButton="raised" igxButtonBackground="red"></button>
     * ```
     */
    set background(value) {
        this._backgroundColor = value || this._backgroundColor;
        this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
    }
    /**
     * Sets the `aria-label` attribute.
     *
     * @example
     *  ```html
     * <button igxButton= "flat" igxLabel="Label"></button>
     * ```
     */
    set label(value) {
        this._label = value || this._label;
        this._renderer.setAttribute(this.nativeElement, `aria-label`, this._label);
    }
    /**
     * Enables/disables the button.
     *
     * @example
     * ```html
     * <button igxButton= "fab" [disabled]="true"></button>
     * ```
     */
    set disabled(val) {
        val = !!val;
        this._disabled = val;
        if (val) {
            this._renderer.addClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
        else {
            this._renderer.removeClass(this.nativeElement, `${this._cssClassPrefix}--disabled`);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosy() {
        return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
            this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompact() {
        return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
            this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosyFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompactFab() {
        return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get disabledAttribute() {
        return this._disabled ? this._disabled : null;
    }
    /**
     * @hidden
     * @internal
     */
    onClick(ev) {
        this.buttonClick.emit(ev);
    }
};
IgxButtonDirective.ɵfac = function IgxButtonDirective_Factory(t) { return new (t || IgxButtonDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxButtonDirective, selectors: [["", "igxButton", ""]], hostVars: 10, hostBindings: function IgxButtonDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxButtonDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("disabled", ctx.disabledAttribute);
        ɵngcc0.ɵɵclassProp("igx-button--cosy", ctx.cssClassCosy)("igx-button--compact", ctx.cssClassCompact)("igx-button--fab-cosy", ctx.cssClassCosyFab)("igx-button--fab-compact", ctx.cssClassCompactFab);
    } }, inputs: { selected: "selected", type: ["igxButton", "type"], color: ["igxButtonColor", "color"], background: ["igxButtonBackground", "background"], label: ["igxLabel", "label"], disabled: "disabled" }, outputs: { buttonClick: "buttonClick" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxButtonDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    Output()
], IgxButtonDirective.prototype, "buttonClick", void 0);
__decorate([
    HostBinding('attr.role')
], IgxButtonDirective.prototype, "role", void 0);
__decorate([
    Input('igxButton')
], IgxButtonDirective.prototype, "type", null);
__decorate([
    Input('igxButtonColor')
], IgxButtonDirective.prototype, "color", null);
__decorate([
    Input('igxButtonBackground')
], IgxButtonDirective.prototype, "background", null);
__decorate([
    Input('igxLabel')
], IgxButtonDirective.prototype, "label", null);
__decorate([
    Input()
], IgxButtonDirective.prototype, "disabled", null);
__decorate([
    HostBinding('class.igx-button--cosy')
], IgxButtonDirective.prototype, "cssClassCosy", null);
__decorate([
    HostBinding('class.igx-button--compact')
], IgxButtonDirective.prototype, "cssClassCompact", null);
__decorate([
    HostBinding('class.igx-button--fab-cosy')
], IgxButtonDirective.prototype, "cssClassCosyFab", null);
__decorate([
    HostBinding('class.igx-button--fab-compact')
], IgxButtonDirective.prototype, "cssClassCompactFab", null);
__decorate([
    HostBinding('attr.disabled')
], IgxButtonDirective.prototype, "disabledAttribute", null);
__decorate([
    Input()
], IgxButtonDirective.prototype, "selected", void 0);
__decorate([
    HostListener('click', ['$event'])
], IgxButtonDirective.prototype, "onClick", null);
IgxButtonDirective = __decorate([ __param(2, Optional()), __param(2, Inject(DisplayDensityToken))
], IgxButtonDirective);
/**
 * @hidden
 */
let IgxButtonModule = class IgxButtonModule {
};
IgxButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxButtonModule });
IgxButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxButtonModule_Factory(t) { return new (t || IgxButtonModule)(); } });

var IgxDividerType;
(function (IgxDividerType) {
    IgxDividerType["SOLID"] = "solid";
    IgxDividerType["DASHED"] = "dashed";
})(IgxDividerType || (IgxDividerType = {}));
let NEXT_ID$5 = 0;
let IgxDividerDirective = class IgxDividerDirective {
    constructor() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = `igx-divider-${NEXT_ID$5++}`;
        /**
         * An @Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An @Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.SOLID;
        /**
         * An @Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An @Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    get isDashed() {
        return this.type === IgxDividerType.DASHED;
    }
    /**
     * A getter that returns `true` if the type of the divider is `default`;
     * ```typescript
     * const isDefault = this.divider.isDefault;
     * ```
     */
    get isSolid() {
        return this.type === IgxDividerType.SOLID;
    }
    /**
     * Sets the inset of the divider from the side(s).
     * If the divider attribute `middle` is set to `true`,
     * it will inset the divider on both sides.
     * ```typescript
     * this.divider.inset = '32px';
     * ```
     */
    set inset(value) {
        this._inset = value;
    }
    /**
     * Gets the current divider inset in terms of
     * margin representation as applied to the divider.
     * ```typescript
     * const inset = this.divider.inset;
     * ```
     */
    get inset() {
        const baseMargin = '0';
        if (this.middle) {
            if (this.vertical) {
                return `${this._inset} ${baseMargin}`;
            }
            return `${baseMargin} ${this._inset}`;
        }
        else {
            if (this.vertical) {
                return `${this._inset} ${baseMargin} 0 ${baseMargin}`;
            }
            return `${baseMargin} 0 ${baseMargin} ${this._inset}`;
        }
    }
};
IgxDividerDirective.ɵfac = function IgxDividerDirective_Factory(t) { return new (t || IgxDividerDirective)(); };
IgxDividerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDividerDirective, selectors: [["igx-divider"]], hostVars: 12, hostBindings: function IgxDividerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵstyleProp("margin", ctx.inset);
        ɵngcc0.ɵɵclassProp("igx-divider", ctx.type)("igx-divider--inset", ctx.middle)("igx-divider--vertical", ctx.vertical)("igx-divider--dashed", ctx.isDashed);
    } }, inputs: { id: "id", _inset: ["inset", "_inset"], role: "role", type: "type", middle: "middle", vertical: "vertical" } });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxDividerDirective.prototype, "id", void 0);
__decorate([
    Input('inset')
], IgxDividerDirective.prototype, "_inset", void 0);
__decorate([
    HostBinding('attr.role'),
    Input()
], IgxDividerDirective.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-divider'),
    Input()
], IgxDividerDirective.prototype, "type", void 0);
__decorate([
    HostBinding('class.igx-divider--dashed')
], IgxDividerDirective.prototype, "isDashed", null);
__decorate([
    HostBinding('class.igx-divider--inset'),
    Input()
], IgxDividerDirective.prototype, "middle", void 0);
__decorate([
    HostBinding('class.igx-divider--vertical'),
    Input()
], IgxDividerDirective.prototype, "vertical", void 0);
__decorate([
    HostBinding('style.margin')
], IgxDividerDirective.prototype, "inset", null);
let IgxDividerModule = class IgxDividerModule {
};
IgxDividerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDividerModule });
IgxDividerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDividerModule_Factory(t) { return new (t || IgxDividerModule)(); } });

// @dynamic
class IgxDefaultDropStrategy {
    dropAction(drag, drop, atIndex) { }
}
// @dynamic
class IgxAppendDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        this._renderer.appendChild(dropAreaElement, dragElement);
    }
}
// @dynamic
class IgxPrependDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (dropAreaElement.children.length) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[0]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}
// @dynamic
class IgxInsertDropStrategy {
    constructor(_renderer) {
        this._renderer = _renderer;
    }
    dropAction(drag, drop, atIndex) {
        if (drag.element.nativeElement.parentElement === drop.element.nativeElement && atIndex === -1) {
            return;
        }
        const dragElement = drag.element.nativeElement;
        const dropAreaElement = drop.element.nativeElement;
        this._renderer.removeChild(dragElement.parentNode, dragElement);
        if (atIndex !== -1 && dropAreaElement.children.length > atIndex) {
            this._renderer.insertBefore(dropAreaElement, dragElement, dropAreaElement.children[atIndex]);
        }
        else {
            this._renderer.appendChild(dropAreaElement, dragElement);
        }
    }
}

var DragDirection;
(function (DragDirection) {
    DragDirection[DragDirection["VERTICAL"] = 0] = "VERTICAL";
    DragDirection[DragDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    DragDirection[DragDirection["BOTH"] = 2] = "BOTH";
})(DragDirection || (DragDirection = {}));
class IgxDragLocation {
    constructor(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
}
let IgxDragHandleDirective = class IgxDragHandleDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
};
IgxDragHandleDirective.ɵfac = function IgxDragHandleDirective_Factory(t) { return new (t || IgxDragHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxDragHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragHandleDirective, selectors: [["", "igxDragHandle", ""]], hostVars: 2, hostBindings: function IgxDragHandleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drag__handle", ctx.baseClass);
    } } });
IgxDragHandleDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('class.igx-drag__handle')
], IgxDragHandleDirective.prototype, "baseClass", void 0);
let IgxDragIgnoreDirective = class IgxDragIgnoreDirective {
    constructor(element) {
        this.element = element;
        this.baseClass = true;
    }
};
IgxDragIgnoreDirective.ɵfac = function IgxDragIgnoreDirective_Factory(t) { return new (t || IgxDragIgnoreDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxDragIgnoreDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragIgnoreDirective, selectors: [["", "igxDragIgnore", ""]], hostVars: 2, hostBindings: function IgxDragIgnoreDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drag__ignore", ctx.baseClass);
    } } });
IgxDragIgnoreDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('class.igx-drag__ignore')
], IgxDragIgnoreDirective.prototype, "baseClass", void 0);
let IgxDragDirective = class IgxDragDirective {
    constructor(cdr, element, viewContainer, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.ghostContext = null;
        /**
         * An @Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An @Input property that indicates the directions that the element can be dragged.
         * By default it is set to both horizontal and vertical directions.
         * ```html
         * <div igxDrag [dragDirection]="dragDir">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragDir = DragDirection.HORIZONTAL;
         * ```
         * @memberof IgxDragDirective
         */
        this.dragDirection = DragDirection.BOTH;
        /**
         * An @Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         * @memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetX]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetX(value) {
        this._offsetX = parseInt(value, 10);
    }
    get ghostOffsetX() {
        return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
    }
    /**
     * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
     * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostOffsetY]="0">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * @memberof IgxDragDirective
     */
    set ghostOffsetY(value) {
        this._offsetY = parseInt(value, 10);
    }
    get ghostOffsetY() {
        return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
    }
    /**
     * Gets the current location of the element relative to the page.
     */
    get location() {
        return new IgxDragLocation(this.pageX, this.pageY);
    }
    /**
     * Gets the original location of the element before dragging started.
     */
    get originLocation() {
        return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
    }
    /**
     * @hidden
     */
    get pointerEventsEnabled() {
        return typeof PointerEvent !== 'undefined';
    }
    /**
     * @hidden
     */
    get touchEventsEnabled() {
        return 'ontouchstart' in window;
    }
    /**
     * @hidden
     */
    get pageX() {
        if (this.ghost && this.ghostElement) {
            return this.ghostLeft;
        }
        return this.baseLeft;
    }
    /**
     * @hidden
     */
    get pageY() {
        if (this.ghost && this.ghostElement) {
            return this.ghostTop;
        }
        return this.baseTop;
    }
    get baseLeft() {
        return this.element.nativeElement.getBoundingClientRect().left;
    }
    get baseTop() {
        return this.element.nativeElement.getBoundingClientRect().top;
    }
    get baseOriginLeft() {
        return this.baseLeft - this.getTransformX(this.element.nativeElement);
    }
    get baseOriginTop() {
        return this.baseTop - this.getTransformY(this.element.nativeElement);
    }
    set ghostLeft(pageX) {
        if (this.ghostElement) {
            // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
            const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.left = (pageX - ghostMarginLeft - this._ghostHostX) + 'px';
        }
    }
    get ghostLeft() {
        return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
    }
    set ghostTop(pageY) {
        if (this.ghostElement) {
            // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
            const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
            // If ghost host is defined it needs to be taken into account.
            this.ghostElement.style.top = (pageY - ghostMarginTop - this._ghostHostY) + 'px';
        }
    }
    get ghostTop() {
        return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(() => {
            const targetElements = this.dragHandles && this.dragHandles.length ?
                this.dragHandles.map((item) => item.element.nativeElement) : [this.element.nativeElement];
            targetElements.forEach((element) => {
                if (this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                    fromEvent(element, 'pointermove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                    fromEvent(element, 'pointerup').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerUp(res));
                    if (!this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(this._destroy))
                            .subscribe((res) => this.onPointerLost(res));
                    }
                }
                else if (this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(this._destroy))
                        .subscribe((res) => this.onPointerDown(res));
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!this.pointerEventsEnabled && this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            else if (!this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onPointerMove(res));
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                    .subscribe((res) => this.onPointerUp(res));
            }
            this.element.nativeElement.addEventListener('transitionend', (args) => {
                this.onTransitionEnd(args);
            });
        });
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
    }
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    setLocation(newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            const offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            const offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
            this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
        }
        else if (!this.ghost) {
            const deltaX = newLocation.pageX - this.pageX;
            const deltaY = newLocation.pageY - this.pageY;
            const transformX = this.getTransformX(this.element.nativeElement);
            const transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    }
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionToOrigin(customAnimArgs, startLocation) {
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            if (this.ghost) {
                this.ghostElement.style.transitionProperty = 'top, left';
                this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this.setLocation(new IgxDragLocation(this.baseLeft, this.baseTop));
            }
            else if (!this.ghost) {
                this.element.nativeElement.style.transitionProperty = 'transform';
                this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
                this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                this._startX = this.baseLeft;
                this._startY = this.baseTop;
                this.setTransformXY(0, 0);
            }
        }, 0);
    }
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    transitionTo(target, customAnimArgs, startLocation) {
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.getWindowScrollLeft();
            this._ghostStartY = this._startY + this.getWindowScrollTop();
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(() => {
            const movedElem = this.ghost ? this.ghostElement : this.element.nativeElement;
            movedElem.style.transitionProperty = this.ghost && this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                const targetRects = target.nativeElement.getBoundingClientRect();
                this.setLocation(new IgxDragLocation(targetRects.left - this.getWindowScrollLeft(), targetRects.top - this.getWindowScrollTop()));
            }
        }, 0);
    }
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    onPointerDown(event) {
        const ignoredElement = this.dragIgnoredElems.find(elem => elem.element.nativeElement === event.target);
        if (ignoredElement) {
            return;
        }
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        const handleFound = this.dragHandles.find(handle => handle.element.nativeElement === event.currentTarget);
        const targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
        this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    }
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    onPointerMove(event) {
        if (this._clicked) {
            let pageX, pageY;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            const totalMovedX = pageX - this._startX;
            const totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                const dragStartArgs = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX: pageX,
                    pageY: pageY,
                    cancel: false
                };
                this.zone.run(() => {
                    this.dragStart.emit(dragStartArgs);
                });
                if (!dragStartArgs.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        const transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        const transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            const moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            const setPageX = moveArgs.nextPageX;
            const setPageY = moveArgs.nextPageY;
            if (!moveArgs.cancel) {
                if (this.ghost) {
                    const updatedTotalMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._startX;
                    const updatedTotalMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._startY;
                    this.ghostLeft = this._ghostStartX + updatedTotalMovedX;
                    this.ghostTop = this._ghostStartY + updatedTotalMovedY;
                }
                else {
                    const lastMovedX = this.dragDirection === DragDirection.VERTICAL ? 0 : setPageX - this._lastX;
                    const lastMovedY = this.dragDirection === DragDirection.HORIZONTAL ? 0 : setPageY - this._lastY;
                    const translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    const translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    }
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        let pageX, pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(() => {
                this.dragClick.emit(eventArgs);
            });
        }
    }
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    onPointerLost(event) {
        if (!this._clicked) {
            return;
        }
        const eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(() => {
                this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    }
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    createGhost(pageX, pageY, node = null) {
        if (!this.ghost) {
            return;
        }
        let dynamicGhostRef;
        if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        const totalMovedX = pageX - this._startX;
        const totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        const createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && dynamicGhostRef) {
                dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        const ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        const ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', (args) => {
                this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', (args) => {
                this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', (args) => {
                this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', (args) => {
            this.onTransitionEnd(args);
        });
        this.cdr.detectChanges();
    }
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    dispatchDragEvents(pageX, pageY, originalEvent) {
        let topDropArea;
        const customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        const elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (let i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' &&
                elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    }
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    dispatchDropEvent(pageX, pageY, originalEvent) {
        const eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    }
    /**
     * @hidden
     */
    onTransitionEnd(event) {
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
            this._ghostStartY = this.baseTop + this.getWindowScrollTop();
            const ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(() => {
            this.transitioned.emit({
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._startX,
                pageY: this._startY
            });
        });
    }
    /**
     * @hidden
     */
    getElementsAtPoint(pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        const viewPortX = pageX - window.pageXOffset;
        const viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            const elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    }
    /**
     * @hidden
     */
    dispatchEvent(target, eventName, eventArgs) {
        // This way is IE11 compatible.
        const dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    }
    getTransformX(elem) {
        let posX = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    }
    getTransformY(elem) {
        let posY = 0;
        if (elem.style.transform) {
            const matrix = elem.style.transform;
            const values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    }
    /** Method setting transformation to the base draggable element. */
    setTransformXY(x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    ghostHostOffsetLeft(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
    }
    ghostHostOffsetTop(ghostHost) {
        const ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
        }
        return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
    }
};
IgxDragDirective.ɵfac = function IgxDragDirective_Factory(t) { return new (t || IgxDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragDirective, selectors: [["", "igxDrag", ""]], contentQueries: function IgxDragDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDragHandleDirective, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDragIgnoreDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragHandles = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIgnoredElems = _t);
    } }, hostVars: 4, hostBindings: function IgxDragDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drag", ctx.baseClass)("igx-drag--select-disabled", ctx.selectDisabled);
    } }, inputs: { dragTolerance: "dragTolerance", dragDirection: "dragDirection", ghost: "ghost", ghostClass: "ghostClass", ghostOffsetX: "ghostOffsetX", ghostOffsetY: "ghostOffsetY", data: ["igxDrag", "data"], dragChannel: "dragChannel", ghostTemplate: "ghostTemplate", ghostHost: "ghostHost" }, outputs: { dragStart: "dragStart", dragMove: "dragMove", dragEnd: "dragEnd", dragClick: "dragClick", ghostCreate: "ghostCreate", ghostDestroy: "ghostDestroy", transitioned: "transitioned" }, exportAs: ["drag"] });
IgxDragDirective.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 }
];
__decorate([
    Input('igxDrag')
], IgxDragDirective.prototype, "data", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "dragTolerance", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "dragDirection", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "dragChannel", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghost", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostClass", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostTemplate", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostHost", void 0);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostOffsetX", null);
__decorate([
    Input()
], IgxDragDirective.prototype, "ghostOffsetY", null);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragStart", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragMove", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragEnd", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "dragClick", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "ghostCreate", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "ghostDestroy", void 0);
__decorate([
    Output()
], IgxDragDirective.prototype, "transitioned", void 0);
__decorate([
    ContentChildren(IgxDragHandleDirective)
], IgxDragDirective.prototype, "dragHandles", void 0);
__decorate([
    ContentChildren(IgxDragIgnoreDirective)
], IgxDragDirective.prototype, "dragIgnoredElems", void 0);
__decorate([
    HostBinding('class.igx-drag')
], IgxDragDirective.prototype, "baseClass", void 0);
__decorate([
    HostBinding('class.igx-drag--select-disabled')
], IgxDragDirective.prototype, "selectDisabled", void 0);
let IgxDropDirective = class IgxDropDirective {
    constructor(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.over = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         * @memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    /**
     * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
     *  the current drop area. The provided strategies are:
     *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
     *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
     *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
     *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
     *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
     * ```html
     * <div igxDrag>
     *      <span>DragMe</span>
     * </div>
     * <div igxDrop [dropStrategy]="myDropStrategy">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * ```typescript
     * import { IgxAppendDropStrategy } from 'igniteui-angular';
     *
     * export class App {
     *      public myDropStrategy = IgxAppendDropStrategy;
     * }
     * ```
     * @memberof IgxDropDirective
     */
    set dropStrategy(classRef) {
        this._dropStrategy = new classRef(this._renderer);
    }
    get dropStrategy() {
        return this._dropStrategy;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onDragEnter(res));
            fromEvent(this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragLeave(res));
            fromEvent(this.element.nativeElement, 'igxDragOver').pipe(takeUntil(this._destroy)).subscribe((res) => this.onDragOver(res));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    /**
     * @hidden
     */
    onDragOver(event) {
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this.over.emit(eventArgs);
    }
    /**
     * @hidden
     */
    onDragEnter(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.enter.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragLeave(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(() => {
            this.leave.emit(eventArgs);
        });
    }
    /**
     * @hidden
     */
    onDragDrop(event) {
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        const elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        const elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        const offsetX = event.detail.pageX - elementPosX;
        const offsetY = event.detail.pageY - elementPosY;
        const args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(() => {
            this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            const elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            const insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    }
    getWindowScrollTop() {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    }
    getWindowScrollLeft() {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    }
    isDragLinked(drag) {
        const dragLinkArray = drag.dragChannel instanceof Array;
        const dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            const dropLinks = this.dropChannel;
            for (let i = 0; i < dropLinks.length; i++) {
                if (dropLinks[i] === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            const dragLinks = drag.dragChannel;
            for (let i = 0; i < dragLinks.length; i++) {
                if (dragLinks[i] === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            const dragLinks = drag.dragChannel;
            const dropLinks = this.dropChannel;
            for (let i = 0; i < dragLinks.length; i++) {
                for (let j = 0; j < dropLinks.length; j++) {
                    if (dragLinks[i] === dropLinks[j]) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    getInsertIndexAt(draggedDir, elementsAtPoint) {
        let insertIndex = -1;
        const dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        let i = 0;
        let childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        const draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    }
};
IgxDropDirective.ɵfac = function IgxDropDirective_Factory(t) { return new (t || IgxDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDropDirective, selectors: [["", "igxDrop", ""]], hostVars: 3, hostBindings: function IgxDropDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("igxDrop", function IgxDropDirective_igxDrop_HostBindingHandler($event) { return ctx.onDragDrop($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("droppable", ctx.droppable);
        ɵngcc0.ɵɵclassProp("dragOver", ctx.dragover);
    } }, inputs: { dropStrategy: "dropStrategy", data: ["igxDrop", "data"], dropChannel: "dropChannel" }, outputs: { enter: "enter", over: "over", leave: "leave", dropped: "dropped" }, exportAs: ["drop"] });
IgxDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
__decorate([
    Input('igxDrop')
], IgxDropDirective.prototype, "data", void 0);
__decorate([
    Input()
], IgxDropDirective.prototype, "dropChannel", void 0);
__decorate([
    Input()
], IgxDropDirective.prototype, "dropStrategy", null);
__decorate([
    Output()
], IgxDropDirective.prototype, "enter", void 0);
__decorate([
    Output()
], IgxDropDirective.prototype, "over", void 0);
__decorate([
    Output()
], IgxDropDirective.prototype, "leave", void 0);
__decorate([
    Output()
], IgxDropDirective.prototype, "dropped", void 0);
__decorate([
    HostBinding('attr.droppable')
], IgxDropDirective.prototype, "droppable", void 0);
__decorate([
    HostBinding('class.dragOver')
], IgxDropDirective.prototype, "dragover", void 0);
__decorate([
    HostListener('igxDrop', ['$event'])
], IgxDropDirective.prototype, "onDragDrop", null);
/**
 * @hidden
 */
let IgxDragDropModule = class IgxDragDropModule {
};
IgxDragDropModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDragDropModule });
IgxDragDropModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDragDropModule_Factory(t) { return new (t || IgxDragDropModule)(); } });

class IgxFilterOptions {
    constructor() {
        // Input text value that will be used as a filtering pattern (matching condition is based on it)
        this.inputValue = '';
    }
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    get_value(item, key) {
        let result = '';
        if (key && item[key]) {
            result = item[key].toString();
        }
        else if (item.element) {
            if (item.element.nativeElement) {
                result = item.element.nativeElement.textContent.trim();
                // Check if element doesn't return the DOM element directly
            }
            else if (item.element.textContent) {
                result = item.element.textContent.trim();
            }
        }
        return result;
    }
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    formatter(valueToTest) {
        return valueToTest.toLowerCase();
    }
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    matchFn(valueToTest, inputValue) {
        return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
    }
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    metConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = false;
        }
    }
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    overdueConditionFn(item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = true;
        }
    }
}
let IgxFilterDirective = class IgxFilterDirective {
    constructor(element, renderer) {
        this.element = element;
        this.filtering = new EventEmitter(false); // synchronous event emitter
        this.filtered = new EventEmitter();
    }
    ngOnChanges(changes) {
        // Detect only changes of input value
        if (changes.filterOptions &&
            changes.filterOptions.currentValue &&
            changes.filterOptions.currentValue.inputValue !== undefined &&
            changes.filterOptions.previousValue &&
            changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
            this.filter();
        }
    }
    filter() {
        if (!this.filterOptions.items) {
            return;
        }
        const args = { cancel: false, items: this.filterOptions.items };
        this.filtering.emit(args);
        if (args.cancel) {
            return;
        }
        const pipe = new IgxFilterPipe();
        const filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
        this.filtered.emit({ filteredItems: filtered });
    }
};
IgxFilterDirective.ɵfac = function IgxFilterDirective_Factory(t) { return new (t || IgxFilterDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxFilterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFilterDirective, selectors: [["", "igxFilter", ""]], inputs: { filterOptions: ["igxFilter", "filterOptions"] }, outputs: { filtering: "filtering", filtered: "filtered" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxFilterDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Output()
], IgxFilterDirective.prototype, "filtering", void 0);
__decorate([
    Output()
], IgxFilterDirective.prototype, "filtered", void 0);
__decorate([
    Input('igxFilter')
], IgxFilterDirective.prototype, "filterOptions", void 0);
let IgxFilterPipe = class IgxFilterPipe {
    transform(items, 
    // options - initial settings of filter functionality
    options) {
        let result = [];
        if (!items || !items.length || !options) {
            return;
        }
        if (options.items) {
            items = options.items;
        }
        result = items.filter((item) => {
            const match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
            if (match) {
                if (options.metConditionFn) {
                    options.metConditionFn(item);
                }
            }
            else {
                if (options.overdueConditionFn) {
                    options.overdueConditionFn(item);
                }
            }
            return match;
        });
        return result;
    }
};
IgxFilterPipe.ɵfac = function IgxFilterPipe_Factory(t) { return new (t || IgxFilterPipe)(); };
IgxFilterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxFilter", type: IgxFilterPipe, pure: false });
/**
 * @hidden
 */
let IgxFilterModule = class IgxFilterModule {
};
IgxFilterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxFilterModule });
IgxFilterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxFilterModule_Factory(t) { return new (t || IgxFilterModule)(); }, imports: [[CommonModule]] });

let IgxFocusDirective = class IgxFocusDirective {
    constructor(element, comp) {
        this.element = element;
        this.comp = comp;
        this.focusState = true;
    }
    /**
     * Returns the state of the igxFocus.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let isFocusOn = this.igxFocus.focused;
     * ```
     * @memberof IgxFocusDirective
     */
    get focused() {
        return this.focusState;
    }
    /**
     * Sets the state of the igxFocus.
     * ```html
     * <igx-input-group >
     *  <input #focusContainer igxInput [igxFocus]="true"/>
     * </igx-input-group>
     * ```
     * @memberof IgxFocusDirective
     */
    set focused(val) {
        this.focusState = val;
        this.trigger();
    }
    /**
     * Gets the native element of the igxFocus.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * let igxFocusNativeElement = this.igxFocus.nativeElement;
     * ```
     * @memberof IgxFocusDirective
     */
    get nativeElement() {
        if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
            return this.comp[0].getEditElement();
        }
        return this.element.nativeElement;
    }
    /**
     * Triggers the igxFocus state.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     * @memberof IgxFocusDirective
     */
    trigger() {
        if (this.focusState) {
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
};
IgxFocusDirective.ɵfac = function IgxFocusDirective_Factory(t) { return new (t || IgxFocusDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NG_VALUE_ACCESSOR, 10)); };
IgxFocusDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFocusDirective, selectors: [["", "igxFocus", ""]], inputs: { focused: ["igxFocus", "focused"] }, exportAs: ["igxFocus"] });
IgxFocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Array, decorators: [{ type: Inject, args: [NG_VALUE_ACCESSOR,] }, { type: Self }, { type: Optional }] }
];
__decorate([
    Input('igxFocus')
], IgxFocusDirective.prototype, "focused", null);
IgxFocusDirective = __decorate([ __param(1, Inject(NG_VALUE_ACCESSOR)), __param(1, Self()), __param(1, Optional())
], IgxFocusDirective);
/**
 * @hidden
 */
let IgxFocusModule = class IgxFocusModule {
};
IgxFocusModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxFocusModule });
IgxFocusModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxFocusModule_Factory(t) { return new (t || IgxFocusModule)(); } });

let IgxLayoutDirective = class IgxLayoutDirective {
    constructor() {
        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */
        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */
        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.itemAlign = 'stretch';
        /**
         * @hidden
         */
        this.display = 'flex';
    }
    /**
     * @hidden
     */
    get flexwrap() { return this.wrap; }
    /**
     * @hidden
     */
    get justifycontent() { return this.justify; }
    /**
     * @hidden
     */
    get align() { return this.itemAlign; }
    /**
     * @hidden
     */
    get direction() {
        if (this.reverse) {
            return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
        }
        return (this.dir === 'row') ? 'row' : 'column';
    }
};
IgxLayoutDirective.ɵfac = function IgxLayoutDirective_Factory(t) { return new (t || IgxLayoutDirective)(); };
IgxLayoutDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxLayoutDirective, selectors: [["", "igxLayout", ""]], hostVars: 10, hostBindings: function IgxLayoutDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.display)("flex-wrap", ctx.flexwrap)("justify-content", ctx.justifycontent)("align-items", ctx.align)("flex-direction", ctx.direction);
    } }, inputs: { dir: ["igxLayoutDir", "dir"], reverse: ["igxLayoutReverse", "reverse"], wrap: ["igxLayoutWrap", "wrap"], justify: ["igxLayoutJustify", "justify"], itemAlign: ["igxLayoutItemAlign", "itemAlign"] } });
__decorate([
    Input('igxLayoutDir')
], IgxLayoutDirective.prototype, "dir", void 0);
__decorate([
    Input('igxLayoutReverse')
], IgxLayoutDirective.prototype, "reverse", void 0);
__decorate([
    Input('igxLayoutWrap')
], IgxLayoutDirective.prototype, "wrap", void 0);
__decorate([
    Input('igxLayoutJustify')
], IgxLayoutDirective.prototype, "justify", void 0);
__decorate([
    Input('igxLayoutItemAlign')
], IgxLayoutDirective.prototype, "itemAlign", void 0);
__decorate([
    HostBinding('style.display')
], IgxLayoutDirective.prototype, "display", void 0);
__decorate([
    HostBinding('style.flex-wrap')
], IgxLayoutDirective.prototype, "flexwrap", null);
__decorate([
    HostBinding('style.justify-content')
], IgxLayoutDirective.prototype, "justifycontent", null);
__decorate([
    HostBinding('style.align-items')
], IgxLayoutDirective.prototype, "align", null);
__decorate([
    HostBinding('style.flex-direction')
], IgxLayoutDirective.prototype, "direction", null);
let IgxFlexDirective = class IgxFlexDirective {
    constructor() {
        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */
        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */
        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */
        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */
        this.basis = 'auto';
    }
    /**
     * @hidden
     */
    get style() {
        if (this.flex) {
            return `${this.flex}`;
        }
        return `${this.grow} ${this.shrink} ${this.basis}`;
    }
    /**
     * @hidden
     */
    get itemorder() {
        return this.order || 0;
    }
};
IgxFlexDirective.ɵfac = function IgxFlexDirective_Factory(t) { return new (t || IgxFlexDirective)(); };
IgxFlexDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFlexDirective, selectors: [["", "igxFlex", ""]], hostVars: 4, hostBindings: function IgxFlexDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("flex", ctx.style)("order", ctx.itemorder);
    } }, inputs: { grow: ["igxFlexGrow", "grow"], shrink: ["igxFlexShrink", "shrink"], flex: ["igxFlex", "flex"], order: ["igxFlexOrder", "order"], basis: ["igxFlexBasis", "basis"] } });
__decorate([
    Input('igxFlexGrow')
], IgxFlexDirective.prototype, "grow", void 0);
__decorate([
    Input('igxFlexShrink')
], IgxFlexDirective.prototype, "shrink", void 0);
__decorate([
    Input('igxFlex')
], IgxFlexDirective.prototype, "flex", void 0);
__decorate([
    Input('igxFlexOrder')
], IgxFlexDirective.prototype, "order", void 0);
__decorate([
    Input('igxFlexBasis')
], IgxFlexDirective.prototype, "basis", void 0);
__decorate([
    HostBinding('style.flex')
], IgxFlexDirective.prototype, "style", null);
__decorate([
    HostBinding('style.order')
], IgxFlexDirective.prototype, "itemorder", null);
/**
 * @hidden
 */
let IgxLayoutModule = class IgxLayoutModule {
};
IgxLayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxLayoutModule });
IgxLayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxLayoutModule_Factory(t) { return new (t || IgxLayoutModule)(); } });

/** @hidden */
const MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
/** @hidden */
let MaskParsingService = class MaskParsingService {
    applyMask(inputVal, maskOptions) {
        let outputVal = '';
        let value = '';
        const mask = maskOptions.format;
        const literals = this.getMaskLiterals(mask);
        const literalKeys = Array.from(literals.keys());
        const nonLiteralIndices = this.getNonLiteralIndices(mask, literalKeys);
        const literalValues = Array.from(literals.values());
        if (inputVal != null) {
            value = inputVal.toString();
        }
        for (const maskSym of mask) {
            outputVal += maskOptions.promptChar;
        }
        literals.forEach((val, key) => {
            outputVal = this.replaceCharAt(outputVal, key, val);
        });
        if (!value) {
            return outputVal;
        }
        const nonLiteralValues = this.getNonLiteralValues(value, literalValues);
        for (let i = 0; i < nonLiteralValues.length; i++) {
            const char = nonLiteralValues[i];
            const isCharValid = this.validateCharOnPosition(char, nonLiteralIndices[i], mask);
            if (!isCharValid && char !== maskOptions.promptChar) {
                nonLiteralValues[i] = maskOptions.promptChar;
            }
        }
        if (nonLiteralValues.length > nonLiteralIndices.length) {
            nonLiteralValues.splice(nonLiteralIndices.length);
        }
        let pos = 0;
        for (const nonLiteralValue of nonLiteralValues) {
            const char = nonLiteralValue;
            outputVal = this.replaceCharAt(outputVal, nonLiteralIndices[pos++], char);
        }
        return outputVal;
    }
    parseValueFromMask(maskedValue, maskOptions) {
        let outputVal = '';
        const mask = maskOptions.format;
        const literals = this.getMaskLiterals(mask);
        const literalValues = Array.from(literals.values());
        for (const val of maskedValue) {
            if (literalValues.indexOf(val) === -1) {
                if (val !== maskOptions.promptChar) {
                    outputVal += val;
                }
            }
        }
        return outputVal;
    }
    replaceInMask(maskedValue, value, maskOptions, start, end) {
        const literalsPositions = Array.from(this.getMaskLiterals(maskOptions.format).keys());
        const chars = Array.from(value);
        let cursor = start;
        end = Math.min(end, maskedValue.length);
        for (let i = start; i < end || (chars.length && i < maskedValue.length); i++) {
            if (literalsPositions.indexOf(i) !== -1) {
                if (chars[0] === maskedValue[i]) {
                    cursor = i + 1;
                    chars.shift();
                }
                continue;
            }
            if (chars[0]
                && !this.validateCharOnPosition(chars[0], i, maskOptions.format)
                && chars[0] !== maskOptions.promptChar) {
                break;
            }
            let char = maskOptions.promptChar;
            if (chars.length) {
                cursor = i + 1;
                char = chars.shift();
            }
            maskedValue = this.replaceCharAt(maskedValue, i, char);
        }
        return { value: maskedValue, end: cursor };
    }
    replaceCharAt(strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index + 1);
        }
    }
    /** Validates only non literal positions. */
    validateCharOnPosition(inputChar, position, mask) {
        let regex;
        let isValid;
        const letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        const letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        const letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        const letterSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        const digitRegEx = '[\\d]';
        const digitSpaceRegEx = '[\\d\\u0020]';
        const digitSpecialRegEx = '[\\d-\\+]';
        switch (mask.charAt(position)) {
            case 'C':
                isValid = inputChar !== '';
                break;
            case '&':
                regex = new RegExp('[\\u0020]');
                isValid = !regex.test(inputChar);
                break;
            case 'a':
                regex = new RegExp(letterDigitOrSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'A':
                regex = new RegExp(letterOrDigitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '?':
                regex = new RegExp(letterSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'L':
                regex = new RegExp(letterRegEx);
                isValid = regex.test(inputChar);
                break;
            case '0':
                regex = new RegExp(digitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '9':
                regex = new RegExp(digitSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case '#':
                regex = new RegExp(digitSpecialRegEx);
                isValid = regex.test(inputChar);
                break;
            default: {
                isValid = null;
            }
        }
        return isValid;
    }
    getMaskLiterals(mask) {
        const literals = new Map();
        for (let i = 0; i < mask.length; i++) {
            const char = mask.charAt(i);
            if (MASK_FLAGS.indexOf(char) === -1) {
                literals.set(i, char);
            }
        }
        return literals;
    }
    getNonLiteralIndices(mask, literalKeys) {
        const nonLiteralsIndices = new Array();
        for (let i = 0; i < mask.length; i++) {
            if (literalKeys.indexOf(i) === -1) {
                nonLiteralsIndices.push(i);
            }
        }
        return nonLiteralsIndices;
    }
    getNonLiteralValues(value, literalValues) {
        const nonLiteralValues = new Array();
        for (const val of value) {
            if (literalValues.indexOf(val) === -1) {
                nonLiteralValues.push(val);
            }
        }
        return nonLiteralValues;
    }
};
MaskParsingService.ɵfac = function MaskParsingService_Factory(t) { return new (t || MaskParsingService)(); };
MaskParsingService.ɵprov = ɵɵdefineInjectable({ factory: function MaskParsingService_Factory() { return new MaskParsingService(); }, token: MaskParsingService, providedIn: "root" });

var IgxMaskDirective_1;
const noop = () => { };
const ɵ0 = noop;
let IgxMaskDirective = IgxMaskDirective_1 = class IgxMaskDirective {
    constructor(elementRef, maskParser, renderer) {
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this.renderer = renderer;
        /**
         * Sets the character representing a fillable spot in the input mask.
         * Default value is "'_'".
         * ```html
         * <input [promptChar] = "'/'">
         * ```
         */
        this.promptChar = '_';
        /**
         * Emits an event each time the value changes.
         * Provides `rawValue: string` and `formattedValue: string` as event arguments.
         * ```html
         * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
         * ```
         */
        this.onValueChange = new EventEmitter();
        this._end = 0;
        this._start = 0;
        this._oldText = '';
        this._dataValue = '';
        this._focused = false;
        this._onTouchedCallback = noop;
        this._onChangeCallback = noop;
    }
    /**
     * Specifies a placeholder.
     * ```html
     * <input placeholder = "enter text...">
     * ```
     */
    set placeholder(val) {
        this.renderer.setAttribute(this.nativeElement, 'placeholder', val);
    }
    get placeholder() {
        return this.nativeElement.placeholder;
    }
    /** @hidden */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /** @hidden @internal; */
    get inputValue() {
        return this.nativeElement.value;
    }
    /** @hidden @internal */
    set inputValue(val) {
        this.nativeElement.value = val;
    }
    /** @hidden */
    get maskOptions() {
        const format = this.mask || 'CCCCCCCCCC';
        const promptChar = this.promptChar && this.promptChar.substring(0, 1);
        return { format, promptChar };
    }
    /** @hidden */
    get selectionStart() {
        // Edge(classic) and FF don't select text on drop
        return this.nativeElement.selectionStart === this.nativeElement.selectionEnd && this._hasDropAction ?
            this.nativeElement.selectionEnd - this._droppedData.length :
            this.nativeElement.selectionStart;
    }
    /** @hidden */
    get selectionEnd() {
        return this.nativeElement.selectionEnd;
    }
    /** @hidden */
    get start() {
        return this._start;
    }
    /** @hidden */
    get end() {
        return this._end;
    }
    /** @hidden */
    ngOnInit() {
        this.renderer.setAttribute(this.nativeElement, 'placeholder', this.placeholder ? this.placeholder : this.maskOptions.format);
    }
    /**
     * TODO: Remove after date/time picker integration refactor
     * @hidden
     */
    ngAfterViewChecked() {
        this._oldText = this.inputValue;
    }
    /** @hidden */
    onKeyDown(event) {
        const key = event.keyCode || event.charCode;
        if (!key) {
            return;
        }
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
        }
        if ((key === 17 /* CTRL */ && key === 90 /* Z */) || (key === 17 /* CTRL */ && key === 89 /* Y */)) {
            event.preventDefault();
        }
        this._key = key;
        this._start = this.selectionStart;
        this._end = this.selectionEnd;
    }
    /** @hidden */
    onInputChanged() {
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
            return;
        }
        if (this._hasDropAction) {
            this._start = this.selectionStart;
        }
        if (this.inputValue.length < this._oldText.length && this._key === 229 /* INPUT_METHOD */) {
            // software keyboard input delete
            this._key = 8 /* BACKSPACE */;
        }
        let valueToParse = '';
        switch (this._key) {
            case 46 /* DELETE */:
                this._end = this._start === this._end ? ++this._end : this._end;
                break;
            case 8 /* BACKSPACE */:
                this._start = this.selectionStart;
                break;
            default:
                valueToParse = this.inputValue.substring(this._start, this.selectionEnd);
                break;
        }
        const replacedData = this.maskParser.replaceInMask(this._oldText, valueToParse, this.maskOptions, this._start, this._end);
        this.inputValue = replacedData.value;
        if (this._key === 8 /* BACKSPACE */) {
            replacedData.end = this._start;
        }
        this.setSelectionRange(replacedData.end);
        const rawVal = this.maskParser.parseValueFromMask(this.inputValue, this.maskOptions);
        this._dataValue = this.includeLiterals ? this.inputValue : rawVal;
        this._onChangeCallback(this._dataValue);
        this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.inputValue });
        this.afterInput();
    }
    /** @hidden */
    onPaste() {
        this._oldText = this.inputValue;
        this._start = this.selectionStart;
    }
    /** @hidden */
    onFocus() {
        this._focused = true;
        this.showMask(this._dataValue);
    }
    /** @hidden */
    onBlur(value) {
        this._focused = false;
        this.showDisplayValue(value);
        this._onTouchedCallback();
    }
    /** @hidden */
    onDragEnter() {
        if (!this._focused) {
            this.showMask(this._dataValue);
        }
    }
    /** @hidden */
    onDragLeave() {
        if (!this._focused) {
            this.showDisplayValue(this.inputValue);
        }
    }
    /** @hidden */
    onDrop(event) {
        this._hasDropAction = true;
        this._droppedData = event.dataTransfer.getData('text');
    }
    /** @hidden */
    showMask(value) {
        if (this.focusedValuePipe) {
            if (isIE()) {
                this._stopPropagation = true;
            }
            // TODO(D.P.): focusedValuePipe should be deprecated or force-checked to match mask format
            this.inputValue = this.focusedValuePipe.transform(value);
        }
        else {
            this.inputValue = this.maskParser.applyMask(this.inputValue, this.maskOptions);
        }
        this._oldText = this.inputValue;
    }
    /** @hidden */
    setSelectionRange(start, end = start) {
        this.nativeElement.setSelectionRange(start, end);
    }
    /** @hidden */
    afterInput() {
        this._oldText = this.inputValue;
        this._hasDropAction = false;
        this._start = 0;
        this._end = 0;
        this._key = null;
    }
    showDisplayValue(value) {
        if (this.displayValuePipe) {
            this.inputValue = this.displayValuePipe.transform(value);
        }
        else if (value === this.maskParser.applyMask(null, this.maskOptions)) {
            this.inputValue = '';
        }
    }
    /** @hidden */
    writeValue(value) {
        if (this.promptChar && this.promptChar.length > 1) {
            this.maskOptions.promptChar = this.promptChar.substring(0, 1);
        }
        this.inputValue = value ? this.maskParser.applyMask(value, this.maskOptions) : '';
        if (this.displayValuePipe) {
            this.inputValue = this.displayValuePipe.transform(this.inputValue);
        }
        this._dataValue = this.includeLiterals ? this.inputValue : value;
        this.onValueChange.emit({ rawValue: value, formattedValue: this.inputValue });
    }
    /** @hidden */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
};
IgxMaskDirective.ɵfac = function IgxMaskDirective_Factory(t) { return new (t || IgxMaskDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MaskParsingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxMaskDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxMaskDirective, selectors: [["", "igxMask", ""]], hostBindings: function IgxMaskDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxMaskDirective_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("input", function IgxMaskDirective_input_HostBindingHandler() { return ctx.onInputChanged(); })("paste", function IgxMaskDirective_paste_HostBindingHandler() { return ctx.onPaste(); })("focus", function IgxMaskDirective_focus_HostBindingHandler() { return ctx.onFocus(); })("blur", function IgxMaskDirective_blur_HostBindingHandler($event) { return ctx.onBlur($event.target.value); })("dragenter", function IgxMaskDirective_dragenter_HostBindingHandler() { return ctx.onDragEnter(); })("dragleave", function IgxMaskDirective_dragleave_HostBindingHandler() { return ctx.onDragLeave(); })("drop", function IgxMaskDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); });
    } }, inputs: { promptChar: "promptChar", mask: ["igxMask", "mask"], includeLiterals: "includeLiterals", displayValuePipe: "displayValuePipe", focusedValuePipe: "focusedValuePipe" }, outputs: { onValueChange: "onValueChange" }, exportAs: ["igxMask"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective_1, multi: true }])] });
IgxMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: MaskParsingService },
    { type: Renderer2 }
];
__decorate([
    Input('igxMask')
], IgxMaskDirective.prototype, "mask", void 0);
__decorate([
    Input()
], IgxMaskDirective.prototype, "promptChar", void 0);
__decorate([
    Input()
], IgxMaskDirective.prototype, "includeLiterals", void 0);
__decorate([
    DeprecateProperty('"placeholder" is deprecated, use native placeholder instead.')
], IgxMaskDirective.prototype, "placeholder", null);
__decorate([
    Input()
], IgxMaskDirective.prototype, "displayValuePipe", void 0);
__decorate([
    Input()
], IgxMaskDirective.prototype, "focusedValuePipe", void 0);
__decorate([
    Output()
], IgxMaskDirective.prototype, "onValueChange", void 0);
__decorate([
    HostListener('keydown', ['$event'])
], IgxMaskDirective.prototype, "onKeyDown", null);
__decorate([
    HostListener('input')
], IgxMaskDirective.prototype, "onInputChanged", null);
__decorate([
    HostListener('paste')
], IgxMaskDirective.prototype, "onPaste", null);
__decorate([
    HostListener('focus')
], IgxMaskDirective.prototype, "onFocus", null);
__decorate([
    HostListener('blur', ['$event.target.value'])
], IgxMaskDirective.prototype, "onBlur", null);
__decorate([
    HostListener('dragenter')
], IgxMaskDirective.prototype, "onDragEnter", null);
__decorate([
    HostListener('dragleave')
], IgxMaskDirective.prototype, "onDragLeave", null);
__decorate([
    HostListener('drop', ['$event'])
], IgxMaskDirective.prototype, "onDrop", null);
/** @hidden */
let IgxMaskModule = class IgxMaskModule {
};
IgxMaskModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxMaskModule });
IgxMaskModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxMaskModule_Factory(t) { return new (t || IgxMaskModule)(); }, imports: [[CommonModule]] });

var IgxRadioComponent_1;
var RadioLabelPosition;
(function (RadioLabelPosition) {
    RadioLabelPosition["BEFORE"] = "before";
    RadioLabelPosition["AFTER"] = "after";
})(RadioLabelPosition || (RadioLabelPosition = {}));
let nextId = 0;
const noop$1 = () => { };
const ɵ0$1 = noop$1;
/**
 * **Ignite UI for Angular Radio Button** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio>
 *   Simple radio button
 * </igx-radio>
 * ```
 */
let IgxRadioComponent = IgxRadioComponent_1 = class IgxRadioComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the radio component.
         * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
         * ```html
         * <igx-radio id = "my-first-radio"></igx-radio>
         * ```
         * ```typescript
         * let radioId =  this.radio.id;
         * ```
         * @memberof IgxRadioComponent
         */
        this.id = `igx-radio-${nextId++}`;
        /**
         * Sets/gets the id of the `label` element in the radio component.
         * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
         * ```html
         * <igx-radio labelId = "Label1"></igx-radio>
         * ```
         * ```typescript
         * let labelId =  this.radio.labelId;
         * ```
         * @memberof IgxRadioComponent
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the position of the `label` in the radio component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio labelPosition = "before"></igx-radio>
         * ```
         * ```typescript
         * let labelPosition =  this.radio.labelPosition;
         * ```
         * @memberof IgxRadioComponent
         */
        this.labelPosition = 'after';
        /**
         * Sets the value of the `tabindex` attribute.
         * ```html
         * <igx-radio [tabindex] = "1"></igx-radio>
         * ```
         * ```typescript
         * let tabIndex =  this.radio.tabindex;
         * ```
         * @memberof IgxRadioComponent
         */
        this.tabindex = null;
        /**
         * Enables/disables the ripple effect on the radio button..
         * If not set, the `disableRipple` will have value `false`.
         * ```html
         * <igx-radio [disableRipple] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabledRipple =  this.radio.disableRipple;
         * ```
         * @memberof IgxRadioComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the radio button is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio [required] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isRequired =  this.radio.required;
         * ```
         * @memberof IgxRadioComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute of the radio component.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-radio aria-labelledby = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.radio.ariaLabelledBy;
         * ```
         * @memberof IgxRadioComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the `aria-label` attribute of the radio component.
         * ```html
         * <igx-radio aria-label = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabel =  this.radio.ariaLabel;
         * ```
         * @memberof IgxRadioComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the radio `value` is changed.
         * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
         * @memberof IgxRadioComponent
         */
        this.change = new EventEmitter();
        /**
         * Returns the class of the radio component.
         * ```typescript
         * let radioClass = this.radio.cssClass;
         * ```
         * @memberof IgxRadioComponent
         */
        this.cssClass = 'igx-radio';
        /**
         * Sets/gets  the `checked` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [checked] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isChecked =  this.radio.checked;
         * ```
         * @memberof IgxRadioComponent
         */
        this.checked = false;
        /**
         * Sets/gets  the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [disabled] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabled =  this.radio.disabled;
         * ```
         * @memberof IgxRadioComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the radio component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.radio.focus = true;
         * ```
         * ```typescript
         * let isFocused =  this.radio.focused;
         * ```
         * @memberof IgxRadioComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._value = null;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$1;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$1;
    }
    /**
     * @hidden
     */
    _onRadioChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     */
    _onRadioClick(event) {
        event.stopPropagation();
        this.select();
        if (isIE()) {
            this.nativeRadio.nativeElement.blur();
        }
    }
    /**
     * @hidden
     */
    _onLabelClick() {
        this.select();
    }
    /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     * @memberof IgxRadioComponent
     */
    select() {
        if (this.disabled) {
            return;
        }
        this.checked = true;
        this.focused = false;
        this.change.emit({ value: this.value, radio: this });
        this._onChangeCallback(this.value);
    }
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     */
    writeValue(value) {
        this._value = value;
        this.checked = (this._value === this.value);
    }
    /** @hidden */
    getEditElement() {
        return this.nativeRadio.nativeElement;
    }
    /**
     * @hidden
     */
    get labelClass() {
        switch (this.labelPosition) {
            case RadioLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case RadioLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     */
    onFocus() {
        this.focused = true;
    }
    /**
     * @hidden
     */
    onBlur() {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
};
IgxRadioComponent.ɵfac = function IgxRadioComponent_Factory(t) { return new (t || IgxRadioComponent)(); };
IgxRadioComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxRadioComponent, selectors: [["igx-radio"]], viewQuery: function IgxRadioComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c9, true);
        ɵngcc0.ɵɵstaticViewQuery(_c10, true);
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeRadio = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);
    } }, hostVars: 9, hostBindings: function IgxRadioComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-radio", ctx.cssClass)("igx-radio--checked", ctx.checked)("igx-radio--disabled", ctx.disabled)("igx-radio--focused", ctx.focused);
    } }, inputs: { id: "id", labelId: "labelId", labelPosition: "labelPosition", tabindex: "tabindex", disableRipple: "disableRipple", required: "required", ariaLabelledBy: ["aria-labelledby", "ariaLabelledBy"], ariaLabel: ["aria-label", "ariaLabel"], checked: "checked", disabled: "disabled", value: "value", name: "name" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioComponent_1, multi: true }])], ngContentSelectors: _c2, decls: 8, vars: 17, consts: [["type", "radio", 1, "igx-radio__input", 3, "id", "name", "value", "tabindex", "disabled", "checked", "required", "click", "change", "focus", "blur"], ["radio", ""], ["igxRipple", "", "igxRippleTarget", ".igx-radio__ripple", 1, "igx-radio__composite", 3, "igxRippleDisabled", "igxRippleCentered", "igxRippleDuration", "for"], ["nativeLabel", ""], [1, "igx-radio__ripple"], [3, "id", "click"], ["placeholderLabel", ""]], template: function IgxRadioComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxRadioComponent_Template_input_click_0_listener($event) { return ctx._onRadioClick($event); })("change", function IgxRadioComponent_Template_input_change_0_listener($event) { return ctx._onRadioChange($event); })("focus", function IgxRadioComponent_Template_input_focus_0_listener() { return ctx.onFocus(); })("blur", function IgxRadioComponent_Template_input_blur_0_listener() { return ctx.onBlur(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label", 2, 3);
        ɵngcc0.ɵɵelement(4, "div", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 5, 6);
        ɵngcc0.ɵɵlistener("click", function IgxRadioComponent_Template_span_click_5_listener() { return ctx._onLabelClick(); });
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.inputId)("name", ctx.name)("value", ctx.value)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("checked", ctx.checked)("required", ctx.required);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("igxRippleDisabled", ctx.disableRipple)("igxRippleCentered", true)("igxRippleDuration", 300)("for", ctx.inputId);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵclassMap(ctx.labelClass);
        ɵngcc0.ɵɵproperty("id", ctx.labelId);
    } }, directives: function () { return [IgxRippleDirective]; }, encapsulation: 2 });
__decorate([
    ViewChild('radio', { static: true })
], IgxRadioComponent.prototype, "nativeRadio", void 0);
__decorate([
    ViewChild('nativeLabel', { static: true })
], IgxRadioComponent.prototype, "nativeLabel", void 0);
__decorate([
    ViewChild('placeholderLabel', { static: true })
], IgxRadioComponent.prototype, "placeholderLabel", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxRadioComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "labelId", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "labelPosition", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "name", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "tabindex", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "disableRipple", void 0);
__decorate([
    Input()
], IgxRadioComponent.prototype, "required", void 0);
__decorate([
    Input('aria-labelledby')
], IgxRadioComponent.prototype, "ariaLabelledBy", void 0);
__decorate([
    Input('aria-label')
], IgxRadioComponent.prototype, "ariaLabel", void 0);
__decorate([
    Output()
], IgxRadioComponent.prototype, "change", void 0);
__decorate([
    HostBinding('class.igx-radio')
], IgxRadioComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-radio--checked'),
    Input()
], IgxRadioComponent.prototype, "checked", void 0);
__decorate([
    HostBinding('class.igx-radio--disabled'),
    Input()
], IgxRadioComponent.prototype, "disabled", void 0);
__decorate([
    HostBinding('class.igx-radio--focused')
], IgxRadioComponent.prototype, "focused", void 0);

let IgxRippleDirective = class IgxRippleDirective {
    constructor(builder, elementRef, renderer, zone) {
        this.builder = builder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        /**
         * Sets/gets the ripple target.
         * ```html
         * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleTarget = this.ripple.rippleTarget;
         * ```
         * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
         * ```html
         * <div #rippleContainer [igxRippleTarget] = "'#child"'>
         *  <button id="child">Click</button>
         * </div>
         * ```
         * @memberof IgxRippleDirective
         */
        this.rippleTarget = '';
        /**
         * Sets/gets the ripple duration(in milliseconds).
         * Default value is `600`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleDuration = this.ripple.rippleDuration;
         * ```
         * @memberof IgxRippleDirective
         */
        this.rippleDuration = 600;
        /**
         * Sets/gets whether the ripple is disabled.
         * Default value is `false`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
         * ```
         * ```typescript
         * @ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let isRippleDisabled = this.ripple.rippleDisabled;
         * ```
         * @memberof IgxRippleDirective
         */
        this.rippleDisabled = false;
        this.rippleElementClass = 'igx-ripple__inner';
        this.rippleHostClass = 'igx-ripple';
        this._centered = false;
        this.animationQueue = [];
    }
    /**
     * Enables/disables the ripple to be centered.
     * ```html
     * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
     * ```
     * @memberof IgxRippleDirective
     */
    set centered(value) {
        this._centered = value || this.centered;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        this.zone.runOutsideAngular(() => this._ripple(event));
    }
    setStyles(rippleElement, styleParams) {
        this.renderer.addClass(rippleElement, this.rippleElementClass);
        this.renderer.setStyle(rippleElement, 'width', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'height', `${styleParams.radius}px`);
        this.renderer.setStyle(rippleElement, 'top', `${styleParams.top}px`);
        this.renderer.setStyle(rippleElement, 'left', `${styleParams.left}px`);
        if (this.rippleColor) {
            this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
        }
    }
    _ripple(event) {
        if (this.rippleDisabled) {
            return;
        }
        const target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
        const rectBounds = target.getBoundingClientRect();
        const radius = Math.max(rectBounds.width, rectBounds.height);
        let left = Math.round(event.clientX - rectBounds.left - radius / 2);
        let top = Math.round(event.clientY - rectBounds.top - radius / 2);
        if (this._centered) {
            left = top = 0;
        }
        const dimensions = {
            radius,
            top,
            left
        };
        const rippleElement = this.renderer.createElement('span');
        this.setStyles(rippleElement, dimensions);
        this.renderer.addClass(target, this.rippleHostClass);
        this.renderer.appendChild(target, rippleElement);
        const animation = this.builder.build([
            style({ opacity: 0.5, transform: 'scale(.3)' }),
            animate(this.rippleDuration, style({ opacity: 0, transform: 'scale(2)' }))
        ]).create(rippleElement);
        this.animationQueue.push(animation);
        animation.onDone(() => {
            this.animationQueue.splice(this.animationQueue.indexOf(animation), 1);
            target.removeChild(rippleElement);
            if (this.animationQueue.length < 1) {
                this.renderer.removeClass(target, this.rippleHostClass);
            }
        });
        animation.play();
    }
};
IgxRippleDirective.ɵfac = function IgxRippleDirective_Factory(t) { return new (t || IgxRippleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxRippleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRippleDirective, selectors: [["", "igxRipple", ""]], hostBindings: function IgxRippleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function IgxRippleDirective_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); });
    } }, inputs: { rippleTarget: ["igxRippleTarget", "rippleTarget"], rippleDuration: ["igxRippleDuration", "rippleDuration"], rippleDisabled: ["igxRippleDisabled", "rippleDisabled"], centered: ["igxRippleCentered", "centered"], rippleColor: ["igxRipple", "rippleColor"] } });
IgxRippleDirective.ctorParameters = () => [
    { type: AnimationBuilder },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
__decorate([
    Input('igxRippleTarget')
], IgxRippleDirective.prototype, "rippleTarget", void 0);
__decorate([
    Input('igxRipple')
], IgxRippleDirective.prototype, "rippleColor", void 0);
__decorate([
    Input('igxRippleDuration')
], IgxRippleDirective.prototype, "rippleDuration", void 0);
__decorate([
    Input('igxRippleCentered')
], IgxRippleDirective.prototype, "centered", null);
__decorate([
    Input('igxRippleDisabled')
], IgxRippleDirective.prototype, "rippleDisabled", void 0);
__decorate([
    HostListener('mousedown', ['$event'])
], IgxRippleDirective.prototype, "onMouseDown", null);
/**
 * @hidden
 */
let IgxRippleModule = class IgxRippleModule {
};
IgxRippleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxRippleModule });
IgxRippleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxRippleModule_Factory(t) { return new (t || IgxRippleModule)(); } });

var IgxRadioGroupDirective_1;
const noop$2 = () => { };
const ɵ0$2 = noop$2;
let nextId$1 = 0;
/**
 * Radio group directive renders set of radio buttons.
 *
 * @igxModule IgxRadioModule
 *
 * @igxTheme igx-radio-theme
 *
 * @igxKeywords radiogroup, radio, button, input
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
 *
 * @example:
 * ```html
 * <igx-radio-group name="radioGroup">
 *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
 *      {{item}}
 *   </igx-radio>
 * </igx-radio-group>
 * ```
 */
let IgxRadioGroupDirective = IgxRadioGroupDirective_1 = class IgxRadioGroupDirective {
    constructor() {
        /**
         * An event that is emitted after the radio group `value` is changed.
         *
         * @remarks
         * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
         *
         * @example
         * ```html
         * <igx-radio-group (change)="handler($event)"></igx-radio-group>
         * ```
         */
        this.change = new EventEmitter();
        /**
         * The css class applied to the component.
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-radio-group';
        /**
         * @hidden
         * @internal
         */
        this._onChangeCallback = noop$2;
        /**
         * @hidden
         * @internal
         */
        this._name = `igx-radio-group-${nextId$1++}`;
        /**
         * @hidden
         * @internal
         */
        this._value = null;
        /**
         * @hidden
         * @internal
         */
        this._selected = null;
        /**
         * @hidden
         * @internal
         */
        this._isInitialized = false;
        /**
         * @hidden
         * @internal
         */
        this._labelPosition = 'after';
        /**
         * @hidden
         * @internal
         */
        this._disabled = false;
        /**
         * @hidden
         * @internal
         */
        this._required = false;
        /**
         * @hidden
         * @internal
         */
        this.destroy$ = new Subject();
    }
    /**
     * Sets/gets the `value` attribute.
     *
     * @example
     * ```html
     * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
     * ```
     */
    get value() { return this._value; }
    set value(newValue) {
        if (this._value !== newValue) {
            this._value = newValue;
            this._selectRadioButton();
        }
    }
    /**
     * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
     *
     * @example
     * ```html
     * <igx-radio-group name = "Radio1"></igx-radio-group>
     *  ```
     */
    get name() { return this._name; }
    set name(newValue) {
        if (this._name !== newValue) {
            this._name = newValue;
            this._setRadioButtonNames();
        }
    }
    /**
     * Sets/gets whether the radio group is required.
     *
     * @remarks
     * If not set, `required` will have value `false`.
     *
     * @example
     * ```html
     * <igx-radio-group [required] = "true"></igx-radio-group>
     * ```
     */
    get required() { return this._required; }
    set required(newValue) {
        if (this._required !== newValue) {
            this._required = newValue;
            this._setRadioButtonsRequired();
        }
    }
    /**
     * An @Input property that allows you to disable the radio group. By default it's false.
     *
     * @example
     *  ```html
     * <igx-radio-group [disabled]="true"></igx-radio-group>
     * ```
     */
    get disabled() { return this._disabled; }
    set disabled(newValue) {
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._disableRadioButtons();
        }
    }
    /**
     * Sets/gets the position of the `label` in the child radio buttons.
     *
     * @remarks
     * If not set, `labelPosition` will have value `"after"`.
     *
     * @example
     * ```html
     * <igx-radio-group labelPosition = "before"></igx-radio-group>
     * ```
     */
    get labelPosition() { return this._labelPosition; }
    set labelPosition(newValue) {
        if (this._labelPosition !== newValue) {
            this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;
            this._setRadioButtonLabelPosition();
        }
    }
    /**
     * Sets/gets the selected child radio button.
     *
     * @example
     * ```typescript
     * let selectedButton = this.radioGroup.selected;
     * this.radioGroup.selected = selectedButton;
     * ```
     */
    get selected() { return this._selected; }
    set selected(selected) {
        if (this._selected !== selected) {
            this._selected = selected;
            this.value = selected ? selected.value : null;
        }
    }
    ngAfterContentInit() {
        // The initial value can possibly be set by NgModel and it is possible that
        // the OnInit of the NgModel occurs after the OnInit of this class.
        this._isInitialized = true;
        setTimeout(() => { this._initRadioButtons(); });
    }
    /**
     * Sets the "checked" property value on the radio input element.
     *
     * @remarks
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     *
     * @example
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * Registers a function called when the control value changes.
     *
     * @hidden
     * @internal
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * Registers a function called when the control is touched.
     *
     * @hidden
     * @internal
     */
    registerOnTouched(fn) {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.registerOnTouched(fn);
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @internal
     */
    _initRadioButtons() {
        if (this.radioButtons) {
            const props = { name: this._name, labelPosition: this._labelPosition, disabled: this._disabled, required: this._required };
            this.radioButtons.forEach((button) => {
                Object.assign(button, props);
                if (button.value === this._value) {
                    button.checked = true;
                    this._selected = button;
                }
                button.change.pipe(takeUntil(this.destroy$)).subscribe((ev) => this._selectedRadioButtonChanged(ev));
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _selectedRadioButtonChanged(args) {
        if (this._selected !== args.radio) {
            if (this._selected) {
                this._selected.checked = false;
            }
            this._selected = args.radio;
        }
        this._value = args.value;
        if (this._isInitialized) {
            this.change.emit(args);
            this._onChangeCallback(this.value);
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonNames() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.name = this._name;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _selectRadioButton() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                if (!this._value) {
                    // no value - uncheck all radio buttons
                    if (button.checked) {
                        button.checked = false;
                    }
                }
                else {
                    if (this._value === button.value) {
                        // selected button
                        if (this._selected !== button) {
                            this._selected = button;
                        }
                        if (!button.checked) {
                            button.select();
                        }
                    }
                    else {
                        // non-selected button
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                }
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonLabelPosition() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.labelPosition = this._labelPosition;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _disableRadioButtons() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.disabled = this._disabled;
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    _setRadioButtonsRequired() {
        if (this.radioButtons) {
            this.radioButtons.forEach((button) => {
                button.required = this._required;
            });
        }
    }
};
IgxRadioGroupDirective.ɵfac = function IgxRadioGroupDirective_Factory(t) { return new (t || IgxRadioGroupDirective)(); };
IgxRadioGroupDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRadioGroupDirective, selectors: [["igx-radio-group"], ["", "igxRadioGroup", ""]], contentQueries: function IgxRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRadioComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radioButtons = _t);
    } }, hostVars: 2, hostBindings: function IgxRadioGroupDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-radio-group", ctx.cssClass);
    } }, inputs: { value: "value", name: "name", required: "required", disabled: "disabled", labelPosition: "labelPosition", selected: "selected" }, outputs: { change: "change" }, exportAs: ["igxRadioGroup"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective_1, multi: true }])] });
__decorate([
    ContentChildren(IgxRadioComponent, { descendants: true })
], IgxRadioGroupDirective.prototype, "radioButtons", void 0);
__decorate([
    Input()
], IgxRadioGroupDirective.prototype, "value", null);
__decorate([
    Input()
], IgxRadioGroupDirective.prototype, "name", null);
__decorate([
    Input()
], IgxRadioGroupDirective.prototype, "required", null);
__decorate([
    Input()
], IgxRadioGroupDirective.prototype, "disabled", null);
__decorate([
    Input()
], IgxRadioGroupDirective.prototype, "labelPosition", null);
__decorate([
    Input()
], IgxRadioGroupDirective.prototype, "selected", null);
__decorate([
    Output()
], IgxRadioGroupDirective.prototype, "change", void 0);
__decorate([
    HostBinding('class.igx-radio-group')
], IgxRadioGroupDirective.prototype, "cssClass", void 0);
/**
 * @hidden
 */
let IgxRadioModule = class IgxRadioModule {
};
IgxRadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxRadioModule });
IgxRadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxRadioModule_Factory(t) { return new (t || IgxRadioModule)(); }, imports: [[IgxRippleModule]] });

var IgxTextHighlightDirective_1;
let IgxTextHighlightDirective = IgxTextHighlightDirective_1 = class IgxTextHighlightDirective {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this._div = null;
        this._observer = null;
        this._nodeWasRemoved = false;
        this._forceEvaluation = false;
        this._activeElementIndex = -1;
        this._defaultCssClass = 'igx-highlight';
        this._defaultActiveCssClass = 'igx-highlight--active';
        /**
         * Identifies the highlight within a unique group.
         * This allows it to have several different highlight groups,
         * with each of them having their own active highlight.
         *
         * ```html
         * <div
         *   igxTextHighlight
         *   [groupName]="myGroupName">
         * </div>
         * ```
         */
        this.groupName = '';
        this._value = '';
        this.destroy$ = new Subject();
        IgxTextHighlightDirective_1.onActiveElementChanged.pipe(takeUntil(this.destroy$)).subscribe((groupName) => {
            if (this.groupName === groupName) {
                if (this._activeElementIndex !== -1) {
                    this.deactivate();
                }
                this.activateIfNecessary();
            }
        });
    }
    /**
     * The underlying value of the element that will be highlighted.
     *
     * ```typescript
     * // get
     * const elementValue = this.textHighlight.value;
     * ```
     *
     * ```html
     * <!--set-->
     * <div
     *   igxTextHighlight
     *   [value]="newValue">
     * </div>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(value) {
        if (value === undefined || value === null) {
            this._value = '';
        }
        else {
            this._value = value;
        }
    }
    /**
     * @hidden
     */
    get lastSearchInfo() {
        return this._lastSearchInfo;
    }
    /**
     * Activates the highlight at a given index.
     * (if such index exists)
     */
    static setActiveHighlight(groupName, highlight) {
        IgxTextHighlightDirective_1.highlightGroupsMap.set(groupName, highlight);
        IgxTextHighlightDirective_1.onActiveElementChanged.emit(groupName);
    }
    /**
     * Clears any existing highlight.
     */
    static clearActiveHighlight(groupName) {
        IgxTextHighlightDirective_1.highlightGroupsMap.set(groupName, {
            index: -1
        });
        IgxTextHighlightDirective_1.onActiveElementChanged.emit(groupName);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.clearHighlight();
        if (this._observer !== null) {
            this._observer.disconnect();
        }
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            this._valueChanged = true;
        }
        else if ((changes.row !== undefined && !changes.row.firstChange) ||
            (changes.column !== undefined && !changes.column.firstChange) ||
            (changes.page !== undefined && !changes.page.firstChange)) {
            if (this._activeElementIndex !== -1) {
                this.deactivate();
            }
            this.activateIfNecessary();
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.parentElement = this.renderer.parentNode(this.element.nativeElement);
        if (IgxTextHighlightDirective_1.highlightGroupsMap.has(this.groupName) === false) {
            IgxTextHighlightDirective_1.highlightGroupsMap.set(this.groupName, {
                index: -1
            });
        }
        this._lastSearchInfo = {
            searchedText: '',
            content: this.value,
            matchCount: 0,
            caseSensitive: false,
            exactMatch: false
        };
        this._container = this.parentElement.firstElementChild;
    }
    /**
     * @hidden
     */
    ngAfterViewChecked() {
        if (this._valueChanged) {
            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            this.activateIfNecessary();
            this._valueChanged = false;
        }
    }
    /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     */
    highlight(text, caseSensitive, exactMatch) {
        const caseSensitiveResolved = caseSensitive ? true : false;
        const exactMatchResolved = exactMatch ? true : false;
        if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
            this._lastSearchInfo.content = this.value;
            if (text === '' || text === undefined || text === null) {
                this.clearHighlight();
            }
            else {
                this.clearChildElements(true);
                this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
            }
        }
        else if (this._nodeWasRemoved) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
        }
        return this._lastSearchInfo.matchCount;
    }
    /**
     * Clears any existing highlight.
     */
    clearHighlight() {
        this.clearChildElements(false);
        this._lastSearchInfo.searchedText = '';
        this._lastSearchInfo.matchCount = 0;
    }
    /**
     * Activates the highlight if it is on the currently active row and column.
     */
    activateIfNecessary() {
        const group = IgxTextHighlightDirective_1.highlightGroupsMap.get(this.groupName);
        if (group.column === this.column && group.row === this.row && compareMaps(this.metadata, group.metadata)) {
            this.activate(group.index);
        }
    }
    /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     */
    observe() {
        if (this._observer === null) {
            const callback = (mutationList) => {
                mutationList.forEach((mutation) => {
                    const removedNodes = Array.from(mutation.removedNodes);
                    removedNodes.forEach((n) => {
                        if (n === this._container) {
                            this._nodeWasRemoved = true;
                            this.clearChildElements(false);
                        }
                    });
                    const addedNodes = Array.from(mutation.addedNodes);
                    addedNodes.forEach((n) => {
                        if (n === this.parentElement.firstElementChild && this._nodeWasRemoved) {
                            this._container = this.parentElement.firstElementChild;
                            this._nodeWasRemoved = false;
                            this._forceEvaluation = true;
                            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
                            this._forceEvaluation = false;
                            this.activateIfNecessary();
                            this._observer.disconnect();
                            this._observer = null;
                        }
                    });
                });
            };
            this._observer = new MutationObserver(callback);
            this._observer.observe(this.parentElement, { childList: true });
        }
    }
    activate(index) {
        this.deactivate();
        if (this._div !== null) {
            const spans = this._div.querySelectorAll('span');
            this._activeElementIndex = index;
            if (spans.length <= index) {
                return;
            }
            const elementToActivate = spans[index];
            this.renderer.addClass(elementToActivate, this._defaultActiveCssClass);
            this.renderer.addClass(elementToActivate, this.activeCssClass);
        }
    }
    deactivate() {
        if (this._activeElementIndex === -1) {
            return;
        }
        const spans = this._div.querySelectorAll('span');
        if (spans.length <= this._activeElementIndex) {
            this._activeElementIndex = -1;
            return;
        }
        const elementToDeactivate = spans[this._activeElementIndex];
        this.renderer.removeClass(elementToDeactivate, this._defaultActiveCssClass);
        this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
        this._activeElementIndex = -1;
    }
    clearChildElements(originalContentHidden) {
        this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
        if (this._div !== null) {
            this.renderer.removeChild(this.parentElement, this._div);
            this._div = null;
            this._activeElementIndex = -1;
        }
    }
    getHighlightedText(searchText, caseSensitive, exactMatch) {
        this.appendDiv();
        const stringValue = String(this.value);
        const contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
        const searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
        let matchCount = 0;
        if (exactMatch) {
            if (contentStringResolved === searchTextResolved) {
                // tslint:disable-next-line:max-line-length
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue}</span>`);
                matchCount++;
            }
            else {
                this.appendText(stringValue);
            }
        }
        else {
            let foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
            let previousMatchEnd = 0;
            while (foundIndex !== -1) {
                const start = foundIndex;
                const end = foundIndex + searchTextResolved.length;
                this.appendText(stringValue.substring(previousMatchEnd, start));
                // tslint:disable-next-line:max-line-length
                this.appendSpan(`<span class="${this._defaultCssClass} ${this.cssClass ? this.cssClass : ''}">${stringValue.substring(start, end)}</span>`);
                previousMatchEnd = end;
                matchCount++;
                foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
            }
            this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
        }
        return matchCount;
    }
    appendText(text) {
        const textElement = this.renderer.createText(text);
        this.renderer.appendChild(this._div, textElement);
    }
    appendSpan(outerHTML) {
        const span = this.renderer.createElement('span');
        this.renderer.appendChild(this._div, span);
        this.renderer.setProperty(span, 'outerHTML', outerHTML);
    }
    appendDiv() {
        this._div = this.renderer.createElement('div');
        if (this.containerClass) {
            this.renderer.addClass(this._div, this.containerClass);
        }
        this.renderer.appendChild(this.parentElement, this._div);
    }
    searchNeedsEvaluation(text, caseSensitive, exactMatch) {
        const searchedText = this._lastSearchInfo.searchedText;
        return !this._nodeWasRemoved &&
            (searchedText === null ||
                searchedText !== text ||
                this._lastSearchInfo.content !== this.value ||
                this._lastSearchInfo.caseSensitive !== caseSensitive ||
                this._lastSearchInfo.exactMatch !== exactMatch ||
                this._forceEvaluation);
    }
};
IgxTextHighlightDirective.ɵfac = function IgxTextHighlightDirective_Factory(t) { return new (t || IgxTextHighlightDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxTextHighlightDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTextHighlightDirective, selectors: [["", "igxTextHighlight", ""]], inputs: { groupName: "groupName", value: "value", cssClass: "cssClass", activeCssClass: "activeCssClass", containerClass: "containerClass", row: "row", column: "column", metadata: "metadata" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxTextHighlightDirective.onActiveElementChanged = new EventEmitter();
IgxTextHighlightDirective.highlightGroupsMap = new Map();
IgxTextHighlightDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input('cssClass')
], IgxTextHighlightDirective.prototype, "cssClass", void 0);
__decorate([
    Input('activeCssClass')
], IgxTextHighlightDirective.prototype, "activeCssClass", void 0);
__decorate([
    Input('containerClass')
], IgxTextHighlightDirective.prototype, "containerClass", void 0);
__decorate([
    Input('groupName')
], IgxTextHighlightDirective.prototype, "groupName", void 0);
__decorate([
    Input('value')
], IgxTextHighlightDirective.prototype, "value", null);
__decorate([
    Input('row')
], IgxTextHighlightDirective.prototype, "row", void 0);
__decorate([
    Input('column')
], IgxTextHighlightDirective.prototype, "column", void 0);
__decorate([
    Input()
], IgxTextHighlightDirective.prototype, "metadata", void 0);
/**
 * @hidden
 */
let IgxTextHighlightModule = class IgxTextHighlightModule {
};
IgxTextHighlightModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTextHighlightModule });
IgxTextHighlightModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTextHighlightModule_Factory(t) { return new (t || IgxTextHighlightModule)(); } });

let IgxTextSelectionDirective = class IgxTextSelectionDirective {
    constructor(element) {
        this.element = element;
        this.selectionState = true;
    }
    /**
     * Returns whether the input element is selectable through the directive.
     *
     * ```typescript
     * // get
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public firstName: IgxTextSelectionDirective;
     *
     * public getFirstNameSelectionStatus() {
     *  return this.firstName.selected;
     * }
     * ```
     */
    get selected() {
        return this.selectionState;
    }
    /**
     *  Determines whether the input element could be selected through the directive.
     *
     * ```html
     * <!--set-->
     * <input
     *   type="text"
     *   id="firstName"
     *   [igxTextSelection]="true">
     * </input>
     *
     * <input
     *   type="text"
     *   id="lastName"
     *   igxTextSelection
     *   [selected]="true">
     * </input>
     * ```
     */
    set selected(val) {
        this.selectionState = val;
    }
    /**
     * Returns the nativeElement of the element where the directive was applied.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public getNativeElement() {
     *  return this.inputElement.nativeElement;
     * }
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    onFocus() {
        this.trigger();
    }
    /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     */
    trigger() {
        if (this.selected && this.nativeElement.value.length) {
            requestAnimationFrame(() => this.nativeElement.setSelectionRange(0, this.nativeElement.value.length));
        }
    }
};
IgxTextSelectionDirective.ɵfac = function IgxTextSelectionDirective_Factory(t) { return new (t || IgxTextSelectionDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTextSelectionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTextSelectionDirective, selectors: [["", "igxTextSelection", ""]], hostBindings: function IgxTextSelectionDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function IgxTextSelectionDirective_focus_HostBindingHandler() { return ctx.onFocus(); });
    } }, inputs: { selected: ["igxTextSelection", "selected"] }, exportAs: ["igxTextSelection"] });
IgxTextSelectionDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('igxTextSelection')
], IgxTextSelectionDirective.prototype, "selected", null);
__decorate([
    HostListener('focus')
], IgxTextSelectionDirective.prototype, "onFocus", null);
/**
 * @hidden
 */
let IgxTextSelectionModule = class IgxTextSelectionModule {
};
IgxTextSelectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTextSelectionModule });
IgxTextSelectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTextSelectionModule_Factory(t) { return new (t || IgxTextSelectionModule)(); } });

/**
 * **Ignite UI for Angular Tooltip Target** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
 *
 * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
 * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
 * target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
let IgxTooltipTargetDirective = class IgxTooltipTargetDirective extends IgxToggleActionDirective {
    constructor(_element, _navigationService) {
        super(_element, _navigationService);
        this._element = _element;
        this._navigationService = _navigationService;
        /**
         * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipShowDelay = this.tooltipTarget.showDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.showDelay = 500;
        /**
         * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipHideDelay = this.tooltipTarget.hideDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.hideDelay = 500;
        /**
         * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
         * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
         * the developer will still be able to show/hide the tooltip through the API.
         *
         * ```typescript
         * // get
         * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.tooltipDisabled = false;
        /**
         * Emits an event when the tooltip that is associated with this target starts showing.
         * This event is fired before the start of the countdown to showing the tooltip.
         *
         * ```typescript
         * tooltipShowing(args: ITooltipShowEventArgs) {
         *    alert("Tooltip started showing!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipShow)='tooltipShowing($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.onTooltipShow = new EventEmitter();
        /**
         * Emits an event when the tooltip that is associated with this target starts hiding.
         * This event is fired before the start of the countdown to hiding the tooltip.
         *
         * ```typescript
         * tooltipHiding(args: ITooltipHideEventArgs) {
         *    alert("Tooltip started hiding!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipHide)='tooltipHiding($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        this.onTooltipHide = new EventEmitter();
    }
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this._navigationService.get(this._target);
        }
        return this._target;
    }
    /**
     * Gets the respective native element of the directive.
     *
     * ```typescript
     * let tooltipTargetElement = this.tooltipTarget.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Indicates if the tooltip that is is associated with this target is currently hidden.
     *
     * ```typescript
     * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
     * ```
     */
    get tooltipHidden() {
        return !this.target || this.target.collapsed;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        const positionSettings = {
            target: this.nativeElement,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            openAnimation: useAnimation(scaleInCenter, { params: { duration: '150ms' } }),
            closeAnimation: useAnimation(fadeOut, { params: { duration: '75ms' } })
        };
        this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
        this._overlayDefaults.closeOnOutsideClick = false;
    }
    checkOutletAndOutsideClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
    }
    get mergedOverlaySettings() {
        return Object.assign({}, this._overlayDefaults, this.overlaySettings);
    }
    // Return true if the execution in onMouseEnter should be terminated after this method
    preMouseEnterCheck() {
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
            this.target.toBeShown = false;
        }
        // If Tooltip is opened or about to be hidden
        if (!this.target.collapsed || this.target.toBeHidden) {
            clearTimeout(this.target.timeoutId);
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return true;
            }
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        return false;
    }
    // Return true if the execution in onMouseLeave should be terminated after this method
    preMouseLeaveCheck() {
        clearTimeout(this.target.timeoutId);
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            this.target.toBeShown = false;
            this.target.toBeHidden = false;
            return true;
        }
        return false;
    }
    /**
     * @hidden
     */
    onKeydownEscape(event) {
        const hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.close();
        this.target.toBeHidden = false;
    }
    /**
     * @hidden
     */
    onClick() {
        if (!this.target.collapsed) {
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            this.target.forceClose(this.mergedOverlaySettings);
        }
    }
    /**
     * @hidden
     */
    onMouseEnter() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        const shouldReturn = this.preMouseEnterCheck();
        if (shouldReturn) {
            return;
        }
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * @hidden
     */
    onMouseLeave() {
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        const shouldReturn = this.preMouseLeaveCheck();
        if (shouldReturn || this.target.collapsed) {
            return;
        }
        const hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
    /**
     * @hidden
     */
    onTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        this.showTooltip();
    }
    /**
     * @hidden
     */
    onDocumentTouchStart(event) {
        if (this.tooltipDisabled) {
            return;
        }
        if (this.nativeElement !== event.target &&
            !this.nativeElement.contains(event.target)) {
            this.hideTooltip();
        }
    }
    /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     */
    showTooltip() {
        clearTimeout(this.target.timeoutId);
        if (!this.target.collapsed) {
            const hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        const showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.open(this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            this.target.toBeShown = false;
        }, this.showDelay);
    }
    /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     */
    hideTooltip() {
        if (this.target.collapsed && this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
        }
        if (this.target.collapsed || this.target.toBeHidden) {
            return;
        }
        const hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(() => {
            this.target.close(); // Call close() of IgxTooltipDirective
            this.target.toBeHidden = false;
        }, this.hideDelay);
    }
};
IgxTooltipTargetDirective.ɵfac = function IgxTooltipTargetDirective_Factory(t) { return new (t || IgxTooltipTargetDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxTooltipTargetDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTooltipTargetDirective, selectors: [["", "igxTooltipTarget", ""]], hostBindings: function IgxTooltipTargetDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.escape", function IgxTooltipTargetDirective_keydown_escape_HostBindingHandler($event) { return ctx.onKeydownEscape($event); }, false, ɵngcc0.ɵɵresolveDocument)("click", function IgxTooltipTargetDirective_click_HostBindingHandler() { return ctx.onClick(); })("mouseenter", function IgxTooltipTargetDirective_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function IgxTooltipTargetDirective_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("touchstart", function IgxTooltipTargetDirective_touchstart_HostBindingHandler($event) { return ctx.onTouchStart($event); })("touchstart", function IgxTooltipTargetDirective_touchstart_HostBindingHandler($event) { return ctx.onDocumentTouchStart($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { showDelay: "showDelay", hideDelay: "hideDelay", tooltipDisabled: "tooltipDisabled", target: ["igxTooltipTarget", "target"] }, outputs: { onTooltipShow: "onTooltipShow", onTooltipHide: "onTooltipHide" }, exportAs: ["tooltipTarget"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxTooltipTargetDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    Input('showDelay')
], IgxTooltipTargetDirective.prototype, "showDelay", void 0);
__decorate([
    Input('hideDelay')
], IgxTooltipTargetDirective.prototype, "hideDelay", void 0);
__decorate([
    Input('tooltipDisabled')
], IgxTooltipTargetDirective.prototype, "tooltipDisabled", void 0);
__decorate([
    Input('igxTooltipTarget')
], IgxTooltipTargetDirective.prototype, "target", null);
__decorate([
    Output()
], IgxTooltipTargetDirective.prototype, "onTooltipShow", void 0);
__decorate([
    Output()
], IgxTooltipTargetDirective.prototype, "onTooltipHide", void 0);
__decorate([
    HostListener('document:keydown.escape', ['$event'])
], IgxTooltipTargetDirective.prototype, "onKeydownEscape", null);
__decorate([
    HostListener('click')
], IgxTooltipTargetDirective.prototype, "onClick", null);
__decorate([
    HostListener('mouseenter')
], IgxTooltipTargetDirective.prototype, "onMouseEnter", null);
__decorate([
    HostListener('mouseleave')
], IgxTooltipTargetDirective.prototype, "onMouseLeave", null);
__decorate([
    HostListener('touchstart', ['$event'])
], IgxTooltipTargetDirective.prototype, "onTouchStart", null);
__decorate([
    HostListener('document:touchstart', ['$event'])
], IgxTooltipTargetDirective.prototype, "onDocumentTouchStart", null);
IgxTooltipTargetDirective = __decorate([ __param(1, Optional())
], IgxTooltipTargetDirective);
let NEXT_ID$6 = 0;
/**
 * **Ignite UI for Angular Tooltip** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
 *
 * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
 * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
 * respective target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
let IgxTooltipDirective = class IgxTooltipDirective extends IgxToggleDirective {
    /** @hidden */
    constructor(elementRef, cdr, overlayService, navigationService) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(elementRef, cdr, overlayService, navigationService);
        /**
         * @hidden
         * Returns whether close time out has started
         */
        this.toBeHidden = false;
        /**
         * @hidden
         * Returns whether open time out has started
         */
        this.toBeShown = false;
        /**
         * Identifier for the tooltip.
         * If this is property is not explicitly set, it will be automatically generated.
         *
         * ```typescript
         * let tooltipId = this.tooltip.id;
         * ```
         */
        this.id = `igx-tooltip-${NEXT_ID$6++}`;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * Get the role attribute of the tooltip.
     *
     * ```typescript
     * let tooltipRole = this.tooltip.role;
     * ```
     */
    get role() {
        return 'tooltip';
    }
    /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     * @param overlaySettings setting to use for opening the toggle
     */
    forceOpen(overlaySettings) {
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasOpenAnimation = info ? info.openAnimationPlayer : false;
        if (hasOpenAnimation) {
            info.openAnimationPlayer.finish();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
        }
        else if (this.collapsed) {
            const animation = overlaySettings.positionStrategy.settings.openAnimation;
            overlaySettings.positionStrategy.settings.openAnimation = null;
            this.open(overlaySettings);
            overlaySettings.positionStrategy.settings.openAnimation = animation;
        }
    }
    /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     * @param overlaySettings settings to use for closing the toggle
     */
    forceClose(overlaySettings) {
        const info = this.overlayService.getOverlayById(this._overlayId);
        const hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasCloseAnimation) {
            info.closeAnimationPlayer.finish();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
        }
        else if (!this.collapsed) {
            const animation = overlaySettings.positionStrategy.settings.closeAnimation;
            overlaySettings.positionStrategy.settings.closeAnimation = null;
            this.close();
            overlaySettings.positionStrategy.settings.closeAnimation = animation;
        }
    }
};
IgxTooltipDirective.ɵfac = function IgxTooltipDirective_Factory(t) { return new (t || IgxTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxTooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTooltipDirective, selectors: [["", "igxTooltip", ""]], hostVars: 6, hostBindings: function IgxTooltipDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-tooltip--hidden", ctx.hiddenClass)("igx-tooltip--desktop", ctx.defaultClass);
    } }, inputs: { id: "id", context: "context" }, exportAs: ["tooltip"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxTooltipDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    HostBinding('class.igx-tooltip--hidden')
], IgxTooltipDirective.prototype, "hiddenClass", null);
__decorate([
    HostBinding('class.igx-tooltip--desktop')
], IgxTooltipDirective.prototype, "defaultClass", null);
__decorate([
    Input('context')
], IgxTooltipDirective.prototype, "context", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxTooltipDirective.prototype, "id", void 0);
__decorate([
    HostBinding('attr.role')
], IgxTooltipDirective.prototype, "role", null);
IgxTooltipDirective = __decorate([ __param(2, Inject(IgxOverlayService)),
    __param(3, Optional())
], IgxTooltipDirective);
/**
 * @hidden
 */
let IgxTooltipModule = class IgxTooltipModule {
};
IgxTooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTooltipModule });
IgxTooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTooltipModule_Factory(t) { return new (t || IgxTooltipModule)(); }, providers: [IgxOverlayService], imports: [[CommonModule]] });

/**
 * Specify a particular date, time or AmPm part.
 */
var DatePart;
(function (DatePart) {
    DatePart["Date"] = "date";
    DatePart["Month"] = "month";
    DatePart["Year"] = "year";
    DatePart["Hours"] = "hour";
    DatePart["Minutes"] = "minute";
    DatePart["Seconds"] = "second";
    DatePart["AmPm"] = "ampm";
    DatePart["Literal"] = "literal";
})(DatePart || (DatePart = {}));

const DATE_CHARS = ['h', 'H', 'm', 's', 'S', 't', 'T'];
const TIME_CHARS = ['d', 'D', 'M', 'y', 'Y'];
/** @hidden */
class DatePickerUtil {
    /**
     *  TODO: Unit tests for all public methods.
     */
    /**
     * Parse a Date value from masked string input based on determined date parts
     * @param inputData masked value to parse
     * @param dateTimeParts Date parts array for the mask
     */
    static parseValueFromMask(inputData, dateTimeParts, promptChar) {
        const parts = {};
        dateTimeParts.forEach(dp => {
            let value = parseInt(this.getCleanVal(inputData, dp, promptChar), 10);
            if (!value) {
                value = dp.type === DatePart.Date || dp.type === DatePart.Month ? 1 : 0;
            }
            parts[dp.type] = value;
        });
        if (parts[DatePart.Month] < 1 || 12 < parts[DatePart.Month]) {
            return null;
        }
        // TODO: Century threshold
        if (parts[DatePart.Year] < 50) {
            parts[DatePart.Year] += 2000;
        }
        if (parts[DatePart.Date] > DatePickerUtil.daysInMonth(parts[DatePart.Year], parts[DatePart.Month])) {
            return null;
        }
        if (parts[DatePart.Hours] > 23 || parts[DatePart.Minutes] > 59 || parts[DatePart.Seconds] > 59) {
            return null;
        }
        return new Date(parts[DatePart.Year] || 2000, parts[DatePart.Month] - 1 || 0, parts[DatePart.Date] || 1, parts[DatePart.Hours] || 0, parts[DatePart.Minutes] || 0, parts[DatePart.Seconds] || 0);
    }
    /**
     * Parse the mask into date/time and literal parts
     */
    static parseDateTimeFormat(mask, locale = DatePickerUtil.DEFAULT_LOCALE) {
        const format = mask || DatePickerUtil.getDefaultInputFormat(locale);
        const dateTimeParts = [];
        const formatArray = Array.from(format);
        let currentPart = null;
        let position = 0;
        for (let i = 0; i < formatArray.length; i++, position++) {
            const type = DatePickerUtil.determineDatePart(formatArray[i]);
            if (currentPart) {
                if (currentPart.type === type) {
                    currentPart.format += formatArray[i];
                    if (i < formatArray.length - 1) {
                        continue;
                    }
                }
                DatePickerUtil.ensureLeadingZero(currentPart);
                currentPart.end = currentPart.start + currentPart.format.length;
                position = currentPart.end;
                dateTimeParts.push(currentPart);
            }
            currentPart = {
                start: position,
                end: position + formatArray[i].length,
                type: type,
                format: formatArray[i]
            };
        }
        return dateTimeParts;
    }
    static getDefaultInputFormat(locale) {
        if (!Intl || !Intl.DateTimeFormat || !Intl.DateTimeFormat.prototype.formatToParts) {
            // TODO: fallback with Intl.format for IE?
            return DatePickerUtil.SHORT_DATE_MASK;
        }
        const parts = DatePickerUtil.getDefaultLocaleMask(locale);
        parts.forEach(p => {
            if (p.type !== DatePart.Year && p.type !== DatePickerUtil.SEPARATOR) {
                p.formatType = "2-digit" /* TwoDigits */;
            }
        });
        return DatePickerUtil.getMask(parts);
    }
    static isDateOrTimeChar(char) {
        return DATE_CHARS.indexOf(char) !== -1 || TIME_CHARS.indexOf(char) !== -1;
    }
    static spinDate(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth());
        let date = newDate.getDate() + delta;
        if (date > maxDate) {
            date = isSpinLoop ? date % maxDate : maxDate;
        }
        else if (date < 1) {
            date = isSpinLoop ? maxDate + (date % maxDate) : 1;
        }
        newDate.setDate(date);
    }
    static spinMonth(delta, newDate, isSpinLoop) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear(), newDate.getMonth() + delta);
        if (newDate.getDate() > maxDate) {
            newDate.setDate(maxDate);
        }
        const maxMonth = 11;
        const minMonth = 0;
        let month = newDate.getMonth() + delta;
        if (month > maxMonth) {
            month = isSpinLoop ? (month % maxMonth) - 1 : maxMonth;
        }
        else if (month < minMonth) {
            month = isSpinLoop ? maxMonth + (month % maxMonth) + 1 : minMonth;
        }
        newDate.setMonth(month);
    }
    static spinYear(delta, newDate) {
        const maxDate = DatePickerUtil.daysInMonth(newDate.getFullYear() + delta, newDate.getMonth());
        if (newDate.getDate() > maxDate) {
            // clip to max to avoid leap year change shifting the entire value
            newDate.setDate(maxDate);
        }
        newDate.setFullYear(newDate.getFullYear() + delta);
    }
    static spinHours(delta, newDate, isSpinLoop) {
        const maxHour = 23;
        const minHour = 0;
        let hours = newDate.getHours() + delta;
        if (hours > maxHour) {
            hours = isSpinLoop ? hours % maxHour - 1 : maxHour;
        }
        else if (hours < minHour) {
            hours = isSpinLoop ? maxHour + (hours % maxHour) + 1 : minHour;
        }
        newDate.setHours(hours);
    }
    static spinMinutes(delta, newDate, isSpinLoop) {
        const maxMinutes = 59;
        const minMinutes = 0;
        let minutes = newDate.getMinutes() + delta;
        if (minutes > maxMinutes) {
            minutes = isSpinLoop ? minutes % maxMinutes - 1 : maxMinutes;
        }
        else if (minutes < minMinutes) {
            minutes = isSpinLoop ? maxMinutes + (minutes % maxMinutes) + 1 : minMinutes;
        }
        newDate.setMinutes(minutes);
    }
    static spinSeconds(delta, newDate, isSpinLoop) {
        const maxSeconds = 59;
        const minSeconds = 0;
        let seconds = newDate.getSeconds() + delta;
        if (seconds > maxSeconds) {
            seconds = isSpinLoop ? seconds % maxSeconds - 1 : maxSeconds;
        }
        else if (seconds < minSeconds) {
            seconds = isSpinLoop ? maxSeconds + (seconds % maxSeconds) + 1 : minSeconds;
        }
        newDate.setSeconds(seconds);
    }
    static spinAmPm(newDate, currentDate, amPmFromMask) {
        switch (amPmFromMask) {
            case 'AM':
                newDate = new Date(newDate.setHours(newDate.getHours() + 12));
                break;
            case 'PM':
                newDate = new Date(newDate.setHours(newDate.getHours() - 12));
                break;
        }
        if (newDate.getDate() !== currentDate.getDate()) {
            return currentDate;
        }
        return newDate;
    }
    /**
     * Determines whether the provided value is greater than the provided max value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is greater than provided maxValue
     */
    static greaterThanMaxValue(value, maxValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if maxValue is Invalid Date and value is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() > maxValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _maxValue = new Date(maxValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _maxValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _maxValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() > _maxValue.getTime();
    }
    /**
     * Determines whether the provided value is less than the provided min value.
     * @param includeTime set to false if you want to exclude time portion of the two dates
     * @param includeDate set to false if you want to exclude the date portion of the two dates
     * @returns true if provided value is less than provided minValue
     */
    static lessThanMinValue(value, minValue, includeTime = true, includeDate = true) {
        // TODO: check if provided dates are valid dates and not Invalid Date
        // if value is Invalid Date and minValue is valid date this will return:
        // - false if includeDate is true
        // - true if includeDate is false
        if (includeTime && includeDate) {
            return value.getTime() < minValue.getTime();
        }
        const _value = new Date(value.getTime());
        const _minValue = new Date(minValue.getTime());
        if (!includeTime) {
            _value.setHours(0, 0, 0, 0);
            _minValue.setHours(0, 0, 0, 0);
        }
        if (!includeDate) {
            _value.setFullYear(0, 0, 0);
            _minValue.setFullYear(0, 0, 0);
        }
        return _value.getTime() < _minValue.getTime();
    }
    static ensureLeadingZero(part) {
        switch (part.type) {
            case DatePart.Date:
            case DatePart.Month:
            case DatePart.Hours:
            case DatePart.Minutes:
            case DatePart.Seconds:
                if (part.format.length === 1) {
                    part.format = part.format.repeat(2);
                }
                break;
        }
    }
    static getCleanVal(inputData, datePart, promptChar) {
        return DatePickerUtil.trimEmptyPlaceholders(inputData.substring(datePart.start, datePart.end), promptChar);
    }
    static determineDatePart(char) {
        switch (char) {
            case 'd':
            case 'D':
                return DatePart.Date;
            case 'M':
                return DatePart.Month;
            case 'y':
            case 'Y':
                return DatePart.Year;
            case 'h':
            case 'H':
                return DatePart.Hours;
            case 'm':
                return DatePart.Minutes;
            case 's':
            case 'S':
                return DatePart.Seconds;
            case 't':
            case 'T':
                return DatePart.AmPm;
            default:
                return DatePart.Literal;
        }
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    static parseDateFormat(maskValue, locale = DatePickerUtil.DEFAULT_LOCALE) {
        let dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            const mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            const maskArray = Array.from(mask);
            const monthInitPosition = mask.indexOf("M" /* MonthChar */);
            const dayInitPosition = mask.indexOf("d" /* DayChar */);
            const yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (let i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort((a, b) => a.initialPosition - b.initialPosition);
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    }
    /**
     * This method generates input mask based on date parts.
     * @param dateStruct array
     * @returns input mask
     */
    static getInputMask(dateStruct) {
        const inputMask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    }
    /**
     * This method generates editor mask.
     * @param dateStruct
     * @returns editor mask
     */
    static getMask(dateStruct) {
        const mask = [];
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    }
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    static parseDateArray(dateFormatParts, prevDateValue, inputValue) {
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        const yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        const yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        const day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        const month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        let year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        let yearPrefix;
        if (prevDateValue) {
            const originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        const fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    }
    static maskToPromptChars(mask) {
        const result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    }
    /**
     * This method replaces prompt chars with empty string.
     * @param value
     */
    static trimEmptyPlaceholders(value, promptChar) {
        const result = value.replace(new RegExp(promptChar || '_', 'g'), '');
        return result;
    }
    /**
     * This method is used for spinning date parts.
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    static getModifiedDateInput(dateFormatParts, inputValue, position, delta, isSpinLoop) {
        const datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        const datePartType = datePart.type;
        const datePartFormatType = datePart.formatType;
        let newValue;
        const datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        let maxValue, minValue;
        const minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        let tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        const startIdx = datePart.position[0];
        const endIdx = datePart.position[1];
        const start = inputValue.slice(0, startIdx);
        const end = inputValue.slice(endIdx, inputValue.length);
        let changedPart;
        const prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? `${prefix}${newValue}` : `${newValue}`;
        return `${start}${changedPart}${end}`;
    }
    /**
     * This method returns date input with prompt chars.
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    static addPromptCharsEditMode(dateFormatParts, date, inputValue) {
        const dateArray = Array.from(inputValue);
        for (let i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    }
    /**
     * This method checks if date input is done.
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    static checkForCompleteDateInput(dateFormatParts, input) {
        const dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        const monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        const yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        const dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        const monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    }
    static daysInMonth(fullYear, month) {
        return new Date(fullYear, month + 1, 0).getDate();
    }
    /**
     * Parse provided input to Date.
     * @param value input to parse
     * @returns Date if parse succeed or null
     */
    static parseDate(value) {
        if (typeof value === 'number') {
            return new Date(value);
        }
        // if value is Invalid Date we should return null
        if (this.isDate(value)) {
            return this.isValidDate(value) ? value : null;
        }
        return value ? new Date(Date.parse(value)) : null;
    }
    /**
     * Returns whether provided input is date
     * @param value input to check
     * @returns true if provided input is date
     */
    static isDate(value) {
        return Object.prototype.toString.call(value) === '[object Date]';
    }
    /**
     * Returns whether the input is valid date
     * @param value input to check
     * @returns true if provided input is a valid date
     */
    static isValidDate(value) {
        if (this.isDate(value)) {
            return !isNaN(value.getTime());
        }
        return false;
    }
    static getYearFormatType(format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getMonthFormatType(format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDayFormatType(format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    }
    static getDefaultLocaleMask(locale) {
        const dateStruct = [];
        const formatter = new Intl.DateTimeFormat(locale);
        const formatToParts = formatter.formatToParts(new Date());
        for (let i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type
                });
            }
        }
        const formatterOptions = formatter.resolvedOptions();
        for (let i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.year;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    }
    static isDateChar(char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    }
    static getNumericFormatPrefix(formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    }
    static getMinMaxValue(dateFormatParts, datePart, inputValue) {
        let maxValue, minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    }
    static getDateValueFromInput(dateFormatParts, type, inputValue, trim = true) {
        const partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        const result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimEmptyPlaceholders(result) : result;
    }
    static getDayValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    }
    static getMonthValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    }
    static getYearValueFromInput(dateFormatParts, inputValue, trim = true) {
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    }
    static getDateFormatPart(dateFormatParts, type) {
        const result = dateFormatParts.filter((datePart) => (datePart.type === type))[0];
        return result;
    }
    static isFullInput(value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    }
    static isFullYearInput(dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    }
    static getDatePartOnPosition(dateFormatParts, position) {
        const result = dateFormatParts.filter((element) => element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR)[0];
        return result;
    }
    static getFullYearFromString(yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    }
    static fillDatePartsPositions(dateArray) {
        let currentPos = 0;
        for (let i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    }
}
DatePickerUtil.DEFAULT_INPUT_FORMAT = 'MM/dd/yyyy';
// TODO: this is the def mask for the date-picker, should remove it during refactoring
DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
DatePickerUtil.SEPARATOR = 'literal';
DatePickerUtil.NUMBER_OF_MONTHS = 12;
DatePickerUtil.PROMPT_CHAR = '_';
DatePickerUtil.DEFAULT_LOCALE = 'en';

var IgxDateTimeEditorDirective_1;
/**
 * Date Time Editor provides a functionality to input, edit and format date and time.
 *
 * @igxModule IgxDateTimeEditorModule
 *
 * @igxParent IgxInputGroup
 *
 * @igxTheme igx-input-theme
 *
 * @igxKeywords date, time, editor
 *
 * @igxGroup Scheduling
 *
 * @remarks
 *
 * The Ignite UI Date Time Editor Directive makes it easy for developers to manipulate date/time user input.
 * It requires input in a specified or default input format which is visible in the input element as a placeholder.
 * It allows the input of only date (ex: 'dd/MM/yyyy'), only time (ex:'HH:mm tt') or both at once, if needed.
 * Supports display format that may differ from the input format.
 * Provides methods to increment and decrement any specific/targeted `DatePart`.
 *
 * @example
 * ```html
 * <igx-input-group>
 *   <input type="text" igxInput [igxDateTimeEditor]="'dd/MM/yyyy'" [displayFormat]="'shortDate'" [(ngModel)]="date"/>
 * </igx-input-group>
 * ```
 */
let IgxDateTimeEditorDirective = IgxDateTimeEditorDirective_1 = class IgxDateTimeEditorDirective extends IgxMaskDirective {
    constructor(renderer, elementRef, maskParser, _document, _locale) {
        super(elementRef, maskParser, renderer);
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.maskParser = maskParser;
        this._document = _document;
        this._locale = _locale;
        /**
         * Specify if the currently spun date segment should loop over.
         * @example
         * ```html
         * <input igxDateTimeEditor [isSpinLoop]="false">
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the editor's value has changed.
         * @example
         * ```html
         * <input igxDateTimeEditor (valueChange)="onValueChanged($event)"/>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the editor is not within a specified range or when the editor's value is in an invalid state.
         * @example
         * ```html
         * <input igxDateTimeEditor [minValue]="minDate" [maxValue]="maxDate" (validationFailed)="onValidationFailed($event)"/>
         * ```
         */
        this.validationFailed = new EventEmitter();
        this.onTouchCallback = (...args) => { };
        this.onChangeCallback = (...args) => { };
        this.onValidatorChange = (...args) => { };
        this.document = this._document;
        this.locale = this.locale || this._locale;
    }
    /**
     * Minimum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [minValue]="minDate">
     * ```
     */
    get minValue() {
        return this._minValue;
    }
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    /**
     * Maximum value required for the editor to remain valid.
     *
     * @remarks
     * If a `string` value is passed in, it must be in the defined input format.
     *
     * @example
     * ```html
     * <input igxDateTimeEditor [maxValue]="maxDate">
     * ```
     */
    get maxValue() {
        return this._maxValue;
    }
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    /**
     * Expected user input format (and placeholder).
     * @example
     * ```html
     * <input [igxDateTimeEditor]="'dd/MM/yyyy'">
     * ```
     */
    set inputFormat(value) {
        if (value) {
            this._format = value;
        }
        const mask = (this.inputFormat || DatePickerUtil.DEFAULT_INPUT_FORMAT)
            .replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this.mask = mask.indexOf('tt') !== -1 ? mask.replace(new RegExp('tt', 'g'), 'LL') : mask;
    }
    get inputFormat() {
        return this._format;
    }
    /**
     * Editor value.
     * @example
     * ```html
     * <input igxDateTimeEditor [value]="date">
     * ```
     */
    set value(value) {
        this._value = value;
        this.onChangeCallback(value);
        this.updateMask();
    }
    get value() {
        return this._value;
    }
    get emptyMask() {
        return this.maskParser.applyMask(null, this.maskOptions);
    }
    get targetDatePart() {
        var _a;
        if (this.document.activeElement === this.nativeElement) {
            return (_a = this._inputDateParts
                .find(p => p.start <= this.selectionStart && this.selectionStart <= p.end && p.type !== DatePart.Literal)) === null || _a === void 0 ? void 0 : _a.type;
        }
        else {
            if (this._inputDateParts.some(p => p.type === DatePart.Date)) {
                return DatePart.Date;
            }
            else if (this._inputDateParts.some(p => p.type === DatePart.Hours)) {
                return DatePart.Hours;
            }
        }
    }
    get hasDateParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Date
            || p.type === DatePart.Month
            || p.type === DatePart.Year);
    }
    get hasTimeParts() {
        return this._inputDateParts.some(p => p.type === DatePart.Hours
            || p.type === DatePart.Minutes
            || p.type === DatePart.Seconds);
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['inputFormat'] || changes['locale']) {
            const defPlaceholder = this.inputFormat || DatePickerUtil.getDefaultInputFormat(this.locale);
            this._inputDateParts = DatePickerUtil.parseDateTimeFormat(this.inputFormat);
            this.inputFormat = this._inputDateParts.map(p => p.format).join('');
            if (!this.nativeElement.placeholder) {
                this.renderer.setAttribute(this.nativeElement, 'placeholder', defPlaceholder);
            }
            // TODO: fill in partial dates?
            this.updateMask();
        }
    }
    /** Clear the input element value. */
    clear() {
        this.updateValue(null);
    }
    /**
     * Increment specified DatePart.
     * @param datePart The optional DatePart to increment. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    increment(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, 1)
            : this.spinValue(targetDatePart, 1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /**
     * Decrement specified DatePart.
     *
     * @param datePart The optional DatePart to decrement. Defaults to Date or Hours(when Date is absent from the inputFormat - ex:'HH:mm').
     */
    decrement(datePart) {
        const targetDatePart = this.targetDatePart;
        if (!targetDatePart) {
            return;
        }
        const newValue = datePart
            ? this.spinValue(datePart, -1)
            : this.spinValue(targetDatePart, -1);
        this.updateValue(newValue ? newValue : new Date());
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.updateMask();
    }
    /** @hidden @internal */
    validate(control) {
        if (!this.inputIsComplete() || !control.value) {
            return { 'value': true };
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(control.value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { 'minValue': true };
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(control.value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return { 'maxValue': true };
        }
        return null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) { this.onValidatorChange = fn; }
    /** @hidden @internal */
    registerOnChange(fn) { this.onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this.onTouchCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { }
    /** @hidden @internal */
    onInputChanged() {
        var _a;
        super.onInputChanged();
        if (this.inputIsComplete()) {
            const parsedDate = this.parseDate(this.inputValue);
            if (this.isValidDate(parsedDate)) {
                this.updateValue(parsedDate);
            }
            else {
                const oldValue = this.value && new Date(this.value.getTime());
                const args = { oldValue: oldValue, newValue: parsedDate, userInput: this.inputValue };
                this.validationFailed.emit(args);
                if (((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.getTime) && args.newValue.getTime() !== oldValue.getTime()) {
                    this.updateValue(args.newValue);
                }
                else {
                    this.updateValue(null);
                }
            }
        }
        else {
            this.updateValue(null);
        }
    }
    /** @hidden @internal */
    onKeyDown(event) {
        super.onKeyDown(event);
        if (event.altKey) {
            return;
        }
        if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
            event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
            this.spin(event);
            return;
        }
        if (event.ctrlKey && event.key === ";" /* SEMICOLON */) {
            this.updateValue(new Date());
        }
        this.moveCursor(event);
    }
    /** @hidden @internal */
    onFocus() {
        this._isFocused = true;
        this.onTouchCallback();
        this.updateMask();
        super.onFocus();
    }
    /** @hidden @internal */
    onBlur(value) {
        this._isFocused = false;
        if (!this.inputIsComplete() && this.inputValue !== this.emptyMask) {
            this.updateValue(this.parseDate(this.inputValue));
        }
        else {
            this.updateMask();
        }
        super.onBlur(value);
    }
    /** @hidden @internal */
    updateMask() {
        if (this._isFocused) {
            if (!this.value) {
                return;
            }
            // store the cursor position as it will be moved during masking
            const cursor = this.selectionEnd;
            this.inputValue = this.getMaskedValue();
            this.setSelectionRange(cursor);
        }
        else {
            if (!this.value || !this.isValidDate(this.value)) {
                this.inputValue = '';
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (format) {
                this.inputValue = formatDate(this.value, format.replace('tt', 'aa'), this.locale);
            }
            else {
                // TODO: formatter function?
                this.inputValue = this.value.toLocaleString();
            }
        }
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        for (const part of this._inputDateParts) {
            if (part.type === DatePart.Literal) {
                continue;
            }
            const targetValue = this.getPartValue(part, part.format.length);
            mask = this.maskParser.replaceInMask(mask, targetValue, this.maskOptions, part.start, part.end).value;
        }
        return mask;
    }
    // TODO: move isDate to utils
    isDate(value) {
        return value instanceof Date && typeof value === 'object';
    }
    valueInRange(value) {
        if (!value) {
            return false;
        }
        const maxValueAsDate = this.isDate(this.maxValue) ? this.maxValue : this.parseDate(this.maxValue);
        const minValueAsDate = this.isDate(this.minValue) ? this.minValue : this.parseDate(this.minValue);
        if (minValueAsDate
            && DatePickerUtil.lessThanMinValue(value, minValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        if (maxValueAsDate
            && DatePickerUtil.greaterThanMaxValue(value, maxValueAsDate, this.hasTimeParts, this.hasDateParts)) {
            return false;
        }
        return true;
    }
    spinValue(datePart, delta) {
        if (!this.value || !this.isValidDate(this.value)) {
            return null;
        }
        const newDate = new Date(this.value.getTime());
        switch (datePart) {
            case DatePart.Date:
                DatePickerUtil.spinDate(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Month:
                DatePickerUtil.spinMonth(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Year:
                DatePickerUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DatePickerUtil.spinHours(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Minutes:
                DatePickerUtil.spinMinutes(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.Seconds:
                DatePickerUtil.spinSeconds(delta, newDate, this.isSpinLoop);
                break;
            case DatePart.AmPm:
                const formatPart = this._inputDateParts.find(dp => dp.type === DatePart.AmPm);
                const amPmFromMask = this.inputValue.substring(formatPart.start, formatPart.end);
                return DatePickerUtil.spinAmPm(newDate, this.value, amPmFromMask);
        }
        return newDate;
    }
    updateValue(newDate) {
        this._oldValue = this.value;
        this.value = newDate;
        if (this.value && !this.valueInRange(this.value)) {
            this.validationFailed.emit({ oldValue: this._oldValue, newValue: this.value, userInput: this.inputValue });
        }
        if (this.inputIsComplete() || this.inputValue === this.emptyMask) {
            this.valueChange.emit(this.value);
        }
    }
    toTwelveHourFormat(value) {
        let hour = parseInt(value.replace(new RegExp(this.promptChar, 'g'), '0'), 10);
        if (hour > 12) {
            hour -= 12;
        }
        else if (hour === 0) {
            hour = 12;
        }
        return hour;
    }
    getPartValue(datePartInfo, partLength) {
        let maskedValue;
        const datePart = datePartInfo.type;
        switch (datePart) {
            case DatePart.Date:
                maskedValue = this.value.getDate();
                break;
            case DatePart.Month:
                // months are zero based
                maskedValue = this.value.getMonth() + 1;
                break;
            case DatePart.Year:
                if (partLength === 2) {
                    maskedValue = this.prependValue(parseInt(this.value.getFullYear().toString().slice(-2), 10), partLength, '0');
                }
                else {
                    maskedValue = this.value.getFullYear();
                }
                break;
            case DatePart.Hours:
                if (datePartInfo.format.indexOf('h') !== -1) {
                    maskedValue = this.prependValue(this.toTwelveHourFormat(this.value.getHours().toString()), partLength, '0');
                }
                else {
                    maskedValue = this.value.getHours();
                }
                break;
            case DatePart.Minutes:
                maskedValue = this.value.getMinutes();
                break;
            case DatePart.Seconds:
                maskedValue = this.value.getSeconds();
                break;
            case DatePart.AmPm:
                maskedValue = this.value.getHours() >= 12 ? 'PM' : 'AM';
                break;
        }
        if (datePartInfo.type !== DatePart.AmPm) {
            return this.prependValue(maskedValue, partLength, '0');
        }
        return maskedValue;
    }
    prependValue(value, partLength, prependChar) {
        return (prependChar + value.toString()).slice(-partLength);
    }
    spin(event) {
        event.preventDefault();
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                this.increment();
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                this.decrement();
                break;
        }
    }
    inputIsComplete() {
        return this.inputValue.indexOf(this.promptChar) === -1;
    }
    isValidDate(date) {
        return date && date.getTime && !isNaN(date.getTime());
    }
    // TODO: move parseDate to utils
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DatePickerUtil.parseValueFromMask(val, this._inputDateParts, this.promptChar);
    }
    moveCursor(event) {
        const value = event.target.value;
        switch (event.key) {
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value));
                }
                break;
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                if (event.ctrlKey) {
                    event.preventDefault();
                    this.setSelectionRange(this.getNewPosition(value, 1));
                }
                break;
        }
    }
    /**
     * Move the cursor in a specific direction until it reaches a date/time separator.
     * Then return its index.
     *
     * @param value The string it operates on.
     * @param direction 0 is left, 1 is right. Default is 0.
     */
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter(p => p.type === DatePart.Literal);
        let cursorPos = this.selectionStart;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some(l => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some(l => l.start === cursorPos) && cursorPos < value.length);
            return cursorPos;
        }
    }
};
IgxDateTimeEditorDirective.ɵfac = function IgxDateTimeEditorDirective_Factory(t) { return new (t || IgxDateTimeEditorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MaskParsingService), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxDateTimeEditorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDateTimeEditorDirective, selectors: [["", "igxDateTimeEditor", ""]], inputs: { isSpinLoop: "isSpinLoop", locale: "locale", minValue: "minValue", maxValue: "maxValue", inputFormat: ["igxDateTimeEditor", "inputFormat"], value: "value", displayFormat: "displayFormat" }, outputs: { valueChange: "valueChange", validationFailed: "validationFailed" }, exportAs: ["igxDateTimeEditor"], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective_1, multi: true },
            { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective_1, multi: true }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature] });
IgxDateTimeEditorDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: MaskParsingService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "locale", void 0);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "minValue", null);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "maxValue", null);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "isSpinLoop", void 0);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "displayFormat", void 0);
__decorate([
    Input(`igxDateTimeEditor`)
], IgxDateTimeEditorDirective.prototype, "inputFormat", null);
__decorate([
    Input()
], IgxDateTimeEditorDirective.prototype, "value", null);
__decorate([
    Output()
], IgxDateTimeEditorDirective.prototype, "valueChange", void 0);
__decorate([
    Output()
], IgxDateTimeEditorDirective.prototype, "validationFailed", void 0);
IgxDateTimeEditorDirective = IgxDateTimeEditorDirective_1 = __decorate([ __param(3, Inject(DOCUMENT)),
    __param(4, Inject(LOCALE_ID))
], IgxDateTimeEditorDirective);
let IgxDateTimeEditorModule = class IgxDateTimeEditorModule {
};
IgxDateTimeEditorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDateTimeEditorModule });
IgxDateTimeEditorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDateTimeEditorModule_Factory(t) { return new (t || IgxDateTimeEditorModule)(); } });

/**
 * Provides base filtering operations
 * Implementations should be Singleton
 *
 * @export
 */
class IgxFilteringOperand {
    constructor() {
        this.operations = [{
                name: 'null',
                isUnary: true,
                iconName: 'is_null',
                logic: (target) => {
                    return target === null;
                }
            }, {
                name: 'notNull',
                isUnary: true,
                iconName: 'is_not_null',
                logic: (target) => {
                    return target !== null;
                }
            }, {
                name: 'in',
                isUnary: false,
                iconName: 'is_in',
                hidden: true,
                logic: (target, searchVal) => {
                    return this.findValueInSet(target, searchVal);
                }
            }];
    }
    static instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * @hidden
     */
    findValueInSet(target, searchVal) {
        return searchVal.has(target);
    }
    /**
     * Returns an array of names of the conditions which are visible in the UI
     */
    conditionList() {
        return this.operations.filter(f => !f.hidden).map((element) => element.name);
    }
    /**
     * Returns an instance of the condition with the specified name.
     * @param name The name of the condition.
     */
    condition(name) {
        return this.operations.find((element) => element.name === name);
    }
    /**
     * Adds a new condition to the filtering operations.
     * @param operation The filtering operation.
     */
    append(operation) {
        this.operations.push(operation);
    }
}
IgxFilteringOperand._instance = null;
/**
 * Provides filtering operations for booleans
 *
 * @export
 */
class IgxBooleanFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'all',
                isUnary: true,
                iconName: 'all',
                logic: (target) => {
                    return true;
                }
            }, {
                name: 'true',
                isUnary: true,
                iconName: 'is_true',
                logic: (target) => {
                    return !!(target && target !== null && target !== undefined);
                }
            }, {
                name: 'false',
                isUnary: true,
                iconName: 'is_false',
                logic: (target) => {
                    return !target && target !== null && target !== undefined;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined;
                }
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for Dates
 *
 * @export
 */
class IgxDateFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year === searchp.year &&
                        targetp.month === searchp.month &&
                        targetp.day === searchp.day;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: (target, searchVal) => {
                    if (!target) {
                        return true;
                    }
                    this.validateInputData(target);
                    const targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year !== searchp.year ||
                        targetp.month !== searchp.month ||
                        targetp.day !== searchp.day;
                }
            }, {
                name: 'before',
                isUnary: false,
                iconName: 'is_before',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target < searchVal;
                }
            }, {
                name: 'after',
                isUnary: false,
                iconName: 'is_after',
                logic: (target, searchVal) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    return target > searchVal;
                }
            }, {
                name: 'today',
                isUnary: true,
                iconName: 'today',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                    return d.year === now.year &&
                        d.month === now.month &&
                        d.day === now.day;
                }
            }, {
                name: 'yesterday',
                isUnary: true,
                iconName: 'yesterday',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    const y = ((d) => new Date(d.setDate(d.getDate() - 1)))(new Date());
                    const yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                    return td.year === yesterday.year &&
                        td.month === yesterday.month &&
                        td.day === yesterday.day;
                }
            }, {
                name: 'thisMonth',
                isUnary: true,
                iconName: 'this_month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'lastMonth',
                isUnary: true,
                iconName: 'last_month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (!now.month) {
                        now.month = 11;
                        now.year -= 1;
                    }
                    else {
                        now.month--;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'nextMonth',
                isUnary: true,
                iconName: 'next_month',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (now.month === 11) {
                        now.month = 0;
                        now.year += 1;
                    }
                    else {
                        now.month++;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'thisYear',
                isUnary: true,
                iconName: 'this_year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year;
                }
            }, {
                name: 'lastYear',
                isUnary: true,
                iconName: 'last_year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year - 1;
                }
            }, {
                name: 'nextYear',
                isUnary: true,
                iconName: 'next_year',
                logic: (target) => {
                    if (!target) {
                        return false;
                    }
                    this.validateInputData(target);
                    const d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    const now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year + 1;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined;
                }
            }].concat(this.operations);
    }
    /**
     * Splits a Date object into parts
     *
     * @memberof IgxDateFilteringOperand
     */
    static getDateParts(date, dateFormat) {
        const res = {
            day: null,
            hours: null,
            milliseconds: null,
            minutes: null,
            month: null,
            seconds: null,
            year: null
        };
        if (!date || !dateFormat) {
            return res;
        }
        if (dateFormat.indexOf('y') >= 0) {
            res.year = date.getFullYear();
        }
        if (dateFormat.indexOf('M') >= 0) {
            res.month = date.getMonth();
        }
        if (dateFormat.indexOf('d') >= 0) {
            res.day = date.getDate();
        }
        if (dateFormat.indexOf('h') >= 0) {
            res.hours = date.getHours();
        }
        if (dateFormat.indexOf('m') >= 0) {
            res.minutes = date.getMinutes();
        }
        if (dateFormat.indexOf('s') >= 0) {
            res.seconds = date.getSeconds();
        }
        if (dateFormat.indexOf('f') >= 0) {
            res.milliseconds = date.getMilliseconds();
        }
        return res;
    }
    validateInputData(target) {
        if (!(target instanceof Date)) {
            throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
        }
    }
    findValueInSet(target, searchVal) {
        if (!target) {
            return false;
        }
        return searchVal.has(new Date(target.getFullYear(), target.getMonth(), target.getDate()).toISOString());
    }
}
/**
 * Provides filtering operations for numbers
 *
 * @export
 */
class IgxNumberFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal) => {
                    return target === searchVal;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: (target, searchVal) => {
                    return target !== searchVal;
                }
            }, {
                name: 'greaterThan',
                isUnary: false,
                iconName: 'greater_than',
                logic: (target, searchVal) => {
                    return target > searchVal;
                }
            }, {
                name: 'lessThan',
                isUnary: false,
                iconName: 'less_than',
                logic: (target, searchVal) => {
                    return target < searchVal;
                }
            }, {
                name: 'greaterThanOrEqualTo',
                isUnary: false,
                iconName: 'greater_than_or_equal',
                logic: (target, searchVal) => {
                    return target >= searchVal;
                }
            }, {
                name: 'lessThanOrEqualTo',
                isUnary: false,
                iconName: 'less_than_or_equal',
                logic: (target, searchVal) => {
                    return target <= searchVal;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined || isNaN(target);
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined && !isNaN(target);
                }
            }].concat(this.operations);
    }
}
/**
 * Provides filtering operations for strings
 *
 * @export
 */
class IgxStringFilteringOperand extends IgxFilteringOperand {
    constructor() {
        super();
        this.operations = [{
                name: 'contains',
                isUnary: false,
                iconName: 'contains',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) !== -1;
                }
            }, {
                name: 'doesNotContain',
                isUnary: false,
                iconName: 'does_not_contain',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) === -1;
                }
            }, {
                name: 'startsWith',
                isUnary: false,
                iconName: 'starts_with',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.startsWith(search);
                }
            }, {
                name: 'endsWith',
                isUnary: false,
                iconName: 'ends_with',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.endsWith(search);
                }
            }, {
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target === search;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: (target, searchVal, ignoreCase) => {
                    const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target !== search;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: (target) => {
                    return target === null || target === undefined || target.length === 0;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: (target) => {
                    return target !== null && target !== undefined && target.length > 0;
                }
            }].concat(this.operations);
    }
    /**
     * Applies case sensitivity on strings if provided
     *
     * @memberof IgxStringFilteringOperand
     */
    static applyIgnoreCase(a, ignoreCase) {
        a = a || '';
        // bulletproof
        return ignoreCase ? ('' + a).toLowerCase() : a;
    }
}

const filteringStateDefaults = {
    strategy: new FilteringStrategy()
};

/**
 * @hidden
 */
class GroupedRecords extends Array {
}

let IgxActionStripMenuItemDirective = class IgxActionStripMenuItemDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
IgxActionStripMenuItemDirective.ɵfac = function IgxActionStripMenuItemDirective_Factory(t) { return new (t || IgxActionStripMenuItemDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxActionStripMenuItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxActionStripMenuItemDirective, selectors: [["", "igxActionStripMenuItem", ""]] });
IgxActionStripMenuItemDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * Action Strip provides templatable area for one or more actions.
 *
 * @igxModule IgxActionStripModule
 *
 * @igxTheme igx-action-strip-theme
 *
 * @igxKeywords action, strip, actionStrip, pinning, editing
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Action Strip is a container, overlaying its parent container,
 * and displaying action buttons with action applicable to the parent component the strip is instantiated or shown for.
 *
 * @example
 * ```html
 * <igx-action-strip #actionStrip>
 *     <igx-icon (click)="doSomeAction()"></igx-icon>
 * </igx-action-strip>
 */
let IgxActionStripComponent = class IgxActionStripComponent extends DisplayDensityBase {
    constructor(_viewContainer, renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._viewContainer = _viewContainer;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        this._hidden = false;
    }
    /**
     * Getter for the 'display' property of the current `IgxActionStrip`
     * @hidden
     * @internal
     */
    get display() {
        return this._hidden ? 'none' : 'flex';
    }
    /**
     * An @Input property that set the visibility of the Action Strip.
     * Could be used to set if the Action Strip will be initially hidden.
     * @example
     * ```html
     *  <igx-action-strip [hidden]="false">
     * ```
     */
    set hidden(value) {
        this._hidden = value;
    }
    get hidden() {
        return this._hidden;
    }
    /**
     * Host `attr.class` binding.
     * @hidden
     * @internal
     */
    get hostClasses() {
        const classes = [this.getComponentDensityClass('igx-action-strip')];
        // The custom classes should be at the end.
        if (!classes.includes('igx-action-strip')) {
            classes.push('igx-action-strip');
        }
        classes.push(this.hostClass);
        return classes.join(' ');
    }
    /**
     * Showing the Action Strip and appending it the specified context element.
     * @param context
     * @example
     * ```typescript
     * this.actionStrip.show(row);
     * ```
     */
    show(context) {
        this.hidden = false;
        if (!context) {
            return;
        }
        // when shown for different context make sure the menu won't stay opened
        if (this.context !== context) {
            this.closeMenu();
        }
        this.context = context;
        if (this.context && this.context.element) {
            this.renderer.appendChild(context.element.nativeElement, this._viewContainer.element.nativeElement);
        }
    }
    /**
     * Hiding the Action Strip and removing it from its current context element.
     * @example
     * ```typescript
     * this.actionStrip.hide();
     * ```
     */
    hide() {
        this.hidden = true;
        this.closeMenu();
        if (this.context && this.context.element) {
            this.renderer.removeChild(this.context.element.nativeElement, this._viewContainer.element.nativeElement);
        }
    }
    /**
     * Getter for menu overlay settings
     * @hidden
     * @internal
     */
    get menuOverlaySettings() {
        return { scrollStrategy: new CloseScrollStrategy() };
    }
    /**
     * Close the menu if opened
     * @hidden
     * @internal
     */
    closeMenu() {
        if (this.menu && !this.menu.collapsed) {
            this.menu.close();
        }
    }
};
IgxActionStripComponent.ɵfac = function IgxActionStripComponent_Factory(t) { return new (t || IgxActionStripComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxActionStripComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxActionStripComponent, selectors: [["igx-action-strip"]], contentQueries: function IgxActionStripComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxActionStripMenuItemDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menuItems = _t);
    } }, viewQuery: function IgxActionStripComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c12, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.menu = _t.first);
    } }, hostVars: 3, hostBindings: function IgxActionStripComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.hostClasses);
        ɵngcc0.ɵɵstyleProp("display", ctx.display);
    } }, inputs: { hidden: "hidden", context: "context", hostClass: ["class", "hostClass"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 3, vars: 1, consts: [[1, "igx-action-strip__actions"], [4, "ngIf"], ["igxButton", "icon", "igxRipple", "", 3, "igxToggleAction", "overlaySettings", "igxDropDownItemNavigation", "click"], ["dropdown", ""], [4, "ngFor", "ngForOf"], [1, "igx-drop-down__item-template"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function IgxActionStripComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1, 0, ["#content", ""]);
        ɵngcc0.ɵɵtemplate(2, IgxActionStripComponent_ng_container_2_Template, 7, 4, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItems.length > 0);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxButtonDirective,
        IgxRippleDirective,
        IgxToggleActionDirective,
        IgxDropDownItemNavigationDirective,
        IgxIconComponent,
        IgxDropDownComponent, ɵngcc2.NgForOf, IgxDropDownItemComponent, ɵngcc2.NgTemplateOutlet]; }, encapsulation: 2 });
IgxActionStripComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    HostBinding('style.display')
], IgxActionStripComponent.prototype, "display", null);
__decorate([
    Input()
], IgxActionStripComponent.prototype, "hidden", null);
__decorate([
    Input('class')
], IgxActionStripComponent.prototype, "hostClass", void 0);
__decorate([
    HostBinding('attr.class')
], IgxActionStripComponent.prototype, "hostClasses", null);
__decorate([
    Input()
], IgxActionStripComponent.prototype, "context", void 0);
__decorate([
    ContentChildren(IgxActionStripMenuItemDirective)
], IgxActionStripComponent.prototype, "menuItems", void 0);
__decorate([
    ViewChild('dropdown')
], IgxActionStripComponent.prototype, "menu", void 0);
IgxActionStripComponent = __decorate([ __param(2, Optional()), __param(2, Inject(DisplayDensityToken))
], IgxActionStripComponent);

// TODO: Refactor - export in a separate file
class IgxRow {
    constructor(id, index, data) {
        this.id = id;
        this.index = index;
        this.data = data;
    }
    createEditEventArgs() {
        return {
            rowID: this.id,
            oldValue: Object.assign({}, this.data),
            newValue: this.newData,
            cancel: false
        };
    }
}
class IgxCell {
    constructor(id, rowIndex, column, value, editValue, rowData) {
        this.id = id;
        this.rowIndex = rowIndex;
        this.column = column;
        this.value = value;
        this.editValue = editValue;
        this.rowData = rowData;
    }
    castToNumber(value) {
        if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
            const v = parseFloat(value);
            return !isNaN(v) && isFinite(v) ? v : 0;
        }
        return value;
    }
    createEditEventArgs() {
        return {
            rowID: this.id.rowID,
            cellID: this.id,
            oldValue: this.value,
            newValue: this.editValue,
            cancel: false
        };
    }
}
let IgxGridCRUDService = class IgxGridCRUDService {
    constructor() {
        this.cell = null;
        this.row = null;
        this.isInCompositionMode = false;
    }
    createCell(cell) {
        return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData);
    }
    createRow(cell) {
        return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData);
    }
    sameRow(rowID) {
        return this.row && this.row.id === rowID;
    }
    sameCell(cell) {
        return (this.cell.id.rowID === cell.id.rowID &&
            this.cell.id.columnID === cell.id.columnID);
    }
    get inEditMode() {
        return !!this.cell;
    }
    get rowEditing() {
        return this.grid.rowEditable;
    }
    get primaryKey() {
        return this.grid.primaryKey;
    }
    beginRowEdit() {
        if (this.grid.rowEditable && (this.grid.primaryKey === undefined || this.grid.primaryKey === null)) {
            console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
        }
        this.row = this.createRow(this.cell);
        const args = {
            rowID: this.row.id,
            oldValue: this.row.data,
            cancel: false
        };
        this.grid.onRowEditEnter.emit(args);
        if (args.cancel) {
            this.endRowEdit();
            return;
        }
        this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
        this.grid.transactions.startPending();
        this.grid.openRowOverlay(this.row.id);
    }
    endRowEdit() {
        this.row = null;
    }
    begin(cell) {
        const newCell = this.createCell(cell);
        newCell.primaryKey = this.primaryKey;
        const args = {
            cellID: newCell.id,
            rowID: newCell.id.rowID,
            oldValue: newCell.value,
            cancel: false
        };
        this.grid.onCellEditEnter.emit(args);
        if (args.cancel) {
            this.end();
            return;
        }
        if (this.rowEditing) {
            if (this.row && !this.sameRow(newCell.id.rowID)) {
                this.grid.endEdit(true);
                this.cell = newCell;
                this.beginRowEdit();
                return;
            }
            this.cell = newCell;
            if (!this.row) {
                this.beginRowEdit();
                return;
            }
        }
        else {
            this.cell = newCell;
            this.endRowEdit();
        }
    }
    end() {
        this.cell = null;
    }
    enterEditMode(cell) {
        if (this.isInCompositionMode) {
            return;
        }
        if (cell && cell.column.editable && !cell.row.deleted) {
            if (this.inEditMode) {
                this.grid.endEdit(true);
                this.grid.tbody.nativeElement.focus();
            }
            else {
                this.begin(cell);
            }
        }
    }
    exitEditMode() {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.inEditMode) {
            const args = this.cell.createEditEventArgs();
            this.grid.onCellEditCancel.emit(args);
            if (args.cancel) {
                return;
            }
            this.grid.endEdit(false);
            if (isEdge()) {
                this.grid.cdr.detectChanges();
            }
            this.grid.tbody.nativeElement.focus();
        }
    }
    isInEditMode(rowIndex, columnIndex) {
        if (!this.cell) {
            return false;
        }
        return this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
    }
};
IgxGridCRUDService.ɵfac = function IgxGridCRUDService_Factory(t) { return new (t || IgxGridCRUDService)(); };
IgxGridCRUDService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridCRUDService, factory: IgxGridCRUDService.ɵfac });
let IgxGridSelectionService = class IgxGridSelectionService {
    constructor(zone) {
        this.zone = zone;
        this.dragMode = false;
        this.keyboardState = {};
        this.pointerState = {};
        this.columnsState = {};
        this.selection = new Map();
        this.temp = new Map();
        this._ranges = new Set();
        this.rowSelection = new Set();
        this.columnSelection = new Set();
        this.initPointerState();
        this.initKeyboardState();
        this.initColumnsState();
    }
    /**
     * Returns the current selected ranges in the grid from both
     * keyboard and pointer interactions
     */
    get ranges() {
        // The last action was keyboard + shift selection -> add it
        this.addKeyboardRange();
        const ranges = Array.from(this._ranges).map(range => JSON.parse(range));
        // No ranges but we have a focused cell -> add it
        if (!ranges.length && this.activeElement && this.grid.isCellSelectable) {
            ranges.push(this.generateRange(this.activeElement));
        }
        return ranges;
    }
    get primaryButton() {
        return this.pointerState.primaryButton;
    }
    set primaryButton(value) {
        this.pointerState.primaryButton = value;
    }
    /**
     * Resets the keyboard state
     */
    initKeyboardState() {
        this.keyboardState.node = null;
        this.keyboardState.shift = false;
        this.keyboardState.range = null;
        this.keyboardState.active = false;
    }
    /**
     * Resets the pointer state
     */
    initPointerState() {
        this.pointerState.node = null;
        this.pointerState.ctrl = false;
        this.pointerState.shift = false;
        this.pointerState.range = null;
        this.pointerState.primaryButton = true;
    }
    /**
     * Resets the columns state
     */
    initColumnsState() {
        this.columnsState.field = null;
        this.columnsState.range = [];
    }
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     */
    add(node, addToRange = true) {
        this.selection.has(node.row) ? this.selection.get(node.row).add(node.column) :
            this.selection.set(node.row, new Set()).get(node.row).add(node.column);
        if (addToRange) {
            this._ranges.add(JSON.stringify(this.generateRange(node)));
        }
    }
    /**
     * Adds the active keyboard range selection (if any) to the `ranges` meta.
     */
    addKeyboardRange() {
        if (this.keyboardState.range) {
            this._ranges.add(JSON.stringify(this.keyboardState.range));
        }
    }
    remove(node) {
        if (this.selection.has(node.row)) {
            this.selection.get(node.row).delete(node.column);
        }
        if (this.isActiveNode(node)) {
            this.activeElement = null;
        }
        this._ranges.delete(JSON.stringify(this.generateRange(node)));
    }
    isInMap(node) {
        return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
            (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
    }
    selected(node) {
        return (this.isActiveNode(node) && this.grid.isCellSelectable) || this.isInMap(node);
    }
    isActiveNode(node) {
        if (this.activeElement) {
            const isActive = this.activeElement.column === node.column && this.activeElement.row === node.row;
            if (this.grid.hasColumnLayouts) {
                const layout = this.activeElement.layout;
                return isActive && this.isActiveLayout(layout, node.layout);
            }
            return isActive;
        }
        return false;
    }
    isActiveLayout(current, target) {
        return current.columnVisibleIndex === target.columnVisibleIndex;
    }
    addRangeMeta(node, state) {
        this._ranges.add(JSON.stringify(this.generateRange(node, state)));
    }
    removeRangeMeta(node, state) {
        this._ranges.delete(JSON.stringify(this.generateRange(node, state)));
    }
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     */
    generateRange(node, state) {
        if (!state) {
            return {
                rowStart: node.row,
                rowEnd: node.row,
                columnStart: node.column,
                columnEnd: node.column
            };
        }
        const { row, column } = state.node;
        const rowStart = Math.min(node.row, row);
        const rowEnd = Math.max(node.row, row);
        const columnStart = Math.min(node.column, column);
        const columnEnd = Math.max(node.column, column);
        return { rowStart, rowEnd, columnStart, columnEnd };
    }
    /**
     *
     */
    keyboardStateOnKeydown(node, shift, shiftTab) {
        this.keyboardState.active = true;
        this.initPointerState();
        this.keyboardState.shift = shift && !shiftTab;
        if (!this.grid.navigation.isDataRow(node.row)) {
            return;
        }
        // Kb navigation with shift and no previous node.
        // Clear the current selection init the start node.
        if (this.keyboardState.shift && !this.keyboardState.node) {
            this.clear();
            this.keyboardState.node = Object.assign({}, node);
        }
    }
    keyboardStateOnFocus(node, emitter, dom) {
        const kbState = this.keyboardState;
        // Focus triggered by keyboard navigation
        if (kbState.active) {
            if (isChromium()) {
                this._moveSelectionChrome(dom);
            }
            // Start generating a range if shift is hold
            if (kbState.shift) {
                this.dragSelect(node, kbState);
                kbState.range = this.generateRange(node, kbState);
                emitter.emit(this.generateRange(node, kbState));
                return;
            }
            this.initKeyboardState();
            this.clear();
            this.add(node);
        }
    }
    pointerDown(node, shift, ctrl) {
        this.addKeyboardRange();
        this.initKeyboardState();
        this.pointerState.ctrl = ctrl;
        this.pointerState.shift = shift;
        // No ctrl key pressed - no multiple selection
        if (!ctrl) {
            this.clear();
        }
        if (shift) {
            // No previously 'clicked' node. Use the last active node.
            if (!this.pointerState.node) {
                this.pointerState.node = this.activeElement || node;
            }
            this.pointerDownShiftKey(node);
            this.clearTextSelection();
            return;
        }
        this.removeRangeMeta(node);
        this.pointerState.node = node;
    }
    pointerDownShiftKey(node) {
        this.clear();
        this.selectRange(node, this.pointerState);
    }
    mergeMap(target, source) {
        const iterator = source.entries();
        let pair = iterator.next();
        let key;
        let value;
        while (!pair.done) {
            [key, value] = pair.value;
            if (target.has(key)) {
                const newValue = target.get(key);
                value.forEach(record => newValue.add(record));
                target.set(key, newValue);
            }
            else {
                target.set(key, value);
            }
            pair = iterator.next();
        }
    }
    pointerEnter(node, event) {
        // https://www.w3.org/TR/pointerevents/#the-button-property
        this.dragMode = event.buttons === 1 && event.button === -1;
        if (!this.dragMode) {
            return false;
        }
        this.clearTextSelection();
        // If the users triggers a drag-like event by first clicking outside the grid cells
        // and then enters in the grid body we may not have a initial pointer starting node.
        // Assume the first pointerenter node is where we start.
        if (!this.pointerState.node) {
            this.pointerState.node = node;
        }
        this.pointerState.ctrl ? this.selectRange(node, this.pointerState, this.temp) :
            this.dragSelect(node, this.pointerState);
        return true;
    }
    pointerUp(node, emitter) {
        if (this.dragMode) {
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            this.mergeMap(this.selection, this.temp);
            this.zone.runTask(() => emitter.emit(this.generateRange(node, this.pointerState)));
            this.temp.clear();
            this.dragMode = false;
            return true;
        }
        if (this.pointerState.shift) {
            this.clearTextSelection();
            this.restoreTextSelection();
            this.addRangeMeta(node, this.pointerState);
            emitter.emit(this.generateRange(node, this.pointerState));
            return true;
        }
        this.add(node);
        return false;
    }
    selectRange(node, state, collection = this.selection) {
        if (collection === this.temp) {
            collection.clear();
        }
        const { rowStart, rowEnd, columnStart, columnEnd } = this.generateRange(node, state);
        for (let i = rowStart; i <= rowEnd; i++) {
            for (let j = columnStart; j <= columnEnd; j++) {
                collection.has(i) ? collection.get(i).add(j) :
                    collection.set(i, new Set()).get(i).add(j);
            }
        }
    }
    dragSelect(node, state) {
        if (!this.pointerState.ctrl) {
            this.selection.clear();
        }
        this.selectRange(node, state);
    }
    clear(clearAcriveEl = false) {
        if (clearAcriveEl) {
            this.activeElement = null;
        }
        this.selection.clear();
        this.temp.clear();
        this._ranges.clear();
    }
    clearTextSelection() {
        const selection = window.getSelection();
        if (selection.rangeCount) {
            this._selectionRange = selection.getRangeAt(0);
            this._selectionRange.collapse(true);
            selection.removeAllRanges();
        }
    }
    restoreTextSelection() {
        const selection = window.getSelection();
        if (!selection.rangeCount) {
            selection.addRange(this._selectionRange || document.createRange());
        }
    }
    /**
     * (╯°□°）╯︵ ┻━┻
     * Chrome and Chromium don't care about the active
     * range after keyboard navigation, thus this.
     */
    _moveSelectionChrome(node) {
        const selection = window.getSelection();
        selection.removeAllRanges();
        const range = new Range();
        range.selectNode(node);
        range.collapse(true);
        selection.addRange(range);
    }
    /** Returns array of the selected row id's. */
    getSelectedRows() {
        return this.rowSelection.size ? Array.from(this.rowSelection.keys()) : [];
    }
    /** Clears row selection, if filtering is applied clears only selected rows from filtered data. */
    clearRowSelection(event) {
        const removedRec = this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rID => this.isRowSelected(rID)) : this.getSelectedRows();
        const newSelection = this.isFilteringApplied() ? this.getSelectedRows().filter(x => !removedRec.includes(x)) : [];
        this.emitRowSelectionEvent(newSelection, [], removedRec, event);
    }
    /** Select all rows, if filtering is applied select only from filtered data. */
    selectAllRows(event) {
        const allRowIDs = this.getRowIDs(this.allData);
        const addedRows = allRowIDs.filter((rID) => !this.isRowSelected(rID));
        const newSelection = this.rowSelection.size ? this.getSelectedRows().concat(addedRows) : addedRows;
        this.emitRowSelectionEvent(newSelection, addedRows, [], event);
    }
    /** Select the specified row and emit event. */
    selectRowById(rowID, clearPrevSelection, event) {
        if (!this.grid.isRowSelectable || this.isRowDeleted(rowID)) {
            return;
        }
        clearPrevSelection = !this.grid.isMultiRowSelectionEnabled || clearPrevSelection;
        const newSelection = clearPrevSelection ? [rowID] : this.getSelectedRows().indexOf(rowID) !== -1 ?
            this.getSelectedRows() : [...this.getSelectedRows(), rowID];
        const removed = clearPrevSelection ? this.getSelectedRows() : [];
        this.emitRowSelectionEvent(newSelection, [rowID], removed, event);
    }
    /** Deselect the specified row and emit event. */
    deselectRow(rowID, event) {
        if (!this.isRowSelected(rowID)) {
            return;
        }
        const newSelection = this.getSelectedRows().filter(r => r !== rowID);
        if (this.rowSelection.size && this.rowSelection.has(rowID)) {
            this.emitRowSelectionEvent(newSelection, [], [rowID], event);
        }
    }
    /** Select specified rows. No event is emitted. */
    selectRowsWithNoEvent(rowIDs, clearPrevSelection) {
        if (clearPrevSelection) {
            this.rowSelection.clear();
        }
        rowIDs.forEach(rowID => { this.rowSelection.add(rowID); });
        this.allRowsSelected = undefined;
    }
    /** Deselect specified rows. No event is emitted. */
    deselectRowsWithNoEvent(rowIDs) {
        rowIDs.forEach(rowID => this.rowSelection.delete(rowID));
        this.allRowsSelected = undefined;
    }
    isRowSelected(rowID) {
        return this.rowSelection.size > 0 && this.rowSelection.has(rowID);
    }
    /** Select range from last selected row to the current specified row. */
    selectMultipleRows(rowID, rowData, event) {
        this.allRowsSelected = undefined;
        if (!this.rowSelection.size || this.isRowDeleted(rowID)) {
            this.selectRowById(rowID);
            return;
        }
        const gridData = this.allData;
        const lastRowID = this.getSelectedRows()[this.rowSelection.size - 1];
        const currIndex = gridData.indexOf(this.getRowDataById(lastRowID));
        const newIndex = gridData.indexOf(rowData);
        const rows = gridData.slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1);
        const added = this.getRowIDs(rows).filter(rID => !this.isRowSelected(rID));
        const newSelection = this.getSelectedRows().concat(added);
        this.emitRowSelectionEvent(newSelection, added, [], event);
    }
    areAllRowSelected() {
        if (!this.grid.data) {
            return false;
        }
        if (this.allRowsSelected !== undefined) {
            return this.allRowsSelected;
        }
        const dataItemsID = this.getRowIDs(this.allData);
        return this.allRowsSelected = Math.min(this.rowSelection.size, dataItemsID.length) > 0 &&
            new Set(Array.from(this.rowSelection.values()).concat(dataItemsID)).size === this.rowSelection.size;
    }
    hasSomeRowSelected() {
        const filteredData = this.isFilteringApplied() ?
            this.getRowIDs(this.grid.filteredData).some(rID => this.isRowSelected(rID)) : true;
        return this.rowSelection.size > 0 && filteredData && !this.areAllRowSelected();
    }
    get filteredSelectedRowIds() {
        return this.isFilteringApplied() ?
            this.getRowIDs(this.allData).filter(rowID => this.isRowSelected(rowID)) :
            this.getSelectedRows().filter(rowID => !this.isRowDeleted(rowID));
    }
    emitRowSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedRows();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection: newSelection,
            added: added, removed: removed, event: event, cancel: false
        };
        this.grid.onRowSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectRowsWithNoEvent(args.newSelection, true);
    }
    getRowDataById(rowID) {
        if (!this.grid.primaryKey) {
            return rowID;
        }
        const rowIndex = this.getRowIDs(this.grid.gridAPI.get_all_data(true)).indexOf(rowID);
        return rowIndex < 0 ? {} : this.grid.gridAPI.get_all_data(true)[rowIndex];
    }
    getRowIDs(data) {
        return this.grid.primaryKey && data.length ? data.map(rec => rec[this.grid.primaryKey]) : data;
    }
    clearHeaderCBState() {
        this.allRowsSelected = undefined;
    }
    /** Clear rowSelection and update checkbox state */
    clearAllSelectedRows() {
        this.rowSelection.clear();
        this.clearHeaderCBState();
    }
    /** Returns all data in the grid, with applied filtering and sorting and without deleted rows. */
    get allData() {
        const allData = this.isFilteringApplied() || this.grid.sortingExpressions.length ?
            this.grid.filteredSortedData : this.grid.gridAPI.get_all_data(true);
        return allData.filter(rData => !this.isRowDeleted(this.grid.gridAPI.get_row_id(rData)));
    }
    areEqualCollections(first, second) {
        return first.length === second.length && new Set(first.concat(second)).size === first.length;
    }
    isFilteringApplied() {
        const grid = this.grid;
        return !FilteringExpressionsTree.empty(grid.filteringExpressionsTree) ||
            !FilteringExpressionsTree.empty(grid.advancedFilteringExpressionsTree);
    }
    isRowDeleted(rowID) {
        return this.grid.gridAPI.row_deleted_transaction(rowID);
    }
    /** Returns array of the selected columns fields. */
    getSelectedColumns() {
        return this.columnSelection.size ? Array.from(this.columnSelection.keys()) : [];
    }
    isColumnSelected(field) {
        return this.columnSelection.size > 0 && this.columnSelection.has(field);
    }
    /** Select the specified column and emit event. */
    selectColumn(field, clearPrevSelection, selectColumnsRange, event) {
        const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
        if (!event || !stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
            this.columnsState.field = field;
            this.columnsState.range = [];
            const newSelection = clearPrevSelection ? [field] : this.getSelectedColumns().indexOf(field) !== -1 ?
                this.getSelectedColumns() : [...this.getSelectedColumns(), field];
            const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => colField !== field) : [];
            const added = this.isColumnSelected(field) ? [] : [field];
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        }
        else if (selectColumnsRange) {
            this.selectColumnsRange(field, event);
        }
    }
    /** Select specified columns. And emit event. */
    selectColumns(fields, clearPrevSelection, selectColumnsRange, event) {
        const columns = fields.map(f => this.grid.getColumnByName(f)).sort((a, b) => a.visibleIndex - b.visibleIndex);
        const stateColumn = this.columnsState.field ? this.grid.getColumnByName(this.columnsState.field) : null;
        if (!stateColumn || stateColumn.visibleIndex < 0 || !selectColumnsRange) {
            this.columnsState.field = columns[0] ? columns[0].field : null;
            this.columnsState.range = [];
            const added = fields.filter(colField => !this.isColumnSelected(colField));
            const removed = clearPrevSelection ? this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1) : [];
            const newSelection = clearPrevSelection ? fields : this.getSelectedColumns().concat(added);
            this.emitColumnSelectionEvent(newSelection, added, removed, event);
        }
        else {
            const filedStart = stateColumn.visibleIndex >
                columns[columns.length - 1].visibleIndex ? columns[0].field : columns[columns.length - 1].field;
            this.selectColumnsRange(filedStart, event);
        }
    }
    /** Select range from last clicked column to the current specified column. */
    selectColumnsRange(field, event) {
        const currIndex = this.grid.getColumnByName(this.columnsState.field).visibleIndex;
        const newIndex = this.grid.columnToVisibleIndex(field);
        const columnsFields = this.grid.visibleColumns
            .filter(c => !c.columnGroup)
            .sort((a, b) => a.visibleIndex - b.visibleIndex)
            .slice(Math.min(currIndex, newIndex), Math.max(currIndex, newIndex) + 1)
            .filter(col => col.selectable).map(col => col.field);
        const removed = [];
        const oldAdded = [];
        const added = columnsFields.filter(colField => !this.isColumnSelected(colField));
        this.columnsState.range.forEach(f => {
            if (columnsFields.indexOf(f) === -1) {
                removed.push(f);
            }
            else {
                oldAdded.push(f);
            }
        });
        this.columnsState.range = columnsFields.filter(colField => !this.isColumnSelected(colField) || oldAdded.indexOf(colField) > -1);
        const newSelection = this.getSelectedColumns().concat(added).filter(c => removed.indexOf(c) === -1);
        this.emitColumnSelectionEvent(newSelection, added, removed, event);
    }
    /** Select specified columns. No event is emitted. */
    selectColumnsWithNoEvent(fields, clearPrevSelection) {
        if (clearPrevSelection) {
            this.columnSelection.clear();
        }
        fields.forEach(field => { this.columnSelection.add(field); });
    }
    /** Deselect the specified column and emit event. */
    deselectColumn(field, event) {
        this.initColumnsState();
        const newSelection = this.getSelectedColumns().filter(c => c !== field);
        this.emitColumnSelectionEvent(newSelection, [], [field], event);
    }
    /** Deselect specified columns. No event is emitted. */
    deselectColumnsWithNoEvent(fields) {
        fields.forEach(field => this.columnSelection.delete(field));
    }
    /** Deselect specified columns. And emit event. */
    deselectColumns(fields, event) {
        const removed = this.getSelectedColumns().filter(colField => fields.indexOf(colField) > -1);
        const newSelection = this.getSelectedColumns().filter(colField => fields.indexOf(colField) === -1);
        this.emitColumnSelectionEvent(newSelection, [], removed, event);
    }
    emitColumnSelectionEvent(newSelection, added, removed, event) {
        const currSelection = this.getSelectedColumns();
        if (this.areEqualCollections(currSelection, newSelection)) {
            return;
        }
        const args = {
            oldSelection: currSelection, newSelection: newSelection,
            added: added, removed: removed, event: event, cancel: false
        };
        this.grid.onColumnSelectionChange.emit(args);
        if (args.cancel) {
            return;
        }
        this.selectColumnsWithNoEvent(args.newSelection, true);
    }
    /** Clear columnSelection */
    clearAllSelectedColumns() {
        this.columnSelection.clear();
    }
};
IgxGridSelectionService.ɵfac = function IgxGridSelectionService_Factory(t) { return new (t || IgxGridSelectionService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
IgxGridSelectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridSelectionService, factory: IgxGridSelectionService.ɵfac });
IgxGridSelectionService.ctorParameters = () => [
    { type: NgZone }
];
function isChromium() {
    return (/Chrom|e?ium/g.test(navigator.userAgent) || /Google Inc/g.test(navigator.vendor)) && !/Edge/g.test(navigator.userAgent);
}

const EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 * @hidden
 */
let HammerGesturesManager = class HammerGesturesManager {
    constructor(_zone, doc, platformUtil) {
        this._zone = _zone;
        this.doc = doc;
        this.platformUtil = platformUtil;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {};
        this._hammerManagers = [];
        this.platformBrowser = this.platformUtil.isBrowser;
        if (this.platformBrowser) {
            this.hammerOptions = {
                // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
                // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
                inputClass: Hammer.TouchInput,
                recognizers: [
                    [Hammer.Pan, { threshold: 0 }],
                    [Hammer.Swipe, {
                            direction: Hammer.DIRECTION_HORIZONTAL
                        }],
                    [Hammer.Tap],
                    [Hammer.Tap, { event: 'doubletap', taps: 2 }, ['tap']]
                ]
            };
        }
    }
    supports(eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     */
    addEventListener(element, eventName, eventHandler, options = null) {
        if (!this.platformBrowser) {
            return;
        }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(() => {
            let mc = this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, Object.assign(this.hammerOptions, options));
                this.addManagerForElement(element, mc);
            }
            const handler = (eventObj) => { this._zone.run(() => { eventHandler(eventObj); }); };
            mc.on(eventName, handler);
            return () => { mc.off(eventName, handler); };
        });
    }
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param target Can be one of either window, body or document(fallback default).
     */
    addGlobalEventListener(target, eventName, eventHandler) {
        if (!this.platformBrowser) {
            return;
        }
        const element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener(element, eventName, eventHandler);
    }
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param target Target name
     */
    getGlobalEventTarget(target) {
        return ɵgetDOM().getGlobalEventTarget(this.doc, target);
    }
    /**
     * Set HammerManager options.
     *
     * @param element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     */
    setManagerOption(element, event, options) {
        const manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    }
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param element The DOM element used to create the manager on.
     */
    addManagerForElement(element, manager) {
        this._hammerManagers.push({ element, manager });
    }
    /**
     * Get HammerManager for the element or null
     *
     * @param element The DOM element used to create the manager on.
     */
    getManagerForElement(element) {
        const result = this._hammerManagers.filter((value, index, array) => {
            return value.element === element;
        });
        return result.length ? result[0].manager : null;
    }
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param element The DOM element used to create the manager on.
     */
    removeManagerForElement(element) {
        let index = null;
        for (let i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            const item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    }
    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
    destroy() {
        for (const item of this._hammerManagers) {
            item.manager.destroy();
        }
        this._hammerManagers = [];
    }
};
HammerGesturesManager.ɵfac = function HammerGesturesManager_Factory(t) { return new (t || HammerGesturesManager)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PlatformUtil)); };
HammerGesturesManager.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: HammerGesturesManager, factory: HammerGesturesManager.ɵfac });
HammerGesturesManager.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
HammerGesturesManager = __decorate([ __param(1, Inject(DOCUMENT))
], HammerGesturesManager);

var FilterMode;
(function (FilterMode) {
    FilterMode["quickFilter"] = "quickFilter";
    FilterMode["excelStyleFilter"] = "excelStyleFilter";
})(FilterMode || (FilterMode = {}));
var GridSummaryPosition;
(function (GridSummaryPosition) {
    GridSummaryPosition["top"] = "top";
    GridSummaryPosition["bottom"] = "bottom";
})(GridSummaryPosition || (GridSummaryPosition = {}));
var GridSummaryCalculationMode;
(function (GridSummaryCalculationMode) {
    GridSummaryCalculationMode["rootLevelOnly"] = "rootLevelOnly";
    GridSummaryCalculationMode["childLevelsOnly"] = "childLevelsOnly";
    GridSummaryCalculationMode["rootAndChildLevels"] = "rootAndChildLevels";
})(GridSummaryCalculationMode || (GridSummaryCalculationMode = {}));
var GridKeydownTargetType;
(function (GridKeydownTargetType) {
    GridKeydownTargetType["dataCell"] = "dataCell";
    GridKeydownTargetType["summaryCell"] = "summaryCell";
    GridKeydownTargetType["groupRow"] = "groupRow";
    GridKeydownTargetType["hierarchicalRow"] = "hierarchicalRow";
})(GridKeydownTargetType || (GridKeydownTargetType = {}));
var GridSelectionMode;
(function (GridSelectionMode) {
    GridSelectionMode["none"] = "none";
    GridSelectionMode["single"] = "single";
    GridSelectionMode["multiple"] = "multiple";
})(GridSelectionMode || (GridSelectionMode = {}));
var ColumnDisplayOrder;
(function (ColumnDisplayOrder) {
    ColumnDisplayOrder["Alphabetical"] = "Alphabetical";
    ColumnDisplayOrder["DisplayOrder"] = "DisplayOrder";
})(ColumnDisplayOrder || (ColumnDisplayOrder = {}));
var ColumnPinningPosition;
(function (ColumnPinningPosition) {
    ColumnPinningPosition[ColumnPinningPosition["Start"] = 0] = "Start";
    ColumnPinningPosition[ColumnPinningPosition["End"] = 1] = "End";
})(ColumnPinningPosition || (ColumnPinningPosition = {}));
var RowPinningPosition;
(function (RowPinningPosition) {
    RowPinningPosition[RowPinningPosition["Top"] = 0] = "Top";
    RowPinningPosition[RowPinningPosition["Bottom"] = 1] = "Bottom";
})(RowPinningPosition || (RowPinningPosition = {}));

/**
 * Providing reference to `IgxGridCellComponent`:
 * ```typescript
 * @ViewChild('grid', { read: IgxGridComponent })
 *  public grid: IgxGridComponent;
 * ```
 * ```typescript
 *  let column = this.grid.columnList.first;
 * ```
 * ```typescript
 *  let cell = column.cells[0];
 * ```
 */
let IgxGridCellComponent = class IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) {
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.touchManager = touchManager;
        this.platformUtil = platformUtil;
        this._vIndex = -1;
        /**
         * Sets/gets the highlight class of the cell.
         * Default value is `"igx-highlight"`.
         * ```typescript
         * let highlightClass = this.cell.highlightClass;
         * ```
         * ```typescript
         * this.cell.highlightClass = 'igx-cell-highlight';
         * ```
         * @memberof IgxGridCellComponent
         */
        this.highlightClass = 'igx-highlight';
        /**
         * Sets/gets the active highlight class class of the cell.
         * Default value is `"igx-highlight__active"`.
         * ```typescript
         * let activeHighlightClass = this.cell.activeHighlightClass;
         * ```
         * ```typescript
         * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
         * ```
         * @memberof IgxGridCellComponent
         */
        this.activeHighlightClass = 'igx-highlight__active';
        /**
         * @hidden
         * @internal
         */
        this.lastPinned = false;
        /**
         * @hidden
         * @internal
         */
        this.firstPinned = false;
        /**
         * Returns whether the cell is in edit mode.
         */
        this.editMode = false;
        /**
         * Sets/get the `role` property of the cell.
         * Default value is `"gridcell"`.
         * ```typescript
         * this.cell.role = 'grid-cell';
         * ```
         * ```typescript
         * let cellRole = this.cell.role;
         * ```
         * @memberof IgxGridCellComponent
         */
        this.role = 'gridcell';
        /**
         * Gets the width of the cell.
         * ```typescript
         * let cellWidth = this.cell.width;
         * ```
         * @memberof IgxGridCellComponent
         */
        this.width = '';
        /**
         * @hidden
         */
        this.displayPinnedChip = false;
        this.focused = this.active;
        this._cellSelection = GridSelectionMode.multiple;
        /**
         *
         * @hidden
         * @internal
         */
        this.pointerdown = (event) => {
            if (this.cellSelectionMode !== GridSelectionMode.multiple) {
                this.activate(event);
                return;
            }
            if (!isLeftClick(event)) {
                this.selectionService.addKeyboardRange();
                this.selectionService.initKeyboardState();
                this.selectionService.primaryButton = false;
                this.gridAPI.submit_value();
                return;
            }
            this.selectionService.pointerDown(this.selectionNode, event.shiftKey, event.ctrlKey);
            this.activate(event);
        };
        /**
         *
         * @hidden
         * @internal
         */
        this.pointerenter = (event) => {
            const dragMode = this.selectionService.pointerEnter(this.selectionNode, event);
            if (dragMode) {
                this.grid.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         * @internal
         */
        this.pointerup = (event) => {
            if (!isLeftClick(event)) {
                return;
            }
            if (this.selectionService.pointerUp(this.selectionNode, this.grid.onRangeSelection)) {
                this.grid.cdr.detectChanges();
            }
            this._updateCRUDStatus();
        };
        /**
         * @hidden
         * @internal
         */
        this.onDoubleClick = (event) => {
            if (event.type === 'doubletap') {
                // prevent double-tap to zoom on iOS
                event.preventDefault();
            }
            if (this.editable && !this.editMode && !this.row.deleted) {
                this.crudService.begin(this);
            }
            this.grid.onDoubleClick.emit({
                cell: this,
                event
            });
        };
    }
    /**
     * Gets the cell template context object.
     * ```typescript
     *  let context = this.cell.context();
     * ```
     * @memberof IgxGridCellComponent
     */
    get context() {
        return {
            $implicit: this.value,
            cell: this
        };
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     * @memberof IgxGridCellComponent
     */
    get template() {
        if (this.editMode) {
            const inlineEditorTemplate = this.column.inlineEditorTemplate;
            return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
        }
        if (this.cellTemplate) {
            return this.cellTemplate;
        }
        return this.defaultCellTemplate;
    }
    /**
     * Gets the cell template.
     * ```typescript
     * let template = this.cell.template;
     * ```
     * @memberof IgxGridCellComponent
     */
    get pinnedIndicatorTemplate() {
        if (this.pinnedIndicator) {
            return this.pinnedIndicator;
        }
        return this.defaultPinnedIndicator;
    }
    /**
     * Gets the `id` of the grid in which the cell is stored.
     * ```typescript
     * let gridId = this.cell.gridID;
     * ```
     * @memberof IgxGridCellComponent
     */
    get gridID() {
        return this.row.gridID;
    }
    /**
     * Gets the grid of the cell.
     * ```typescript
     * let grid = this.cell.grid;
     * ```
     * @memberof IgxGridCellComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the `index` of the row where the cell is stored.
     * ```typescript
     * let rowIndex = this.cell.rowIndex;
     * ```
     * @memberof IgxGridCellComponent
     */
    get rowIndex() {
        return this.row.index;
    }
    /**
     * Gets the `index` of the cell column.
     * ```typescript
     * let columnIndex = this.cell.columnIndex;
     * ```
     * @memberof IgxGridCellComponent
     */
    get columnIndex() {
        return this.column.index;
    }
    /**
     * Gets the visible `index` of the in which the cell is stored.
     * ```typescript
     * let visibleColumnIndex = this.cell.visibleColumnIndex;
     * ```
     * @memberof IgxGridCellComponent
     */
    get visibleColumnIndex() {
        return this.column.columnLayoutChild ? this.column.visibleIndex : this._vIndex;
    }
    set visibleColumnIndex(val) {
        this._vIndex = val;
    }
    /**
     * Gets the ID of the cell.
     * ```typescript
     * let cellID = this.cell.cellID;
     * ```
     * @memberof IgxGridCellComponent
     */
    get cellID() {
        const primaryKey = this.grid.primaryKey;
        const rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
        return { rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
    }
    get attrCellID() {
        return `${this.row.gridID}_${this.rowIndex}_${this.visibleColumnIndex}`;
    }
    /**
     * Returns a reference to the nativeElement of the cell.
     * ```typescript
     * let cellNativeElement = this.cell.nativeElement;
     * ```
     * @memberof IgxGridCellComponent
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get cellSelectionMode() {
        return this._cellSelection;
    }
    /**
     * @hidden
     * @internal
     */
    set lastSearchInfo(value) {
        this._lastSearchInfo = value;
        this.highlightText(this._lastSearchInfo.searchText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
    }
    set cellSelectionMode(value) {
        if (this._cellSelection === value) {
            return;
        }
        this.zone.runOutsideAngular(() => {
            value === GridSelectionMode.multiple ?
                this.addPointerListeners(value) : this.removePointerListeners(this._cellSelection);
        });
        this._cellSelection = value;
    }
    /**
     * Gets whether the cell is editable.
     * ```typescript
     * let isCellReadonly = this.cell.readonly;
     * ```
     * @memberof IgxGridCellComponent
     */
    get readonly() {
        return !this.editable;
    }
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    get rowEnd() {
        return this.column.rowEnd;
    }
    get colEnd() {
        return this.column.colEnd;
    }
    get rowStart() {
        return this.column.rowStart;
    }
    get colStart() {
        return this.column.colStart;
    }
    /**
     * Returns a string containing the grid `id` and the column `field` concatenated by "_".
     * ```typescript
     * let describedBy = this.cell.describedBy;
     * ```
     * @memberof IgxGridCellComponent
     */
    get describedby() {
        return `${this.row.gridID}_${this.column.field}`;
    }
    get ariaSelected() {
        return this.selected || this.column.selected || this.row.selected;
    }
    /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isSelected = this.cell.selected;
     * ```
     * @memberof IgxGridCellComponent
     */
    get selected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * Selects/deselects the cell.
     * ```typescript
     * this.cell.selected = true.
     * ```
     * @memberof IgxGridCellComponent
     */
    set selected(val) {
        const node = this.selectionNode;
        val ? this.selectionService.add(node) : this.selectionService.remove(node);
        this.grid.notifyChanges();
    }
    /**
     * Gets whether the cell column is selected.
     * ```typescript
     * let isCellColumnSelected = this.cell.columnSelected;
     * ```
     * @memberof IgxGridCellComponent
     */
    get columnSelected() {
        return this.selectionService.isColumnSelected(this.column.field);
    }
    get dirty() {
        if (this.grid.rowEditable) {
            const rowCurrentState = this.grid.transactions.getAggregatedValue(this.row.rowID, false);
            if (rowCurrentState) {
                return rowCurrentState[this.column.field] !== undefined && rowCurrentState[this.column.field] !== null;
            }
        }
        else {
            const rowTransaction = this.grid.transactions.getState(this.row.rowID);
            return rowTransaction && rowTransaction.value &&
                (rowTransaction.value[this.column.field] ||
                    rowTransaction.value[this.column.field] === 0 ||
                    rowTransaction.value[this.column.field] === false);
        }
        return false;
    }
    /**
     * Sets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * this.cell.editValue = value;
     * ```
     * @memberof IgxGridCellComponent
     */
    set editValue(value) {
        if (this.crudService.inEditMode) {
            this.crudService.cell.editValue = value;
        }
    }
    /**
     * Gets the current edit value while a cell is in edit mode.
     * Only for cell editing mode.
     * ```typescript
     * let editValue = this.cell.editValue;
     * ```
     * @memberof IgxGridCellComponent
     */
    get editValue() {
        if (this.crudService.inEditMode) {
            return this.crudService.cell.editValue;
        }
    }
    /**
     * Returns whether the cell is editable.
     */
    get editable() {
        return this.column.editable && !this.row.disabled;
    }
    set highlight(value) {
        this._highlight = value;
        if (this._highlight && this.grid.lastSearchInfo.searchText) {
            this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
            this._highlight.activateIfNecessary();
        }
    }
    get highlight() {
        return this._highlight;
    }
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.visibleColumnIndex
            } : null
        };
    }
    addPointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.addEventListener('pointerenter', this.pointerenter);
        this.nativeElement.addEventListener('pointerup', this.pointerup);
    }
    removePointerListeners(selection) {
        if (selection !== GridSelectionMode.multiple) {
            return;
        }
        this.nativeElement.removeEventListener('pointerenter', this.pointerenter);
        this.nativeElement.removeEventListener('pointerup', this.pointerup);
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerdown', this.pointerdown);
            this.addPointerListeners(this.cellSelectionMode);
            // IE 11 workarounds
            if (isIE()) {
                this.compositionStartHandler = () => this.crudService.isInCompositionMode = true;
                this.compositionEndHandler = () => this.crudService.isInCompositionMode = false;
                // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                this.nativeElement.addEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.addEventListener('compositionend', this.compositionEndHandler);
            }
        });
        if (this.platformUtil.isIOS) {
            this.touchManager.addEventListener(this.nativeElement, 'doubletap', this.onDoubleClick, {
                cssProps: {} /* don't disable user-select, etc */
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerdown', this.pointerdown);
            this.removePointerListeners(this.cellSelectionMode);
            if (isIE()) {
                this.nativeElement.removeEventListener('compositionstart', this.compositionStartHandler);
                this.nativeElement.removeEventListener('compositionend', this.compositionEndHandler);
            }
        });
        this.touchManager.destroy();
    }
    /**
     * @hidden
     * @internal
     */
    _updateCRUDStatus() {
        if (this.editMode) {
            return;
        }
        const crud = this.crudService;
        const editableCell = this.crudService.cell;
        const editMode = !!(crud.row || crud.cell);
        if (this.editable && editMode && !this.row.deleted) {
            if (editableCell) {
                this.gridAPI.update_cell(editableCell, editableCell.editValue);
                /* This check is related with the following issue #6517:
                 * when edit cell that belongs to a column which is sorted and press tab,
                 * the next cell in edit mode is with wrong value /its context is not updated/;
                 * So we reapply sorting before the next cell enters edit mode.
                 * Also we need to keep the notifyChanges below, because of the current
                 * change detection cycle when we have editing with enabled transactions
                 */
                if (this.grid.sortingExpressions.length && this.grid.sortingExpressions.indexOf(editableCell.column.field)) {
                    this.grid.cdr.detectChanges();
                }
            }
            crud.end();
            this.grid.tbody.nativeElement.focus({ preventScroll: true });
            this.grid.notifyChanges();
            crud.begin(this);
            return;
        }
        if (editableCell && crud.sameRow(this.cellID.rowID)) {
            this.gridAPI.submit_value();
        }
        else if (editMode && !crud.sameRow(this.cellID.rowID)) {
            this.grid.endEdit(true);
        }
    }
    /**
     * @deprecated
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * @memberof IgxGridCellComponent
     */
    isCellSelected() {
        return this.selectionService.selected(this.selectionNode);
    }
    /**
     * @hidden
     * @internal
     */
    ngOnChanges(changes) {
        if (changes.value && !changes.value.firstChange) {
            if (this.highlight) {
                this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
            }
        }
    }
    /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     */
    setEditMode(value) {
        if (this.row.deleted) {
            return;
        }
        if (this.editable && value) {
            this.gridAPI.submit_value();
            this.crudService.begin(this);
        }
        else {
            this.gridAPI.escape_editMode();
        }
        this.grid.notifyChanges();
    }
    /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     * @memberof IgxGridCellComponent
     */
    // TODO: Refactor
    update(val) {
        if (this.row.deleted) {
            return;
        }
        const cell = this.crudService.createCell(this);
        const args = this.gridAPI.update_cell(cell, val);
        if (this.crudService.cell && this.crudService.sameCell(cell)) {
            if (args.cancel) {
                return;
            }
            this.gridAPI.escape_editMode();
        }
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     * @internal
     */
    onClick(event) {
        this.grid.onCellClick.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * @internal
     */
    onContextMenu(event) {
        this.grid.onContextMenu.emit({
            cell: this,
            event
        });
    }
    /**
     * @hidden
     * @internal
     */
    activate(event) {
        const node = this.selectionNode;
        if (this.grid.navigation.activeNode) {
            Object.assign(this.grid.navigation.activeNode, { row: this.rowIndex, column: this.visibleColumnIndex });
        }
        else {
            const layout = this.column.columnLayoutChild ? this.grid.navigation.layout(this.visibleColumnIndex) : null;
            this.grid.navigation.activeNode = { row: this.rowIndex, column: this.visibleColumnIndex, layout: layout };
        }
        const shouldEmitSelection = !this.selectionService.isActiveNode(node);
        if (this.selectionService.primaryButton) {
            this._updateCRUDStatus();
            this.selectionService.activeElement = node;
        }
        else {
            this.selectionService.activeElement = null;
            if (this.crudService.inEditMode && !this.editMode) {
                this.gridAPI.submit_value();
            }
        }
        this.selectionService.primaryButton = true;
        if (this.cellSelectionMode === GridSelectionMode.multiple && this.selectionService.activeElement) {
            this.selectionService.add(this.selectionService.activeElement, false); // pointer events handle range generation
            this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection, this.nativeElement);
        }
        if (this.grid.isCellSelectable && shouldEmitSelection) {
            this.grid.onSelection.emit({ cell: this, event });
        }
        this.grid.cdr.detectChanges();
    }
    /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     * @memberof IgxGridCellComponent
     */
    highlightText(text, caseSensitive, exactMatch) {
        return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
    }
    /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     * @memberof IgxGridCellComponent
     */
    clearHighlight() {
        if (this.highlight && this.column.searchable) {
            this.highlight.clearHighlight();
        }
    }
    /**
     * @hidden
     * @internal
     */
    calculateSizeToFit(range) {
        return Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
    }
    /**
     * @hidden
     * @internal
     */
    get searchMetadata() {
        const meta = new Map();
        meta.set('pinned', this.grid.isRecordPinnedByViewIndex(this.row.index));
        return meta;
    }
};
IgxGridCellComponent.ɵfac = function IgxGridCellComponent_Factory(t) { return new (t || IgxGridCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxGridCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridCellComponent, selectors: [["igx-grid-cell"]], viewQuery: function IgxGridCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxTextHighlightDirective, true, IgxTextHighlightDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c14, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c15, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c16, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.highlight = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultPinnedIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inlineEditorTemplate = _t.first);
    } }, hostVars: 23, hostBindings: function IgxGridCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("dblclick", function IgxGridCellComponent_dblclick_HostBindingHandler($event) { return ctx.onDoubleClick($event); })("click", function IgxGridCellComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("contextmenu", function IgxGridCellComponent_contextmenu_HostBindingHandler($event) { return ctx.onContextMenu($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("data-rowIndex", ctx.rowIndex)("data-visibleIndex", ctx.visibleColumnIndex)("id", ctx.attrCellID)("aria-readonly", ctx.readonly)("aria-describedby", ctx.describedby)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵclassProp("igx-grid__td--pinned-last", ctx.lastPinned)("igx-grid__td--pinned-first", ctx.firstPinned)("igx-grid__td--editing", ctx.editMode)("igx-grid__td--row-pinned-first", ctx.displayPinnedChip)("igx-grid__td--selected", ctx.selected)("igx-grid__td--column-selected", ctx.columnSelected)("igx-grid__td--edited", ctx.dirty)("igx-grid__td--active", ctx.active);
    } }, inputs: { lastPinned: "lastPinned", firstPinned: "firstPinned", editMode: "editMode", width: "width", displayPinnedChip: "displayPinnedChip", visibleColumnIndex: "visibleColumnIndex", cellSelectionMode: "cellSelectionMode", lastSearchInfo: "lastSearchInfo", column: "column", row: "row", rowData: "rowData", cellTemplate: "cellTemplate", pinnedIndicator: "pinnedIndicator", value: "value", formatter: "formatter", active: "active" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 8, vars: 4, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["inlineEditor", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], [4, "ngIf"], ["displayDensity", "compact"], ["igxInput", "", 3, "value", "igxFocus", "input"], ["igxInput", "", "type", "number", 3, "value", "igxFocus", "input"], [3, "value", "checked", "igxFocus", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"]], template: function IgxGridCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridCellComponent_ng_template_2_Template, 6, 21, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridCellComponent_ng_template_4_Template, 4, 4, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridCellComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(7, IgxGridCellComponent_ng_container_7_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: function () { return [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxChipComponent,
        IgxTextHighlightDirective,
        IgxInputGroupComponent,
        IgxInputDirective,
        IgxFocusDirective,
        IgxCheckboxComponent,
        IgxDatePickerComponent]; }, pipes: function () { return [IgxDecimalPipeComponent,
        IgxDatePipeComponent]; }, encapsulation: 2, changeDetection: 0 });
IgxGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
__decorate([
    Input()
], IgxGridCellComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "row", void 0);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "rowData", void 0);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "cellTemplate", void 0);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "pinnedIndicator", void 0);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "formatter", void 0);
__decorate([
    HostBinding('attr.data-rowIndex')
], IgxGridCellComponent.prototype, "rowIndex", null);
__decorate([
    HostBinding('attr.data-visibleIndex'),
    Input()
], IgxGridCellComponent.prototype, "visibleColumnIndex", null);
__decorate([
    HostBinding('attr.id')
], IgxGridCellComponent.prototype, "attrCellID", null);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "cellSelectionMode", null);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "lastSearchInfo", null);
__decorate([
    Input(),
    HostBinding('class.igx-grid__td--pinned-last')
], IgxGridCellComponent.prototype, "lastPinned", void 0);
__decorate([
    Input(),
    HostBinding('class.igx-grid__td--pinned-first')
], IgxGridCellComponent.prototype, "firstPinned", void 0);
__decorate([
    Input(),
    HostBinding('class.igx-grid__td--editing')
], IgxGridCellComponent.prototype, "editMode", void 0);
__decorate([
    HostBinding('attr.role')
], IgxGridCellComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.aria-readonly')
], IgxGridCellComponent.prototype, "readonly", null);
__decorate([
    HostBinding('attr.aria-describedby')
], IgxGridCellComponent.prototype, "describedby", null);
__decorate([
    Input()
], IgxGridCellComponent.prototype, "width", void 0);
__decorate([
    Input(),
    HostBinding('class.igx-grid__td--active')
], IgxGridCellComponent.prototype, "active", void 0);
__decorate([
    HostBinding('attr.aria-selected')
], IgxGridCellComponent.prototype, "ariaSelected", null);
__decorate([
    HostBinding('class.igx-grid__td--selected')
], IgxGridCellComponent.prototype, "selected", null);
__decorate([
    HostBinding('class.igx-grid__td--column-selected')
], IgxGridCellComponent.prototype, "columnSelected", null);
__decorate([
    HostBinding('class.igx-grid__td--edited')
], IgxGridCellComponent.prototype, "dirty", null);
__decorate([
    Input(),
    HostBinding('class.igx-grid__td--row-pinned-first')
], IgxGridCellComponent.prototype, "displayPinnedChip", void 0);
__decorate([
    ViewChild('defaultCell', { read: TemplateRef, static: true })
], IgxGridCellComponent.prototype, "defaultCellTemplate", void 0);
__decorate([
    ViewChild('defaultPinnedIndicator', { read: TemplateRef, static: true })
], IgxGridCellComponent.prototype, "defaultPinnedIndicator", void 0);
__decorate([
    ViewChild('inlineEditor', { read: TemplateRef, static: true })
], IgxGridCellComponent.prototype, "inlineEditorTemplate", void 0);
__decorate([
    ViewChild(IgxTextHighlightDirective, { read: IgxTextHighlightDirective })
], IgxGridCellComponent.prototype, "highlight", null);
__decorate([
    DeprecateMethod(`'isCellSelected' is deprecated. Use 'selected' property instead.`)
], IgxGridCellComponent.prototype, "isCellSelected", null);
__decorate([
    HostListener('dblclick', ['$event'])
], IgxGridCellComponent.prototype, "onDoubleClick", void 0);
__decorate([
    HostListener('click', ['$event'])
], IgxGridCellComponent.prototype, "onClick", null);
__decorate([
    HostListener('contextmenu', ['$event'])
], IgxGridCellComponent.prototype, "onContextMenu", null);

/**
 * @hidden
 */
function WatchChanges() {
    return (target, key, propDesc) => {
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        const originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
        propDesc.set = function (val) {
            const init = this._init;
            const oldValue = this[key];
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                originalSetter.call(this, val);
                if (this.ngOnChanges && !init) {
                    // in case wacthed prop changes trigger ngOnChanges manually
                    const changes = {
                        [key]: new SimpleChange(oldValue, val, false)
                    };
                    this.ngOnChanges(changes);
                }
            }
        };
        return propDesc;
    };
}
function WatchColumnChanges() {
    return (target, key, propDesc) => {
        const privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        const originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
        propDesc.set = function (val) {
            const init = this._init;
            const oldValue = this[key];
            originalSetter.call(this, val);
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                if (this.rowIslandAPI.rowIsland) {
                    this.rowIslandAPI.rowIsland.updateColumnList();
                }
            }
        };
        return propDesc;
    };
}
function notifyChanges(repaint = false) {
    return (_, key, propDesc) => {
        const privateKey = `__${key}`;
        propDesc = propDesc || {
            enumerable: true,
            configurable: true
        };
        const originalSetter = propDesc ? propDesc.set : null;
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        propDesc.set = function (newValue) {
            if (originalSetter) {
                originalSetter.call(this, newValue);
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
            else {
                if (newValue === this[key]) {
                    return;
                }
                this[privateKey] = newValue;
                if (this.grid) {
                    this.grid.notifyChanges(repaint);
                }
            }
        };
        return propDesc;
    };
}

let IgxRowIslandAPIService = class IgxRowIslandAPIService {
    constructor() {
        this.change = new Subject();
        this.state = new Map();
        this.destroyMap = new Map();
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    register(rowIsland) {
        this.state.set(rowIsland.id, rowIsland);
        this.destroyMap.set(rowIsland.id, new Subject());
    }
    unsubscribe(rowIsland) {
        this.state.delete(rowIsland.id);
    }
    get(id) {
        return this.state.get(id);
    }
    unset(id) {
        this.state.delete(id);
        this.destroyMap.delete(id);
    }
    reset(oldId, newId) {
        const destroy = this.destroyMap.get(oldId);
        const rowIsland = this.get(oldId);
        this.unset(oldId);
        if (rowIsland) {
            this.state.set(newId, rowIsland);
        }
        if (destroy) {
            this.destroyMap.set(newId, destroy);
        }
    }
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    }
    unsetChildRowIsland(rowIsland) {
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    getChildRowIsland(rowIslandKey) {
        return this.childRowIslands.get(rowIslandKey);
    }
    registerChildGrid(parentRowID, grid) {
        this.childGrids.set(parentRowID, grid);
    }
    getChildGrids(inDepth) {
        let allChildren = [];
        this.childGrids.forEach((grid) => {
            allChildren.push(grid);
        });
        if (inDepth) {
            this.childRowIslands.forEach((layout) => {
                allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
            });
        }
        return allChildren;
    }
    getChildGridByID(rowID) {
        return this.childGrids.get(rowID);
    }
};
IgxRowIslandAPIService.ɵfac = function IgxRowIslandAPIService_Factory(t) { return new (t || IgxRowIslandAPIService)(); };
IgxRowIslandAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxRowIslandAPIService, factory: IgxRowIslandAPIService.ɵfac });

var IgxCheckboxComponent_1;
var LabelPosition;
(function (LabelPosition) {
    LabelPosition["BEFORE"] = "before";
    LabelPosition["AFTER"] = "after";
})(LabelPosition || (LabelPosition = {}));
const noop$3 = () => { };
const ɵ0$3 = noop$3;
let nextId$2 = 0;
/**
 * Allows users to make a binary choice for a certain condition.
 *
 * @igxModule IgxCheckboxModule
 *
 * @igxTheme igx-checkbox-theme
 *
 * @igxKeywords checkbox, label
 *
 * @igxGroup Data entry and display
 *
 * @remarks
 * The Ignite UI Checkbox is a selection control that allows users to make a binary choice for a certain condition.It behaves similarly
 * to the native browser checkbox.
 *
 * @example
 * ```html
 * <igx-checkbox checked="true">
 *   simple checkbox
 * </igx-checkbox>
 * ```
 */
let IgxCheckboxComponent = IgxCheckboxComponent_1 = class IgxCheckboxComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the checkbox component.
         * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
         *
         * @example
         * ```html
         * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
         * ```
         * ```typescript
         * let checkboxId =  this.checkbox.id;
         * ```
         */
        this.id = `igx-checkbox-${nextId$2++}`;
        /**
         * Sets/gets the id of the `label` element.
         * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
         *
         * @example
         * ```html
         * <igx-checkbox labelId = "Label1"></igx-checkbox>
         * ```
         * ```typescript
         * let labelId =  this.checkbox.labelId;
         * ```
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox [tabindex] = "1"></igx-checkbox>
         * ```
         * ```typescript
         * let tabIndex =  this.checkbox.tabindex;
         * ```
         */
        this.tabindex = null;
        /**
         *  Sets/gets the position of the `label`.
         *  If not set, the `labelPosition` will have value `"after"`.
         *
         * @example
         * ```html
         * <igx-checkbox labelPosition = "before"></igx-checkbox>
         * ```
         * ```typescript
         * let labelPosition =  this.checkbox.labelPosition;
         * ```
         */
        this.labelPosition = LabelPosition.AFTER;
        /**
         * Enables/Disables the ripple effect.
         * If not set, `disableRipple` will have value `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRippleDisabled = this.checkbox.desableRipple;
         * ```
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the checkbox is required.
         * If not set, `required` will have value `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [required] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRequired =  this.checkbox.required;
         * ```
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
         * ```
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         *
         * @example
         * ```html
         * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabel = this.checkbox.ariaLabel;
         * ```
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the checkbox state is changed.
         * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
         */
        this.change = new EventEmitter();
        /**
         * Returns the class of the checkbox component.
         *
         * @example
         * ```typescript
         * let class =  this.checkbox.cssClass;
         * ```
         */
        this.cssClass = 'igx-checkbox';
        /**
         * Sets/gets whether the checkbox component is on focus.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.checkbox.focused =  true;
         * ```
         * ```typescript
         * let isFocused =  this.checkbox.focused;
         * ```
         */
        this.focused = false;
        /**
         * Sets/gets the checkbox indeterminate visual state.
         * Default value is `false`;
         *
         * @example
         * ```html
         * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isIndeterminate = this.checkbox.indeterminate;
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets/gets whether the checkbox is checked.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [checked] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isChecked =  this.checkbox.checked;
         * ```
         */
        this.checked = false;
        /**
         * Sets/gets whether the checkbox is disabled.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disabled] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isDisabled = this.checkbox.disabled;
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets whether the checkbox is readonly.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [readonly]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let readonly = this.checkbox.readonly;
         * ```
         */
        this.readonly = false;
        /**
         * Sets/gets whether the checkbox should disable all css transitions.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let disableTransitions = this.checkbox.disableTransitions;
         * ```
         */
        this.disableTransitions = false;
        /** @hidden @internal */
        this.inputId = `${this.id}-input`;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$3;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$3;
    }
    /**
     * If `disabled` is `false`, switches the `checked` state.
     *
     * @example
     * ```typescript
     * this.checkbox.toggle();
     * ```
     */
    toggle() {
        if (this.disabled || this.readonly) {
            return;
        }
        this.indeterminate = false;
        this.focused = false;
        this.checked = !this.checked;
        this.change.emit({ checked: this.checked, checkbox: this });
        this._onChangeCallback(this.checked);
    }
    /** @hidden @internal */
    _onCheckboxChange(event) {
        // We have to stop the original checkbox change event
        // from bubbling up since we emit our own change event
        event.stopPropagation();
    }
    /** @hidden @internal */
    _onCheckboxClick(event) {
        // Since the original checkbox is hidden and the label
        // is used for styling and to change the checked state of the checkbox,
        // we need to prevent the checkbox click event from bubbling up
        // as it gets triggered on label click
        event.stopPropagation();
        if (this.readonly) {
            // readonly prevents the component from changing state (see toggle() method).
            // However, the native checkbox can still be activated through user interaction (focus + space, label click)
            // Prevent the native change so the input remains in sync
            event.preventDefault();
        }
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
        this.toggle();
    }
    /** @hidden @internal */
    _onLabelClick(event) {
        // We use a span element as a placeholder label
        // in place of the native label, we need to emit
        // the change event separately here alongside
        // the click event emitted on click
        this.toggle();
    }
    /** @hidden @internal */
    onFocus(event) {
        this.focused = true;
    }
    /** @hidden @internal */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /** @hidden @internal */
    get labelClass() {
        switch (this.labelPosition) {
            case LabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case LabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /** @hidden @internal */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /** @hidden @internal */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
};
IgxCheckboxComponent.ɵfac = function IgxCheckboxComponent_Factory(t) { return new (t || IgxCheckboxComponent)(); };
IgxCheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCheckboxComponent, selectors: [["igx-checkbox"]], viewQuery: function IgxCheckboxComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c17, true);
        ɵngcc0.ɵɵstaticViewQuery(_c18, true);
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeCheckbox = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);
    } }, hostVars: 13, hostBindings: function IgxCheckboxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-checkbox", ctx.cssClass)("igx-checkbox--focused", ctx.focused)("igx-checkbox--indeterminate", ctx.indeterminate)("igx-checkbox--checked", ctx.checked)("igx-checkbox--disabled", ctx.disabled)("igx-checkbox--plain", ctx.disableTransitions);
    } }, inputs: { id: "id", labelId: "labelId", tabindex: "tabindex", labelPosition: "labelPosition", disableRipple: "disableRipple", required: "required", ariaLabelledBy: ["aria-labelledby", "ariaLabelledBy"], ariaLabel: ["aria-label", "ariaLabel"], indeterminate: "indeterminate", checked: "checked", disabled: "disabled", readonly: "readonly", disableTransitions: "disableTransitions", value: "value", name: "name" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent_1, multi: true }])], ngContentSelectors: _c2, decls: 11, vars: 18, consts: [["type", "checkbox", 1, "igx-checkbox__input", 3, "id", "name", "value", "tabindex", "disabled", "indeterminate", "checked", "required", "change", "click", "focus", "blur"], ["checkbox", ""], ["igxRipple", "", "igxRippleTarget", ".igx-checkbox__ripple", 1, "igx-checkbox__composite-wrapper", 3, "igxRippleDisabled", "igxRippleCentered", "igxRippleDuration"], [1, "igx-checkbox__composite"], ["label", ""], ["xmlns", "http://www.w3.org/2000/svg", "viewBox", "0 0 24 24", 1, "igx-checkbox__composite-mark"], ["d", "M4.1,12.7 9,17.6 20.3,6.3"], [1, "igx-checkbox__ripple"], [3, "id", "click"], ["placeholderLabel", ""]], template: function IgxCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function IgxCheckboxComponent_Template_input_change_0_listener($event) { return ctx._onCheckboxChange($event); })("click", function IgxCheckboxComponent_Template_input_click_0_listener($event) { return ctx._onCheckboxClick($event); })("focus", function IgxCheckboxComponent_Template_input_focus_0_listener($event) { return ctx.onFocus($event); })("blur", function IgxCheckboxComponent_Template_input_blur_0_listener($event) { return ctx.onBlur($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "label", 3, 4);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(5, "svg", 5);
        ɵngcc0.ɵɵelement(6, "path", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(7, "div", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 8, 9);
        ɵngcc0.ɵɵlistener("click", function IgxCheckboxComponent_Template_span_click_8_listener($event) { return ctx._onLabelClick($event); });
        ɵngcc0.ɵɵprojection(10);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.inputId)("name", ctx.name)("value", ctx.value)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("indeterminate", ctx.indeterminate)("checked", ctx.checked)("required", ctx.required);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("igxRippleDisabled", ctx.disableRipple)("igxRippleCentered", true)("igxRippleDuration", 300);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵattribute("for", ctx.inputId);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵclassMap(ctx.labelClass);
        ɵngcc0.ɵɵproperty("id", ctx.labelId);
    } }, directives: [IgxRippleDirective], encapsulation: 2 });
__decorate([
    ViewChild('checkbox', { static: true })
], IgxCheckboxComponent.prototype, "nativeCheckbox", void 0);
__decorate([
    ViewChild('label', { static: true })
], IgxCheckboxComponent.prototype, "nativeLabel", void 0);
__decorate([
    ViewChild('placeholderLabel', { static: true })
], IgxCheckboxComponent.prototype, "placeholderLabel", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxCheckboxComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "labelId", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "name", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "tabindex", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "labelPosition", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "disableRipple", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "required", void 0);
__decorate([
    Input('aria-labelledby')
], IgxCheckboxComponent.prototype, "ariaLabelledBy", void 0);
__decorate([
    Input('aria-label')
], IgxCheckboxComponent.prototype, "ariaLabel", void 0);
__decorate([
    Output()
], IgxCheckboxComponent.prototype, "change", void 0);
__decorate([
    HostBinding('class.igx-checkbox')
], IgxCheckboxComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-checkbox--focused')
], IgxCheckboxComponent.prototype, "focused", void 0);
__decorate([
    HostBinding('class.igx-checkbox--indeterminate'),
    Input()
], IgxCheckboxComponent.prototype, "indeterminate", void 0);
__decorate([
    HostBinding('class.igx-checkbox--checked'),
    Input()
], IgxCheckboxComponent.prototype, "checked", void 0);
__decorate([
    HostBinding('class.igx-checkbox--disabled'),
    Input()
], IgxCheckboxComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxCheckboxComponent.prototype, "readonly", void 0);
__decorate([
    HostBinding('class.igx-checkbox--plain'),
    Input()
], IgxCheckboxComponent.prototype, "disableTransitions", void 0);
const IGX_CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => IgxCheckboxRequiredDirective),
    multi: true
};
/* tslint:disable directive-selector */
let IgxCheckboxRequiredDirective = class IgxCheckboxRequiredDirective extends CheckboxRequiredValidator {
};
IgxCheckboxRequiredDirective.ɵfac = function IgxCheckboxRequiredDirective_Factory(t) { return ɵIgxCheckboxRequiredDirective_BaseFactory(t || IgxCheckboxRequiredDirective); };
IgxCheckboxRequiredDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCheckboxRequiredDirective, selectors: [["igx-checkbox", "required", "", "formControlName", ""], ["igx-checkbox", "required", "", "formControl", ""], ["igx-checkbox", "required", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([IGX_CHECKBOX_REQUIRED_VALIDATOR]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @hidden
 */
let IgxCheckboxModule = class IgxCheckboxModule {
};
IgxCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCheckboxModule });
IgxCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCheckboxModule_Factory(t) { return new (t || IgxCheckboxModule)(); }, imports: [[IgxRippleModule]] });

let IgxRowDirective = class IgxRowDirective {
    constructor(gridAPI, crudService, selectionService, element, cdr) {
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
        /**
         * Sets whether this specific row has disabled functionality for editing and row selection.
         * Default value is `false`.
         * ```typescript
         * this.grid.selectedRows[0].pinned = true;
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         */
        this.role = 'row';
        /**
         * @hidden
         */
        this.dragging = false;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         * @internal
         */
        this.defaultCssClass = 'igx-grid__tr';
    }
    /**
     *  The data passed to the row component.
     *
     * ```typescript
     * // get the row data for the first selected row
     * let selectedRowData = this.grid.selectedRows[0].rowData;
     * ```
     */
    get rowData() {
        if (this.inEditMode) {
            return Object.assign({}, this._rowData, this.grid.transactions.getAggregatedValue(this.rowID, false));
        }
        return this._rowData;
    }
    set rowData(v) {
        this._rowData = v;
    }
    /**
     * Gets whether the row is pinned.
     * ```typescript
     * let isPinned = row.pinned;
     * ```
     */
    get pinned() {
        return this.grid.isRecordPinned(this.rowData);
    }
    /**
     * Sets whether the row is pinned.
     * Default value is `false`.
     * ```typescript
     * this.grid.selectedRows[0].pinned = true;
     * ```
     */
    set pinned(value) {
        if (value) {
            this.grid.pinRow(this.rowID);
        }
        else {
            this.grid.unpinRow(this.rowID);
        }
    }
    /**
     * Gets the rendered cells in the row component.
     *
     * ```typescript
     * // get the cells of the third selected row
     * let selectedRowCells = this.grid.selectedRows[2].cells;
     * ```
     */
    get cells() {
        const res = new QueryList();
        if (!this._cells) {
            return res;
        }
        const cList = this._cells.filter((item) => item.nativeElement.parentElement !== null)
            .sort((item1, item2) => item1.column.visibleIndex - item2.column.visibleIndex);
        res.reset(cList);
        return res;
    }
    set cells(cells) {
    }
    get dataRowIndex() {
        return this.index;
    }
    /**
     * @hidden
     */
    get styleClasses() {
        return this.resolveClasses();
    }
    /**
     * @hidden
     */
    get selected() {
        return this.selectionService.isRowSelected(this.rowID);
    }
    set selected(value) {
        value ? this.selectionService.selectRowsWithNoEvent([this.rowID]) :
            this.selectionService.deselectRowsWithNoEvent([this.rowID]);
        this.grid.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    get columns() {
        return this.grid.visibleColumns;
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        if (this.grid.groupingExpressions.length) {
            return this.grid.filteredSortedData.indexOf(this.rowData);
        }
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    /**
     * @hidden
     */
    get showRowSelectors() {
        return this.grid.showRowSelectors;
    }
    /** @hidden */
    get dirty() {
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
        }
        return false;
    }
    /**
     * @hidden
     */
    get rowDraggable() {
        return this.grid.rowDraggable;
    }
    /** @hidden */
    get added() {
        const row = this.grid.transactions.getState(this.rowID);
        if (row) {
            return row.type === TransactionType.ADD;
        }
        return false;
    }
    /** @hidden */
    get deleted() {
        return this.gridAPI.row_deleted_transaction(this.rowID);
    }
    // TODO: Refactor
    get inEditMode() {
        if (this.grid.rowEditable) {
            const editRowState = this.crudService.row;
            return (editRowState && editRowState.id === this.rowID) || false;
        }
        else {
            return false;
        }
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets the ID of the row.
     * A row in the grid is identified either by:
     * - primaryKey data value,
     * - the whole rowData, if the primaryKey is omitted.
     *
     * ```typescript
     * let rowID = this.grid.selectedRows[2].rowID;
     * ```
     */
    get rowID() {
        const primaryKey = this.grid.primaryKey;
        return primaryKey ? this._rowData[primaryKey] : this._rowData;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    onClick(event) {
        if (this.grid.rowSelection === 'none' || this.deleted) {
            return;
        }
        if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selectionService.selectRowById(this.rowID, !event.ctrlKey, event);
    }
    /**
     * @hidden
     */
    onRowSelectorClick(event) {
        event.stopPropagation();
        if (event.shiftKey && this.grid.rowSelection === 'multiple') {
            this.selectionService.selectMultipleRows(this.rowID, this.rowData, event);
            return;
        }
        this.selected ? this.selectionService.deselectRow(this.rowID, event) :
            this.selectionService.selectRowById(this.rowID, false, event);
    }
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     */
    update(value) {
        const crudService = this.crudService;
        if (crudService.inEditMode && crudService.cell.id.rowID === this.rowID) {
            this.grid.endEdit(false);
        }
        const row = new IgxRow(this.rowID, this.index, this.rowData);
        this.gridAPI.update_row(row, value);
        this.cdr.markForCheck();
    }
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     */
    delete() {
        this.grid.deleteRowById(this.rowID);
    }
    isCellActive(visibleColumnIndex) {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === this.index && node.column === visibleColumnIndex : false;
    }
    /**
     * Pins the specified row.
     * This method emits `onRowPinning` event.
     *
     * ```typescript
     * // pin the selected row from the grid
     * this.grid.selectedRows[0].pin();
     * ```
     */
    pin() {
        return this.grid.pinRow(this.rowID);
    }
    /**
     * Unpins the specified row.
     * This method emits `onRowPinning` event.
     *
     * ```typescript
     * // unpin the selected row from the grid
     * this.grid.selectedRows[0].unpin();
     * ```
     */
    unpin() {
        return this.grid.unpinRow(this.rowID);
    }
    /**
     * @hidden
     */
    get rowCheckboxAriaLabel() {
        return this.grid.primaryKey ?
            this.selected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
            this.selected ? 'Deselect row' : 'Select row';
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    shouldDisplayPinnedChip(visibleColumnIndex) {
        return this.pinned && this.disabled && visibleColumnIndex === 0;
    }
    /**
     * @hidden
     */
    resolveClasses() {
        const indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
        const selectedClass = this.selected ? 'igx-grid__tr--selected' : '';
        const editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
        const dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
        const deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
        const mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
        const dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
        return `${this.defaultCssClass} ${indexClass} ${selectedClass} ${editClass} ${dirtyClass}
         ${deletedClass} ${mrlClass} ${dragClass}`.trim();
    }
    /**
     * @hidden
     */
    get resolveDragIndicatorClasses() {
        const defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
        const dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
        return `${defaultDragIndicatorCssClass} ${dragIndicatorOff}`;
    }
};
IgxRowDirective.ɵfac = function IgxRowDirective_Factory(t) { return new (t || IgxRowDirective)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxRowDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowDirective, selectors: [["", "igxRowBaseComponent", ""]], viewQuery: function IgxRowDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c19, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵviewQuery(IgxCheckboxComponent, true, IgxCheckboxComponent);
        ɵngcc0.ɵɵviewQuery(_c20, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDirRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.checkboxElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cells = _t);
    } }, hostVars: 8, hostBindings: function IgxRowDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxRowDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("role", ctx.role)("data-rowIndex", ctx.dataRowIndex)("aria-selected", ctx.selected);
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
        ɵngcc0.ɵɵclassProp("igx-grid__tr--disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", rowData: "rowData", selected: "selected", index: "index", gridID: "gridID" } });
IgxRowDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridCRUDService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxRowDirective.prototype, "rowData", null);
__decorate([
    Input()
], IgxRowDirective.prototype, "index", void 0);
__decorate([
    Input(),
    HostBinding('attr.aria-disabled'),
    HostBinding('class.igx-grid__tr--disabled')
], IgxRowDirective.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxRowDirective.prototype, "gridID", void 0);
__decorate([
    ViewChild('igxDirRef', { read: IgxGridForOfDirective })
], IgxRowDirective.prototype, "virtDirRow", void 0);
__decorate([
    ViewChild(forwardRef(() => IgxCheckboxComponent), { read: IgxCheckboxComponent })
], IgxRowDirective.prototype, "checkboxElement", void 0);
__decorate([
    ViewChildren('cell')
], IgxRowDirective.prototype, "_cells", void 0);
__decorate([
    HostBinding('attr.role')
], IgxRowDirective.prototype, "role", void 0);
__decorate([
    HostBinding('attr.data-rowIndex')
], IgxRowDirective.prototype, "dataRowIndex", null);
__decorate([
    HostBinding('class')
], IgxRowDirective.prototype, "styleClasses", null);
__decorate([
    Input(),
    HostBinding('attr.aria-selected')
], IgxRowDirective.prototype, "selected", null);
__decorate([
    HostListener('click', ['$event'])
], IgxRowDirective.prototype, "onClick", null);

const clear = (el) => el === 0 || Boolean(el);
const ɵ0$4 = clear;
const first = (arr) => arr[0];
const ɵ1 = first;
const last = (arr) => arr[arr.length - 1];
const ɵ2 = last;
class IgxSummaryOperand {
    /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     * @memberof IgxSummaryOperand
     */
    static count(data) {
        return data.length;
    }
    /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     * @memberof IgxSummaryOperand
     */
    operate(data = [], allData = [], fieldName) {
        return [{
                key: 'count',
                label: 'Count',
                summaryResult: IgxSummaryOperand.count(data)
            }];
    }
}
// @dynamic
class IgxNumberSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static min(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.min(a, b)) : 0;
    }
    /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static max(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => Math.max(a, b)) : 0;
    }
    /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static sum(data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce((a, b) => +a + +b) : 0;
    }
    /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    static average(data) {
        return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: "max",
     *       label: "Max",
     *       summaryResult: IgxNumberSummaryOperand.max(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    operate(data = [], allData = [], fieldName) {
        const result = super.operate(data, allData, fieldName);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: IgxNumberSummaryOperand.min(data)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: IgxNumberSummaryOperand.max(data)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: IgxNumberSummaryOperand.sum(data)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: IgxNumberSummaryOperand.average(data)
        });
        return result;
    }
}
// @dynamic
class IgxDateSummaryOperand extends IgxSummaryOperand {
    /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     * @memberof IgxDateSummaryOperand
     */
    static latest(data) {
        return data.length && data.filter(clear).length ?
            first(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     * @memberof IgxDateSummaryOperand
     */
    static earliest(data) {
        return data.length && data.filter(clear).length ?
            last(data.filter(clear).sort((a, b) => new Date(b).valueOf() - new Date(a).valueOf())) : undefined;
    }
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data: any[], allData: any[], fieldName: string): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "latest",
     *       label: "Latest Date",
     *       summaryResult: IgxDateSummaryOperand.latest(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     * @memberof IgxDateSummaryOperand
     */
    operate(data = [], allData = [], fieldName) {
        const result = super.operate(data, allData, fieldName);
        result.push({
            key: 'earliest',
            label: 'Earliest',
            summaryResult: IgxDateSummaryOperand.earliest(data)
        });
        result.push({
            key: 'latest',
            label: 'Latest',
            summaryResult: IgxDateSummaryOperand.latest(data)
        });
        return result;
    }
}

let IgxFilterCellTemplateDirective = class IgxFilterCellTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxFilterCellTemplateDirective.ɵfac = function IgxFilterCellTemplateDirective_Factory(t) { return new (t || IgxFilterCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxFilterCellTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxFilterCellTemplateDirective, selectors: [["", "igxFilterCellTemplate", ""]] });
IgxFilterCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxCellTemplateDirective = class IgxCellTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCellTemplateDirective.ɵfac = function IgxCellTemplateDirective_Factory(t) { return new (t || IgxCellTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellTemplateDirective, selectors: [["", "igxCell", ""]] });
IgxCellTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxCellHeaderTemplateDirective = class IgxCellHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCellHeaderTemplateDirective.ɵfac = function IgxCellHeaderTemplateDirective_Factory(t) { return new (t || IgxCellHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellHeaderTemplateDirective, selectors: [["", "igxHeader", ""]] });
IgxCellHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
let IgxCellFooterTemplateDirective = class IgxCellFooterTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCellFooterTemplateDirective.ɵfac = function IgxCellFooterTemplateDirective_Factory(t) { return new (t || IgxCellFooterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellFooterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellFooterTemplateDirective, selectors: [["", "igxFooter", ""]] });
IgxCellFooterTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxCellEditorTemplateDirective = class IgxCellEditorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCellEditorTemplateDirective.ɵfac = function IgxCellEditorTemplateDirective_Factory(t) { return new (t || IgxCellEditorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCellEditorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCellEditorTemplateDirective, selectors: [["", "igxCellEditor", ""]] });
IgxCellEditorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxCollapsibleIndicatorTemplateDirective = class IgxCollapsibleIndicatorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCollapsibleIndicatorTemplateDirective.ɵfac = function IgxCollapsibleIndicatorTemplateDirective_Factory(t) { return new (t || IgxCollapsibleIndicatorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCollapsibleIndicatorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCollapsibleIndicatorTemplateDirective, selectors: [["", "igxCollapsibleIndicator", ""]] });
IgxCollapsibleIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
let IgxColumnComponent = class IgxColumnComponent {
    constructor(gridAPI, cdr, rowIslandAPI, elementRef) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.rowIslandAPI = rowIslandAPI;
        this.elementRef = elementRef;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        /** @hidden */
        this.expandedChange = new EventEmitter();
        /** @hidden */
        this.collapsibleChange = new EventEmitter();
        /** @hidden */
        this.visibleWhenCollapsedChange = new EventEmitter();
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * @memberof IgxColumnComponent
         */
        this.disableHiding = false;
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * @memberof IgxColumnComponent
         */
        this.disablePinning = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * @hidden
         */
        this.widthChange = new EventEmitter();
        this._calcWidth = null;
        /**
         * @hidden
         */
        this._applySelectableClass = false;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets conditional style properties on the column cells.
         * Similar to `ngStyle` it accepts an object literal where the keys are
         * the style properties and the value is the expression to be evaluated.
         * As with `cellClasses` it accepts a callback function.
         * ```typescript
         * styles = {
         *  background: 'royalblue',
         *  color: (rowData, columnKey, cellValue, rowIndex) => value.startsWith('Important') : 'red': 'inherit'
         * }
         * ```
         * ```html
         * <igx-column [cellStyles]="styles"></igx-column>
         * ```
         *
         * @memberof IgxColumnComponent
         */
        this.cellStyles = null;
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * @hidden
         */
        this.pinnedChange = new EventEmitter();
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * @hidden
         * @internal
         */
        this.collapsible = false;
        /**
         * @hidden
         * @internal
         */
        this.expanded = true;
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * @memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '';
        /**
         * @hidden
         */
        this._hasSummary = false;
        /**
         * @hidden
         */
        this._collapsible = false;
        /**
         * @hidden
         */
        this._expanded = true;
        /**
         * @hidden
         */
        this._selectable = true;
        this._vIndex = NaN;
    }
    /**
     * Returns if the column is selectable.
     * ```typescript
     * let columnSelectable = this.column.selectable;
     * ```
     * @memberof IgxColumnComponent
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * Sets if the column is selectable.
     * Default value is `true`.
     * ```html
     * <igx-column [selectable] = "false"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set selectable(value) {
        this._selectable = value;
    }
    /**
     * Gets whether the column is editable.
     * Default value is `false`.
     * ```typescript
     * let isEditable = this.column.editable;
     * ```
     * @memberof IgxColumnComponent
     */
    get editable() {
        // Updating the primary key when grid has transactions (incl. row edit)
        // should not be allowed, as that can corrupt transaction state.
        const rowEditable = this.grid && this.grid.rowEditable;
        const hasTransactions = this.grid && this.grid.transactions.enabled;
        if (this.isPrimaryColumn && (rowEditable || hasTransactions)) {
            return false;
        }
        if (this._editable !== undefined) {
            return this._editable;
        }
        else {
            return rowEditable;
        }
    }
    /**
     * Sets whether the column is editable.
     * ```typescript
     * this.column.editable = true;
     * ```
     * ```html
     * <igx-column [editable] = "true"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set editable(editable) {
        this._editable = editable;
    }
    /**
     * Gets a value indicating whether the summary for the column is enabled.
     * ```typescript
     * let hasSummary = this.column.hasSummary;
     * ```
     * @memberof IgxColumnComponent
     */
    get hasSummary() {
        return this._hasSummary;
    }
    /**
     * Sets a value indicating whether the summary for the column is enabled.
     * Default value is `false`.
     * ```html
     * <igx-column [hasSummary] = "true"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set hasSummary(value) {
        this._hasSummary = value;
        if (this.grid) {
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets whether the column is hidden.
     * ```typescript
     * let isHidden = this.column.hidden;
     * ```
     * @memberof IgxColumnComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column hidden property.
     * Default value is `false`.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(hidden)] = "model.isHidden"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set hidden(value) {
        if (this._hidden !== value) {
            this._hidden = value;
            this.hiddenChange.emit(this._hidden);
            if (this.columnLayoutChild && this.parent.hidden !== value) {
                this.parent.hidden = value;
                return;
            }
            if (this.grid) {
                this.grid.endEdit(false);
                this.grid.summaryService.resetSummaryHeight();
                this.grid.filteringService.refreshExpressions();
                this.grid.filteringService.hideFilteringRowOnColumnVisibilityChange(this);
                this.grid.notifyChanges();
            }
        }
    }
    /**
     * Returns if the column is selected.
     * ```typescript
     * let isSelected = this.column.selected;
     * ```
     * @memberof IgxColumnComponent
     */
    get selected() {
        return this.grid.selectionService.isColumnSelected(this.field);
    }
    /**
     * Select/deselect a column.
     * Default value is `false`.
     * ```typescript
     * this.column.selected = true;
     * ```
     * @memberof IgxColumnComponent
     */
    set selected(value) {
        if (this.selectable && value !== this.selected) {
            value ? this.grid.selectionService.selectColumnsWithNoEvent([this.field]) :
                this.grid.selectionService.deselectColumnsWithNoEvent([this.field]);
            this.grid.notifyChanges();
        }
    }
    /**
     * Gets the `width` of the column.
     * ```typescript
     * let columnWidth = this.column.width;
     * ```
     * @memberof IgxColumnComponent
     */
    get width() {
        return this.widthSetByUser ? this._width : this.defaultWidth;
    }
    /**
     * Sets the `width` of the column.
     * ```html
     * <igx-column [width] = "'25%'"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(width)]="model.columns[0].width"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set width(value) {
        if (value) {
            this._calcWidth = null;
            this.calcPixelWidth = NaN;
            this.widthSetByUser = true;
            // width could be passed as number from the template
            // host bindings are not px affixed so we need to ensure we affix simple number strings
            if (typeof (value) === 'number' || value.match(/^[0-9]*$/)) {
                value = value + 'px';
            }
            this._width = value;
            if (this.grid) {
                this.cacheCalcWidth();
            }
            this.widthChange.emit(this._width);
        }
    }
    /**
     * @hidden
     */
    get calcWidth() {
        return this.getCalcWidth();
    }
    /**
     * Sets/gets the minimum `width` of the column.
     * Default value is `88`;
     * ```typescript
     * let columnMinWidth = this.column.minWidth;
     * ```
     * ```html
     * <igx-column [minWidth] = "'100px'"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set minWidth(value) {
        const minVal = parseFloat(value);
        if (Number.isNaN(minVal)) {
            return;
        }
        this._defaultMinWidth = value;
    }
    get minWidth() {
        return !this._defaultMinWidth ? this.defaultMinWidth : this._defaultMinWidth;
    }
    /**
     * Gets the column index.
     * ```typescript
     * let columnIndex = this.column.index;
     * ```
     * @memberof IgxColumnComponent
     */
    get index() {
        return this.grid.columns.indexOf(this);
    }
    /**
     * Gets whether the column is `pinned`.
     * ```typescript
     * let isPinned = this.column.pinned;
     * ```
     * @memberof IgxColumnComponent
     */
    get pinned() {
        return this._pinned;
    }
    /**
     * Sets whether the column is pinned.
     * Default value is `false`.
     * ```html
     * <igx-column [pinned] = "true"></igx-column>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-column [(pinned)] = "model.columns[0].isPinned"></igx-column>
     * ```
     * @memberof IgxColumnComponent
     */
    set pinned(value) {
        if (this._pinned !== value) {
            if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                value ? this.pin() : this.unpin();
                return;
            }
            /* No grid/width available at initialization. `initPinning` in the grid
               will re-init the group (if present)
            */
            this._unpinnedIndex = this.grid ? this.grid.columns.filter(x => !x.pinned).indexOf(this) : 0;
            this._pinned = value;
            this.pinnedChange.emit(this._pinned);
        }
    }
    /**
     * Gets the column `summaries`.
     * ```typescript
     * let columnSummaries = this.column.summaries;
     * ```
     * @memberof IgxColumnComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column `summaries`.
     * ```typescript
     * this.column.summaries = IgxNumberSummaryOperand;
     * ```
     * @memberof IgxColumnComponent
     */
    set summaries(classRef) {
        this._summaries = new classRef();
        if (this.grid) {
            this.grid.summaryService.removeSummariesCachePerColumn(this.field);
            this.grid._summaryPipeTrigger++;
            this.grid.summaryService.resetSummaryHeight();
        }
    }
    /**
     * Gets the column `filters`.
     * ```typescript
     * let columnFilters = this.column.filters'
     * ```
     * @memberof IgxColumnComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column `filters`.
     * ```typescript
     * this.column.filters = IgxBooleanFilteringOperand.instance().
     * ```
     * @memberof IgxColumnComponent
     */
    set filters(instance) {
        this._filters = instance;
    }
    /**
     * Gets the column `sortStrategy`.
     * ```typescript
     * let sortStrategy = this.column.sortStrategy
     * ```
     * @memberof IgxColumnComponent
     */
    get sortStrategy() {
        return this._sortStrategy;
    }
    /**
     * Sets the column `sortStrategy`.
     * ```typescript
     * this.column.sortStrategy = new CustomSortingStrategy().
     * class CustomSortingStrategy extends SortingStrategy {...}
     * ```
     * @memberof IgxColumnComponent
     */
    set sortStrategy(classRef) {
        this._sortStrategy = classRef;
    }
    /**
     * Gets the function that compares values for grouping.
     * ```typescript
     * let groupingComparer = this.column.groupingComparer'
     * ```
     * @memberof IgxColumnComponent
     */
    get groupingComparer() {
        return this._groupingComparer;
    }
    /**
     * Sets a custom function to compare values for grouping.
     * Subsequent values in the sorted data that the function returns 0 for are grouped.
     * ```typescript
     * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
     * ```
     * @memberof IgxColumnComponent
     */
    set groupingComparer(funcRef) {
        this._groupingComparer = funcRef;
    }
    /**
     * Gets the default minimum `width` of the column.
     * ```typescript
     * let defaultMinWidth =  this.column.defaultMinWidth;
     * ```
     * @memberof IgxColumnComponent
     */
    get defaultMinWidth() {
        if (!this.grid) {
            return '80';
        }
        switch (this.grid.displayDensity) {
            case DisplayDensity.cosy:
                return '64';
            case DisplayDensity.compact:
                return '56';
            default:
                return '80';
        }
    }
    /**
     * The reference to the `igx-grid` owner.
     * ```typescript
     * let gridComponent = this.column.grid;
     * ```
     * @memberof IgxColumnComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns a reference to the `bodyTemplate`.
     * ```typescript
     * let bodyTemplate = this.column.bodyTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * Sets the body template.
     * ```html
     * <ng-template #bodyTemplate igxCell let-val>
     *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
     *       <span> {{val}} </span>
     *    </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'bodyTemplate'", {read: TemplateRef })
     * public bodyTemplate: TemplateRef<any>;
     * this.column.bodyTemplate = this.bodyTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set bodyTemplate(template) {
        this._bodyTemplate = template;
    }
    /**
     * Returns a reference to the header template.
     * ```typescript
     * let headerTemplate = this.column.headerTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get headerTemplate() {
        return this._headerTemplate;
    }
    /**
     * Sets the header template.
     * Note that the column header height is fixed and any content bigger than it will be cut off.
     * ```html
     * <ng-template #headerTemplate>
     *   <div style = "background-color:black" (click) = "changeColor(val)">
     *       <span style="color:red" >{{column.field}}</span>
     *   </div>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'headerTemplate'", {read: TemplateRef })
     * public headerTemplate: TemplateRef<any>;
     * this.column.headerTemplate = this.headerTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set headerTemplate(template) {
        this._headerTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.column.inlineEditorTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * Sets the inline editor template.
     * ```html
     * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
     *     <input type="string" [(ngModel)]="cell.value"/>
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
     * public inlineEditorTemplate: TemplateRef<any>;
     * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set inlineEditorTemplate(template) {
        this._inlineEditorTemplate = template;
    }
    /**
     * Returns a reference to the `filterCellTemplate`.
     * ```typescript
     * let filterCellTemplate = this.column.filterCellTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    get filterCellTemplate() {
        return this._filterCellTemplate;
    }
    /**
     * Sets the quick filter template.
     * ```html
     * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
     *    <input (input)="onInput()">
     * </ng-template>
     * ```
     * ```typescript
     * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
     * public filterCellTemplate: TemplateRef<any>;
     * this.column.filterCellTemplate = this.filterCellTemplate;
     * ```
     * @memberof IgxColumnComponent
     */
    set filterCellTemplate(template) {
        this._filterCellTemplate = template;
    }
    /**
     * Gets the cells of the column.
     * ```typescript
     * let columnCells =  this.column.cells;
     * ```
     * @memberof IgxColumnComponent
     */
    get cells() {
        return this.grid.rowList.filter((row) => row instanceof IgxRowDirective)
            .map((row) => {
            if (row.cells) {
                return row.cells.filter((cell) => cell.columnIndex === this.index);
            }
        }).reduce((a, b) => a.concat(b), []);
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => !c.columnGroup);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => !c.columnGroup);
        let col = this;
        let vIndex = -1;
        if (this.columnGroup) {
            col = this.allChildren.filter(c => !c.columnGroup && !c.hidden)[0];
        }
        if (this.columnLayoutChild) {
            return this.parent.childrenVisibleIndexes.find(x => x.column === this).index;
        }
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(col);
            vIndex = indexInCollection === -1 ?
                -1 :
                (this.grid.isPinningToStart ?
                    pinnedColumns.length + indexInCollection :
                    indexInCollection);
        }
        else {
            const indexInCollection = pinnedColumns.indexOf(col);
            vIndex = this.grid.isPinningToStart ?
                indexInCollection :
                unpinnedColumns.length + indexInCollection;
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnGroup() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Returns a boolean indicating if the column is a child of a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnLayoutChild =  this.column.columnLayoutChild;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnLayoutChild() {
        return this.parent && this.parent.columnLayout;
    }
    /**
     * Returns the children columns collection.
     * Returns an empty array if the column does not contain children columns.
     * ```typescript
     * let childrenColumns =  this.column.allChildren;
     * ```
     * @memberof IgxColumnComponent
     */
    get allChildren() {
        return [];
    }
    /**
     * Returns the level of the column in a column group.
     * Returns `0` if the column doesn't have a `parent`.
     * ```typescript
     * let columnLevel =  this.column.level;
     * ```
     * @memberof IgxColumnComponent
     */
    get level() {
        let ptr = this.parent;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parent;
        }
        return lvl;
    }
    get isLastPinned() {
        return this.grid.isPinningToStart &&
            this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
    }
    get isFirstPinned() {
        const pinnedCols = this.grid.pinnedColumns.filter(x => !x.columnGroup);
        return !this.grid.isPinningToStart && pinnedCols[0] === this;
    }
    get rightPinnedOffset() {
        return this.pinned && !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    get gridRowSpan() {
        return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
    }
    get gridColumnSpan() {
        return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
    }
    /**
     * Indicates whether the column will be visible when its parent is collapsed.
     * ```html
     * <igx-column-group>
     *   <igx-column [visibleWhenCollapsed]="true"></igx-column>
     * </igx-column-group>
     * ```
     * @memberof IgxColumnComponent
     */
    set visibleWhenCollapsed(value) {
        this._visibleWhenCollapsed = value;
        this.visibleWhenCollapsedChange.emit(this._visibleWhenCollapsed);
        if (this.parent) {
            this.parent.setExpandCollapseState();
        }
    }
    get visibleWhenCollapsed() {
        return this._visibleWhenCollapsed;
    }
    /**
     * Returns the filteringExpressionsTree of the column.
     * ```typescript
     * let tree =  this.column.filteringExpressionsTree;
     * ```
     * @memberof IgxColumnComponent
     */
    get filteringExpressionsTree() {
        return this.grid.filteringExpressionsTree.find(this.field);
    }
    /**
     * @hidden
     */
    get isPrimaryColumn() {
        return this.field !== undefined && this.grid !== undefined && this.field === this.grid.primaryKey;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches() {
        this._vIndex = NaN;
        if (this.grid) {
            this.cacheCalcWidth();
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    }
    /**
     * @hidden
     */
    getGridTemplate(isRow, isIE) {
        if (isRow) {
            const rowsCount = this.grid.multiRowLayoutRowSize;
            return isIE ?
                `(1fr)[${rowsCount}]` :
                `repeat(${rowsCount},1fr)`;
        }
        else {
            return this.getColumnSizesString(this.children);
        }
    }
    getInitialChildColumnSizes(children) {
        const columnSizes = [];
        // find the smallest col spans
        children.forEach(col => {
            if (!col.colStart) {
                return;
            }
            const newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            const newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            const bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            const bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 */
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (let i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (let i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                let j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        const width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width: width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    }
    getFilledChildColumnSizes(children) {
        const columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        const result = [];
        for (let i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
                result.push(columnSizes[i].width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    }
    getColumnSizesString(children) {
        const res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    }
    getResizableColUnderEnd() {
        if (this.columnLayout || !this.columnLayoutChild || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        const columnSized = this.getInitialChildColumnSizes(this.parent.children);
        const targets = [];
        const colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (let i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        const targetsSquashed = [];
        for (let j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(targets[j]);
            }
        }
        return targetsSquashed;
    }
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * @memberof IgxColumnComponent
     */
    pin(index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        const grid = this.grid;
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
        }
        if (!this.parent && !this.pinnable) {
            return false;
        }
        this._pinned = true;
        this.pinnedChange.emit(this._pinned);
        this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
        index = index !== undefined ? index : grid._pinnedColumns.length;
        const targetColumn = grid._pinnedColumns[index];
        const args = { column: this, insertAtIndex: index, isPinned: true };
        grid.onColumnPinning.emit(args);
        if (grid._pinnedColumns.indexOf(this) === -1) {
            grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.pin());
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        return true;
    }
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * @memberof IgxColumnComponent
     */
    unpin(index) {
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        const grid = this.grid;
        const hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
        }
        index = (index !== undefined ? index :
            this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
        this._pinned = false;
        this.pinnedChange.emit(this._pinned);
        const targetColumn = grid._unpinnedColumns[index];
        grid._unpinnedColumns.splice(index, 0, this);
        if (grid._pinnedColumns.indexOf(this) !== -1) {
            grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(child => child.unpin());
        }
        grid.reinitPinStates();
        grid.resetCaches();
        const insertAtIndex = grid._unpinnedColumns.indexOf(this);
        const args = { column: this, insertAtIndex, isPinned: false };
        grid.onColumnPinning.emit(args);
        grid.notifyChanges();
        if (this.columnLayoutChild) {
            this.grid.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        this.grid.filteringService.refreshExpressions();
        return true;
    }
    /**
     * Returns a reference to the top level parent column.
     * ```typescript
     * let topLevelParent =  this.column.topLevelParent;
     * ```
     * @memberof IgxColumnComponent
     */
    get topLevelParent() {
        let parent = this.parent;
        while (parent && parent.parent) {
            parent = parent.parent;
        }
        return parent;
    }
    /**
     * Returns a reference to the header of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let headerCell = column.headerCell;
     * ```
     * @memberof IgxColumnComponent
     */
    get headerCell() {
        return this.grid.headerCellList.find((header) => header.column === this);
    }
    /**
     * Returns a reference to the filter cell of the column.
     * ```typescript
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let filterell = column.filterell;
     * ```
     * @memberof IgxColumnComponent
     */
    get filterCell() {
        return this.grid.filterCellList.find((filterCell) => filterCell.column === this);
    }
    /**
     * Returns a reference to the header group of the column.
     * @memberof IgxColumnComponent
     */
    get headerGroup() {
        return this.grid.headerGroupsList.find((headerGroup) => headerGroup.column === this);
    }
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * @memberof IgxColumnComponent
     */
    autosize() {
        if (!this.columnGroup) {
            this.width = this.getLargestCellWidth();
            this.grid.reflow();
        }
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        if (this._calcWidth !== null && !isNaN(this.calcPixelWidth)) {
            return this._calcWidth;
        }
        this.cacheCalcWidth();
        return this._calcWidth;
    }
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    getLargestCellWidth() {
        const range = this.grid.document.createRange();
        const largest = new Map();
        if (this.cells.length > 0) {
            let cellsContentWidths = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach((cell) => cellsContentWidths.push(cell.calculateSizeToFit(range)));
            }
            else {
                cellsContentWidths = this.cells.map((cell) => getNodeSizeViaRange(range, cell.nativeElement));
            }
            const index = cellsContentWidths.indexOf(Math.max(...cellsContentWidths));
            const cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max(...cellsContentWidths), cellPadding);
        }
        if (this.headerCell) {
            let headerCell;
            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                headerCell = Math.max(...Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                    .map((child) => getNodeSizeViaRange(range, child)));
            }
            else {
                headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }
            if (this.sortable || this.filterable) {
                headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            const headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            const headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                parseFloat(headerStyle.borderRightWidth);
            largest.set(headerCell, headerPadding);
        }
        const largestCell = Math.max(...Array.from(largest.keys()));
        const width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    }
    /**
     * @hidden
     */
    getCellWidth() {
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.columnLayoutChild) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            let cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    }
    /**
     * @hidden
     * @internal
     */
    cacheCalcWidth() {
        const grid = this.gridAPI.grid;
        const colWidth = this.width;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (isPercentageWidth) {
            this._calcWidth = parseInt(colWidth, 10) / 100 * (grid.calcWidth - grid.featureColumnsWidth());
        }
        else if (!colWidth) {
            // no width
            this._calcWidth = this.defaultWidth || grid.getPossibleColumnWidth();
        }
        else {
            this._calcWidth = this.width;
        }
        this.calcPixelWidth = parseInt(this._calcWidth, 10);
    }
    /**
     * @hidden
     * @internal
     */
    setExpandCollapseState() {
        this.children.filter(col => (col.visibleWhenCollapsed !== undefined)).forEach(c => {
            if (!this.collapsible) {
                c.hidden = this.hidden;
                return;
            }
            c.hidden = this._expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
        });
    }
    /**
     * @hidden
     * @internal
     */
    checkCollapsibleState() {
        if (!this.children) {
            return false;
        }
        const cols = this.children.map(child => child.visibleWhenCollapsed);
        return (cols.some(c => c === true) && cols.some(c => c === false));
    }
    /**
     * @hidden
     */
    get pinnable() {
        return this.grid._init || !this.pinned;
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() { }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
        }
    }
};
IgxColumnComponent.ɵfac = function IgxColumnComponent_Factory(t) { return new (t || IgxColumnComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxRowIslandAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnComponent, selectors: [["igx-column"]], contentQueries: function IgxColumnComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCellTemplateDirective, true, IgxCellTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCellEditorTemplateDirective, true, IgxCellEditorTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxFilterCellTemplateDirective, true, IgxFilterCellTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCollapsibleIndicatorTemplateDirective, true, IgxCollapsibleIndicatorTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCellHeaderTemplateDirective, false, IgxCellHeaderTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterCellTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.collapseIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headTemplate = _t);
    } }, inputs: { header: "header", sortable: "sortable", groupable: "groupable", filterable: "filterable", resizable: "resizable", disableHiding: "disableHiding", disablePinning: "disablePinning", movable: "movable", headerClasses: "headerClasses", headerGroupClasses: "headerGroupClasses", cellStyles: "cellStyles", filteringIgnoreCase: "filteringIgnoreCase", sortingIgnoreCase: "sortingIgnoreCase", dataType: "dataType", searchable: "searchable", selectable: "selectable", editable: "editable", hasSummary: "hasSummary", hidden: "hidden", width: "width", minWidth: "minWidth", pinned: "pinned", summaries: "summaries", filters: "filters", sortStrategy: "sortStrategy", groupingComparer: "groupingComparer", bodyTemplate: ["cellTemplate", "bodyTemplate"], headerTemplate: "headerTemplate", inlineEditorTemplate: ["cellEditorTemplate", "inlineEditorTemplate"], filterCellTemplate: "filterCellTemplate", visibleWhenCollapsed: "visibleWhenCollapsed", field: "field", maxWidth: "maxWidth", cellClasses: "cellClasses", formatter: "formatter", collapsibleIndicatorTemplate: "collapsibleIndicatorTemplate", rowEnd: "rowEnd", colEnd: "colEnd", rowStart: "rowStart", colStart: "colStart" }, outputs: { hiddenChange: "hiddenChange", expandedChange: "expandedChange", collapsibleChange: "collapsibleChange", visibleWhenCollapsedChange: "visibleWhenCollapsedChange", widthChange: "widthChange", pinnedChange: "pinnedChange" }, decls: 0, vars: 0, template: function IgxColumnComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
IgxColumnComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: IgxRowIslandAPIService },
    { type: ElementRef }
];
__decorate([
    Input()
], IgxColumnComponent.prototype, "field", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "header", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "sortable", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "selectable", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "groupable", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "editable", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "filterable", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "resizable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "hasSummary", null);
__decorate([
    notifyChanges(true),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "hidden", null);
__decorate([
    Output()
], IgxColumnComponent.prototype, "hiddenChange", void 0);
__decorate([
    Output()
], IgxColumnComponent.prototype, "expandedChange", void 0);
__decorate([
    Output()
], IgxColumnComponent.prototype, "collapsibleChange", void 0);
__decorate([
    Output()
], IgxColumnComponent.prototype, "visibleWhenCollapsedChange", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "disableHiding", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "disablePinning", void 0);
__decorate([
    WatchColumnChanges(),
    notifyChanges(),
    Input()
], IgxColumnComponent.prototype, "movable", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "width", null);
__decorate([
    Output()
], IgxColumnComponent.prototype, "widthChange", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "maxWidth", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "minWidth", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "headerClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "headerGroupClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "cellClasses", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "cellStyles", void 0);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "formatter", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "filteringIgnoreCase", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "sortingIgnoreCase", void 0);
__decorate([
    Input()
], IgxColumnComponent.prototype, "dataType", void 0);
__decorate([
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "pinned", null);
__decorate([
    Output()
], IgxColumnComponent.prototype, "pinnedChange", void 0);
__decorate([
    notifyChanges(true),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "summaries", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "searchable", void 0);
__decorate([
    Input()
], IgxColumnComponent.prototype, "filters", null);
__decorate([
    Input()
], IgxColumnComponent.prototype, "sortStrategy", null);
__decorate([
    Input()
], IgxColumnComponent.prototype, "groupingComparer", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input('cellTemplate')
], IgxColumnComponent.prototype, "bodyTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input()
], IgxColumnComponent.prototype, "headerTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input('cellEditorTemplate')
], IgxColumnComponent.prototype, "inlineEditorTemplate", null);
__decorate([
    notifyChanges(),
    WatchColumnChanges(),
    Input('filterCellTemplate')
], IgxColumnComponent.prototype, "filterCellTemplate", null);
__decorate([
    Input('collapsibleIndicatorTemplate')
], IgxColumnComponent.prototype, "collapsibleIndicatorTemplate", void 0);
__decorate([
    Input()
], IgxColumnComponent.prototype, "rowEnd", void 0);
__decorate([
    Input()
], IgxColumnComponent.prototype, "colEnd", void 0);
__decorate([
    Input()
], IgxColumnComponent.prototype, "rowStart", void 0);
__decorate([
    Input()
], IgxColumnComponent.prototype, "colStart", void 0);
__decorate([
    notifyChanges(true),
    Input()
], IgxColumnComponent.prototype, "visibleWhenCollapsed", null);
__decorate([
    ContentChild(IgxCellTemplateDirective, { read: IgxCellTemplateDirective })
], IgxColumnComponent.prototype, "cellTemplate", void 0);
__decorate([
    ContentChildren(IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false })
], IgxColumnComponent.prototype, "headTemplate", void 0);
__decorate([
    ContentChild(IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective })
], IgxColumnComponent.prototype, "editorTemplate", void 0);
__decorate([
    ContentChild(IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective })
], IgxColumnComponent.prototype, "filterCellTemplateDirective", void 0);
__decorate([
    ContentChild(IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false })
], IgxColumnComponent.prototype, "collapseIndicatorTemplate", void 0);

let IgxGridBodyDirective = class IgxGridBodyDirective {
};
IgxGridBodyDirective.ɵfac = function IgxGridBodyDirective_Factory(t) { return new (t || IgxGridBodyDirective)(); };
IgxGridBodyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridBodyDirective, selectors: [["", "igxGridBody", ""]], features: [ɵngcc0.ɵɵProvidersFeature([IgxForOfSyncService])] });
/**
 * @hidden
 */
class RowEditPositionStrategy extends ConnectedPositioningStrategy {
    constructor() {
        super(...arguments);
        this.isTop = false;
        this.isTopInitialPosition = null;
    }
    position(contentElement, size, document, initialCall) {
        const container = this.settings.container; // grid.tbody
        const target = this.settings.target; // current grid.row
        // Position of the overlay depends on the available space in the grid.
        // If the bottom space is not enough then the the row overlay will show at the top of the row.
        // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
        // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
        this.isTop = this.isTopInitialPosition !== null ?
            this.isTopInitialPosition :
            container.getBoundingClientRect().bottom <
                target.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
        // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
        contentElement.style.width = target.clientWidth + 'px';
        this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
        this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
        super.position(contentElement, { width: target.clientWidth, height: target.clientHeight }, document, initialCall);
    }
}

/**
 * @hidden
 */
let ItemPropertyValueChangedDirective = class ItemPropertyValueChangedDirective {
    constructor(propName) {
        this.valueChanged = new EventEmitter();
        this._propName = propName;
    }
    get object() {
        return this._object;
    }
    set object(value) {
        if (value) {
            this._object = value;
        }
    }
    get value() {
        return (this.object) ? this.object[this._propName] : null;
    }
    set value(value) {
        this.onValueChanged(value);
    }
    onValueChanged(value) {
        const currentValue = this.value;
        if (value !== currentValue) {
            this.object[this._propName] = value;
            this.valueChanged.emit({ oldValue: currentValue, newValue: value });
        }
    }
};
ItemPropertyValueChangedDirective.ɵfac = function ItemPropertyValueChangedDirective_Factory(t) { return new (t || ItemPropertyValueChangedDirective)(ɵngcc0.ɵɵdirectiveInject(String)); };
ItemPropertyValueChangedDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ItemPropertyValueChangedDirective, inputs: { value: "value" }, outputs: { valueChanged: "valueChanged" } });
ItemPropertyValueChangedDirective.ctorParameters = () => [
    { type: String }
];
__decorate([
    Input()
], ItemPropertyValueChangedDirective.prototype, "value", null);
__decorate([
    Output()
], ItemPropertyValueChangedDirective.prototype, "valueChanged", void 0);
/** @hidden */
let ColumnChooserItemBaseDirective = class ColumnChooserItemBaseDirective extends ItemPropertyValueChangedDirective {
    constructor(prop) {
        super(prop);
        this.prop = prop;
        this.indentation = 30;
    }
    get column() {
        return this.object;
    }
    set column(value) {
        if (value) {
            this.object = value;
        }
    }
    get name() {
        return (this.column) ? ((this.column.header) ? this.column.header : this.column.field) : '';
    }
    get level() {
        return this.column.level;
    }
    get calcIndent() {
        return this.indentation * this.level;
    }
};
ColumnChooserItemBaseDirective.ɵfac = function ColumnChooserItemBaseDirective_Factory(t) { return new (t || ColumnChooserItemBaseDirective)(ɵngcc0.ɵɵdirectiveInject(String)); };
ColumnChooserItemBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnChooserItemBaseDirective, inputs: { indentation: "indentation", column: "column", container: "container" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
ColumnChooserItemBaseDirective.ctorParameters = () => [
    { type: String }
];
__decorate([
    Input()
], ColumnChooserItemBaseDirective.prototype, "column", null);
__decorate([
    Input()
], ColumnChooserItemBaseDirective.prototype, "indentation", void 0);
__decorate([
    Input()
], ColumnChooserItemBaseDirective.prototype, "container", void 0);

/** @hidden */
let IgxColumnHidingItemDirective = class IgxColumnHidingItemDirective extends ColumnChooserItemBaseDirective {
    constructor() {
        super('hidden');
    }
    get disabled() {
        return this.column.disableHiding;
    }
};
IgxColumnHidingItemDirective.ɵfac = function IgxColumnHidingItemDirective_Factory(t) { return new (t || IgxColumnHidingItemDirective)(); };
IgxColumnHidingItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnHidingItemDirective, selectors: [["", "igxColumnHidingItem", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });

class CustomFilteringStrategy extends FilteringStrategy {
    filter(data, expressionsTree) {
        const res = [];
        data.forEach((item) => {
            if (this.matchRecord(item, expressionsTree.filteringOperands[0])) {
                res.push(item);
            }
            else if (item.column.columnGroup) {
                if (item.column.allChildren.findIndex((child) => this.matchRecord(child, expressionsTree.filteringOperands[1]) ||
                    this.matchRecord(child, expressionsTree.filteringOperands[2])) > -1) {
                    res.push(item);
                }
            }
        });
        return res;
    }
}
/** @hidden */
let ColumnChooserBaseDirective = class ColumnChooserBaseDirective {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * Hides/ shows the filtering columns input from the UI.
         */
        this.disableFilter = false;
        /**
         * Access to the columnHidingUI:
         * ```typescript
         * @ViewChild('column-hiding-component')
         *  public columnHidingUI: IgxColumnHidingComponent;
         * ```
         * Sets/gets the max height of the column area.
         * ```typescript
         * let columnsAreaMaxHeight =  this.columnHidingUI.columnsAreaMaxHeight;
         * ```
         *
         * ```html
         * <igx-column-hiding [columnsAreaMaxHeight]="200px"></igx-column-hiding>
         * ```
         */
        this.columnsAreaMaxHeight = '100%';
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-hiding"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         */
        this.cssClass = 'igx-column-hiding';
        /**
         * @hidden
         */
        this._currentColumns = [];
        /**
         * @hidden
         */
        this._gridColumns = [];
        /**
         * @hidden
         */
        this._rawColumns = [];
        /**
         * @hidden
         */
        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * @hidden
         */
        this._filterCriteria = '';
        /**
         * @hidden
         */
        this._filterColumnsPrompt = '';
        /**
         * @hidden
         */
        this._title = '';
    }
    /**
     * Gets the grid columns that are going to be manipulated.
     * ```typescript
     * let gridColumns = this.columnHidingUI.columns;
     * ```
     */
    get columns() {
        return this._gridColumns;
    }
    /**
     * Sets the the grid columns that are going to be manipulated.
     * ```html
     * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
     * ```
     */
    set columns(value) {
        if (value) {
            this._gridColumns = value;
            this.createColumnItems();
            if (this.filterCriteria) {
                this.filter();
            }
        }
    }
    /**
     * Sets/gets the title of the column chooser.
     * ```typescript
     * let title =  this.columnHidingUI.title;
     * ```
     */
    get title() {
        return this._title;
    }
    /**
     * ```html
     * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
     * ```
     */
    set title(value) {
        this._title = (value) ? value : '';
    }
    /**
     * Gets the prompt that is displayed in the filter input.
     * ```typescript
     * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
     * ```
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the prompt that is going to be displayed in the filter input.
     * ```html
     * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
     * ```
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = (value) ? value : '';
    }
    /**
     * Gets the items of the selected columns.
     * ```typescript
     * let columnItems =  this.columnHidingUI.columnItems;
     * ```
     */
    get columnItems() {
        return this._currentColumns;
    }
    /**
     * Gets the value which filters the columns list.
     * ```typescript
     * let filterCriteria =  this.columnHidingUI.filterCriteria;
     * ```
     */
    get filterCriteria() {
        return this._filterCriteria;
    }
    /**
     * Sets the value which filters the columns list.
     * ```html
     *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
     * ```
     */
    set filterCriteria(value) {
        if (!value || value.length === 0) {
            this.clearFiltering();
            this._filterCriteria = '';
            this.cdr.detectChanges();
            return;
        }
        else if (this._filterCriteria && this._filterCriteria.length > value.length) {
            this.clearFiltering();
        }
        this._filterCriteria = value;
        this.filter();
        this.cdr.detectChanges();
    }
    /**
     * Gets the display order of the columns.
     * ```typescript
     * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
     * ```
     */
    get columnDisplayOrder() {
        return this._columnDisplayOrder;
    }
    /**
     * Sets the display order of the columns.
     * ```typescript
     * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
     * ```
     */
    set columnDisplayOrder(value) {
        if (value !== undefined) {
            this.orderColumns(value);
            if (this._filterCriteria.length > 0) {
                this.filter();
            }
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        for (const item of this._currentColumns) {
            item.valueChanged.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    createColumnItems() {
        if (this._gridColumns.length > 0) {
            this._rawColumns = [];
            this._gridColumns.forEach((column) => {
                const item = this.createColumnItem(this, column);
                if (item) {
                    this._rawColumns.push(item);
                }
            });
            this._currentColumns = this._rawColumns.slice(0);
            this.orderColumns(this._columnDisplayOrder);
        }
    }
    /**
     * @hidden
     */
    orderColumns(value) {
        this._columnDisplayOrder = value;
        if (value === ColumnDisplayOrder[ColumnDisplayOrder.Alphabetical] ||
            value === ColumnDisplayOrder.Alphabetical) {
            this._currentColumns = this._rawColumns.slice(0).sort((current, next) => {
                return current.name.toLowerCase().localeCompare(next.name.toLowerCase());
            });
        }
        else {
            this._currentColumns = this._rawColumns;
        }
    }
    /**
     * @hidden
     */
    filter() {
        const filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.Or);
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('name'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('field'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('header'));
        const strategy = new CustomFilteringStrategy();
        this._currentColumns = strategy.filter(this._currentColumns, filteringExpressionsTree);
    }
    /**
     * @hidden
     */
    createFilteringExpression(fieldName) {
        return {
            condition: IgxStringFilteringOperand.instance().condition('contains'),
            fieldName: fieldName,
            ignoreCase: true,
            searchVal: this._filterCriteria
        };
    }
    /**
     * @hidden
     */
    clearFiltering() {
        this.createColumnItems();
    }
};
ColumnChooserBaseDirective.ɵfac = function ColumnChooserBaseDirective_Factory(t) { return new (t || ColumnChooserBaseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
ColumnChooserBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ColumnChooserBaseDirective, hostVars: 1, hostBindings: function ColumnChooserBaseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.cssClass);
    } }, inputs: { disableFilter: "disableFilter", columnsAreaMaxHeight: "columnsAreaMaxHeight", columns: "columns", title: "title", filterColumnsPrompt: "filterColumnsPrompt", columnItems: "columnItems", filterCriteria: "filterCriteria", columnDisplayOrder: "columnDisplayOrder" } });
ColumnChooserBaseDirective.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "columns", null);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "title", null);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "filterColumnsPrompt", null);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "disableFilter", void 0);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "columnItems", null);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "filterCriteria", null);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "columnDisplayOrder", null);
__decorate([
    Input()
], ColumnChooserBaseDirective.prototype, "columnsAreaMaxHeight", void 0);
__decorate([
    HostBinding('attr.class')
], ColumnChooserBaseDirective.prototype, "cssClass", void 0);

let IgxColumnHidingComponent = class IgxColumnHidingComponent extends ColumnChooserBaseDirective {
    constructor(cdr) {
        super(cdr);
        this.cdr = cdr;
        /**
         * Sets/gets the text of the button that shows all columns if they are hidden.
         * ```typescript
         * let showAllButtonText =  this.columnHiding.showAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [showAllText] = "'Show Columns'"></igx-column-hiding>
         * ```
         * @memberof IgxColumnHidingComponent
         */
        this.showAllText = 'Show All';
        /**
         * Sets/gets the text of the button that hides all columns if they are shown.
         * ```typescript
         * let hideAllButtonText =  this.columnHiding.hideAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [hideAllText] = "'Hide Columns'"></igx-column-hiding>
         * ```
         * @memberof IgxColumnHidingComponent
         */
        this.hideAllText = 'Hide All';
        /**
         * An event that is emitted after the columns visibility is changed.
         * Provides references to the `column` and the `newValue` properties as event arguments.
         * ```html
         *  <igx-column-hiding (onColumnVisibilityChanged) = "onColumnVisibilityChanged($event)"></igx-column-hiding>
         * ```
         * @memberof IgxColumnHidingComponent
         */
        this.onColumnVisibilityChanged = new EventEmitter();
        this.destroy$ = new Subject();
    }
    /**
     * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
     * ```html
     * <igx-column-hiding #columnHidingUI
     *     [columns]="grid.columns" [title]="'Column Hiding'">
     * </igx-column-hiding>
     * ```
     * ```typescript
     * @ViewChild("'columnHidingUI'")
     * public columnHiding: IgxColumnHidingComponent;
     * let isHideAlldisabled =  this.columnHiding.disableHideAll;
     * ```
     * @memberof IgxColumnHidingComponent
     */
    get disableHideAll() {
        if (!this.columnItems || this.columnItems.length < 1 ||
            this.hiddenColumnsCount === this.columns.length) {
            return true;
        }
        else if (this.hidableColumns.length < 1 ||
            this.hidableColumns.length === this.hidableColumns.filter((col) => col.value).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
     * ```typescript
     * let isShowAlldisabled =  this.columnHiding.disableShowAll;
     * ```
     * @memberof IgxColumnHidingComponent
     */
    get disableShowAll() {
        if (!this.columnItems || this.columnItems.length < 1 ||
            this.hiddenColumnsCount < 1 || this.hidableColumns.length < 1) {
            return true;
        }
        else if (this.hidableColumns.length === this.hidableColumns.filter((col) => !col.value).length) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Gets the count of the hidden columns.
     * ```typescript
     * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
     * ```
     * @memberof IgxColumnHidingComponent
     */
    get hiddenColumnsCount() {
        return (this.columns) ? this.columns.filter((col) => col.hidden).length : 0;
    }
    /**
     * @hidden
     */
    get hidableColumns() {
        return this.columnItems.filter((col) => !col.disabled);
    }
    /**
     * @hidden
     */
    createColumnItem(container, column) {
        if (column.grid.hasColumnLayouts && !column.columnLayout) {
            return null;
        }
        const item = new IgxColumnHidingItemDirective();
        item.container = container;
        item.column = column;
        item.valueChanged.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.onVisibilityChanged({ column: item.column, newValue: args.newValue });
        });
        return item;
    }
    /**
     * Shows all columns in the grid.
     * ```typescript
     * this.columnHiding.showAllColumns();
     * ```
     * @memberof IgxColumnHidingComponent
     */
    showAllColumns() {
        const collection = this.hidableColumns;
        for (const col of collection) {
            col.value = false;
        }
    }
    /**
     * Hides all columns in the grid.
     * ```typescript
     * this.columnHiding.hideAllColumns();
     * ```
     * @memberof IgxColumnHidingComponent
     */
    hideAllColumns() {
        const collection = this.hidableColumns;
        for (const col of collection) {
            col.value = true;
        }
    }
    /**
     * @hidden
     */
    onVisibilityChanged(args) {
        this.onColumnVisibilityChanged.emit(args);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
};
IgxColumnHidingComponent.ɵfac = function IgxColumnHidingComponent_Factory(t) { return new (t || IgxColumnHidingComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxColumnHidingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnHidingComponent, selectors: [["igx-column-hiding"]], inputs: { showAllText: "showAllText", hideAllText: "hideAllText", disableHideAll: "disableHideAll", disableShowAll: "disableShowAll" }, outputs: { onColumnVisibilityChanged: "onColumnVisibilityChanged" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 10, vars: 9, consts: [[1, "igx-column-hiding__header"], ["class", "igx-column-hiding__header-title", 4, "ngIf"], ["class", "igx-column-hiding__header-input", 4, "ngIf"], [1, "igx-column-hiding__columns"], ["class", "igx-column-hiding__columns-item", 3, "checked", "disabled", "margin-left", "onColumnVisibilityChanged", "change", 4, "ngFor", "ngForOf"], [1, "igx-column-hiding__buttons"], ["igxButton", "", "igxRipple", "", 3, "disabled", "click"], [1, "igx-column-hiding__header-title"], [1, "igx-column-hiding__header-input"], ["igxInput", "", "type", "text", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange"], [1, "igx-column-hiding__columns-item", 3, "checked", "disabled", "onColumnVisibilityChanged", "change"]], template: function IgxColumnHidingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxColumnHidingComponent_h4_1_Template, 2, 1, "h4", 1);
        ɵngcc0.ɵɵtemplate(2, IgxColumnHidingComponent_igx_input_group_2_Template, 2, 2, "igx-input-group", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxColumnHidingComponent_igx_checkbox_4_Template, 2, 5, "igx-checkbox", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵelementStart(6, "button", 6);
        ɵngcc0.ɵɵlistener("click", function IgxColumnHidingComponent_Template_button_click_6_listener() { return ctx.showAllColumns(); });
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "button", 6);
        ɵngcc0.ɵɵlistener("click", function IgxColumnHidingComponent_Template_button_click_8_listener() { return ctx.hideAllColumns(); });
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disableFilter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.columnsAreaMaxHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.hidableColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("disabled", ctx.disableShowAll);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.showAllText);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disableHideAll);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.hideAllText);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxButtonDirective,
        IgxRippleDirective,
        IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxCheckboxComponent], encapsulation: 2 });
IgxColumnHidingComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxColumnHidingComponent.prototype, "disableHideAll", null);
__decorate([
    Input()
], IgxColumnHidingComponent.prototype, "disableShowAll", null);
__decorate([
    Input()
], IgxColumnHidingComponent.prototype, "showAllText", void 0);
__decorate([
    Input()
], IgxColumnHidingComponent.prototype, "hideAllText", void 0);
__decorate([
    Output()
], IgxColumnHidingComponent.prototype, "onColumnVisibilityChanged", void 0);

let IgxColumnPinningItemDirective = class IgxColumnPinningItemDirective extends ColumnChooserItemBaseDirective {
    constructor() {
        super('pinned');
    }
    /**
     * Returns whether a column could be pinned.
     * It's not possible to pin a column if there is not enough space for the unpinned area.
     * ```typescript
     * const columnItem: IgxColumnPinningItemDirective;
     * this.columnItem.pinnable;
     * ```
     */
    get pinnable() {
        return this.column.pinnable;
    }
    /**
     * Returns whether a column have pinning enabled
     */
    get pinningDisabled() {
        return this.column.disablePinning;
    }
};
IgxColumnPinningItemDirective.ɵfac = function IgxColumnPinningItemDirective_Factory(t) { return new (t || IgxColumnPinningItemDirective)(); };
IgxColumnPinningItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnPinningItemDirective, selectors: [["", "igxColumnPinningItem", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });

let IgxColumnPinningComponent = class IgxColumnPinningComponent extends ColumnChooserBaseDirective {
    constructor(cdr) {
        super(cdr);
        this.cdr = cdr;
    }
    /**
     * @hidden
     */
    createColumnItem(container, column) {
        if (column.level !== 0 || column.disablePinning) {
            return null;
        }
        const item = new IgxColumnPinningItemDirective();
        item.container = container;
        item.column = column;
        return item;
    }
    /**
     * @hidden
     */
    checkboxValueChange(event, columnItem) {
        if (event.checked && !columnItem.pinnable) {
            event.checkbox.checked = false;
            return false;
        }
        columnItem.value = !columnItem.value;
    }
    /**
     * @hidden @internal
     */
    get pinnableColumns() {
        return this.columnItems.filter((col) => !col.pinningDisabled);
    }
};
IgxColumnPinningComponent.ɵfac = function IgxColumnPinningComponent_Factory(t) { return new (t || IgxColumnPinningComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxColumnPinningComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnPinningComponent, selectors: [["igx-column-pinning"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 5, consts: [[1, "igx-column-hiding__header"], ["class", "igx-column-hiding__header-title", 4, "ngIf"], ["class", "igx-column-hiding__header-input", 4, "ngIf"], [1, "igx-column-hiding__columns"], ["igxColumnPinningItem", "", "class", "igx-column-hiding__columns-item", 3, "checked", "change", 4, "ngFor", "ngForOf"], [1, "igx-column-hiding__header-title"], [1, "igx-column-hiding__header-input"], ["igxInput", "", "type", "text", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange"], ["igxColumnPinningItem", "", 1, "igx-column-hiding__columns-item", 3, "checked", "change"]], template: function IgxColumnPinningComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxColumnPinningComponent_h4_1_Template, 2, 1, "h4", 1);
        ɵngcc0.ɵɵtemplate(2, IgxColumnPinningComponent_igx_input_group_2_Template, 2, 2, "igx-input-group", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxColumnPinningComponent_igx_checkbox_4_Template, 2, 2, "igx-checkbox", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disableFilter);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.columnsAreaMaxHeight);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.pinnableColumns);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxCheckboxComponent,
        IgxColumnPinningItemDirective], encapsulation: 2 });
IgxColumnPinningComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];

/**
 * **Ignite UI for Angular Icon Service** -
 *
 * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
 * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given fontSet.
 *
 * Example:
 * ```typescript
 * this.iconService.registerFontSetAlias('material', 'material-icons');
 * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
 * ```
 */
let IgxIconService = class IgxIconService {
    constructor(_sanitizer, _document) {
        this._sanitizer = _sanitizer;
        this._document = _document;
        this._fontSet = 'material-icons';
        this._fontSetAliases = new Map();
        this._cachedSvgIcons = new Set();
        this._iconLoaded = new Subject();
        /**
         * Observable that emits when an icon is successfully loaded
         * through a HTTP request.
         * @example
         * ```typescript
         * this.service.iconLoaded.subscribe((ev: IgxIconLoadedEvent) => ...);
         * ```
         */
        this.iconLoaded = this._iconLoaded.asObservable();
    }
    /**
     *  Returns the default font set.
     * ```typescript
     *   const defaultFontSet = this.iconService.defaultFontSet;
     * ```
     */
    get defaultFontSet() {
        return this._fontSet;
    }
    /**
     *  Sets the default font set.
     * ```typescript
     *   this.iconService.defaultFontSet = 'svg-flags';
     * ```
     */
    set defaultFontSet(className) {
        this._fontSet = className;
    }
    /**
     *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
     * ```typescript
     *   this.iconService.registerFontSetAlias('material', 'material-icons');
     * ```
     */
    registerFontSetAlias(alias, className = alias) {
        this._fontSetAliases.set(alias, className);
        return this;
    }
    /**
     *  Returns the custom class, if any, associated to a given fontSet.
     * ```typescript
     *   const fontSetClass = this.iconService.fontSetClassName('material');
     * ```
     */
    fontSetClassName(alias) {
        return this._fontSetAliases.get(alias) || alias;
    }
    /**
     *  Adds an SVG image to the cache. SVG source is an url.
     * ```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */
    addSvgIcon(iconName, url, fontSet = '') {
        if (iconName && url) {
            const safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
            if (!safeUrl) {
                throw new Error(`The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: "${url}".`);
            }
            const sanitizedUrl = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
            if (!sanitizedUrl) {
                throw new Error(`The URL provided was not trusted as a resource URL: "${url}".`);
            }
            this.fetchSvg(iconName, url, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `url` to register an svg icon.');
        }
    }
    /**
     *  Adds an SVG image to the cache. SVG source is its text.
     * ```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     */
    addSvgIconFromText(iconName, iconText, fontSet = '') {
        if (iconName && iconText) {
            this.cacheSvgIcon(iconName, iconText, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `iconText` to register an svg icon.');
        }
    }
    /**
     *  Returns whether a given SVG image is present in the cache.
     * ```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     */
    isSvgIconCached(iconName, fontSet = '') {
        const iconKey = this.getSvgIconKey(iconName, fontSet);
        return this._cachedSvgIcons.has(iconKey);
    }
    /**
     *  Returns the key of a cached SVG image.
     * ```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     */
    getSvgIconKey(iconName, fontSet = '') {
        return fontSet + '_' + iconName;
    }
    /**
     * @hidden
     */
    fetchSvg(iconName, url, fontSet = '') {
        const instance = this;
        const httpRequest = new XMLHttpRequest();
        httpRequest.open('GET', url, true);
        httpRequest.responseType = 'text';
        // load – when the result is ready, that includes HTTP errors like 404.
        httpRequest.onload = function (event) {
            if (event) {
                const request = event.target;
                if (request.status === 200) {
                    instance.cacheSvgIcon(iconName, request.responseText, fontSet);
                    instance._iconLoaded.next({ name: iconName, value: request.responseText, fontSet });
                }
                else {
                    throw new Error(`Could not fetch SVG from url: ${url}; error: ${request.status} (${request.statusText})`);
                }
            }
            else {
                throw new Error(`Could not fetch SVG from url: ${url};`);
            }
        };
        // error – when the request couldn’t be made, e.g.network down or invalid URL.
        httpRequest.onerror = function (event) {
            if (event) {
                const request = event.target;
                throw new Error(`Could not fetch SVG from url: ${url}; error status code: ${request.status} (${request.statusText})`);
            }
            throw new Error(`Could not fetch SVG from url: ${url};`);
        };
        httpRequest.send();
    }
    /**
     * @hidden
     */
    cacheSvgIcon(iconName, value, fontSet = '') {
        if (iconName && value) {
            this.ensureSvgContainerCreated();
            const div = this._document.createElement('DIV');
            div.innerHTML = value;
            const svg = div.querySelector('svg');
            if (svg) {
                const iconKey = this.getSvgIconKey(iconName, fontSet);
                svg.setAttribute('id', iconKey);
                svg.setAttribute('fit', '');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                if (this._cachedSvgIcons.has(iconKey)) {
                    const oldChild = this._svgContainer.querySelector(`svg[id='${iconKey}']`);
                    this._svgContainer.removeChild(oldChild);
                }
                this._svgContainer.appendChild(svg);
                this._cachedSvgIcons.add(iconKey);
            }
        }
    }
    /**
     * @hidden
     */
    ensureSvgContainerCreated() {
        if (!this._svgContainer) {
            this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
            if (!this._svgContainer) {
                this._svgContainer = this._document.createElement('DIV');
                this._svgContainer.classList.add('igx-svg-container');
                this._document.documentElement.appendChild(this._svgContainer);
            }
        }
    }
};
IgxIconService.ɵfac = function IgxIconService_Factory(t) { return new (t || IgxIconService)(ɵngcc0.ɵɵinject(ɵngcc4.DomSanitizer), ɵngcc0.ɵɵinject(DOCUMENT)); };
IgxIconService.ctorParameters = () => [
    { type: DomSanitizer },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
IgxIconService.ɵprov = ɵɵdefineInjectable({ factory: function IgxIconService_Factory() { return new IgxIconService(ɵɵinject(DomSanitizer), ɵɵinject(DOCUMENT)); }, token: IgxIconService, providedIn: "root" });
IgxIconService = __decorate([ __param(1, Inject(DOCUMENT))
], IgxIconService);

/* tslint:disable */
var icons = [
    {
        name: 'add_filter',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19 15v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3zM5 10h10v2H5zM2 5h16v2H2zM8 15h4v2H8z"/>
      </svg>`
    },
    {
        name: 'contains',
        value: `<svg xmlns="http://www.w3.org/2000/svg" id="Layer_1" data-name="Layer 1" viewBox="0 0 24 24">
        <path d="M3 3v18h18V3zm16 16H5V5h14z"/>
        <path d="M12 11.3a4.39 4.39 0 0 0-2.54.63 2.07 2.07 0 0 0-.9 1.78 2.29 2.29 0 0 0 .66 1.74 2.63 2.63 0 0 0 1.89.63 2.39 2.39 0 0 0 1.32-.37 3.05 3.05 0 0 0 1-.93 3.72 3.72 0 0 0 .08.57c0 .19.1.38.16.58h1.79a4.51 4.51 0 0 1-.21-.88 5.57 5.57 0 0 1-.07-.93v-3.5a2.44 2.44 0 0 0-.84-2 3.34 3.34 0 0 0-2.22-.7 3.54 3.54 0 0 0-2.3.72A1.93 1.93 0 0 0 9 10.29h1.71a.93.93 0 0 1 .29-.71 1.5 1.5 0 0 1 1-.29 1.45 1.45 0 0 1 1 .35 1.3 1.3 0 0 1 .37 1v.69zm1.4 1.08v1.17a1.61 1.61 0 0 1-.71.77 2.27 2.27 0 0 1-1.21.34 1.18 1.18 0 0 1-.84-.27.92.92 0 0 1-.3-.72 1.16 1.16 0 0 1 .44-.9 1.76 1.76 0 0 1 1.22-.39z"/>
      </svg>`
    },
    {
        name: 'does_not_contain',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21,19.74V3H4.26L2.89,1.63,1.63,2.92,3,4.29V21H19.73l1.37,1.37,1.27-1.26ZM5,19V6.28l5.28,5.27a3.19,3.19,0,0,0-.81.38,2.07,2.07,0,0,0-.9,1.78,2.29,2.29,0,0,0,.66,1.74,2.63,2.63,0,0,0,1.89.63,2.39,2.39,0,0,0,1.32-.37,3.05,3.05,0,0,0,1-.93,3.72,3.72,0,0,0,.08.57c0,.19.1.38.16.58h1L17.73,19Zm5.79-6.23a1.31,1.31,0,0,1,.45-.25l1.37,1.36.28.29a1.57,1.57,0,0,1-.19.15,2.27,2.27,0,0,1-1.21.34,1.18,1.18,0,0,1-.84-.27.92.92,0,0,1-.3-.72A1.16,1.16,0,0,1,10.79,12.77Zm2.6-1.47h-.83L10.94,9.68l.08-.1a1.5,1.5,0,0,1,1-.29,1.45,1.45,0,0,1,1,.35,1.3,1.3,0,0,1,.37,1ZM19,17.74l-3.85-3.85V10.62a2.44,2.44,0,0,0-.84-2,3.34,3.34,0,0,0-2.22-.7,3.64,3.64,0,0,0-2.24.67L6.26,5H19Z"/>
    </svg>`
    },
    {
        name: 'all',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M2 14h8v2H2zM2 6h12v2H2zM16 17l-3-3-1.5 1.5L16 20l7-7-1.5-1.5L16 17zM2 10h12v2H2z"/>
      </svg>
      `
    },
    {
        name: 'empty',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5 17h2v2H5zM13 17h2v2h-2zM5 13h2v2H5zM17 17h2v2h-2zM13 5h2v2h-2zM9 17h2v2H9zM17 9h2v2h-2zM17 13h2v2h-2zM17 5h2v2h-2zM5 9h2v2H5zM5 5h2v2H5zM9 5h2v2H9z"/>
      </svg>`
    },
    {
        name: 'end_expression',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M13.14 6.76L17.49 12l-4.35 5.24 1.54 1.28L20.09 12l-5.41-6.52-1.54 1.28z"/>
        <path d="M11.91 11h2v2h-2zM7.91 11h2v2h-2zM3.91 11h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'ends_with',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 14.5h2v2H3zM11 14.5h2v2h-2zM7 14.5h2v2H7zM20.8 14.8v-3A2.1 2.1 0 0 0 20 10a3 3 0 0 0-2-.6 3 3 0 0 0-2 .6 1.7 1.7 0 0 0-.7 1.5h1.5a.8.8 0 0 1 .3-.7 1.3 1.3 0 0 1 .9-.3 1.3 1.3 0 0 1 .9.4 1.1 1.1 0 0 1 .3.8v.6H18a3.8 3.8 0 0 0-2.2.6 1.8 1.8 0 0 0-.8 1.5 2 2 0 0 0 .6 1.6 2.3 2.3 0 0 0 1.6.6 2.1 2.1 0 0 0 1.2-.4 2.8 2.8 0 0 0 .8-.8 4.3 4.3 0 0 0 .1.5l.1.5H21a4.1 4.1 0 0 1-.2-.7 5.4 5.4 0 0 1 0-1zm-1.6-.5a1.5 1.5 0 0 1-.6.7 2 2 0 0 1-1 .2 1.1 1.1 0 0 1-.8-.2.8.8 0 0 1-.2-.6 1 1 0 0 1 .3-.8 1.5 1.5 0 0 1 1.1-.3h1.2z"/>
      </svg>`
    },
    {
        name: 'equals',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5 13.5h14v2H5zM5 8.5h14v2H5z"/>
      </svg>`
    },
    {
        name: 'greater_than_or_equal',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5.99 19h12.02v2H5.99zM18 9.47L6 3v2.11L15.09 10 6 14.9v2.11l12-6.47V9.47z"/>
      </svg>`
    },
    {
        name: 'greater_than',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M6 7.11L15.09 12 6 16.89V19l12-6.46v-1.08L6 5v2.11z"/>
      </svg>
      `
    },
    {
        name: 'is_after',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15 7h4v10h-4v2h6V5h-6v2zM11 3h2v18h-2zM7 5h2v2H7zM3 5h2v2H3zM3 17h2v2H3zM3 13h2v2H3zM3 9h2v2H3zM7 17h2v2H7z"/>
      </svg>`
    },
    {
        name: 'is_before',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 19h6v-2H5V7h4V5H3v14zM11 3h2v18h-2zM15 5h2v2h-2zM19 5h2v2h-2zM19 13h2v2h-2zM15 17h2v2h-2zM19 17h2v2h-2zM19 9h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'is_false',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm4.31 9.79l-1.52 1.52L8 13.52l-2.79 2.79-1.52-1.52L6.48 12 3.69 9.21l1.52-1.52L8 10.48l2.79-2.79 1.52 1.52L9.52 12zM18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7z"/>
        <path d="M17.52 13.85l2.91-2.92-.78-.78-2.13 2.12-1.17-1.15-.38.37-.41.41.42.42L17 13.34l.52.51z"/>
      </svg>`
    },
    {
        name: 'is_not_null',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M16.58 6.07l.79-1.36-1.74-1-.78 1.35a7.5 7.5 0 0 0-7.43 12.87l-.79 1.36 1.74 1 .78-1.35a7.5 7.5 0 0 0 7.43-12.87zM6.5 12A5.5 5.5 0 0 1 12 6.5a5.65 5.65 0 0 1 1.84.32l-5.41 9.36A5.49 5.49 0 0 1 6.5 12zm5.5 5.5a5.65 5.65 0 0 1-1.84-.32l5.41-9.36A5.5 5.5 0 0 1 12 17.5z"/>
      </svg>`
    },
    {
        name: 'is_null',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 4.5a7.5 7.5 0 1 0 7.5 7.5A7.5 7.5 0 0 0 12 4.5zm0 13a5.5 5.5 0 1 1 5.5-5.5 5.5 5.5 0 0 1-5.5 5.5z"/>
      </svg>`
    },
    {
        name: 'is_true',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19.44 14.22zM16.56 14.22zM16.56 14.22L18 12.79l1.44 1.43.78-.78L18.79 12l1.43-1.44-.78-.78L18 11.21l-1.44-1.43-.78.78L17.21 12l-1.43 1.44.78.78z"/>
        <path d="M18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7zM8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm-.93 10.18l-3.38-3.37 1.13-1.12 2.25 2.25 4.11-4.12 1.13 1.12z"/>
      </svg>`
    },
    {
        name: 'last_month',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M17.5 14a4.48 4.48 0 1 0 4.5 4.5 4.47 4.47 0 0 0-4.5-4.5zm3.5 5.5h-4v2l-3-3 3-3v2h4zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z"/>
        <path d="M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z"/>
      </svg>`
    },
    {
        name: 'last_year',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 10v11H7v2h14a2 2 0 0 0 2-2V10z"/>
        <path d="M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z"/>
        <path d="M8.87 9l-2.99 3 2.99 3v-2.25h5.26v-1.5H8.87V9z"/>
      </svg>`
    },
    {
        name: 'less_than_or_equal',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5.99 19h12.02v2H5.99zM18 14.9L8.91 10 18 5.11V3L6 9.47v1.07l12 6.47V14.9z"/>
      </svg>`
    },
    {
        name: 'less_than',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M6 12.54L18 19v-2.11L8.91 12 18 7.11V5L6 11.46v1.08z"/>
      </svg>`
    },
    {
        name: 'next_month',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M20 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2 6.74v-2h-4v-2h4v-2l3 3zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z"/>
        <path d="M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z"/>
      </svg>`
    },
    {
        name: 'next_year',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z"/>
        <path d="M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z"/>
        <path d="M11.13 11.25H5.88v1.5h5.25V15l3-3-3-3v2.25z"/>
      </svg>`
    },
    {
        name: 'not_empty',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M5 9h2v2H5zM9 17h2v2H9zM13 17h2v2h-2zM17 9h2v2h-2zM17 5h2v2h-2zM5 17h2v2H5zM13 5h2v2h-2zM5 13h2v2H5zM19 15v-2h-2v.47L18.53 15H19zM11 7V5H9v.46L10.54 7H11zM2.76 1.76L1.5 3.06 20.97 22.5l1.26-1.26-8.89-8.89L2.76 1.76z"/>
      </svg>`
    },
    {
        name: 'not_equal',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M17.37 4.71l-1.74-1-2.76 4.79H5v2h6.71l-1.73 3H5v2h3.82l-2.19 3.79 1.74 1 2.76-4.79H19v-2h-6.71l1.73-3H19v-2h-3.82l2.19-3.79z"/>
      </svg>`
    },
    {
        name: 'start_expression',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M18.1 11h2v2h-2zM10.1 11h2v2h-2z"/>
        <path d="M10.9 6.8L9.3 5.5 4 12l5.4 6.5 1.6-1.3L6.5 12 11 6.8zM14.1 11h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'starts_with',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path fill="none" d="M4.97 13.23h3.06L6.5 9.12l-1.53 4.11z"/>
        <path d="M5.89 7.5L2 16.5h1.72l.73-1.8h4.1l.73 1.8H11l-3.89-9zM5 13.23l1.5-4.11L8 13.23zM12 14.5h2v2h-2zM20 14.5h2v2h-2zM16 14.5h2v2h-2z"/>
      </svg>`
    },
    {
        name: 'this_month',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M6 9h2v2H6zM6 13h2v2H6zM11 13h2v2h-2zM6 17h2v2H6zM11 17h2v2h-2zM11 9h2v2h-2zM16 9h2v2h-2zM21 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2.94 5.41l-1.75-1.76.69-.71 1.05 1L20 16.83l.71.71z"/>
        <path d="M5 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1H6v2H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H5z"/>
      </svg>`
    },
    {
        name: 'this_year',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z"/>
        <path d="M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z"/>
        <path d="M8.85 13.15l-1.77-1.77-.88.89 2.65 2.65 4.95-4.96-.88-.88-4.07 4.07z"/>
      </svg>`
    },
    {
        name: 'today',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z"/>
        <path d="M16.53 12.06L15.47 11l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 18l5.94-5.94z"/>
      </svg>`
    },
    {
        name: 'ungroup',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15 15h5v5h-5zM6 13h5v5H6zM13 6h5v5h-5zM6 6h5v5H6z"/>
        <path d="M20 2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9v-2H4V4h16v9h2V4a2 2 0 0 0-2-2z"/>
      </svg>`
    },
    {
        name: 'yesterday',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M10.68 15.38h6.13v-1.75h-6.13V11l-3.49 3.5 3.49 3.5v-2.62z"/>
        <path d="M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z"/>
      </svg>`
    },
    {
        name: 'pin',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M15.18 2.25l7.07 7.07-2.83-.01-3.54 3.55.01 4.24-3.53-3.54-5.66 5.66H5.28V17.8l5.66-5.66L7.4 8.61l4.24.01 3.55-3.54-.01-2.83z"/>
      </svg>`
    },
    {
        name: 'unpin',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path fill="none" d="M0 0h24v25H0V0z"/>
        <path d="M11.84 14.08L6.7 19.22H5.28V17.8l5.14-5.14L2 4.26 3.29 3l18 18L20 22.21zm4-.49l-5-5h.73l3.55-3.54v-2.8l7.07 7.07h-2.77l-3.54 3.54z" />
      </svg>`
    },
    {
        name: 'ungroup',
        value: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M18,4.5H6A1.5,1.5,0,0,0,4.5,6V18A1.5,1.5,0,0,0,6,19.5h6.75V18H6V6H18v6.75h1.5V6A1.5,1.5,0,0,0,18,4.5Z"/>
          <rect x="7.5" y="12.75" width="3.75" height="3.75"/>
          <rect x="14.25" y="14.25" width="3.75" height="3.75"/>
          <rect x="7.5" y="7.5" width="3.75" height="3.75"/>
          <rect x="12.75" y="7.5" width="3.75" height="3.75"/>
        </svg>`
    },
    {
        name: 'jump_up',
        value: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M6 8l4 4H7c0 3.31 2.69 6 6 6 1.01 0 1.97-.25 2.8-.7l1.46 1.46A7.93 7.93 0 0113 20c-4.42 0-8-3.58-8-8H2l4-4zm15-5v2H5V3h16z"/>
        </svg>`
    },
    {
        name: 'jump_down',
        value: `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M21 19v2H5v-2h16zM13 4c1.57 0 3.03.46 4.26 1.24L15.8 6.7A5.87 5.87 0 0013 6c-3.31 0-6 2.69-6 6h3l-4 4-4-4h3c0-4.42 3.58-8 8-8z"/>
        </svg>`
    }
];

const FILTERING_ICONS_FONT_SET = 'filtering-icons';
/**
 * This class encapsulates the Toolbar's logic and is internally used by
 * the `IgxGridComponent`, `IgxTreeGridComponent` and `IgxHierarchicalGridComponent`.
 */
let IgxGridToolbarComponent = class IgxGridToolbarComponent extends DisplayDensityBase {
    constructor(gridAPI, cdr, excelExporter, csvExporter, _displayDensityOptions, iconService) {
        super(_displayDensityOptions);
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.excelExporter = excelExporter;
        this.csvExporter = csvExporter;
        this._displayDensityOptions = _displayDensityOptions;
        this.iconService = iconService;
        this._filterColumnsPrompt = 'Filter columns list ...';
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        this._positionSettings = {
            horizontalDirection: HorizontalAlignment.Left,
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._overlaySettings = {
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludePositionTarget: true
        };
    }
    /**
     * Gets the default text shown in the filtering box.
     * ```typescript
     * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
     * ```
     */
    get filterColumnsPrompt() {
        return this._filterColumnsPrompt;
    }
    /**
     * Sets the default text shown in the filtering box.
     * ```typescript
     * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
     * ```
     */
    set filterColumnsPrompt(value) {
        this._filterColumnsPrompt = value;
    }
    /**
     * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
     * ```typescript
     * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
     * ```
     */
    get defaultDropDownsMaxHeight() {
        const gridHeight = this.grid.totalHeight;
        return (gridHeight) ? gridHeight * 0.7 + 'px' : '100%';
    }
    /**
     * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
     * ```typescript
     * const grid = this.igxGrid1.toolbar.grid;
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Returns whether the `IgxGridComponent` renders an export button.
     * ```typescript
     * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
     * ```
     */
    get shouldShowExportButton() {
        return (this.grid != null && (this.grid.exportExcel || this.grid.exportCsv));
    }
    /**
     * Returns whether the `IgxGridComponent` renders an Excel export button.
     * ```typescript
     * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
     * ```
     */
    get shouldShowExportExcelButton() {
        return (this.grid != null && this.grid.exportExcel);
    }
    /**
     * Returns whether the `IgxGridComponent` renders an CSV export button.
     * ```typescript
     * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
     * ```
     */
    get shouldShowExportCsvButton() {
        return (this.grid != null && this.grid.exportCsv);
    }
    /**
     * Returns how many columns are pinned.
     * ```typescript
     * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
     * ```
     */
    get pinnedColumnsCount() {
        return this.grid.pinnedColumns.filter(col => !col.columnLayout).length;
    }
    /**
     * Returns the theme of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTheme = this.grid.toolbar.hostClass;
     * ```
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-grid-toolbar')];
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
        return this.getComponentDensityClass('igx-grid-toolbar');
    }
    /**
     * Returns the title of `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
     * ```
     */
    getTitle() {
        return this.grid != null ? this.grid.toolbarTitle : '';
    }
    /**
     * Returns the text of the export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
     * ```
     */
    getExportText() {
        return this.grid != null ? this.grid.exportText : '';
    }
    /**
     * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
     * ```
     */
    getExportExcelText() {
        return this.grid != null ? this.grid.exportExcelText : '';
    }
    /**
     * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
     * ```
     */
    getExportCsvText() {
        return this.grid != null ? this.grid.exportCsvText : '';
    }
    /**
     * Toggles the export button's dropdown menu.
     * ```typescript
     * this.igxGrid1.toolbar.exportClicked();
     * ```
     */
    exportClicked() {
        this._overlaySettings.positionStrategy.settings.target = this.exportButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.exportDropdown.toggle(this._overlaySettings);
    }
    /**
     * Exports the grid to excel.
     * ```typescript
     * this.igxGrid1.toolbar.exportToExcelClicked();
     * ```
     */
    exportToExcelClicked() {
        this.performExport(this.excelExporter, 'excel');
    }
    /**
     * Exports the grid to CSV.
     * ```typescript
     * this.igxGrid1.toolbar.exportToCsvClicked();
     * ```
     */
    exportToCsvClicked() {
        this.performExport(this.csvExporter, 'csv');
    }
    performExport(exp, exportType) {
        this.exportClicked();
        const fileName = 'ExportedData';
        const options = exportType === 'excel' ?
            new IgxExcelExporterOptions(fileName) :
            new IgxCsvExporterOptions(fileName, CsvFileTypes.CSV);
        const args = { grid: this.grid, exporter: exp, options: options, cancel: false };
        this.grid.onToolbarExporting.emit(args);
        if (args.cancel) {
            return;
        }
        exp.export(this.grid, options);
    }
    /**
     * Toggles the Column Hiding UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnHidingUI();
     * ```
     */
    toggleColumnHidingUI() {
        this._overlaySettings.positionStrategy.settings.target = this.columnHidingButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.columnHidingDropdown.toggle(this._overlaySettings);
    }
    /**
     * Toggles the Column Pinning UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnPinningUI();
     * ```
     */
    toggleColumnPinningUI() {
        this._overlaySettings.positionStrategy.settings.target = this.columnPinningButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.columnPinningDropdown.toggle(this._overlaySettings);
    }
    /**
     * @hidden @internal
     */
    showAdvancedFilteringUI() {
        this.grid.openAdvancedFilteringDialog();
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the
     * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
     * ```typescript
     * const context =  this.igxGrid.toolbar.context;
     * ```
     */
    get context() {
        return {
            // $implicit: this
            grid: this.grid,
            toolbar: this
        };
    }
    /** @hidden */
    get customContentTemplate() {
        if (this.grid != null && this.grid.toolbarCustomContentTemplate != null) {
            return this.grid.toolbarCustomContentTemplate.template;
        }
        else {
            return null;
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        const pinnedIcons = icons.filter(icon => icon.name === 'pin' || icon.name === 'unpin');
        for (const icon of pinnedIcons) {
            if (!this.iconService.isSvgIconCached(icon.name, FILTERING_ICONS_FONT_SET)) {
                this.iconService.addSvgIconFromText(icon.name, icon.value, FILTERING_ICONS_FONT_SET);
            }
        }
    }
};
IgxGridToolbarComponent.ɵfac = function IgxGridToolbarComponent_Factory(t) { return new (t || IgxGridToolbarComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxExcelExporterService, 8), ɵngcc0.ɵɵdirectiveInject(IgxCsvExporterService, 8), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IgxIconService)); };
IgxGridToolbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridToolbarComponent, selectors: [["igx-grid-toolbar"]], viewQuery: function IgxGridToolbarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c21, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(IgxColumnHidingComponent, true);
        ɵngcc0.ɵɵviewQuery(_c22, true, IgxButtonDirective);
        ɵngcc0.ɵɵviewQuery(_c23, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(_c24, true, IgxButtonDirective);
        ɵngcc0.ɵɵviewQuery(_c25, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(IgxColumnPinningComponent, true);
        ɵngcc0.ɵɵviewQuery(_c26, true, IgxButtonDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnHidingDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnHidingUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnHidingButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.exportDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.exportButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnPinningDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnPinningUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnPinningButton = _t.first);
    } }, hostVars: 3, hostBindings: function IgxGridToolbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.hostClass);
        ɵngcc0.ɵɵclassProp("igx-grid-toolbar", ctx.gridID);
    } }, inputs: { class: "class", filterColumnsPrompt: "filterColumnsPrompt", defaultDropDownsMaxHeight: "defaultDropDownsMaxHeight", gridID: "gridID" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 7, vars: 6, consts: [["class", "igx-grid-toolbar__title", 4, "ngIf"], ["class", "igx-grid-toolbar__custom-content", 4, "ngIf"], [1, "igx-grid-toolbar__actions"], [4, "ngIf"], ["class", "igx-grid-toolbar__dropdown", "id", "btnExport", 4, "ngIf"], [1, "igx-grid-toolbar__title"], [1, "igx-grid-toolbar__custom-content"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["igxButton", "outlined", "name", "btnAdvancedFiltering", "igxRipple", "", 3, "displayDensity", "ngClass", "click"], ["advancedFilteringButton", ""], [1, "igx-grid-toolbar__button-space"], ["igxButton", "outlined", "name", "btnColumnHiding", "igxRipple", "", 3, "displayDensity", "click"], ["columnHidingButton", ""], ["columnHidingDropdown", ""], [3, "columns", "title", "filterColumnsPrompt", "columnsAreaMaxHeight", "onColumnVisibilityChanged"], ["igxButton", "outlined", "name", "btnColumnPinning", "igxRipple", "", 3, "displayDensity", "click"], ["columnPinningButton", ""], ["fontSet", "filtering-icons", "name", "pin", 4, "ngIf"], ["fontSet", "filtering-icons", "name", "unpin", 4, "ngIf"], ["columnPinningDropdown", ""], [3, "columns", "title", "filterColumnsPrompt", "columnsAreaMaxHeight"], ["fontSet", "filtering-icons", "name", "pin"], ["fontSet", "filtering-icons", "name", "unpin"], ["id", "btnExport", 1, "igx-grid-toolbar__dropdown"], ["igxButton", "outlined", "igxRipple", "", 3, "displayDensity", "click"], ["btnExport", ""], ["fontSet", "material"], ["exportDropdown", ""], [1, "igx-grid-toolbar__dd-list"], ["class", "igx-grid-toolbar__dd-list-items", "igxRipple", "", "id", "btnExportExcel", 3, "click", 4, "ngIf"], ["class", "igx-grid-toolbar__dd-list-items", "igxRipple", "", "id", "btnExportCsv", 3, "click", 4, "ngIf"], ["igxRipple", "", "id", "btnExportExcel", 1, "igx-grid-toolbar__dd-list-items", 3, "click"], ["igxRipple", "", "id", "btnExportCsv", 1, "igx-grid-toolbar__dd-list-items", 3, "click"]], template: function IgxGridToolbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridToolbarComponent_span_0_Template, 2, 1, "span", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridToolbarComponent_div_1_Template, 2, 2, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, IgxGridToolbarComponent_div_3_Template, 8, 3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, IgxGridToolbarComponent_div_4_Template, 13, 9, "div", 3);
        ɵngcc0.ɵɵtemplate(5, IgxGridToolbarComponent_div_5_Template, 14, 9, "div", 3);
        ɵngcc0.ɵɵtemplate(6, IgxGridToolbarComponent_div_6_Template, 15, 4, "div", 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.getTitle());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.customContentTemplate != null);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.allowAdvancedFiltering);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.columnHiding);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.columnPinning);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldShowExportButton);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxButtonDirective,
        IgxRippleDirective, ɵngcc2.NgClass, IgxIconComponent,
        IgxDropDownComponent,
        IgxColumnHidingComponent,
        IgxColumnPinningComponent]; }, encapsulation: 2 });
IgxGridToolbarComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: IgxExcelExporterService, decorators: [{ type: Optional }] },
    { type: IgxCsvExporterService, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: IgxIconService }
];
__decorate([
    HostBinding('class.igx-grid-toolbar'),
    Input()
], IgxGridToolbarComponent.prototype, "gridID", void 0);
__decorate([
    Input()
], IgxGridToolbarComponent.prototype, "filterColumnsPrompt", null);
__decorate([
    Input()
], IgxGridToolbarComponent.prototype, "class", void 0);
__decorate([
    Input()
], IgxGridToolbarComponent.prototype, "defaultDropDownsMaxHeight", null);
__decorate([
    ViewChild('columnHidingDropdown', { read: IgxDropDownComponent })
], IgxGridToolbarComponent.prototype, "columnHidingDropdown", void 0);
__decorate([
    ViewChild(IgxColumnHidingComponent)
], IgxGridToolbarComponent.prototype, "columnHidingUI", void 0);
__decorate([
    ViewChild('columnHidingButton', { read: IgxButtonDirective })
], IgxGridToolbarComponent.prototype, "columnHidingButton", void 0);
__decorate([
    ViewChild('exportDropdown', { read: IgxDropDownComponent })
], IgxGridToolbarComponent.prototype, "exportDropdown", void 0);
__decorate([
    ViewChild('btnExport', { read: IgxButtonDirective })
], IgxGridToolbarComponent.prototype, "exportButton", void 0);
__decorate([
    ViewChild('columnPinningDropdown', { read: IgxDropDownComponent })
], IgxGridToolbarComponent.prototype, "columnPinningDropdown", void 0);
__decorate([
    ViewChild(IgxColumnPinningComponent)
], IgxGridToolbarComponent.prototype, "columnPinningUI", void 0);
__decorate([
    ViewChild('columnPinningButton', { read: IgxButtonDirective })
], IgxGridToolbarComponent.prototype, "columnPinningButton", void 0);
__decorate([
    HostBinding('attr.class')
], IgxGridToolbarComponent.prototype, "hostClass", null);
IgxGridToolbarComponent = __decorate([ __param(2, Optional()),
    __param(3, Optional()),
    __param(4, Optional()), __param(4, Inject(DisplayDensityToken))
], IgxGridToolbarComponent);

/** @hidden */
let IgxRowEditTemplateDirective = class IgxRowEditTemplateDirective {
};
IgxRowEditTemplateDirective.ɵfac = function IgxRowEditTemplateDirective_Factory(t) { return new (t || IgxRowEditTemplateDirective)(); };
IgxRowEditTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditTemplateDirective, selectors: [["", "igxRowEdit", ""]] });
/** @hidden */
let IgxRowEditTextDirective = class IgxRowEditTextDirective {
};
IgxRowEditTextDirective.ɵfac = function IgxRowEditTextDirective_Factory(t) { return new (t || IgxRowEditTextDirective)(); };
IgxRowEditTextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditTextDirective, selectors: [["", "igxRowEditText", ""]] });
/** @hidden */
let IgxRowEditActionsDirective = class IgxRowEditActionsDirective {
};
IgxRowEditActionsDirective.ɵfac = function IgxRowEditActionsDirective_Factory(t) { return new (t || IgxRowEditActionsDirective)(); };
IgxRowEditActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditActionsDirective, selectors: [["", "igxRowEditActions", ""]] });
// TODO: Refactor circular ref, deps and logic
/** @hidden */
let IgxRowEditTabStopDirective = class IgxRowEditTabStopDirective {
    constructor(api, element) {
        this.api = api;
        this.element = element;
    }
    get grid() {
        return this.api.grid;
    }
    handleTab(event) {
        event.stopPropagation();
        if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
            (this.grid.rowEditTabs.first === this && event.shiftKey)) {
            this.move(event);
        }
    }
    handleEscape(event) {
        this.grid.endEdit(false, event);
        this.grid.tbody.nativeElement.focus();
    }
    /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     * @param event keyboard event containing information about whether SHIFT key was pressed
     */
    move(event) {
        event.preventDefault();
        this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
        this.grid.navigation.activeNode.row = this.grid.rowInEditMode.index;
        this.grid.navigation.activeNode.column = this.currentCellIndex;
        this.grid.navigateTo(this.grid.rowInEditMode.index, this.currentCellIndex, (obj) => {
            obj.target.activate(event);
            this.grid.cdr.detectChanges();
        });
    }
};
IgxRowEditTabStopDirective.ɵfac = function IgxRowEditTabStopDirective_Factory(t) { return new (t || IgxRowEditTabStopDirective)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxRowEditTabStopDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowEditTabStopDirective, selectors: [["", "igxRowEditTabStop", ""]], hostBindings: function IgxRowEditTabStopDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.Tab", function IgxRowEditTabStopDirective_keydown_Tab_HostBindingHandler($event) { return ctx.handleTab($event); })("keydown.Shift.Tab", function IgxRowEditTabStopDirective_keydown_Shift_Tab_HostBindingHandler($event) { return ctx.handleTab($event); })("keydown.Escape", function IgxRowEditTabStopDirective_keydown_Escape_HostBindingHandler($event) { return ctx.handleEscape($event); });
    } } });
IgxRowEditTabStopDirective.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef }
];
__decorate([
    HostListener('keydown.Tab', [`$event`]),
    HostListener('keydown.Shift.Tab', [`$event`])
], IgxRowEditTabStopDirective.prototype, "handleTab", null);
__decorate([
    HostListener('keydown.Escape', [`$event`])
], IgxRowEditTabStopDirective.prototype, "handleEscape", null);

/** @hidden */
let IgxListBaseDirective = class IgxListBaseDirective extends DisplayDensityBase {
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
    }
};
IgxListBaseDirective.ɵfac = function IgxListBaseDirective_Factory(t) { return new (t || IgxListBaseDirective)(ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxListBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListBaseDirective, selectors: [["", "igxListBase", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxListBaseDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
IgxListBaseDirective = __decorate([ __param(0, Optional()), __param(0, Inject(DisplayDensityToken))
], IgxListBaseDirective);
var IgxListPanState;
(function (IgxListPanState) {
    IgxListPanState[IgxListPanState["NONE"] = 0] = "NONE";
    IgxListPanState[IgxListPanState["LEFT"] = 1] = "LEFT";
    IgxListPanState[IgxListPanState["RIGHT"] = 2] = "RIGHT";
})(IgxListPanState || (IgxListPanState = {}));
let IgxEmptyListTemplateDirective = class IgxEmptyListTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxEmptyListTemplateDirective.ɵfac = function IgxEmptyListTemplateDirective_Factory(t) { return new (t || IgxEmptyListTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxEmptyListTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxEmptyListTemplateDirective, selectors: [["", "igxEmptyList", ""]] });
IgxEmptyListTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxDataLoadingTemplateDirective = class IgxDataLoadingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxDataLoadingTemplateDirective.ɵfac = function IgxDataLoadingTemplateDirective_Factory(t) { return new (t || IgxDataLoadingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxDataLoadingTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDataLoadingTemplateDirective, selectors: [["", "igxDataLoading", ""]] });
IgxDataLoadingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxListItemLeftPanningTemplateDirective = class IgxListItemLeftPanningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxListItemLeftPanningTemplateDirective.ɵfac = function IgxListItemLeftPanningTemplateDirective_Factory(t) { return new (t || IgxListItemLeftPanningTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxListItemLeftPanningTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListItemLeftPanningTemplateDirective, selectors: [["", "igxListItemLeftPanning", ""]] });
IgxListItemLeftPanningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxListItemRightPanningTemplateDirective = class IgxListItemRightPanningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxListItemRightPanningTemplateDirective.ɵfac = function IgxListItemRightPanningTemplateDirective_Factory(t) { return new (t || IgxListItemRightPanningTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxListItemRightPanningTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListItemRightPanningTemplateDirective, selectors: [["", "igxListItemRightPanning", ""]] });
IgxListItemRightPanningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
let IgxListItemComponent = class IgxListItemComponent {
    constructor(list, elementRef, _renderer) {
        this.list = list;
        this.elementRef = elementRef;
        this._renderer = _renderer;
        /**
         * @hidden
         */
        this._panState = IgxListPanState.NONE;
        /**
         * @hidden
         */
        this.panOffset = 0;
        /**
         * @hidden
         */
        this._index = null;
        /**
         * @hidden
         */
        this.lastPanDir = IgxListPanState.NONE;
        /**
         * Sets/gets whether the `list item` is hidden.
         * By default the `hidden` value is `false`.
         * ```html
         * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
         * ```
         * ```typescript
         * let isHidden =  this.listItem.hidden;
         * ```
         * @memberof IgxListItemComponent
         */
        this.hidden = false;
        /**
         * Gets the `touch-action` style of the `list item`.
         * ```typescript
         * let touchAction = this.listItem.touchAction;
         * ```
         */
        this.touchAction = 'pan-y';
    }
    /**
     * Gets the `role` attribute of the `list item`.
     * ```typescript
     * let itemRole =  this.listItem.role;
     * ```
     * @memberof IgxListItemComponent
     */
    get role() {
        return this.isHeader ? 'separator' : 'listitem';
    }
    /**
     * Indicates whether `list item` should have header style.
     * ```typescript
     * let headerStyle =  this.listItem.headerStyle;
     * ```
     * @memberof IgxListItemComponent
     */
    get headerStyle() {
        return this.isHeader;
    }
    /**
     * Applies the inner style of the `list item` if the item is not counted as header.
     * ```typescript
     * let innerStyle =  this.listItem.innerStyle;
     * ```
     * @memberof IgxListItemComponent
     */
    get innerStyle() {
        return !this.isHeader;
    }
    /**
     * Returns string value which describes the display mode of the `list item`.
     * ```typescript
     * let isHidden = this.listItem.display;
     * ```
     * @memberof IgxListItemComponent
     */
    get display() {
        return this.hidden ? 'none' : '';
    }
    /**
     * @hidden
     */
    clicked(evt) {
        this.list.onItemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
        this.lastPanDir = IgxListPanState.NONE;
    }
    /**
     * @hidden
     */
    panStart(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
    }
    /**
     * @hidden
     */
    panMove(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        const isPanningToLeft = ev.deltaX < 0;
        if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
            this.showLeftPanTemplate();
            this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
        }
        else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
            this.showRightPanTemplate();
            this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
        }
    }
    /**
     * @hidden
     */
    panEnd(ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        // the translation offset of the current list item content
        const relativeOffset = this.panOffset;
        const widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
        if (relativeOffset === 0) {
            return; // no panning has occured
        }
        const dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;
        this.lastPanDir = dir;
        const oldPanState = this._panState;
        if (Math.abs(relativeOffset) < widthTriggeringGrip) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
            this.hideLeftAndRightPanTemplates();
            return;
        }
        const args = { item: this, direction: dir, keepItem: false };
        if (dir === IgxListPanState.LEFT) {
            this.list.onLeftPan.emit(args);
        }
        else {
            this.list.onRightPan.emit(args);
        }
        if (args.keepItem === true) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
        }
        else {
            if (dir === IgxListPanState.LEFT) {
                this.setContentElementLeft(this.maxLeft);
                this._panState = IgxListPanState.LEFT;
            }
            else {
                this.setContentElementLeft(this.maxRight);
                this._panState = IgxListPanState.RIGHT;
            }
        }
        if (oldPanState !== this._panState) {
            const args2 = { oldState: oldPanState, newState: this._panState, item: this };
            this.list.onPanStateChange.emit(args2);
        }
        this.hideLeftAndRightPanTemplates();
    }
    /**
     * @hidden
     */
    showLeftPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
    }
    /**
     * @hidden
     */
    showRightPanTemplate() {
        this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
    }
    /**
     * @hidden
     */
    hideLeftAndRightPanTemplates() {
        setTimeout(() => {
            this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
        }, 500);
    }
    /**
     * @hidden
     */
    setLeftAndRightTemplatesVisibility(leftVisibility, rightVisibility) {
        if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
            this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
        }
        if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
            this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
        }
    }
    /**
     * Gets the `panState` of a `list item`.
     * ```typescript
     * let itemPanState =  this.listItem.panState;
     * ```
     * @memberof IgxListItemComponent
     */
    get panState() {
        return this._panState;
    }
    /**
     * Gets the `index` of a `list item`.
     * ```typescript
     * let itemIndex =  this.listItem.index;
     * ```
     * @memberof IgxListItemComponent
     */
    get index() {
        return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
    }
    /**
     * Sets the `index` of the `list item`.
     * ```typescript
     * this.listItem.index = index;
     * ```
     * @memberof IgxListItemComponent
     */
    set index(value) {
        this._index = value;
    }
    /**
     * Returns an element reference to the list item.
     * ```typescript
     * let listItemElement =  this.listItem.element.
     * ```
     * @memberof IgxListItemComponent
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns a reference container which contains the list item's content.
     * ```typescript
     * let listItemContainer =  this.listItem.contentElement.
     * ```
     * @memberof IgxListItemComponent
     */
    get contentElement() {
        const candidates = this.element.getElementsByClassName('igx-list__item-content');
        return (candidates && candidates.length > 0) ? candidates[0] : null;
    }
    /**
     * Returns the `context` object which represents the `template context` binding into the `list item container`
     * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
     * ```typescript
     * let listItemComponent = this.listItem.context;
     * ```
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets the width of a `list item`.
     * ```typescript
     * let itemWidth = this.listItem.width;
     * ```
     * @memberof IgxListItemComponent
     */
    get width() {
        if (this.element) {
            return this.element.offsetWidth;
        }
    }
    /**
     * Gets the maximum left position of the `list item`.
     * ```typescript
     * let maxLeft = this.listItem.maxLeft;
     * ```
     * @memberof IgxListItemComponent
     */
    get maxLeft() {
        return -this.width;
    }
    /**
     * Gets the maximum right position of the `list item`.
     * ```typescript
     * let maxRight = this.listItem.maxRight;
     * ```
     * @memberof IgxListItemComponent
     */
    get maxRight() {
        return this.width;
    }
    /**
     * @hidden
     */
    setContentElementLeft(value) {
        this.panOffset = value;
        this.contentElement.style.transform = 'translateX(' + value + 'px)';
    }
    /**
     * @hidden
     */
    isTrue(value) {
        if (typeof (value) === 'boolean') {
            return value;
        }
        else {
            return value === 'true';
        }
    }
};
IgxListItemComponent.ɵfac = function IgxListItemComponent_Factory(t) { return new (t || IgxListItemComponent)(ɵngcc0.ɵɵdirectiveInject(IgxListBaseDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
IgxListItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxListItemComponent, selectors: [["igx-list-item"]], viewQuery: function IgxListItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c27, true);
        ɵngcc0.ɵɵviewQuery(_c28, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.leftPanningTemplateElement = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rightPanningTemplateElement = _t.first);
    } }, hostVars: 10, hostBindings: function IgxListItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxListItemComponent_click_HostBindingHandler($event) { return ctx.clicked($event); })("panstart", function IgxListItemComponent_panstart_HostBindingHandler($event) { return ctx.panStart($event); })("panmove", function IgxListItemComponent_panmove_HostBindingHandler($event) { return ctx.panMove($event); })("panend", function IgxListItemComponent_panend_HostBindingHandler($event) { return ctx.panEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.touchAction)("display", ctx.display);
        ɵngcc0.ɵɵclassProp("igx-list__header", ctx.headerStyle)("igx-list__item-base", ctx.innerStyle);
    } }, inputs: { hidden: "hidden", index: "index", isHeader: "isHeader" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager])], ngContentSelectors: _c30, decls: 12, vars: 4, consts: [["class", "igx-list__item-right", 3, "width", "height", 4, "ngIf"], ["class", "igx-list__item-left", 3, "width", "height", 4, "ngIf"], ["itemsContent", ""], ["itemThumbnails", ""], ["itemLines", ""], ["itemActions", ""], [4, "ngIf"], [1, "igx-list__item-right"], ["leftPanningTmpl", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-list__item-left"], ["rightPanningTmpl", ""], [1, "igx-list__item-thumbnail"], [1, "igx-list__item-lines"], [1, "igx-list__item-actions"], [4, "ngTemplateOutlet"], [1, "igx-list__item-content"]], template: function IgxListItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c29);
        ɵngcc0.ɵɵtemplate(0, IgxListItemComponent_div_0_Template, 3, 6, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxListItemComponent_div_1_Template, 3, 6, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxListItemComponent_ng_template_2_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxListItemComponent_ng_template_4_Template, 2, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxListItemComponent_ng_template_6_Template, 2, 0, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxListItemComponent_ng_template_8_Template, 2, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxListItemComponent_ng_container_10_Template, 2, 1, "ng-container", 6);
        ɵngcc0.ɵɵtemplate(11, IgxListItemComponent_ng_container_11_Template, 6, 4, "ng-container", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader && ctx.list.listItemLeftPanningTemplate != null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader && ctx.list.listItemRightPanningTemplate != null);
        ɵngcc0.ɵɵadvance(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
IgxListItemComponent.ctorParameters = () => [
    { type: IgxListBaseDirective },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    ViewChild('leftPanningTmpl')
], IgxListItemComponent.prototype, "leftPanningTemplateElement", void 0);
__decorate([
    ViewChild('rightPanningTmpl')
], IgxListItemComponent.prototype, "rightPanningTemplateElement", void 0);
__decorate([
    Input()
], IgxListItemComponent.prototype, "isHeader", void 0);
__decorate([
    Input()
], IgxListItemComponent.prototype, "hidden", void 0);
__decorate([
    HostBinding('attr.role')
], IgxListItemComponent.prototype, "role", null);
__decorate([
    HostBinding('attr.aria-label')
], IgxListItemComponent.prototype, "ariaLabel", void 0);
__decorate([
    HostBinding('style.touch-action')
], IgxListItemComponent.prototype, "touchAction", void 0);
__decorate([
    HostBinding('class.igx-list__header')
], IgxListItemComponent.prototype, "headerStyle", null);
__decorate([
    HostBinding('class.igx-list__item-base')
], IgxListItemComponent.prototype, "innerStyle", null);
__decorate([
    HostBinding('style.display')
], IgxListItemComponent.prototype, "display", null);
__decorate([
    HostListener('click', ['$event'])
], IgxListItemComponent.prototype, "clicked", null);
__decorate([
    HostListener('panstart', ['$event'])
], IgxListItemComponent.prototype, "panStart", null);
__decorate([
    HostListener('panmove', ['$event'])
], IgxListItemComponent.prototype, "panMove", null);
__decorate([
    HostListener('panend', ['$event'])
], IgxListItemComponent.prototype, "panEnd", null);
__decorate([
    Input()
], IgxListItemComponent.prototype, "index", null);

var IgxListComponent_1;
let NEXT_ID$7 = 0;
/**
 * igxListThumbnail is container for the List media
 * Use it to wrap anything you want to be used as a thumbnail.
 */
let IgxListThumbnailDirective = class IgxListThumbnailDirective {
};
IgxListThumbnailDirective.ɵfac = function IgxListThumbnailDirective_Factory(t) { return new (t || IgxListThumbnailDirective)(); };
IgxListThumbnailDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListThumbnailDirective, selectors: [["", "igxListThumbnail", ""]] });
/**
 * igxListAction is container for the List action
 * Use it to wrap anything you want to be used as a list action: icon, checkbox...
 */
let IgxListActionDirective = class IgxListActionDirective {
};
IgxListActionDirective.ɵfac = function IgxListActionDirective_Factory(t) { return new (t || IgxListActionDirective)(); };
IgxListActionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListActionDirective, selectors: [["", "igxListAction", ""]] });
/**
 * igxListLine is container for the List text content
 * Use it to wrap anything you want to be used as a plane text.
 */
let IgxListLineDirective = class IgxListLineDirective {
};
IgxListLineDirective.ɵfac = function IgxListLineDirective_Factory(t) { return new (t || IgxListLineDirective)(); };
IgxListLineDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListLineDirective, selectors: [["", "igxListLine", ""]] });
/**
 * igxListLineTitle is a directive that add class to the target element
 * Use it to make anything to look like list Title.
 */
let IgxListLineTitleDirective = class IgxListLineTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-title';
    }
};
IgxListLineTitleDirective.ɵfac = function IgxListLineTitleDirective_Factory(t) { return new (t || IgxListLineTitleDirective)(); };
IgxListLineTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListLineTitleDirective, selectors: [["", "igxListLineTitle", ""]], hostVars: 2, hostBindings: function IgxListLineTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-list__item-line-title", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-list__item-line-title')
], IgxListLineTitleDirective.prototype, "cssClass", void 0);
/**
 * igxListLineSubTitle is a directive that add class to the target element
 * Use it to make anything to look like list Subtitle.
 */
let IgxListLineSubTitleDirective = class IgxListLineSubTitleDirective {
    constructor() {
        this.cssClass = 'igx-list__item-line-subtitle';
    }
};
IgxListLineSubTitleDirective.ɵfac = function IgxListLineSubTitleDirective_Factory(t) { return new (t || IgxListLineSubTitleDirective)(); };
IgxListLineSubTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxListLineSubTitleDirective, selectors: [["", "igxListLineSubTitle", ""]], hostVars: 2, hostBindings: function IgxListLineSubTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-list__item-line-subtitle", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-list__item-line-subtitle')
], IgxListLineSubTitleDirective.prototype, "cssClass", void 0);
/**
 * Displays a collection of data items in a templatable list format
 *
 * @igxModule IgxListModule
 *
 * @igxTheme igx-list-theme
 *
 * @igxKeywords list, data
 *
 * @igxGroup Grids & Lists
 *
 * @remarks
 * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
 * of list items. Each list item is completely templatable and will support any valid HTML or Angular component.
 *
 * @example
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
let IgxListComponent = IgxListComponent_1 = class IgxListComponent extends IgxListBaseDirective {
    constructor(element, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * Provides a threshold after which the item's panning will be completed automatically.
         *
         * @remarks
         * By default this property is set to 0.5 which is 50% of the list item's width.
         *
         * @example
         * ```html
         * <igx-list [panEndTriggeringThreshold]="0.8"></igx-list>
         * ```
         */
        this.panEndTriggeringThreshold = 0.5;
        /**
         * Sets/gets the `id` of the list.
         *
         * @remarks
         * If not set, the `id` of the first list component will be `"igx-list-0"`.
         *
         * @example
         * ```html
         * <igx-list id="my-first-list"></igx-list>
         * ```
         * ```typescript
         * let listId = this.list.id;
         * ```
         */
        this.id = `igx-list-${NEXT_ID$7++}`;
        /**
         * Sets/gets whether the left panning of an item is allowed.
         *
         * @remarks
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-list [allowLeftPanning]="true"></igx-list>
         * ```
         * ```typescript
         * let isLeftPanningAllowed = this.list.allowLeftPanning;
         * ```
         */
        this.allowLeftPanning = false;
        /**
         * Sets/gets whether the right panning of an item is allowed.
         *
         * @remarks
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-list [allowRightPanning]="true"></igx-list>
         * ```
         * ```typescript
         * let isRightPanningAllowed = this.list.allowRightPanning;
         * ```
         */
        this.allowRightPanning = false;
        /**
         * Sets/gets whether the list is currently loading data.
         *
         * @remarks
         * Set it to display the dataLoadingTemplate while data is being retrieved.
         * Default value is `false`.
         *
         * @example
         * ```html
         *  <igx-list [isLoading]="true"></igx-list>
         * ```
         * ```typescript
         * let isLoading = this.list.isLoading;
         * ```
         */
        this.isLoading = false;
        /**
         * Event emitted when a left pan gesture is executed on a list item.
         *
         * @remarks
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         *
         * @example
         * ```html
         * <igx-list [allowLeftPanning]="true" (onLeftPan)="onLeftPan($event)"></igx-list>
         * ```
         */
        this.onLeftPan = new EventEmitter();
        /**
         * Event emitted when a right pan gesture is executed on a list item.
         *
         * @remarks
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         *
         * @example
         * ```html
         * <igx-list [allowRightPanning]="true" (onRightPan)="onRightPan($event)"></igx-list>
         * ```
         */
        this.onRightPan = new EventEmitter();
        /**
         *
         * Event emitted when a pan gesture is executed on a list item.
         *
         * @remarks
         * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
         *
         * @example
         * ```html
         * <igx-list (onPanStateChange)="onPanStateChange($event)"></igx-list>
         * ```
         */
        this.onPanStateChange = new EventEmitter();
        /**
         * Event emitted when a list item is clicked.
         *
         * @remarks
         * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
         *
         * @example
         * ```html
         * <igx-list (onItemClicked)="onItemClicked($event)"></igx-list>
         * ```
         */
        this.onItemClicked = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => {
                return a.index - b.index;
            });
        }
        return null;
    }
    /**
     * Gets the `role` attribute value.
     *
     * @example
     * ```typescript
     * let listRole =  this.list.role;
     * ```
     */
    get role() {
        return 'list';
    }
    /**
     * Gets a boolean indicating if the list is empty.
     *
     * @example
     * ```typescript
     * let isEmpty =  this.list.isListEmpty;
     * ```
     */
    get isListEmpty() {
        return !this.children || this.children.length === 0;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClass() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCompact() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
    }
    /**
     * @hidden
     * @internal
     */
    get cssClassCosy() {
        return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
    }
    /**
     * Gets the list `items` excluding the header ones.
     *
     * @example
     * ```typescript
     * let listItems: IgxListItemComponent[] = this.list.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            for (const child of this.sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * Gets the header list `items`.
     *
     * @example
     * ```typescript
     * let listHeaders: IgxListItemComponent[] =  this.list.headers;
     * ```
     */
    get headers() {
        const headers = [];
        if (this.children !== undefined) {
            for (const child of this.children.toArray()) {
                if (child.isHeader) {
                    headers.push(child);
                }
            }
        }
        return headers;
    }
    /**
     * Gets the `context` object of the template binding.
     *
     * @remark
     * Gets the `context` object which represents the `template context` binding into the `list container`
     * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
     *
     * @example
     * ```typescript
     * let listComponent =  this.list.context;
     * ```
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * Gets a `TemplateRef` to the currently used template.
     *
     * @example
     * ```typescript
     * let listTemplate = this.list.template;
     * ```
     */
    get template() {
        if (this.isLoading) {
            return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
        }
        else {
            return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
        }
    }
};
IgxListComponent.ɵfac = function IgxListComponent_Factory(t) { return new (t || IgxListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxListComponent, selectors: [["igx-list"]], contentQueries: function IgxListComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxEmptyListTemplateDirective, true, IgxEmptyListTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDataLoadingTemplateDirective, true, IgxDataLoadingTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxListItemLeftPanningTemplateDirective, true, IgxListItemLeftPanningTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxListItemRightPanningTemplateDirective, true, IgxListItemRightPanningTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxListItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyListTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dataLoadingTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItemLeftPanningTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItemRightPanningTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, viewQuery: function IgxListComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c31, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c32, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultEmptyListTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultDataLoadingTemplate = _t.first);
    } }, hostVars: 10, hostBindings: function IgxListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-list-empty", ctx.isListEmpty)("igx-list", ctx.cssClass)("igx-list--compact", ctx.cssClassCompact)("igx-list--cosy", ctx.cssClassCosy);
    } }, inputs: { panEndTriggeringThreshold: "panEndTriggeringThreshold", id: "id", allowLeftPanning: "allowLeftPanning", allowRightPanning: "allowRightPanning", isLoading: "isLoading" }, outputs: { onLeftPan: "onLeftPan", onRightPan: "onRightPan", onPanStateChange: "onPanStateChange", onItemClicked: "onItemClicked" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxListBaseDirective, useExisting: IgxListComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 6, vars: 1, consts: [["defaultEmptyList", ""], ["defaultDataLoading", ""], [4, "ngIf"], [1, "message"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function IgxListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxListComponent_ng_template_1_Template, 2, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxListComponent_ng_template_3_Template, 2, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxListComponent_ng_container_5_Template, 2, 2, "ng-container", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.children || ctx.children.length === 0 || ctx.isLoading);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    ContentChildren(forwardRef(() => IgxListItemComponent), { descendants: true })
], IgxListComponent.prototype, "children", void 0);
__decorate([
    ContentChild(IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective })
], IgxListComponent.prototype, "emptyListTemplate", void 0);
__decorate([
    ContentChild(IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective })
], IgxListComponent.prototype, "dataLoadingTemplate", void 0);
__decorate([
    ContentChild(IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective })
], IgxListComponent.prototype, "listItemLeftPanningTemplate", void 0);
__decorate([
    ContentChild(IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective })
], IgxListComponent.prototype, "listItemRightPanningTemplate", void 0);
__decorate([
    Input()
], IgxListComponent.prototype, "panEndTriggeringThreshold", void 0);
__decorate([
    ViewChild('defaultEmptyList', { read: TemplateRef, static: true })
], IgxListComponent.prototype, "defaultEmptyListTemplate", void 0);
__decorate([
    ViewChild('defaultDataLoading', { read: TemplateRef, static: true })
], IgxListComponent.prototype, "defaultDataLoadingTemplate", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxListComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxListComponent.prototype, "allowLeftPanning", void 0);
__decorate([
    Input()
], IgxListComponent.prototype, "allowRightPanning", void 0);
__decorate([
    Input()
], IgxListComponent.prototype, "isLoading", void 0);
__decorate([
    Output()
], IgxListComponent.prototype, "onLeftPan", void 0);
__decorate([
    Output()
], IgxListComponent.prototype, "onRightPan", void 0);
__decorate([
    Output()
], IgxListComponent.prototype, "onPanStateChange", void 0);
__decorate([
    Output()
], IgxListComponent.prototype, "onItemClicked", void 0);
__decorate([
    HostBinding('attr.role')
], IgxListComponent.prototype, "role", null);
__decorate([
    HostBinding('class.igx-list-empty')
], IgxListComponent.prototype, "isListEmpty", null);
__decorate([
    HostBinding('class.igx-list')
], IgxListComponent.prototype, "cssClass", null);
__decorate([
    HostBinding('class.igx-list--compact')
], IgxListComponent.prototype, "cssClassCompact", null);
__decorate([
    HostBinding('class.igx-list--cosy')
], IgxListComponent.prototype, "cssClassCosy", null);
IgxListComponent = IgxListComponent_1 = __decorate([ __param(1, Optional()), __param(1, Inject(DisplayDensityToken))
], IgxListComponent);
/**
 * @hidden
 */
let IgxListModule = class IgxListModule {
};
IgxListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxListModule });
IgxListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxListModule_Factory(t) { return new (t || IgxListModule)(); }, imports: [[
            CommonModule,
            IgxRippleModule
        ]] });

let IgxExcelStyleLoadingValuesTemplateDirective = class IgxExcelStyleLoadingValuesTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxExcelStyleLoadingValuesTemplateDirective.ɵfac = function IgxExcelStyleLoadingValuesTemplateDirective_Factory(t) { return new (t || IgxExcelStyleLoadingValuesTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStyleLoadingValuesTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleLoadingValuesTemplateDirective, selectors: [["", "igxExcelStyleLoading", ""]] });
IgxExcelStyleLoadingValuesTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
let IgxExcelStyleSearchComponent = class IgxExcelStyleSearchComponent {
    constructor(cdr) {
        this.cdr = cdr;
    }
    get isLoading() {
        return this._isLoading;
    }
    set isLoading(value) {
        this._isLoading = value;
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    get valuesLoadingTemplate() {
        if (this.grid.excelStyleLoadingValuesTemplateDirective) {
            return this.grid.excelStyleLoadingValuesTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleLoadingValuesTemplate;
        }
    }
    ngAfterViewInit() {
        this.refreshSize();
    }
    refreshSize() {
        requestAnimationFrame(() => {
            this.virtDir.recalcUpdateSizes();
        });
    }
    clearInput() {
        this.searchValue = null;
    }
    onCheckboxChange(eventArgs) {
        const selectedIndex = this.data.indexOf(eventArgs.checkbox.value);
        if (selectedIndex === 0) {
            this.data.forEach(element => {
                element.isSelected = eventArgs.checked;
                this.data[0].indeterminate = false;
            });
        }
        else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;
            if (!this.data.slice(1, this.data.length).find(el => el.isSelected === false)) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = true;
            }
            else if (!this.data.slice(1, this.data.length).find(el => el.isSelected === true)) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = false;
            }
            else {
                this.data[0].indeterminate = true;
            }
        }
        eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
    }
    get itemSize() {
        let itemSize = '40px';
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                itemSize = '32px';
                break;
            case DisplayDensity.compact:
                itemSize = '24px';
                break;
            default: break;
        }
        return itemSize;
    }
    get containerSize() {
        return this.list.element.nativeElement.offsetHeight;
    }
};
IgxExcelStyleSearchComponent.ɵfac = function IgxExcelStyleSearchComponent_Factory(t) { return new (t || IgxExcelStyleSearchComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExcelStyleSearchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleSearchComponent, selectors: [["igx-excel-style-search"]], viewQuery: function IgxExcelStyleSearchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c33, true, IgxInputDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c34, true, IgxListComponent);
        ɵngcc0.ɵɵstaticViewQuery(IgxForOfDirective, true);
        ɵngcc0.ɵɵstaticViewQuery(_c35, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.list = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStyleLoadingValuesTemplate = _t.first);
    } }, inputs: { grid: "grid", data: "data", inline: "inline", column: "column", displayDensity: "displayDensity" }, decls: 14, vars: 17, consts: [["type", "box", 3, "displayDensity"], ["igxPrefix", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange"], ["input", ""], ["igxSuffix", "", "tabindex", "0", 3, "click", 4, "ngIf"], [3, "displayDensity", "isLoading"], ["list", ""], [4, "igxFor", "igxForOf", "igxForScrollOrientation", "igxForContainerSize", "igxForItemSize"], ["igxDataLoading", ""], ["defaultExcelStyleLoadingValuesTemplate", ""], ["igxSuffix", "", "tabindex", "0", 3, "click"], ["tabindex", "-1", 3, "value", "checked", "disableRipple", "indeterminate", "disableTransitions", "change"], [1, "igx-excel-filter__loading"], [4, "ngTemplateOutlet"], [3, "indeterminate"]], template: function IgxExcelStyleSearchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-input-group", 0);
        ɵngcc0.ɵɵelementStart(1, "igx-icon", 1);
        ɵngcc0.ɵɵtext(2, "search");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "input", 2, 3);
        ɵngcc0.ɵɵlistener("ngModelChange", function IgxExcelStyleSearchComponent_Template_input_ngModelChange_3_listener($event) { return ctx.searchValue = $event; });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, IgxExcelStyleSearchComponent_igx_icon_5_Template, 2, 0, "igx-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "igx-list", 5, 6);
        ɵngcc0.ɵɵelementStart(8, "div");
        ɵngcc0.ɵɵtemplate(9, IgxExcelStyleSearchComponent_igx_list_item_9_Template, 3, 6, "igx-list-item", 7);
        ɵngcc0.ɵɵpipe(10, "excelStyleSearchFilter");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, IgxExcelStyleSearchComponent_ng_template_11_Template, 2, 1, "ng-template", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, IgxExcelStyleSearchComponent_ng_template_12_Template, 1, 1, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngModel", ctx.searchValue)("placeholder", ctx.column.grid.resourceStrings.igx_grid_excel_search_placeholder);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.searchValue || ctx.searchValue === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("isLoading", ctx.isLoading);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("overflow", "hidden")("position", "relative");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxForOf", ɵngcc0.ɵɵpipeBind2(10, 14, ctx.data, ctx.searchValue))("igxForScrollOrientation", "vertical")("igxForContainerSize", ctx.containerSize)("igxForItemSize", ctx.itemSize);
    } }, directives: function () { return [IgxInputGroupComponent,
        IgxIconComponent,
        IgxPrefixDirective, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, ɵngcc2.NgIf, IgxListComponent,
        IgxForOfDirective,
        IgxDataLoadingTemplateDirective,
        IgxSuffixDirective,
        IgxListItemComponent,
        IgxCheckboxComponent, ɵngcc2.NgTemplateOutlet, IgxCircularProgressBarComponent]; }, pipes: function () { return [IgxExcelStyleSearchFilterPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxExcelStyleSearchComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxExcelStyleSearchComponent.prototype, "grid", void 0);
__decorate([
    Input()
], IgxExcelStyleSearchComponent.prototype, "data", void 0);
__decorate([
    Input()
], IgxExcelStyleSearchComponent.prototype, "inline", void 0);
__decorate([
    Input()
], IgxExcelStyleSearchComponent.prototype, "column", void 0);
__decorate([
    ViewChild('input', { read: IgxInputDirective, static: true })
], IgxExcelStyleSearchComponent.prototype, "searchInput", void 0);
__decorate([
    ViewChild('list', { read: IgxListComponent, static: true })
], IgxExcelStyleSearchComponent.prototype, "list", void 0);
__decorate([
    Input()
], IgxExcelStyleSearchComponent.prototype, "displayDensity", void 0);
__decorate([
    ViewChild(IgxForOfDirective, { static: true })
], IgxExcelStyleSearchComponent.prototype, "virtDir", void 0);
__decorate([
    ViewChild('defaultExcelStyleLoadingValuesTemplate', { read: TemplateRef, static: true })
], IgxExcelStyleSearchComponent.prototype, "defaultExcelStyleLoadingValuesTemplate", void 0);

/**
 * @hidden
 * @internal
 */
let IgxGridCellStyleClassesPipe = class IgxGridCellStyleClassesPipe {
    transform(cssClasses, value, data, field, index) {
        if (!cssClasses) {
            return '';
        }
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            const callbackOrValue = cssClasses[cssClass];
            const apply = typeof callbackOrValue === 'function' ? callbackOrValue(data, field, value, index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
};
IgxGridCellStyleClassesPipe.ɵfac = function IgxGridCellStyleClassesPipe_Factory(t) { return new (t || IgxGridCellStyleClassesPipe)(); };
IgxGridCellStyleClassesPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxCellStyleClasses", type: IgxGridCellStyleClassesPipe, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxGridCellStylesPipe = class IgxGridCellStylesPipe {
    transform(styles, value, data, field, index) {
        const css = {};
        if (!styles) {
            return css;
        }
        for (const prop of Object.keys(styles)) {
            const res = styles[prop];
            css[prop] = typeof res === 'function' ? res(data, field, value, index) : res;
        }
        return css;
    }
};
IgxGridCellStylesPipe.ɵfac = function IgxGridCellStylesPipe_Factory(t) { return new (t || IgxGridCellStylesPipe)(); };
IgxGridCellStylesPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxCellStyles", type: IgxGridCellStylesPipe, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxGridNotGroupedPipe = class IgxGridNotGroupedPipe {
    transform(value) {
        return value.filter(item => !item.columnGroup);
    }
};
IgxGridNotGroupedPipe.ɵfac = function IgxGridNotGroupedPipe_Factory(t) { return new (t || IgxGridNotGroupedPipe)(); };
IgxGridNotGroupedPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxNotGrouped", type: IgxGridNotGroupedPipe, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxGridTopLevelColumns = class IgxGridTopLevelColumns {
    transform(value) {
        return value.filter(item => item.level === 0);
    }
};
IgxGridTopLevelColumns.ɵfac = function IgxGridTopLevelColumns_Factory(t) { return new (t || IgxGridTopLevelColumns)(); };
IgxGridTopLevelColumns.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxTopLevel", type: IgxGridTopLevelColumns, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxGridFilterConditionPipe = class IgxGridFilterConditionPipe {
    transform(value) {
        return value.split(/(?=[A-Z])/).join(' ');
    }
};
IgxGridFilterConditionPipe.ɵfac = function IgxGridFilterConditionPipe_Factory(t) { return new (t || IgxGridFilterConditionPipe)(); };
IgxGridFilterConditionPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "filterCondition", type: IgxGridFilterConditionPipe, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxGridTransactionPipe = class IgxGridTransactionPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            const result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
            return result;
        }
        return collection;
    }
};
IgxGridTransactionPipe.ɵfac = function IgxGridTransactionPipe_Factory(t) { return new (t || IgxGridTransactionPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridTransactionPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridTransaction", type: IgxGridTransactionPipe, pure: true });
IgxGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 * @internal
 */
let IgxGridPaginatorOptionsPipe = class IgxGridPaginatorOptionsPipe {
    transform(values) {
        return Array.from(new Set([...values])).sort((a, b) => a - b);
    }
};
IgxGridPaginatorOptionsPipe.ɵfac = function IgxGridPaginatorOptionsPipe_Factory(t) { return new (t || IgxGridPaginatorOptionsPipe)(); };
IgxGridPaginatorOptionsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "paginatorOptions", type: IgxGridPaginatorOptionsPipe, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxHasVisibleColumnsPipe = class IgxHasVisibleColumnsPipe {
    transform(values, hasVisibleColumns) {
        if (!(values && values.length)) {
            return values;
        }
        return hasVisibleColumns ? values : [];
    }
};
IgxHasVisibleColumnsPipe.ɵfac = function IgxHasVisibleColumnsPipe_Factory(t) { return new (t || IgxHasVisibleColumnsPipe)(); };
IgxHasVisibleColumnsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "visibleColumns", type: IgxHasVisibleColumnsPipe, pure: true });
/**
 * @hidden
 * @internal
 */
let IgxDatePipeComponent = class IgxDatePipeComponent extends DatePipe {
    constructor(locale) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(locale);
        this.DEFAULT_DATE_FORMAT = 'mediumDate';
    }
    transform(value, locale) {
        if (value && value instanceof Date) {
            if (locale) {
                return super.transform(value, this.DEFAULT_DATE_FORMAT, undefined, locale);
            }
            else {
                return super.transform(value);
            }
        }
        else {
            return value;
        }
    }
};
IgxDatePipeComponent.ɵfac = function IgxDatePipeComponent_Factory(t) { return new (t || IgxDatePipeComponent)(ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxDatePipeComponent.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxdate", type: IgxDatePipeComponent, pure: true });
IgxDatePipeComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxDatePipeComponent = __decorate([ __param(0, Inject(LOCALE_ID))
], IgxDatePipeComponent);
/**
 * @hidden
 * @internal
 */
let IgxDecimalPipeComponent = class IgxDecimalPipeComponent extends DecimalPipe {
    constructor(locale) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(locale);
    }
    transform(value, locale) {
        if (value && typeof value === 'number') {
            if (locale) {
                return super.transform(value, undefined, locale);
            }
            else {
                return super.transform(value);
            }
        }
        else {
            return value;
        }
    }
};
IgxDecimalPipeComponent.ɵfac = function IgxDecimalPipeComponent_Factory(t) { return new (t || IgxDecimalPipeComponent)(ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
IgxDecimalPipeComponent.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxdecimal", type: IgxDecimalPipeComponent, pure: true });
IgxDecimalPipeComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];
IgxDecimalPipeComponent = __decorate([ __param(0, Inject(LOCALE_ID))
], IgxDecimalPipeComponent);
/**
 * @hidden
 */
let IgxGridRowPinningPipe = class IgxGridRowPinningPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, isPinned = false, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.hasPinnedRecords && isPinned) {
            const result = collection.filter(rec => grid.isRecordPinned(rec));
            result.sort((rec1, rec2) => grid.getInitialPinnedIndex(rec1) - grid.getInitialPinnedIndex(rec2));
            return result;
        }
        grid.unpinnedRecords = collection;
        if (!grid.hasPinnedRecords) {
            grid.pinnedRecords = [];
            return isPinned ? [] : collection;
        }
        return collection.map((rec) => {
            return grid.isRecordPinned(rec) ? { recordRef: rec, ghostRecord: true } : rec;
        });
    }
};
IgxGridRowPinningPipe.ɵfac = function IgxGridRowPinningPipe_Factory(t) { return new (t || IgxGridRowPinningPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridRowPinningPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridRowPinning", type: IgxGridRowPinningPipe, pure: true });
IgxGridRowPinningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/** @hidden */
class ExcelStylePositionStrategy extends AutoPositionStrategy {
    shouldFitInViewPort(connectedFit) {
        return true;
    }
    fitInViewport(element, connectedFit) {
        const heightOverflow = connectedFit.contentElementRect.height - connectedFit.viewPortRect.height;
        if (heightOverflow > 0) {
            element.style.width = 'auto';
            element.style.height = `${connectedFit.viewPortRect.height}px`;
        }
        else {
            element.style.height = `${Math.max(connectedFit.viewPortRect.height - connectedFit.targetRect.bottom - 1, connectedFit.contentElementRect.height)}px`;
        }
        super.fitInViewport(element, connectedFit);
    }
}

const FILTERING_ICONS_FONT_SET$1 = 'filtering-icons';
/**
 * @hidden
 */
class ExpressionUI {
    constructor() {
        this.isSelected = false;
        this.isVisible = true;
    }
}
/**
 * @hidden
 */
let IgxFilteringService = class IgxFilteringService {
    constructor(gridAPI, _moduleRef, iconService, _overlayService) {
        this.gridAPI = gridAPI;
        this._moduleRef = _moduleRef;
        this.iconService = iconService;
        this._overlayService = _overlayService;
        this.columnsWithComplexFilter = new Set();
        this.areEventsSubscribed = false;
        this.destroy$ = new Subject();
        this.isFiltering = false;
        this.columnToExpressionsMap = new Map();
        this.columnStartIndex = -1;
        this._filterIconsRegistered = false;
        this.isFilterRowVisible = false;
        this.filteredColumn = null;
        this.selectedExpression = null;
        this.columnToMoreIconHidden = new Map();
        this.activeFilterCell = 0;
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    toggleFilterDropdown(element, column, classRef) {
        if (!this._componentOverlayId || (this.column && this.column.field !== column.field)) {
            this.column = column;
            const filterIcon = this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
            const filterIconTarget = element.querySelector('.' + filterIcon);
            this._filterMenuOverlaySettings.positionStrategy.settings.target = filterIconTarget;
            this._filterMenuOverlaySettings.outlet = this.grid.outlet;
            this._componentOverlayId =
                this._overlayService.attach(classRef, this._filterMenuOverlaySettings, this._moduleRef);
            this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
        }
    }
    initFilteringSettings() {
        this._filterMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: useAnimation(fadeIn, { params: { duration: '250ms' } }),
            closeAnimation: useAnimation(fadeOut, { params: { duration: '200ms' } })
        };
        this._filterMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ExcelStylePositionStrategy(this._filterMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this._overlayService.onOpening.pipe(filter((overlay) => overlay.id === this._componentOverlayId), takeUntil(this.destroy$)).subscribe((eventArgs) => {
            const instance = eventArgs.componentRef.instance;
            if (instance) {
                instance.initialize(this.column, this._overlayService, eventArgs.id);
            }
        });
        this._overlayService.onClosed.pipe(filter(overlay => overlay.id === this._componentOverlayId), takeUntil(this.destroy$)).subscribe(() => {
            this._componentOverlayId = null;
            this.grid.theadRow.nativeElement.focus();
        });
    }
    hideExcelFiltering() {
        if (this._componentOverlayId) {
            this._overlayService.hide(this._componentOverlayId);
        }
    }
    get datePipe() {
        if (!this._datePipe) {
            this._datePipe = new IgxDatePipeComponent(this.grid.locale);
        }
        return this._datePipe;
    }
    /**
     * Subscribe to grid's events.
     */
    subscribeToEvents() {
        if (!this.areEventsSubscribed) {
            this.areEventsSubscribed = true;
            this.grid.onColumnResized.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => {
                this.updateFilteringCell(eventArgs.column);
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(takeUntil(this.destroy$)).subscribe((eventArgs) => {
                if (eventArgs.startIndex !== this.columnStartIndex) {
                    this.columnStartIndex = eventArgs.startIndex;
                    this.grid.filterCellList.forEach((filterCell) => {
                        filterCell.updateFilterCellArea();
                    });
                }
            });
            this.grid.onColumnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.grid.filterCellList.forEach((filterCell) => {
                    filterCell.updateFilterCellArea();
                });
            });
        }
    }
    /**
     * Close filtering row if a column is hidden.
     */
    hideFilteringRowOnColumnVisibilityChange(col) {
        const filteringRow = this.grid.filteringRow;
        if (filteringRow && filteringRow.column && filteringRow.column === col) {
            filteringRow.close();
        }
    }
    /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     */
    filterInternal(field, expressions = null) {
        this.isFiltering = true;
        let expressionsTree;
        if (expressions instanceof FilteringExpressionsTree) {
            expressionsTree = expressions;
        }
        else {
            expressionsTree = this.createSimpleFilteringTree(field, expressions);
        }
        if (expressionsTree.filteringOperands.length === 0) {
            this.clearFilter(field);
        }
        else {
            this.filter(field, null, expressionsTree);
        }
        this.isFiltering = false;
    }
    /**
     * Execute filtering on the grid.
     */
    filter(field, value, conditionOrExpressionTree, ignoreCase) {
        const col = this.gridAPI.get_column_by_name(field);
        const filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
        if (conditionOrExpressionTree) {
            this.gridAPI.filter(field, value, conditionOrExpressionTree, filteringIgnoreCase);
        }
        else {
            const expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
            if (!expressionsTreeForColumn) {
                throw new Error('Invalid condition or Expression Tree!');
            }
            else if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                this.gridAPI.filter(field, value, expressionsTreeForColumn, filteringIgnoreCase);
            }
            else {
                const expressionForColumn = expressionsTreeForColumn;
                this.gridAPI.filter(field, value, expressionForColumn.condition, filteringIgnoreCase);
            }
        }
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(col.filteringExpressionsTree));
    }
    /**
     * Clear the filter of a given column.
     */
    clearFilter(field) {
        if (field) {
            const column = this.gridAPI.get_column_by_name(field);
            if (!column) {
                return;
            }
        }
        this.isFiltering = true;
        this.gridAPI.clear_filter(field);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(null));
        if (field) {
            const expressions = this.getExpressions(field);
            expressions.length = 0;
        }
        this.isFiltering = false;
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     */
    filterGlobal(value, condition, ignoreCase) {
        this.gridAPI.filter_global(value, condition, ignoreCase);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.grid.onFilteringDone.emit(this.grid.filteringExpressionsTree));
    }
    /**
     * Register filtering SVG icons in the icon service.
     */
    registerSVGIcons() {
        if (!this._filterIconsRegistered) {
            for (const icon of icons) {
                if (!this.iconService.isSvgIconCached(icon.name, FILTERING_ICONS_FONT_SET$1)) {
                    this.iconService.addSvgIconFromText(icon.name, icon.value, FILTERING_ICONS_FONT_SET$1);
                }
            }
            this._filterIconsRegistered = true;
        }
    }
    /**
     * Returns the ExpressionUI array for a given column.
     */
    getExpressions(columnId) {
        if (!this.columnToExpressionsMap.has(columnId)) {
            const column = this.grid.columns.find((col) => col.field === columnId);
            const expressionUIs = new Array();
            if (column) {
                this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
                this.columnToExpressionsMap.set(columnId, expressionUIs);
            }
            return expressionUIs;
        }
        return this.columnToExpressionsMap.get(columnId);
    }
    /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     */
    refreshExpressions() {
        if (!this.isFiltering) {
            this.columnsWithComplexFilter.clear();
            this.columnToExpressionsMap.forEach((value, key) => {
                const column = this.grid.columns.find((col) => col.field === key);
                if (column) {
                    value.length = 0;
                    this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, value);
                    const isComplex = this.isFilteringTreeComplex(column.filteringExpressionsTree);
                    if (isComplex) {
                        this.columnsWithComplexFilter.add(key);
                    }
                    this.updateFilteringCell(column);
                }
                else {
                    this.columnToExpressionsMap.delete(key);
                }
            });
        }
    }
    /**
     * Remove an ExpressionUI for a given column.
     */
    removeExpression(columnId, indexToRemove) {
        const expressionsList = this.getExpressions(columnId);
        if (indexToRemove === 0 && expressionsList.length > 1) {
            expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === expressionsList.length - 1) {
            expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
            expressionsList[0].beforeOperator = null;
            expressionsList[expressionsList.length - 1].afterOperator = null;
        }
        expressionsList.splice(indexToRemove, 1);
    }
    /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     */
    createSimpleFilteringTree(columnId, expressionUIList = null) {
        const expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
        const expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);
        let currAndBranch;
        let currExpressionUI;
        for (let i = 0; i < expressionsList.length; i++) {
            currExpressionUI = expressionsList[i];
            if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {
                    currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                    expressionsTree.filteringOperands.push(currAndBranch);
                }
                continue;
            }
            if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                currExpressionUI.beforeOperator === FilteringLogic.Or) &&
                currExpressionUI.afterOperator === FilteringLogic.And) {
                currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                expressionsTree.filteringOperands.push(currAndBranch);
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else if (currExpressionUI.beforeOperator === FilteringLogic.And) {
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else {
                expressionsTree.filteringOperands.push(currExpressionUI.expression);
                currAndBranch = null;
            }
        }
        return expressionsTree;
    }
    /**
     * Returns whether a complex filter is applied to a given column.
     */
    isFilterComplex(columnId) {
        if (this.columnsWithComplexFilter.has(columnId)) {
            return true;
        }
        const column = this.grid.columns.find((col) => col.field === columnId);
        const isComplex = column && this.isFilteringTreeComplex(column.filteringExpressionsTree);
        if (isComplex) {
            this.columnsWithComplexFilter.add(columnId);
        }
        return isComplex;
    }
    /**
     * Returns the string representation of the FilteringLogic operator.
     */
    getOperatorAsString(operator) {
        if (operator === 0) {
            return this.grid.resourceStrings.igx_grid_filter_operator_and;
        }
        else {
            return this.grid.resourceStrings.igx_grid_filter_operator_or;
        }
    }
    /**
     * Generate the label of a chip from a given filtering expression.
     */
    getChipLabel(expression) {
        if (expression.condition.isUnary) {
            return this.grid.resourceStrings[`igx_grid_filter_${expression.condition.name}`] || expression.condition.name;
        }
        else if (expression.searchVal instanceof Date) {
            return this.datePipe.transform(expression.searchVal, this.grid.locale);
        }
        else {
            return expression.searchVal;
        }
    }
    /**
     * Updates the content of a filterCell.
     */
    updateFilteringCell(column) {
        const filterCell = column.filterCell;
        if (filterCell) {
            filterCell.updateFilterCellArea();
        }
    }
    get filteredData() {
        return this.grid.filteredData;
    }
    isFilteringTreeComplex(expressions) {
        if (!expressions) {
            return false;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            const expressionsTree = expressions;
            if (expressionsTree.operator === FilteringLogic.Or) {
                const andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                return andOperatorsCount > 1;
            }
            let isComplex = false;
            for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                isComplex = isComplex || this.isFilteringTreeComplex(expressionsTree.filteringOperands[i]);
            }
            return isComplex;
        }
        return false;
    }
    getChildAndOperatorsCount(expressions) {
        let count = 0;
        let operand;
        for (let i = 0; i < expressions.filteringOperands.length; i++) {
            operand = expressions[i];
            if (operand instanceof FilteringExpressionsTree) {
                if (operand.operator === FilteringLogic.And) {
                    count++;
                }
                count = count + this.getChildAndOperatorsCount(operand);
            }
        }
        return count;
    }
    generateExpressionsList(expressions, operator, expressionsUIs) {
        this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
        // The beforeOperator of the first expression and the afterOperator of the last expression should be null
        if (expressionsUIs.length) {
            expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
        }
    }
    generateExpressionsListRecursive(expressions, operator, expressionsUIs) {
        if (!expressions) {
            return;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            const expressionsTree = expressions;
            for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
                this.generateExpressionsListRecursive(expressionsTree.filteringOperands[i], expressionsTree.operator, expressionsUIs);
            }
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
            }
        }
        else {
            const exprUI = new ExpressionUI();
            exprUI.expression = expressions;
            exprUI.afterOperator = operator;
            const prevExprUI = expressionsUIs[expressionsUIs.length - 1];
            if (prevExprUI) {
                exprUI.beforeOperator = prevExprUI.afterOperator;
            }
            expressionsUIs.push(exprUI);
        }
    }
    isFilteringExpressionsTreeEmpty(expressionTree) {
        if (FilteringExpressionsTree.empty(expressionTree)) {
            return true;
        }
        let expr;
        for (let i = 0; i < expressionTree.filteringOperands.length; i++) {
            expr = expressionTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                const exprTree = expr;
                if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
};
IgxFilteringService.ɵfac = function IgxFilteringService_Factory(t) { return new (t || IgxFilteringService)(ɵngcc0.ɵɵinject(GridBaseAPIService), ɵngcc0.ɵɵinject(ɵngcc0.NgModuleRef), ɵngcc0.ɵɵinject(IgxIconService), ɵngcc0.ɵɵinject(IgxOverlayService)); };
IgxFilteringService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxFilteringService, factory: IgxFilteringService.ɵfac });
IgxFilteringService.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: NgModuleRef },
    { type: IgxIconService },
    { type: IgxOverlayService }
];

/**
 * Icon provides a way to include material icons to markup
 *
 * @igxModule IgxIconModule
 *
 * @igxTheme igx-icon-theme
 *
 * @igxKeywords icon, picture
 *
 * @igxGroup Display
 *
 * @remarks
 *
 * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
 * support custom colors and can be marked as active or disabled using the `isActive` property. This will change the appearance
 * of the icon.
 *
 * @example
 * ```html
 * <igx-icon color="#00ff00" isActive="true">home</igx-icon>
 * ```
 */
let NEXT_ID$8 = 0;
let IgxIconComponent = class IgxIconComponent {
    constructor(_el, iconService, ref) {
        this._el = _el;
        this.iconService = iconService;
        this.ref = ref;
        this.destroy$ = new Subject();
        /**
         *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-icon';
        /**
         *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
         * @example
         * ```typescript
         * @ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *     this.icon.ariaHidden = false;
         *     this.cdRef.detectChanges();
         * }
         * ```
         */
        this.ariaHidden = true;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * @example
         * ```html
         * <igx-icon id="igx-icon-1" fontSet="material">settings</igx-icon>
         * ```
         */
        this.id = `igx-icon-${NEXT_ID$8++}`;
        /**
         * An @Input property that allows you to disable the `active` property. By default it's applied.
         * @example
         * ```html
         * <igx-icon [isActive]="false">settings</igx-icon>
         * ```
         */
        this.active = true;
        this.el = _el;
        this.font = this.iconService.defaultFontSet;
        this.iconService.registerFontSetAlias('material', 'material-icons');
        this.iconService.iconLoaded.pipe(first$1(e => e.name === this.iconName && e.fontSet === this.font), takeUntil(this.destroy$))
            .subscribe(_ => this.ref.detectChanges());
    }
    /**
     * @hidden
     * @internal
     */
    ngOnInit() {
        this.updateIconClass();
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     *  An accessor that returns the value of the font property.
     * @example
     * ```typescript
     *  @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconFont = this.icon.getFontSet;
     * }
     * ```
     */
    get getFontSet() {
        return this.font;
    }
    /**
     *  An accessor that returns the value of the active property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getActive;
     * }
     * ```
     */
    get getActive() {
        return this.active;
    }
    /**
     *  An accessor that returns inactive property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconActive = this.icon.getInactive;
     * }
     * ```
     */
    get getInactive() {
        return !this.active;
    }
    /**
     * An accessor that returns the opposite value of the `iconColor` property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconColor = this.icon.getIconColor;
     * }
     * ```
     */
    get getIconColor() {
        return this.iconColor;
    }
    /**
     * An accessor that returns the value of the iconName property.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconName = this.icon.getIconName;
     * }
     * ```
     */
    get getIconName() {
        return this.iconName;
    }
    /**
     *  An accessor that returns the key of the SVG image.
     *  The key consists of the fontSet and the iconName separated by underscore.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let svgKey = this.icon.getSvgKey;
     * }
     * ```
     */
    get getSvgKey() {
        if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
            return '#' + this.iconService.getSvgIconKey(this.iconName, this.font);
        }
        return null;
    }
    /**
     *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
     * @example
     * ```typescript
     * @ViewChild("MyIcon")
     * public icon: IgxIconComponent;
     * ngAfterViewInit() {
     *    let iconTemplate = this.icon.template;
     * }
     * ```
     */
    get template() {
        if (this.iconName) {
            if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                return this.svgImage;
            }
            return this.noLigature;
        }
        return this.explicitLigature;
    }
    /**
     * @hidden
     * @internal
     */
    updateIconClass() {
        const className = this.iconService.fontSetClassName(this.font);
        this.el.nativeElement.classList.add(className);
        if (this.iconName && !this.iconService.isSvgIconCached(this.iconName, this.font)) {
            this.el.nativeElement.classList.add(this.iconName);
        }
    }
};
IgxIconComponent.ɵfac = function IgxIconComponent_Factory(t) { return new (t || IgxIconComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxIconService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxIconComponent, selectors: [["igx-icon"]], viewQuery: function IgxIconComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c36, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c37, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c38, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.noLigature = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.explicitLigature = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.svgImage = _t.first);
    } }, hostVars: 8, hostBindings: function IgxIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.ariaHidden)("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("color", ctx.getIconColor);
        ɵngcc0.ɵɵclassProp("igx-icon", ctx.cssClass)("igx-icon--inactive", ctx.getInactive);
    } }, inputs: { id: "id", active: ["isActive", "active"], font: ["fontSet", "font"], iconColor: ["color", "iconColor"], iconName: ["name", "iconName"] }, ngContentSelectors: _c2, decls: 7, vars: 1, consts: [["noLigature", ""], ["explicitLigature", ""], ["svgImage", ""], [4, "ngTemplateOutlet"]], template: function IgxIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxIconComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxIconComponent_ng_template_2_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxIconComponent_ng_template_4_Template, 2, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxIconComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
    } }, directives: [ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxIconComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxIconService },
    { type: ChangeDetectorRef }
];
__decorate([
    ViewChild('noLigature', { read: TemplateRef, static: true })
], IgxIconComponent.prototype, "noLigature", void 0);
__decorate([
    ViewChild('explicitLigature', { read: TemplateRef, static: true })
], IgxIconComponent.prototype, "explicitLigature", void 0);
__decorate([
    ViewChild('svgImage', { read: TemplateRef, static: true })
], IgxIconComponent.prototype, "svgImage", void 0);
__decorate([
    HostBinding('class.igx-icon')
], IgxIconComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.aria-hidden')
], IgxIconComponent.prototype, "ariaHidden", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxIconComponent.prototype, "id", void 0);
__decorate([
    Input('fontSet')
], IgxIconComponent.prototype, "font", void 0);
__decorate([
    Input('isActive')
], IgxIconComponent.prototype, "active", void 0);
__decorate([
    Input('color')
], IgxIconComponent.prototype, "iconColor", void 0);
__decorate([
    Input('name')
], IgxIconComponent.prototype, "iconName", void 0);
__decorate([
    HostBinding('class.igx-icon--inactive')
], IgxIconComponent.prototype, "getInactive", null);
__decorate([
    HostBinding('style.color')
], IgxIconComponent.prototype, "getIconColor", null);

/**
 * @hidden
 */
let IgxIconModule = class IgxIconModule {
};
IgxIconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxIconModule });
IgxIconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxIconModule_Factory(t) { return new (t || IgxIconModule)(); }, imports: [[CommonModule]] });

var ButtonGroupAlignment;
(function (ButtonGroupAlignment) {
    ButtonGroupAlignment[ButtonGroupAlignment["horizontal"] = 0] = "horizontal";
    ButtonGroupAlignment[ButtonGroupAlignment["vertical"] = 1] = "vertical";
})(ButtonGroupAlignment || (ButtonGroupAlignment = {}));
let NEXT_ID$9 = 0;
/**
 * **Ignite UI for Angular Button Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
 *
 * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
 * single, multiple and toggle selection.
 *
 * Example:
 * ```html
 * <igx-buttongroup multiSelection="true" [values]="fontOptions">
 * </igx-buttongroup>
 * ```
 * The `fontOptions` value shown above is defined as:
 * ```typescript
 * this.fontOptions = [
 *   { icon: 'format_bold', selected: false },
 *   { icon: 'format_italic', selected: false },
 *   { icon: 'format_underlined', selected: false }];
 * ```
 */
let IgxButtonGroupComponent = class IgxButtonGroupComponent extends DisplayDensityBase {
    constructor(_cdr, _renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this._cdr = _cdr;
        this._renderer = _renderer;
        this._displayDensityOptions = _displayDensityOptions;
        this._disabled = false;
        this.buttonClickNotifier$ = new Subject();
        this.queryListNotifier$ = new Subject();
        /**
         * An @Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
         * ```html
         *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         */
        this.id = `igx-buttongroup-${NEXT_ID$9++}`;
        /**
         * @hidden
         */
        this.zIndex = 0;
        /**
         * An @Input property that enables selecting multiple buttons. By default, multi-selection is false.
         * ```html
         * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
         * ```
         */
        this.multiSelection = false;
        /**
         * @hidden
         */
        this.selectedIndexes = [];
        /**
         * An @Ouput property that emits an event when a button is selected.
         * ```typescript
         * @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onSelect(buttongroup){
         *     this.toast.show()
         * }
         *  //...
         * ```
         * ```html
         * <igx-buttongroup #MyChild [multiSelection]="!multi" (onSelect)="onSelect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have made a selection!"></igx-toast>
         * ```
         */
        this.onSelect = new EventEmitter();
        /**
         * An @Ouput property that emits an event when a button is deselected.
         * ```typescript
         *  @ViewChild("toast")
         *  private toast: IgxToastComponent;
         *  public onUnselect(buttongroup){
         *     this.toast.show()
         * }
         *  //...
         * ```
         * ```html
         * <igx-buttongroup> #MyChild [multiSelection]="multi" (onUnselect)="onUnselect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have deselected a button!"></igx-toast>
         * ```
         */
        this.onUnselect = new EventEmitter();
    }
    /**
     * A collection containing all buttons inside the button group.
     */
    get buttons() {
        return [...this.viewButtons.toArray(), ...this.templateButtons.toArray()];
    }
    /**
     * Allows you to set a style using the `itemContentCssClass` input.
     * The value should be the CSS class name that will be applied to the button group.
     * ```typescript
     * public style1 = "styleClass";
     *  //..
     * ```
     *  ```html
     * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
     * ```
     */
    set itemContentCssClass(value) {
        this._itemContentCssClass = value || this._itemContentCssClass;
    }
    /**
     * Returns the CSS class of the item content of the `IgxButtonGroup`.
     * ```typescript
     *  @ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonSelect = this.buttonG.itemContentCssClass;
     * }
     * ```
     */
    get itemContentCssClass() {
        return this._itemContentCssClass;
    }
    /**
     * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
     * ```html
     * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (this._disabled !== value) {
            this._disabled = value;
            if (this.viewButtons && this.templateButtons) {
                this.buttons.forEach((b) => b.disabled = this._disabled);
            }
        }
    }
    /**
     * Allows you to set the button group alignment.
     * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
     * ```typescript
     * public alignment = ButtonGroupAlignment.vertical;
     * //..
     * ```
     * ```html
     * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
     * ```
     */
    set alignment(value) {
        this._isVertical = value === ButtonGroupAlignment.vertical;
    }
    /**
     * Returns the alignment of the `igx-buttongroup`.
     * ```typescript
     * @ViewChild("MyChild")
     * public buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let buttonAlignment = this.buttonG.alignment;
     * }
     * ```
     */
    get alignment() {
        return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
    }
    /**
     * Returns true if the `igx-buttongroup` alignment is vertical.
     * Note that in order for the accessor to work correctly the property should be set explicitly.
     * ```html
     * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
     * ```
     * ```typescript
     * //...
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let orientation = this.buttonG.isVertical;
     * }
     * ```
     */
    get isVertical() {
        return this._isVertical;
    }
    /**
     * Gets the selected button/buttons.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    let selectedButton = this.buttonG.selectedButtons;
     * }
     * ```
     */
    get selectedButtons() {
        return this.buttons.filter((b, i) => {
            return this.selectedIndexes.indexOf(i) !== -1;
        });
    }
    /**
     * Selects a button by its index.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @memberOf {@link IgxButtonGroupComponent}
     */
    selectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        const button = this.buttons[index];
        const buttonElement = button.nativeElement;
        this.selectedIndexes.push(index);
        button.selected = true;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
        this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
        this.onSelect.emit({ button: button, index: index });
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = true;
        }
        // deselect other buttons if multiSelection is not enabled
        if (!this.multiSelection && this.selectedIndexes.length > 1) {
            this.buttons.forEach((b, i) => {
                if (i !== index && this.selectedIndexes.indexOf(i) !== -1) {
                    this.deselectButton(i);
                }
            });
        }
    }
    /**
     * Deselects a button by its index.
     * ```typescript
     * @ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @memberOf {@link IgxButtonGroupComponent}
     */
    deselectButton(index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        const button = this.buttons[index];
        const buttonElement = button.nativeElement;
        this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
        button.selected = false;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
        this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
        this.onUnselect.emit({ button: button, index: index });
        const indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = false;
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.templateButtons.forEach((button) => {
            if (!button.initialDensity) {
                button.displayDensity = this.displayDensity;
            }
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        const initButtons = () => {
            // Cancel any existing buttonClick subscriptions
            this.buttonClickNotifier$.next();
            this.selectedIndexes.splice(0, this.selectedIndexes.length);
            // initial configuration
            this.buttons.forEach((button, index) => {
                const buttonElement = button.nativeElement;
                if (this.disabled) {
                    button.disabled = true;
                }
                if (button.selected) {
                    this.selectButton(index);
                }
                button.buttonClick.pipe(takeUntil(this.buttonClickNotifier$)).subscribe((ev) => this._clickHandler(ev, index));
                this._renderer.addClass(buttonElement, 'igx-button-group__item');
            });
        };
        this.viewButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());
        this.templateButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(() => initButtons());
        initButtons();
        this._cdr.detectChanges();
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.buttonClickNotifier$.next();
        this.buttonClickNotifier$.complete();
        this.queryListNotifier$.next();
        this.queryListNotifier$.complete();
    }
    /**
     * @hidden
     */
    _clickHandler(event, i) {
        if (this.selectedIndexes.indexOf(i) !== -1) {
            this.deselectButton(i);
        }
        else {
            this.selectButton(i);
        }
    }
};
IgxButtonGroupComponent.ɵfac = function IgxButtonGroupComponent_Factory(t) { return new (t || IgxButtonGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxButtonGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxButtonGroupComponent, selectors: [["igx-buttongroup"]], contentQueries: function IgxButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxButtonDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateButtons = _t);
    } }, viewQuery: function IgxButtonGroupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxButtonDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewButtons = _t);
    } }, hostVars: 3, hostBindings: function IgxButtonGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("z-index", ctx.zIndex);
    } }, inputs: { id: "id", multiSelection: "multiSelection", itemContentCssClass: "itemContentCssClass", disabled: "disabled", alignment: "alignment", values: "values" }, outputs: { onSelect: "onSelect", onUnselect: "onUnselect" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 3, vars: 3, consts: [["role", "group", 1, "igx-button-group"], ["type", "button", "igxButton", "flat", 3, "displayDensity", "selected", "disabled", "igxButtonColor", "igxButtonBackground", "igxLabel", "igxRipple", 4, "ngFor", "ngForOf"], ["type", "button", "igxButton", "flat", 3, "displayDensity", "selected", "disabled", "igxButtonColor", "igxButtonBackground", "igxLabel", "igxRipple"], ["fontSet", "material", 4, "ngIf"], ["class", "igx-button-group__button-text", 4, "ngIf"], ["fontSet", "material"], [1, "igx-button-group__button-text"]], template: function IgxButtonGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxButtonGroupComponent_button_1_Template, 4, 13, "button", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-button-group--vertical", ctx.isVertical);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.values);
    } }, directives: [ɵngcc2.NgForOf, IgxButtonDirective,
        IgxRippleDirective, ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxButtonGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    ViewChildren(IgxButtonDirective)
], IgxButtonGroupComponent.prototype, "viewButtons", void 0);
__decorate([
    ContentChildren(IgxButtonDirective)
], IgxButtonGroupComponent.prototype, "templateButtons", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxButtonGroupComponent.prototype, "id", void 0);
__decorate([
    HostBinding('style.zIndex')
], IgxButtonGroupComponent.prototype, "zIndex", void 0);
__decorate([
    Input()
], IgxButtonGroupComponent.prototype, "itemContentCssClass", null);
__decorate([
    Input()
], IgxButtonGroupComponent.prototype, "multiSelection", void 0);
__decorate([
    Input()
], IgxButtonGroupComponent.prototype, "values", void 0);
__decorate([
    Input()
], IgxButtonGroupComponent.prototype, "disabled", null);
__decorate([
    Input()
], IgxButtonGroupComponent.prototype, "alignment", null);
__decorate([
    Output()
], IgxButtonGroupComponent.prototype, "onSelect", void 0);
__decorate([
    Output()
], IgxButtonGroupComponent.prototype, "onUnselect", void 0);
IgxButtonGroupComponent = __decorate([ __param(2, Optional()), __param(2, Inject(DisplayDensityToken))
], IgxButtonGroupComponent);
/**
 * @hidden
 */
let IgxButtonGroupModule = class IgxButtonGroupModule {
};
IgxButtonGroupModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxButtonGroupModule });
IgxButtonGroupModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxButtonGroupModule_Factory(t) { return new (t || IgxButtonGroupModule)(); }, imports: [[IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]] });

/**
 * @hidden
 */
let IgxExcelStyleDefaultExpressionComponent = class IgxExcelStyleDefaultExpressionComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new CloseScrollStrategy()
        };
        this.onExpressionRemoved = new EventEmitter();
        this.onLogicOperatorChanged = new EventEmitter();
    }
    get inputValuesElement() {
        return this.inputValuesDirective;
    }
    get isLast() {
        return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
    }
    get isSingle() {
        return this.expressionsList.length === 1;
    }
    get inputConditionsPlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
    }
    get inputValuePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
    }
    get type() {
        switch (this.column.dataType) {
            case DataType.Number:
                return 'number';
            default:
                return 'text';
        }
    }
    ngAfterViewInit() {
        this._dropDownOverlaySettings.outlet = this.column.grid.outletDirective;
        this._dropDownOverlaySettings.positionStrategy.settings.target = this.inputGroupConditions.element.nativeElement;
    }
    focus() {
        // use requestAnimationFrame to focus the values input because when initializing the component
        // datepicker's input group is not yet fully initialized
        requestAnimationFrame(() => this.inputValuesElement.focus());
    }
    isConditionSelected(conditionName) {
        return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
    }
    getConditionName(condition) {
        return condition ? this.translateCondition(condition.name) : null;
    }
    getInputWidth() {
        return this.inputGroupConditions.element.nativeElement.offsetWidth + 'px';
    }
    get conditions() {
        return this.column.filters.conditionList();
    }
    translateCondition(value) {
        return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else if (!this.expressionUI.expression.condition) {
            return 'filter_list';
        }
        else {
            return this.expressionUI.expression.condition.iconName;
        }
    }
    toggleCustomDialogDropDown() {
        this.dropdownConditions.toggle(this._dropDownOverlaySettings);
    }
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    onConditionsChanged(eventArgs) {
        const value = eventArgs.newSelection.value;
        this.expressionUI.expression.condition = this.getCondition(value);
        this.focus();
    }
    onValuesInput(eventArgs) {
        this.expressionUI.expression.searchVal = DataUtil.parseValue(this.column.dataType, eventArgs.target.value);
    }
    onLogicOperatorButtonClicked(eventArgs, buttonIndex) {
        if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
            eventArgs.stopPropagation();
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
        }
        else {
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: buttonIndex
            });
        }
    }
    onLogicOperatorKeyDown(eventArgs, buttonIndex) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: buttonIndex
            });
        }
    }
    onRemoveButtonClick() {
        this.onExpressionRemoved.emit(this.expressionUI);
    }
    onInputConditionsKeyDown(eventArgs) {
        if (eventArgs.altKey && (eventArgs.key === "ArrowDown" /* DOWN_ARROW */ || eventArgs.key === "Down" /* DOWN_ARROW_IE */)) {
            this.toggleCustomDialogDropDown();
        }
        if (eventArgs.key === "Tab" /* TAB */ && eventArgs.shiftKey && this.expressionsList[0] === this.expressionUI) {
            eventArgs.preventDefault();
        }
        eventArgs.stopPropagation();
    }
};
IgxExcelStyleDefaultExpressionComponent.ɵfac = function IgxExcelStyleDefaultExpressionComponent_Factory(t) { return new (t || IgxExcelStyleDefaultExpressionComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExcelStyleDefaultExpressionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleDefaultExpressionComponent, selectors: [["igx-excel-style-default-expression"]], viewQuery: function IgxExcelStyleDefaultExpressionComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c39, true, IgxInputGroupComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c40, true, IgxInputDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c41, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(_c42, true, IgxButtonGroupComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroupConditions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputValuesDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownConditions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.logicOperatorButtonGroup = _t.first);
    } }, inputs: { column: "column", expressionUI: "expressionUI", expressionsList: "expressionsList", grid: "grid", displayDensity: "displayDensity" }, outputs: { onExpressionRemoved: "onExpressionRemoved", onLogicOperatorChanged: "onLogicOperatorChanged" }, decls: 15, vars: 18, consts: [[3, "maxHeight", "width", "displayDensity", "onSelection"], ["dropdownConditions", ""], [3, "value", "selected", 4, "ngFor", "ngForOf"], ["type", "box", 3, "displayDensity", "click"], ["inputGroupConditions", ""], ["fontSet", "filtering-icons", 3, "name", 4, "ngIf"], [4, "ngIf"], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "igxDropDownItemNavigation", "placeholder", "value", "readonly", "keydown"], ["type", "box", 3, "displayDensity"], ["inputGroupValues", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "type", "placeholder", "disabled", "value", "input"], ["inputValues", ""], ["igxButton", "icon", 3, "displayDensity", "click", 4, "ngIf"], [3, "multiSelection", 4, "ngIf"], [3, "value", "selected"], ["fontSet", "filtering-icons", 3, "name"], ["igxButton", "icon", 3, "displayDensity", "click"], [3, "multiSelection"], ["logicOperatorButtonGroup", ""], ["igxButton", "", "tabindex", "0", "type", "button", 3, "displayDensity", "selected", "keydown", "click"], ["andButton", ""], ["orButton", ""]], template: function IgxExcelStyleDefaultExpressionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-drop-down", 0, 1);
        ɵngcc0.ɵɵlistener("onSelection", function IgxExcelStyleDefaultExpressionComponent_Template_igx_drop_down_onSelection_0_listener($event) { return ctx.onConditionsChanged($event); });
        ɵngcc0.ɵɵtemplate(2, IgxExcelStyleDefaultExpressionComponent_igx_drop_down_item_2_Template, 4, 4, "igx-drop-down-item", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "igx-input-group", 3, 4);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDefaultExpressionComponent_Template_igx_input_group_click_3_listener() { return ctx.toggleCustomDialogDropDown(); });
        ɵngcc0.ɵɵelementStart(5, "igx-prefix");
        ɵngcc0.ɵɵtemplate(6, IgxExcelStyleDefaultExpressionComponent_igx_icon_6_Template, 1, 1, "igx-icon", 5);
        ɵngcc0.ɵɵtemplate(7, IgxExcelStyleDefaultExpressionComponent_igx_icon_7_Template, 2, 0, "igx-icon", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "input", 7);
        ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDefaultExpressionComponent_Template_input_keydown_8_listener($event) { return ctx.onInputConditionsKeyDown($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "igx-input-group", 8, 9);
        ɵngcc0.ɵɵelementStart(11, "input", 10, 11);
        ɵngcc0.ɵɵlistener("input", function IgxExcelStyleDefaultExpressionComponent_Template_input_input_11_listener($event) { return ctx.onValuesInput($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(13, IgxExcelStyleDefaultExpressionComponent_button_13_Template, 3, 1, "button", 12);
        ɵngcc0.ɵɵtemplate(14, IgxExcelStyleDefaultExpressionComponent_igx_buttongroup_14_Template, 8, 7, "igx-buttongroup", 13);
    } if (rf & 2) {
        const _r165 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵproperty("maxHeight", "200px")("width", ctx.getInputWidth())("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.conditions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r165)("placeholder", ctx.inputConditionsPlaceholder)("value", ctx.getConditionName(ctx.expressionUI.expression.condition))("readonly", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("type", ctx.type)("placeholder", ctx.inputValuePlaceholder)("disabled", ctx.expressionUI.expression.condition && ctx.expressionUI.expression.condition.isUnary)("value", ctx.expressionUI.expression.searchVal);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isSingle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isLast);
    } }, directives: [IgxDropDownComponent, ɵngcc2.NgForOf, IgxInputGroupComponent,
        IgxPrefixDirective, ɵngcc2.NgIf, IgxInputDirective,
        IgxDropDownItemNavigationDirective,
        IgxDropDownItemComponent,
        IgxIconComponent,
        IgxButtonDirective,
        IgxButtonGroupComponent], encapsulation: 2, changeDetection: 0 });
IgxExcelStyleDefaultExpressionComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxExcelStyleDefaultExpressionComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxExcelStyleDefaultExpressionComponent.prototype, "expressionUI", void 0);
__decorate([
    Input()
], IgxExcelStyleDefaultExpressionComponent.prototype, "expressionsList", void 0);
__decorate([
    Input()
], IgxExcelStyleDefaultExpressionComponent.prototype, "grid", void 0);
__decorate([
    Input()
], IgxExcelStyleDefaultExpressionComponent.prototype, "displayDensity", void 0);
__decorate([
    Output()
], IgxExcelStyleDefaultExpressionComponent.prototype, "onExpressionRemoved", void 0);
__decorate([
    Output()
], IgxExcelStyleDefaultExpressionComponent.prototype, "onLogicOperatorChanged", void 0);
__decorate([
    ViewChild('inputGroupConditions', { read: IgxInputGroupComponent, static: true })
], IgxExcelStyleDefaultExpressionComponent.prototype, "inputGroupConditions", void 0);
__decorate([
    ViewChild('inputValues', { read: IgxInputDirective, static: true })
], IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuesDirective", void 0);
__decorate([
    ViewChild('dropdownConditions', { read: IgxDropDownComponent, static: true })
], IgxExcelStyleDefaultExpressionComponent.prototype, "dropdownConditions", void 0);
__decorate([
    ViewChild('logicOperatorButtonGroup', { read: IgxButtonGroupComponent })
], IgxExcelStyleDefaultExpressionComponent.prototype, "logicOperatorButtonGroup", void 0);

var DateRangeType;
(function (DateRangeType) {
    DateRangeType[DateRangeType["After"] = 0] = "After";
    DateRangeType[DateRangeType["Before"] = 1] = "Before";
    DateRangeType[DateRangeType["Between"] = 2] = "Between";
    DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
    DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
    DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
})(DateRangeType || (DateRangeType = {}));

/**
 * @hidden
 */
var TimeDeltaInterval;
(function (TimeDeltaInterval) {
    TimeDeltaInterval["Month"] = "month";
    TimeDeltaInterval["Year"] = "year";
})(TimeDeltaInterval || (TimeDeltaInterval = {}));
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;
function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param year
 * @returns
 */
function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}
function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param year
 * @param month
 * @returns
 */
function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}
function isDateInRanges(date, ranges) {
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const dateInMs = date.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        const dRanges = descriptor.dateRange ? descriptor.dateRange.map(r => new Date(r.getFullYear(), r.getMonth(), r.getDate())) : undefined;
        switch (descriptor.type) {
            case (DateRangeType.After):
                if (dateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Before):
                if (dateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case (DateRangeType.Between):
                const dRange = dRanges.map(d => d.getTime());
                const min = Math.min(dRange[0], dRange[1]);
                const max = Math.max(dRange[0], dRange[1]);
                if (dateInMs >= min && dateInMs <= max) {
                    return true;
                }
                break;
            case (DateRangeType.Specific):
                const datesInMs = dRanges.map(d => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (dateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            case (DateRangeType.Weekdays):
                const day = date.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            case (DateRangeType.Weekends):
                const weekday = date.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            default:
                return false;
        }
    }
    return false;
}
var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
class Calendar {
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        const res = [];
        let value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, 'day', 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    timedelta(date, interval, units) {
        const ret = new Date(date);
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    formatToParts(date, locale, options, parts) {
        const formatter = new Intl.DateTimeFormat(locale, options);
        const result = {
            date,
            full: formatter.format(date)
        };
        if (formatter.formatToParts) {
            const formattedParts = formatter.formatToParts(date);
            const toType = (partType) => {
                const index = formattedParts.findIndex(({ type }) => type === partType);
                const o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts[index].value;
                o.literal = formattedParts[index + 1] ? formattedParts[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            for (const each of parts) {
                result[each] = toType(each);
            }
        }
        else {
            for (const each of parts) {
                result[each] = { value: '', literal: '', combined: '' };
            }
        }
        return result;
    }
    getFirstViewDate(date, interval, activeViewIdx) {
        return this.timedelta(date, interval, -activeViewIdx);
    }
    getNextMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, 1);
    }
    getPrevMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, -1);
    }
    getNextYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, 1);
    }
    getPrevYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, -1);
    }
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    }
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}

/**
 * @hidden
 */
let IgxCalendarYearDirective = class IgxCalendarYearDirective {
    constructor() {
        this.onYearSelection = new EventEmitter();
    }
    get defaultCSS() {
        return !this.isCurrentYear;
    }
    get currentCSS() {
        return this.isCurrentYear;
    }
    get isCurrentYear() {
        return this.date.getFullYear() === this.value.getFullYear();
    }
    onClick() {
        this.onYearSelection.emit(this.value);
    }
};
IgxCalendarYearDirective.ɵfac = function IgxCalendarYearDirective_Factory(t) { return new (t || IgxCalendarYearDirective)(); };
IgxCalendarYearDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarYearDirective, selectors: [["", "igxCalendarYear", ""]], hostVars: 4, hostBindings: function IgxCalendarYearDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxCalendarYearDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-calendar__year", ctx.defaultCSS)("igx-calendar__year--current", ctx.currentCSS);
    } }, inputs: { value: ["igxCalendarYear", "value"], date: "date" }, outputs: { onYearSelection: "onYearSelection" } });
__decorate([
    Input('igxCalendarYear')
], IgxCalendarYearDirective.prototype, "value", void 0);
__decorate([
    Input()
], IgxCalendarYearDirective.prototype, "date", void 0);
__decorate([
    Output()
], IgxCalendarYearDirective.prototype, "onYearSelection", void 0);
__decorate([
    HostBinding('class.igx-calendar__year')
], IgxCalendarYearDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-calendar__year--current')
], IgxCalendarYearDirective.prototype, "currentCSS", null);
__decorate([
    HostListener('click')
], IgxCalendarYearDirective.prototype, "onClick", null);
let IgxCalendarMonthDirective = class IgxCalendarMonthDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.onMonthSelection = new EventEmitter();
        this.tabindex = 0;
    }
    get defaultCSS() {
        return !this.isCurrentMonth;
    }
    get currentCSS() {
        return this.isCurrentMonth;
    }
    get isCurrentMonth() {
        return this.date.getMonth() === this.value.getMonth();
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    onClick() {
        const date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.onMonthSelection.emit(date);
    }
};
IgxCalendarMonthDirective.ɵfac = function IgxCalendarMonthDirective_Factory(t) { return new (t || IgxCalendarMonthDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxCalendarMonthDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarMonthDirective, selectors: [["", "igxCalendarMonth", ""]], hostVars: 5, hostBindings: function IgxCalendarMonthDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxCalendarMonthDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-calendar__month", ctx.defaultCSS)("igx-calendar__month--current", ctx.currentCSS);
    } }, inputs: { value: ["igxCalendarMonth", "value"], date: "date", index: "index" }, outputs: { onMonthSelection: "onMonthSelection" } });
IgxCalendarMonthDirective.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input('igxCalendarMonth')
], IgxCalendarMonthDirective.prototype, "value", void 0);
__decorate([
    Input()
], IgxCalendarMonthDirective.prototype, "date", void 0);
__decorate([
    Input()
], IgxCalendarMonthDirective.prototype, "index", void 0);
__decorate([
    Output()
], IgxCalendarMonthDirective.prototype, "onMonthSelection", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxCalendarMonthDirective.prototype, "tabindex", void 0);
__decorate([
    HostBinding('class.igx-calendar__month')
], IgxCalendarMonthDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-calendar__month--current')
], IgxCalendarMonthDirective.prototype, "currentCSS", null);
__decorate([
    HostListener('click')
], IgxCalendarMonthDirective.prototype, "onClick", null);
/**
 * @hidden
 */
let IgxCalendarHeaderTemplateDirective = class IgxCalendarHeaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCalendarHeaderTemplateDirective.ɵfac = function IgxCalendarHeaderTemplateDirective_Factory(t) { return new (t || IgxCalendarHeaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCalendarHeaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarHeaderTemplateDirective, selectors: [["", "igxCalendarHeader", ""]] });
IgxCalendarHeaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
let IgxCalendarSubheaderTemplateDirective = class IgxCalendarSubheaderTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxCalendarSubheaderTemplateDirective.ɵfac = function IgxCalendarSubheaderTemplateDirective_Factory(t) { return new (t || IgxCalendarSubheaderTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxCalendarSubheaderTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarSubheaderTemplateDirective, selectors: [["", "igxCalendarSubheader", ""]] });
IgxCalendarSubheaderTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
let IgxCalendarScrollMonthDirective = class IgxCalendarScrollMonthDirective {
    constructor(element, zone) {
        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        fromEvent(this.element.nativeElement, 'keyup').pipe(debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
            this.stopScroll(event);
        });
        this.zone.runOutsideAngular(() => {
            fromEvent(this.element.nativeElement, 'keydown').pipe(tap((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }), debounce(() => interval(100)), takeUntil(this.destroy$)).subscribe((event) => {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    this.zone.run(() => this.startScroll(true));
                }
            });
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    onMouseDown() {
        this.startScroll();
    }
    /**
     * @hidden
     */
    onMouseUp(event) {
        this.stopScroll(event);
    }
};
IgxCalendarScrollMonthDirective.ɵfac = function IgxCalendarScrollMonthDirective_Factory(t) { return new (t || IgxCalendarScrollMonthDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxCalendarScrollMonthDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarScrollMonthDirective, selectors: [["", "igxCalendarScrollMonth", ""]], hostBindings: function IgxCalendarScrollMonthDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function IgxCalendarScrollMonthDirective_mousedown_HostBindingHandler() { return ctx.onMouseDown(); })("mouseup", function IgxCalendarScrollMonthDirective_mouseup_HostBindingHandler($event) { return ctx.onMouseUp($event); });
    } }, inputs: { startScroll: "startScroll", stopScroll: "stopScroll" } });
IgxCalendarScrollMonthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input()
], IgxCalendarScrollMonthDirective.prototype, "startScroll", void 0);
__decorate([
    Input()
], IgxCalendarScrollMonthDirective.prototype, "stopScroll", void 0);
__decorate([
    HostListener('mousedown')
], IgxCalendarScrollMonthDirective.prototype, "onMouseDown", null);
__decorate([
    HostListener('mouseup', ['$event'])
], IgxCalendarScrollMonthDirective.prototype, "onMouseUp", null);

/**
 * Sets the selction type - single, multi or range.
 */
var CalendarSelection;
(function (CalendarSelection) {
    CalendarSelection["SINGLE"] = "single";
    CalendarSelection["MULTI"] = "multi";
    CalendarSelection["RANGE"] = "range";
})(CalendarSelection || (CalendarSelection = {}));
var ScrollMonth;
(function (ScrollMonth) {
    ScrollMonth["PREV"] = "prev";
    ScrollMonth["NEXT"] = "next";
    ScrollMonth["NONE"] = "none";
})(ScrollMonth || (ScrollMonth = {}));
/** @hidden @internal */
let IgxCalendarBaseDirective = class IgxCalendarBaseDirective {
    /**
     * @hidden
     */
    constructor() {
        /**
         * Sets/gets whether the outside dates (dates that are out of the current month) will be hidden.
         * Default value is `false`.
         * ```html
         * <igx-calendar [hideOutsideDays] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let hideOutsideDays = this.calendar.hideOutsideDays;
         * ```
         */
        this.hideOutsideDays = false;
        /**
         * Emits an event when a date is selected.
         * Provides reference the `selectedDates` property.
         */
        this.onSelection = new EventEmitter();
        /**
         * @hidden
         */
        this._selection = CalendarSelection.SINGLE;
        /**
         * @hidden
         */
        this.rangeStarted = false;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._disabledDates = null;
        /**
         * @hidden
         */
        this._specialDates = null;
        /**
         * @hidden
         */
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        /**
         * @hidden
         */
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        /**
         * @hidden
         */
        this.monthScrollDirection = ScrollMonth.NONE;
        /**
         * @hidden
         */
        this.scrollMonth$ = new Subject();
        /**
         * @hidden
         */
        this.stopMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this.startMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.calendarModel = new Calendar();
        this.viewDate = this.viewDate ? this.viewDate : new Date();
        this.calendarModel.firstWeekDay = this.weekStart;
        this.initFormatters();
    }
    /**
     * Gets the start day of the week.
     * Can return a numeric or an enum representation of the week day.
     * Defaults to `Sunday` / `0`.
     */
    get weekStart() {
        return this.calendarModel.firstWeekDay;
    }
    /**
     * Sets the start day of the week.
     * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
     */
    set weekStart(value) {
        this.calendarModel.firstWeekDay = value;
    }
    /**
     * Gets the `locale` of the calendar.
     * Default value is `"en"`.
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the calendar.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     */
    set locale(value) {
        this._locale = value;
        this.initFormatters();
    }
    /**
     * Gets the date format options of the days view.
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the date format options of the days view.
     * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
        this.initFormatters();
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    get formatViews() {
        return this._formatViews;
    }
    /**
     * Gets whether the `day`, `month` and `year` should be rendered
     * according to the locale and formatOptions, if any.
     */
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     *
     * Gets the selection type.
     * Default value is `"single"`.
     * Changing the type of selection resets the currently
     * selected values if any.
     */
    get selection() {
        return this._selection;
    }
    /**
     * Sets the selection.
     */
    set selection(value) {
        switch (value) {
            case CalendarSelection.SINGLE:
                this.selectedDates = null;
                break;
            case CalendarSelection.MULTI:
            case CalendarSelection.RANGE:
                this.selectedDates = [];
                break;
            default:
                throw new Error('Invalid selection value');
        }
        this._onChangeCallback(this.selectedDates);
        this.rangeStarted = false;
        this._selection = value;
    }
    /**
     * Gets the selected date(s).
     *
     * When selection is set to `single`, it returns
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    get value() {
        return this.selectedDates;
    }
    /**
     * Sets the selected date(s).
     *
     * When selection is set to `single`, it accepts
     * a single `Date` object.
     * Otherwise it is an array of `Date` objects.
     */
    set value(value) {
        if (!value || !!value && value.length === 0) {
            return;
        }
        this.selectDate(value);
    }
    /**
     * Gets the date that is presented.
     * By default it is the current date.
     */
    get viewDate() {
        return this._viewDate;
    }
    /**
     * Sets the date that will be presented in the default view when the component renders.
     */
    set viewDate(value) {
        this._viewDate = this.getDateOnly(value);
    }
    /**
     * Gets the disabled dates descriptors.
     */
    get disabledDates() {
        return this._disabledDates;
    }
    /**
     * Sets the disabled dates' descriptors.
     * ```typescript
     * @ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.disabledDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     */
    set disabledDates(value) {
        this._disabledDates = value;
    }
    /**
     * Gets the special dates descriptors.
     */
    get specialDates() {
        return this._specialDates;
    }
    /**
     * Sets the special dates' descriptors.
     * ```typescript
     * @ViewChild("MyCalendar")
     * public calendar: IgxCalendarComponent;
     * ngOnInit(){
     *    this.calendar.specialDates = [
     *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
     *     {type: DateRangeType.Weekends}];
     * }
     * ```
     */
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * @hidden
     */
    getDateOnlyInMs(date) {
        return this.getDateOnly(date).getTime();
    }
    /**
     * @hidden
     */
    generateDateRange(start, end) {
        const result = [];
        start = this.getDateOnly(start);
        end = this.getDateOnly(end);
        while (start.getTime() !== end.getTime()) {
            start = this.calendarModel.timedelta(start, 'day', 1);
            result.push(start);
        }
        return result;
    }
    /**
     * Performs a single selection.
     * @hidden
     */
    selectSingle(value) {
        this.selectedDates = this.getDateOnly(value);
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a multiple selection
     * @hidden
     */
    selectMultiple(value) {
        if (Array.isArray(value)) {
            const newDates = value.map(v => this.getDateOnly(v).getTime());
            const selDates = this.selectedDates.map(v => this.getDateOnly(v).getTime());
            if (JSON.stringify(newDates) === JSON.stringify(selDates)) {
                return;
            }
            this.selectedDates = Array.from(new Set([...newDates, ...selDates])).map(v => new Date(v));
        }
        else {
            const valueDateOnly = this.getDateOnly(value);
            const newSelection = [];
            if (this.selectedDates.every((date) => date.getTime() !== valueDateOnly.getTime())) {
                newSelection.push(valueDateOnly);
            }
            else {
                this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
            }
            if (newSelection.length > 0) {
                this.selectedDates = this.selectedDates.concat(newSelection);
            }
        }
        this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * @hidden
     */
    selectRange(value, excludeDisabledDates = false) {
        let start;
        let end;
        if (Array.isArray(value)) {
            // this.rangeStarted = false;
            value.sort((a, b) => a.valueOf() - b.valueOf());
            start = this.getDateOnly(value[0]);
            end = this.getDateOnly(value[value.length - 1]);
            this.selectedDates = [start, ...this.generateDateRange(start, end)];
        }
        else {
            if (!this.rangeStarted) {
                this.rangeStarted = true;
                this.selectedDates = [value];
            }
            else {
                this.rangeStarted = false;
                if (this.selectedDates[0].getTime() === value.getTime()) {
                    this.selectedDates = [];
                    this._onChangeCallback(this.selectedDates);
                    return;
                }
                this.selectedDates.push(value);
                this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
                start = this.selectedDates.shift();
                end = this.selectedDates.pop();
                this.selectedDates = [start, ...this.generateDateRange(start, end)];
            }
        }
        if (excludeDisabledDates) {
            this.selectedDates = this.selectedDates.filter(d => !this.isDateDisabled(d));
        }
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Performs a single deselection.
     * @hidden
     */
    deselectSingle(value) {
        if (this.selectedDates !== null &&
            this.getDateOnlyInMs(value) === this.getDateOnlyInMs(this.selectedDates)) {
            this.selectedDates = null;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs a multiple deselection.
     * @hidden
     */
    deselectMultiple(value) {
        value = value.filter(v => v !== null);
        const selectedDatesCount = this.selectedDates.length;
        const datesInMsToDeselect = new Set(value.map(v => this.getDateOnlyInMs(v)));
        for (let i = this.selectedDates.length - 1; i >= 0; i--) {
            if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                this.selectedDates.splice(i, 1);
            }
        }
        if (this.selectedDates.length !== selectedDatesCount) {
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * Performs deselection of a single value, when selection is multi
     * Usually performed by the selectMultiple method, but leads to bug when multiple months are in view
     * @hidden
     */
    deselectMultipleInMonth(value) {
        const valueDateOnly = this.getDateOnly(value);
        this.selectedDates = this.selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
    }
    /**
     * Performs a range deselection.
     * @hidden
     */
    deselectRange(value) {
        value = value.filter(v => v !== null);
        if (value.length < 1) {
            return;
        }
        value.sort((a, b) => a.valueOf() - b.valueOf());
        const valueStart = this.getDateOnlyInMs(value[0]);
        const valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
        this.selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        const selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
        const selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
        if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
            this.selectedDates = [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
        }
    }
    /**
     * @hidden
     */
    initFormatters() {
        this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
        this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
        this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
        this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
        this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
    }
    /**
     * @hidden
     */
    getDateOnly(date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        this.selectDate(value);
    }
    /**
     * Checks whether a date is disabled.
     * @hidden
     */
    isDateDisabled(date) {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(date, this.disabledDates);
    }
    /**
     * Selects date(s) (based on the selection type).
     */
    selectDate(value) {
        if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                if (isDate(value) && !this.isDateDisabled(value)) {
                    this.selectSingle(value);
                }
                break;
            case CalendarSelection.MULTI:
                this.selectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     */
    deselectDate(value) {
        if (!this.selectedDates || this.selectedDates.length === 0) {
            return;
        }
        if (value === null || value === undefined) {
            this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                this.deselectSingle(value);
                break;
            case CalendarSelection.MULTI:
                this.deselectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.deselectRange(value);
                break;
        }
    }
    /**
     * @hidden
     */
    selectDateFromClient(value) {
        switch (this.selection) {
            case CalendarSelection.SINGLE:
            case CalendarSelection.MULTI:
                this.selectDate(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    }
};
IgxCalendarBaseDirective.ɵfac = function IgxCalendarBaseDirective_Factory(t) { return new (t || IgxCalendarBaseDirective)(); };
IgxCalendarBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCalendarBaseDirective, selectors: [["", "igxCalendarBase", ""]], inputs: { hideOutsideDays: "hideOutsideDays", viewDate: "viewDate", weekStart: "weekStart", locale: "locale", formatOptions: "formatOptions", formatViews: "formatViews", selection: "selection", value: "value", disabledDates: "disabledDates", specialDates: "specialDates" }, outputs: { onSelection: "onSelection" } });
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "weekStart", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "locale", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "formatOptions", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "formatViews", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "selection", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "value", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "viewDate", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "disabledDates", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "specialDates", null);
__decorate([
    Input()
], IgxCalendarBaseDirective.prototype, "hideOutsideDays", void 0);
__decorate([
    Output()
], IgxCalendarBaseDirective.prototype, "onSelection", void 0);

/**
 * Sets the calender view - days, months or years.
 */
var CalendarView;
(function (CalendarView) {
    CalendarView[CalendarView["DEFAULT"] = 0] = "DEFAULT";
    CalendarView[CalendarView["YEAR"] = 1] = "YEAR";
    CalendarView[CalendarView["DECADE"] = 2] = "DECADE";
})(CalendarView || (CalendarView = {}));
let IgxMonthPickerBaseDirective = class IgxMonthPickerBaseDirective extends IgxCalendarBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Holds month view index we are operating on.
         */
        this.activeViewIdx = 0;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._activeView = CalendarView.DEFAULT;
    }
    /**
     * Gets the current active view.
     */
    get activeView() {
        return this._activeView;
    }
    /**
     * Sets the current active view.
     */
    set activeView(val) {
        this._activeView = val;
    }
    /**
     * @hidden
     */
    get isDefaultView() {
        return this._activeView === CalendarView.DEFAULT;
    }
    /**
     * @hidden
     */
    get isDecadeView() {
        return this._activeView === CalendarView.DECADE;
    }
    /**
     * @hidden
     */
    changeYear(event) {
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            if (this.yearsBtns && this.yearsBtns.length) {
                this.yearsBtns.find((e, idx) => idx === this.activeViewIdx).nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    activeViewDecade(activeViewIdx = 0) {
        this._activeView = CalendarView.DECADE;
        this.activeViewIdx = activeViewIdx;
    }
    /**
     * @hidden
     */
    activeViewDecadeKB(event, activeViewIdx = 0) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewDecade(activeViewIdx);
        }
    }
    /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatViews.year) {
            return this.formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
};
IgxMonthPickerBaseDirective.ɵfac = function IgxMonthPickerBaseDirective_Factory(t) { return ɵIgxMonthPickerBaseDirective_BaseFactory(t || IgxMonthPickerBaseDirective); };
IgxMonthPickerBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxMonthPickerBaseDirective, selectors: [["", "igxMonthPickerBase", ""]], viewQuery: function IgxMonthPickerBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c43, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearsBtns = _t);
    } }, hostVars: 1, hostBindings: function IgxMonthPickerBaseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    HostBinding('attr.tabindex')
], IgxMonthPickerBaseDirective.prototype, "tabindex", void 0);
__decorate([
    ViewChildren('yearsBtn')
], IgxMonthPickerBaseDirective.prototype, "yearsBtns", void 0);

var IgxMonthsViewComponent_1;
let NEXT_ID$a = 0;
let IgxMonthsViewComponent = IgxMonthsViewComponent_1 = class IgxMonthsViewComponent {
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         * @memberof IgxMonthsViewComponent
         */
        this.id = `igx-months-view-${NEXT_ID$a++}`;
        /**
         * Gets/sets the selected date of the months view.
         * By default it is the current date.
         * ```html
         * <igx-months-view [date]="myDate"></igx-months-view>
         * ```
         * ```typescript
         * let date =  this.monthsView.date;
         * ```
         * @memberof IgxMonthsViewComponent
         */
        this.date = new Date();
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and monthFormat, if any.
         */
        this.formatView = true;
        /**
         * Emits an event when a selection is made in the months view.
         * Provides reference the `date` property in the `IgxMonthsViewComponent`.
         * ```html
         * <igx-months-view (onSelection)="onSelection($event)"></igx-months-view>
         * ```
         * @memberof IgxMonthsViewComponent
         */
        this.onSelection = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._monthFormat = 'short';
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.initMonthFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets the month format option of the months view.
     * ```typescript
     * let monthFormat = this.monthsView.monthFormat.
     * ```
     */
    get monthFormat() {
        return this._monthFormat;
    }
    /**
     * Sets the month format option of the months view.
     * ```html
     * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
     * ```
     * @memberof IgxMonthsViewComponent
     */
    set monthFormat(value) {
        this._monthFormat = value;
        this.initMonthFormatter();
    }
    /**
     * Gets the `locale` of the months view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.monthsView.locale;
     * ```
     * @memberof IgxMonthsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the months view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-months-view [locale]="de"></igx-months-view>
     * ```
     * @memberof IgxMonthsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initMonthFormatter();
    }
    /**
     * Returns an array of date objects which are then used to
     * properly render the month names.
     *
     * Used in the template of the component
     *
     * @hidden
     */
    get months() {
        let start = new Date(this.date.getFullYear(), 0, 1);
        const result = [];
        for (let i = 0; i < 12; i++) {
            result.push(start);
            start = this._calendarModel.timedelta(start, 'month', 1);
        }
        return result;
    }
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     */
    formattedMonth(value) {
        if (this.formatView) {
            return this._formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * @hidden
     */
    selectMonth(event) {
        this.onSelection.emit(event);
        this.date = event;
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    monthTracker(index, item) {
        return `${item.getMonth()}}`;
    }
    /**
     * @hidden
     */
    initMonthFormatter() {
        this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) - 1; index >= 0; index--) {
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            const tolerance = 6;
            if (nodeRect.top !== nextNodeRect.top && (nextNodeRect.left - nodeRect.left) < tolerance) {
                months[index].nativeElement.focus();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        const nodeRect = node.nativeElement.getBoundingClientRect();
        for (let index = months.indexOf(node) + 1; index < months.length; index++) {
            const nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            const tolerance = 6;
            if (nextNodeRect.top !== nodeRect.top && (nodeRect.left - nextNodeRect.left) < tolerance) {
                months[index].nativeElement.focus();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        if (months.indexOf(node) + 1 < months.length) {
            const month = months[months.indexOf(node) + 1];
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        const node = this.monthsRef.find((date) => date.nativeElement === event.target);
        if (!node) {
            return;
        }
        const months = this.monthsRef.toArray();
        if (months.indexOf(node) - 1 >= 0) {
            const month = months[months.indexOf(node) - 1];
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        const month = this.monthsRef.toArray()[0];
        month.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        const months = this.monthsRef.toArray();
        const month = months[months.length - 1];
        month.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onKeydownEnter(event) {
        const value = this.monthsRef.find((date) => date.nativeElement === event.target).value;
        this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
};
IgxMonthsViewComponent.ɵfac = function IgxMonthsViewComponent_Factory(t) { return new (t || IgxMonthsViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxMonthsViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxMonthsViewComponent, selectors: [["igx-months-view"]], viewQuery: function IgxMonthsViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxCalendarMonthDirective, true, IgxCalendarMonthDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsRef = _t);
    } }, hostVars: 4, hostBindings: function IgxMonthsViewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowup", function IgxMonthsViewComponent_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrowUp($event); })("keydown.arrowdown", function IgxMonthsViewComponent_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrowDown($event); })("keydown.arrowright", function IgxMonthsViewComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrowRight($event); })("keydown.arrowleft", function IgxMonthsViewComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrowLeft($event); })("keydown.home", function IgxMonthsViewComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxMonthsViewComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); })("keydown.enter", function IgxMonthsViewComponent_keydown_enter_HostBindingHandler($event) { return ctx.onKeydownEnter($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id", date: "date", formatView: "formatView", monthFormat: "monthFormat", locale: "locale" }, outputs: { onSelection: "onSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent_1, multi: true }])], decls: 3, vars: 2, consts: [[1, "igx-calendar__body"], [1, "igx-calendar__body-row--wrap"], [3, "igxCalendarMonth", "date", "index", "onMonthSelection", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "igxCalendarMonth", "date", "index", "onMonthSelection"]], template: function IgxMonthsViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxMonthsViewComponent_div_2_Template, 3, 6, "div", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.months)("ngForTrackBy", ctx.monthTracker);
    } }, directives: [ɵngcc2.NgForOf, IgxCalendarMonthDirective], pipes: [ɵngcc2.TitleCasePipe], encapsulation: 2 });
IgxMonthsViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxMonthsViewComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxMonthsViewComponent.prototype, "date", void 0);
__decorate([
    Input()
], IgxMonthsViewComponent.prototype, "monthFormat", null);
__decorate([
    Input()
], IgxMonthsViewComponent.prototype, "locale", null);
__decorate([
    Input()
], IgxMonthsViewComponent.prototype, "formatView", void 0);
__decorate([
    Output()
], IgxMonthsViewComponent.prototype, "onSelection", void 0);
__decorate([
    HostBinding('class.igx-calendar')
], IgxMonthsViewComponent.prototype, "styleClass", void 0);
__decorate([
    ViewChildren(IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective })
], IgxMonthsViewComponent.prototype, "monthsRef", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxMonthsViewComponent.prototype, "tabindex", void 0);
__decorate([
    HostListener('keydown.arrowup', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownArrowUp", null);
__decorate([
    HostListener('keydown.arrowdown', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownArrowDown", null);
__decorate([
    HostListener('keydown.arrowright', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownArrowRight", null);
__decorate([
    HostListener('keydown.arrowleft', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownArrowLeft", null);
__decorate([
    HostListener('keydown.home', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownHome", null);
__decorate([
    HostListener('keydown.end', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownEnd", null);
__decorate([
    HostListener('keydown.enter', ['$event'])
], IgxMonthsViewComponent.prototype, "onKeydownEnter", null);

var IgxYearsViewComponent_1;
let NEXT_ID$b = 0;
let CalendarHammerConfig = class CalendarHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
};
CalendarHammerConfig.ɵfac = function CalendarHammerConfig_Factory(t) { return ɵCalendarHammerConfig_BaseFactory(t || CalendarHammerConfig); };
CalendarHammerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CalendarHammerConfig, factory: CalendarHammerConfig.ɵfac });
let IgxYearsViewComponent = IgxYearsViewComponent_1 = class IgxYearsViewComponent {
    constructor(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the years view.
         * If not set, the `id` will have value `"igx-years-view-0"`.
         * ```html
         * <igx-years-view id = "my-years-view"></igx-years-view>
         * ```
         * ```typescript
         * let yearsViewId =  this.yearsView.id;
         * ```
         * @memberof IgxCalendarComponent
         */
        this.id = `igx-years-view-${NEXT_ID$b++}`;
        /**
         * Gets/sets the selected date of the years view.
         * By default it is the current date.
         * ```html
         * <igx-years-view [date]="myDate"></igx-years-view>
         * ```
         * ```typescript
         * let date =  this.yearsView.date;
         * ```
         * @memberof IgxYearsViewComponent
         */
        this.date = new Date();
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (onSelection)="onSelection($event)"></igx-years-view>
         * ```
         * @memberof IgxYearsViewComponent
         */
        this.onSelection = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._yearFormat = 'numeric';
        /**
         * @hidden
         */
        this._onTouchedCallback = () => { };
        /**
         * @hidden
         */
        this._onChangeCallback = () => { };
        this.initYearFormatter();
        this._calendarModel = new Calendar();
    }
    /**
     * Gets the year format option of the years view.
     * ```typescript
     * let yearFormat = this.yearsView.yearFormat.
     * ```
     */
    get yearFormat() {
        return this._yearFormat;
    }
    /**
     * Sets the year format option of the years view.
     * ```html
     * <igx-years-view [yearFormat]="numeric"></igx-years-view>
     * ```
     * @memberof IgxYearsViewComponent
     */
    set yearFormat(value) {
        this._yearFormat = value;
        this.initYearFormatter();
    }
    /**
     * Gets the `locale` of the years view.
     * Default value is `"en"`.
     * ```typescript
     * let locale =  this.yearsView.locale;
     * ```
     * @memberof IgxYearsViewComponent
     */
    get locale() {
        return this._locale;
    }
    /**
     * Sets the `locale` of the years view.
     * Expects a valid BCP 47 language tag.
     * Default value is `"en"`.
     * ```html
     * <igx-years-view [locale]="de"></igx-years-view>
     * ```
     * @memberof IgxYearsViewComponent
     */
    set locale(value) {
        this._locale = value;
        this.initYearFormatter();
    }
    /**
     * Returns an array of date objects which are then used to properly
     * render the years.
     *
     * Used in the template of the component.
     *
     * @hidden
     */
    get decade() {
        const result = [];
        const start = this.date.getFullYear() - 3;
        const end = this.date.getFullYear() + 4;
        for (const year of range(start, end)) {
            result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
        }
        return result;
    }
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     */
    formattedYear(value) {
        if (this.formatView) {
            return this._formatterYear.format(value);
        }
        return `${value.getFullYear()}`;
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.date = event;
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    scroll(event) {
        event.preventDefault();
        event.stopPropagation();
        const delta = event.deltaY < 0 ? -1 : 1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    pan(event) {
        const delta = event.deltaY < 0 ? 1 : -1;
        this.generateYearRange(delta);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     */
    yearTracker(index, item) {
        return `${item.getFullYear()}}`;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (value) {
            this.date = value;
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(1);
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(-1);
    }
    /**
     * @hidden
     */
    onKeydownEnter() {
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    }
    /**
     * @hidden
     */
    initYearFormatter() {
        this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
    }
    /**
     * @hidden
     */
    generateYearRange(delta) {
        const currentYear = new Date().getFullYear();
        if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
            (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
            return;
        }
        this.date = this._calendarModel.timedelta(this.date, 'year', delta);
    }
};
IgxYearsViewComponent.ɵfac = function IgxYearsViewComponent_Factory(t) { return new (t || IgxYearsViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxYearsViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxYearsViewComponent, selectors: [["igx-years-view"]], hostVars: 4, hostBindings: function IgxYearsViewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowdown", function IgxYearsViewComponent_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrowDown($event); })("keydown.arrowup", function IgxYearsViewComponent_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrowUp($event); })("keydown.enter", function IgxYearsViewComponent_keydown_enter_HostBindingHandler() { return ctx.onKeydownEnter(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id", date: "date", yearFormat: "yearFormat", locale: "locale", formatView: "formatView" }, outputs: { onSelection: "onSelection" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxYearsViewComponent_1,
                multi: true
            },
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: CalendarHammerConfig
            }
        ])], decls: 3, vars: 2, consts: [[1, "igx-calendar__body"], [1, "igx-calendar__body-column", 3, "wheel", "pan"], [3, "igxCalendarYear", "date", "onYearSelection", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "igxCalendarYear", "date", "onYearSelection"]], template: function IgxYearsViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵlistener("wheel", function IgxYearsViewComponent_Template_div_wheel_1_listener($event) { return ctx.scroll($event); })("pan", function IgxYearsViewComponent_Template_div_pan_1_listener($event) { return ctx.pan($event); });
        ɵngcc0.ɵɵtemplate(2, IgxYearsViewComponent_span_2_Template, 2, 3, "span", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.decade)("ngForTrackBy", ctx.yearTracker);
    } }, directives: [ɵngcc2.NgForOf, IgxCalendarYearDirective], encapsulation: 2 });
IgxYearsViewComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxYearsViewComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxYearsViewComponent.prototype, "date", void 0);
__decorate([
    Input()
], IgxYearsViewComponent.prototype, "yearFormat", null);
__decorate([
    Input()
], IgxYearsViewComponent.prototype, "locale", null);
__decorate([
    Input()
], IgxYearsViewComponent.prototype, "formatView", void 0);
__decorate([
    Output()
], IgxYearsViewComponent.prototype, "onSelection", void 0);
__decorate([
    HostBinding('class.igx-calendar')
], IgxYearsViewComponent.prototype, "styleClass", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxYearsViewComponent.prototype, "tabindex", void 0);
__decorate([
    HostListener('keydown.arrowdown', ['$event'])
], IgxYearsViewComponent.prototype, "onKeydownArrowDown", null);
__decorate([
    HostListener('keydown.arrowup', ['$event'])
], IgxYearsViewComponent.prototype, "onKeydownArrowUp", null);
__decorate([
    HostListener('keydown.enter')
], IgxYearsViewComponent.prototype, "onKeydownEnter", null);

/**
 * @hidden
 */
let IgxDayItemComponent = class IgxDayItemComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.hideOutsideDays = false;
        this.isLastInRange = false;
        this.isFirstInRange = false;
        this.isWithinRange = false;
        this.onDateSelection = new EventEmitter();
        this._selected = false;
    }
    /**
     * Returns boolean indicating if the day is selected
     *
     */
    get selected() {
        return this._selected;
    }
    /**
     * Selects the day
     */
    set selected(value) {
        this._selected = value;
    }
    get isCurrentMonth() {
        return this.date.isCurrentMonth;
    }
    get isPreviousMonth() {
        return this.date.isPrevMonth;
    }
    get isNextMonth() {
        return this.date.isNextMonth;
    }
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    get isSelectedCSS() {
        return (!this.isDisabled && this.selected);
    }
    get isInactive() {
        return this.date.isNextMonth || this.date.isPrevMonth;
    }
    get isHidden() {
        return this.hideOutsideDays && this.isInactive;
    }
    get isToday() {
        const today = new Date(Date.now());
        const date = this.date.date;
        return (date.getFullYear() === today.getFullYear() &&
            date.getMonth() === today.getMonth() &&
            date.getDate() === today.getDate());
    }
    get isWeekend() {
        const day = this.date.date.getDay();
        return day === 0 || day === 6;
    }
    get isDisabled() {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.disabledDates);
    }
    get isOutOfRange() {
        if (!this.outOfRangeDates) {
            return false;
        }
        return isDateInRanges(this.date.date, this.outOfRangeDates);
    }
    get isFocusable() {
        return this.isCurrentMonth && !this.isHidden && !this.isDisabled && !this.isOutOfRange;
    }
    get isWithinRangeCSS() {
        return !this.isSingleSelection && this.isWithinRange;
    }
    get isSpecial() {
        if (this.specialDates === null) {
            return false;
        }
        return isDateInRanges(this.date.date, this.specialDates);
    }
    get defaultCSS() {
        return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
    }
    get isDisabledCSS() {
        return this.isHidden || this.isDisabled || this.isOutOfRange;
    }
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    get tabindex() {
        return this.isDisabled || this.isHidden ? -1 : 0;
    }
    onSelect() {
        this.onDateSelection.emit(this.date);
    }
};
IgxDayItemComponent.ɵfac = function IgxDayItemComponent_Factory(t) { return new (t || IgxDayItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxDayItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDayItemComponent, selectors: [["igx-day-item"]], hostVars: 25, hostBindings: function IgxDayItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxDayItemComponent_click_HostBindingHandler() { return ctx.onSelect(); })("keydown.enter", function IgxDayItemComponent_keydown_enter_HostBindingHandler() { return ctx.onSelect(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-calendar__date--last", ctx.isLastInRange)("igx-calendar__date--first", ctx.isFirstInRange)("igx-calendar__date--selected", ctx.isSelectedCSS)("igx-calendar__date--inactive", ctx.isInactive)("igx-calendar__date--hidden", ctx.isHidden)("igx-calendar__date--current", ctx.isToday)("igx-calendar__date--weekend", ctx.isWeekend)("igx-calendar__date--range", ctx.isWithinRangeCSS)("igx-calendar__date--special", ctx.isSpecial)("igx-calendar__date", ctx.defaultCSS)("igx-calendar__date--disabled", ctx.isDisabledCSS)("igx-calendar__date--single", ctx.isSingleSelection);
    } }, inputs: { hideOutsideDays: "hideOutsideDays", isLastInRange: "isLastInRange", isFirstInRange: "isFirstInRange", isWithinRange: "isWithinRange", selected: "selected", date: "date", selection: "selection", disabledDates: "disabledDates", outOfRangeDates: "outOfRangeDates", specialDates: "specialDates" }, outputs: { onDateSelection: "onDateSelection" }, ngContentSelectors: _c2, decls: 2, vars: 0, consts: [[1, "igx-calendar__date-content"]], template: function IgxDayItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } }, encapsulation: 2 });
IgxDayItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], IgxDayItemComponent.prototype, "date", void 0);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "selection", void 0);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "selected", null);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "disabledDates", void 0);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "outOfRangeDates", void 0);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "specialDates", void 0);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "hideOutsideDays", void 0);
__decorate([
    Input(),
    HostBinding('class.igx-calendar__date--last')
], IgxDayItemComponent.prototype, "isLastInRange", void 0);
__decorate([
    Input(),
    HostBinding('class.igx-calendar__date--first')
], IgxDayItemComponent.prototype, "isFirstInRange", void 0);
__decorate([
    Input()
], IgxDayItemComponent.prototype, "isWithinRange", void 0);
__decorate([
    Output()
], IgxDayItemComponent.prototype, "onDateSelection", void 0);
__decorate([
    HostBinding('class.igx-calendar__date--selected')
], IgxDayItemComponent.prototype, "isSelectedCSS", null);
__decorate([
    HostBinding('class.igx-calendar__date--inactive')
], IgxDayItemComponent.prototype, "isInactive", null);
__decorate([
    HostBinding('class.igx-calendar__date--hidden')
], IgxDayItemComponent.prototype, "isHidden", null);
__decorate([
    HostBinding('class.igx-calendar__date--current')
], IgxDayItemComponent.prototype, "isToday", null);
__decorate([
    HostBinding('class.igx-calendar__date--weekend')
], IgxDayItemComponent.prototype, "isWeekend", null);
__decorate([
    HostBinding('class.igx-calendar__date--range')
], IgxDayItemComponent.prototype, "isWithinRangeCSS", null);
__decorate([
    HostBinding('class.igx-calendar__date--special')
], IgxDayItemComponent.prototype, "isSpecial", null);
__decorate([
    HostBinding('class.igx-calendar__date')
], IgxDayItemComponent.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-calendar__date--disabled')
], IgxDayItemComponent.prototype, "isDisabledCSS", null);
__decorate([
    HostBinding('class.igx-calendar__date--single')
], IgxDayItemComponent.prototype, "isSingleSelection", null);
__decorate([
    HostBinding('attr.tabindex')
], IgxDayItemComponent.prototype, "tabindex", null);
__decorate([
    HostListener('click'),
    HostListener('keydown.enter')
], IgxDayItemComponent.prototype, "onSelect", null);

var Direction;
(function (Direction) {
    Direction["Up"] = "ArrowUp";
    Direction["Down"] = "ArrowDown";
    Direction["Left"] = "ArrowLeft";
    Direction["Right"] = "ArrowRight";
})(Direction || (Direction = {}));
const ARROW = 'Arrow';
/** @hidden */
let IgxDaysViewNavigationService = class IgxDaysViewNavigationService {
    /**
     * Implements kb navigation in all MoveDirections. nextDate and nextMonthView naming convention is used for both previous/next
     * @hidden
     */
    focusNextDate(target, key, nextView = false) {
        if (target.childElementCount === 0) {
            target = target.parentElement;
        }
        if (key.indexOf('Arrow') === -1) {
            key = ARROW.concat(key);
        }
        const monthView = this.monthView;
        const node = monthView.dates.find((date) => date.nativeElement === target);
        let dates = monthView.dates.toArray(), day, step, i, nextDate;
        const index = dates.indexOf(node);
        if (!node) {
            return;
        }
        // focus item in current month
        switch (key) {
            case Direction.Left: {
                step = -1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i > 0; i--) {
                    day = nextView ? dates[i] : dates[i - 1];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Right: {
                step = 1;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i < dates.length - 1; i++) {
                    day = nextView ? dates[i] : dates[i + 1];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Up: {
                step = -7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i - 7 > -1; i -= 7) {
                    day = nextView ? dates[i] : dates[i - 7];
                    nextDate = day.date.date;
                    if (day.date.isPrevMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
            case Direction.Down: {
                step = 7;
                nextDate = this.timedelta(node.date.date, step);
                for (i = index; i + 7 < 42; i += 7) {
                    day = nextView ? dates[i] : dates[i + 7];
                    nextDate = day.date.date;
                    if (day.date.isNextMonth) {
                        break;
                    }
                    if (day && day.isFocusable) {
                        day.nativeElement.focus();
                        return;
                    }
                }
                break;
            }
        }
        // focus item in prev/next visible month
        const nextMonthView = step > 0 ? monthView.nextMonthView : monthView.prevMonthView;
        if (nextMonthView) {
            dates = nextMonthView.dates.toArray();
            day = dates.find((item) => item.date.date.getTime() === nextDate.getTime());
            if (day && day.isFocusable) {
                day.nativeElement.focus();
                return;
            }
            nextMonthView.daysNavService.focusNextDate(day.nativeElement, key);
        }
        // if iterating in the visible prev/next moths above found a day that is not focusable, ie is disabled, hidden, etc
        // then it is needed to recalculate the next day, which is going to be part of the prev/next months
        if (day && !day.isFocusable) {
            day = dates[i + step];
            if (!day) {
                nextDate = this.timedelta(node.date.date, step + i - index);
            }
        }
        // focus item in prev/next month, which is currently out of view
        let dayIsNextMonth; // determine what we need to check for next date - if it belongs to prev or next month
        if (day) {
            dayIsNextMonth = step > 0 ? day.date.isNextMonth : day.date.isPrevMonth;
        }
        if (monthView.changeDaysView && !nextMonthView && ((day && dayIsNextMonth) || !day)) {
            const monthAction = step > 0 ? ScrollMonth.NEXT : ScrollMonth.PREV;
            monthView.onViewChanging.emit({ monthAction: monthAction, key: key, nextDate: nextDate });
        }
    }
    /**
     * Focuses first focusable day in the month. Will go to next visible month, if no day in the first month is focusable
     * @hidden
     */
    focusHomeDate() {
        let monthView = this.monthView;
        while (!this.focusFirstDay(monthView) && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
    }
    /**
     * Focuses last focusable day in the month. Will go to previous visible month, if no day in the first month is focusable
     * @hidden
     */
    focusEndDate() {
        let monthView = this.monthView;
        while (!this.focusLastDay(monthView) && monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
    }
    timedelta(date, units) {
        const ret = new Date(date);
        ret.setDate(ret.getDate() + units);
        return ret;
    }
    focusFirstDay(monthView) {
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = 0; i < dates.length; i++) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
    focusLastDay(monthView) {
        const dates = monthView.dates.filter(d => d.isCurrentMonth);
        for (let i = dates.length - 1; i >= 0; i--) {
            if (dates[i].isFocusable) {
                dates[i].nativeElement.focus();
                return true;
            }
        }
        return false;
    }
};
IgxDaysViewNavigationService.ɵfac = function IgxDaysViewNavigationService_Factory(t) { return new (t || IgxDaysViewNavigationService)(); };
IgxDaysViewNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxDaysViewNavigationService, factory: IgxDaysViewNavigationService.ɵfac });

var IgxDaysViewComponent_1;
let NEXT_ID$c = 0;
let IgxDaysViewComponent = IgxDaysViewComponent_1 = class IgxDaysViewComponent extends IgxCalendarBaseDirective {
    /**
     * @hidden
     */
    constructor(daysNavService) {
        super();
        this.daysNavService = daysNavService;
        /**
         * Sets/gets the `id` of the days view.
         * If not set, the `id` will have value `"igx-days-view-0"`.
         * ```html
         * <igx-days-view id="my-days-view"></igx-days-view>
         * ```
         * ```typescript
         * let daysViewId =  this.daysView.id;
         * ```
         */
        this.id = `igx-days-view-${NEXT_ID$c++}`;
        /**
         * @hidden
         */
        this.changeDaysView = false;
        /**
         * @hidden
         */
        this.onDateSelection = new EventEmitter();
        /**
         * @hidden
         */
        this.onViewChanging = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * @hidden
     */
    get getCalendarMonth() {
        return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.daysNavService.monthView = this;
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (!this.changeDaysView && this.dates) {
            this.disableOutOfRangeDates();
        }
    }
    /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     */
    formattedDate(value) {
        if (this.formatViews.day) {
            return this.formatterDay.format(value);
        }
        return `${value.getDate()}`;
    }
    /**
     * @hidden
     */
    generateWeekHeader() {
        const dayNames = [];
        const rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
        for (const day of rv) {
            dayNames.push(this.formatterWeekday.format(day.date));
        }
        return dayNames;
    }
    /**
     * @hidden
     */
    rowTracker(index, item) {
        return `${item[index].date.getMonth()}${item[index].date.getDate()}`;
    }
    /**
     * @hidden
     */
    dateTracker(index, item) {
        return `${item.date.getMonth()}--${item.date.getDate()}`;
    }
    /**
     * @hidden
     */
    isCurrentMonth(value) {
        return this.viewDate.getMonth() === value.getMonth();
    }
    /**
     * @hidden
     */
    isCurrentYear(value) {
        return this.viewDate.getFullYear() === value.getFullYear();
    }
    /**
     * @hidden
     */
    isSelected(date) {
        let selectedDates;
        if (this.isDateDisabled(date.date) || !this.value ||
            (Array.isArray(this.value) && this.value.length === 0)) {
            return false;
        }
        if (this.selection === CalendarSelection.SINGLE) {
            selectedDates = this.value;
            return this.getDateOnly(selectedDates).getTime() === date.date.getTime();
        }
        selectedDates = this.value;
        if (this.selection === CalendarSelection.RANGE && selectedDates.length === 1) {
            return this.getDateOnly(selectedDates[0]).getTime() === date.date.getTime();
        }
        if (this.selection === CalendarSelection.MULTI) {
            const start = this.getDateOnly(selectedDates[0]);
            const end = this.getDateOnly(selectedDates[selectedDates.length - 1]);
            if (this.isWithinRange(date.date, false, start, end)) {
                const currentDate = selectedDates.find(element => element.getTime() === date.date.getTime());
                return !!currentDate;
            }
            else {
                return false;
            }
        }
        else {
            return this.isWithinRange(date.date, true);
        }
    }
    /**
     * @hidden
     */
    isLastInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        const dates = this.value;
        const lastDate = dates[dates.length - 1];
        return isEqual(lastDate, date.date);
    }
    /**
     * @hidden
     */
    isFirstInRange(date) {
        if (this.isSingleSelection || !this.value) {
            return false;
        }
        return isEqual(this.value[0], date.date);
    }
    /**
     * @hidden
     */
    isWithinRange(date, checkForRange, min, max) {
        if (checkForRange && !(Array.isArray(this.value) && this.value.length > 1)) {
            return false;
        }
        min = min ? min : this.value[0];
        max = max ? max : this.value[this.value.length - 1];
        return isDateInRanges(date, [
            {
                type: DateRangeType.Between,
                dateRange: [min, max]
            }
        ]);
    }
    /**
     * @hidden
     */
    focusActiveDate() {
        let date = this.dates.find((d) => d.selected);
        if (!date) {
            date = this.dates.find((d) => d.isToday);
        }
        if (date.isFocusable) {
            date.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    selectDay(event) {
        this.selectDateFromClient(event.date);
        this.onDateSelection.emit(event);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     */
    disableOutOfRangeDates() {
        const dateRange = [];
        this.dates.toArray().forEach((date) => {
            if (!date.isCurrentMonth) {
                dateRange.push(date.date.date);
            }
        });
        this.outOfRangeDates = [{
                type: DateRangeType.Specific,
                dateRange: dateRange
            }];
    }
    /**
     * @hidden
     */
    getFirstMonthView() {
        let monthView = this;
        while (monthView.prevMonthView) {
            monthView = monthView.prevMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     */
    getLastMonthView() {
        let monthView = this;
        while (monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
        }
        return monthView;
    }
    /**
     * @hidden
     */
    get isSingleSelection() {
        return this.selection !== CalendarSelection.RANGE;
    }
    /**
     * @hidden
     */
    onKeydownArrow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.daysNavService.focusNextDate(event.target, event.key);
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        event.preventDefault();
        event.stopPropagation();
        this.getFirstMonthView().daysNavService.focusHomeDate();
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        event.preventDefault();
        event.stopPropagation();
        this.getLastMonthView().daysNavService.focusEndDate();
    }
};
IgxDaysViewComponent.ɵfac = function IgxDaysViewComponent_Factory(t) { return new (t || IgxDaysViewComponent)(ɵngcc0.ɵɵdirectiveInject(IgxDaysViewNavigationService)); };
IgxDaysViewComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDaysViewComponent, selectors: [["igx-days-view"]], viewQuery: function IgxDaysViewComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxDayItemComponent, true, IgxDayItemComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dates = _t);
    } }, hostVars: 3, hostBindings: function IgxDaysViewComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowleft", function IgxDaysViewComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.arrowright", function IgxDaysViewComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.arrowup", function IgxDaysViewComponent_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.arrowdown", function IgxDaysViewComponent_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrow($event); })("keydown.home", function IgxDaysViewComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxDaysViewComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id", changeDaysView: "changeDaysView" }, outputs: { onDateSelection: "onDateSelection", onViewChanging: "onViewChanging" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxDaysViewComponent_1
            },
            { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 3, consts: [[1, "igx-calendar__body-row"], ["class", "igx-calendar__label", 4, "ngFor", "ngForOf"], ["class", "igx-calendar__body-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "igx-calendar__label"], [3, "date", "selection", "selected", "isLastInRange", "isFirstInRange", "isWithinRange", "disabledDates", "specialDates", "outOfRangeDates", "hideOutsideDays", "onDateSelection", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "date", "selection", "selected", "isLastInRange", "isFirstInRange", "isWithinRange", "disabledDates", "specialDates", "outOfRangeDates", "hideOutsideDays", "onDateSelection"]], template: function IgxDaysViewComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxDaysViewComponent_span_1_Template, 3, 3, "span", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, IgxDaysViewComponent_div_2_Template, 2, 2, "div", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.generateWeekHeader());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.getCalendarMonth)("ngForTrackBy", ctx.rowTracker);
    } }, directives: [ɵngcc2.NgForOf, IgxDayItemComponent], pipes: [ɵngcc2.TitleCasePipe], encapsulation: 2 });
IgxDaysViewComponent.ctorParameters = () => [
    { type: IgxDaysViewNavigationService }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxDaysViewComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxDaysViewComponent.prototype, "changeDaysView", void 0);
__decorate([
    Output()
], IgxDaysViewComponent.prototype, "onDateSelection", void 0);
__decorate([
    Output()
], IgxDaysViewComponent.prototype, "onViewChanging", void 0);
__decorate([
    ViewChildren(IgxDayItemComponent, { read: IgxDayItemComponent })
], IgxDaysViewComponent.prototype, "dates", void 0);
__decorate([
    HostBinding('class.igx-calendar')
], IgxDaysViewComponent.prototype, "styleClass", void 0);
__decorate([
    HostListener('keydown.arrowleft', ['$event']),
    HostListener('keydown.arrowright', ['$event']),
    HostListener('keydown.arrowup', ['$event']),
    HostListener('keydown.arrowdown', ['$event'])
], IgxDaysViewComponent.prototype, "onKeydownArrow", null);
__decorate([
    HostListener('keydown.home', ['$event'])
], IgxDaysViewComponent.prototype, "onKeydownHome", null);
__decorate([
    HostListener('keydown.end', ['$event'])
], IgxDaysViewComponent.prototype, "onKeydownEnd", null);

var IgxCalendarComponent_1;
let NEXT_ID$d = 0;
/**
 * Calendar provides a way to display date information.
 *
 * @igxModule IgxCalendarModule
 *
 * @igxTheme igx-calendar-theme, igx-icon-theme
 *
 * @igxKeywords calendar, datepicker, schedule, date
 *
 * @igxGroup Scheduling
 *
 * @remarks
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * @example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
let IgxCalendarComponent = IgxCalendarComponent_1 = class IgxCalendarComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the calendar.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-calendar-0"`.
         *
         * @example
         * ```html
         * <igx-calendar id="my-first-calendar"></igx-calendar>
         * ```
         * @memberof IgxCalendarComponent
         */
        this.id = `igx-calendar-${NEXT_ID$d++}`;
        /**
         * Sets/gets whether the calendar has header.
         * Default value is `true`.
         *
         * @example
         * ```html
         * <igx-calendar [hasHeader]="false"></igx-calendar>
         * ```
         */
        this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         */
        this.vertical = false;
        /**
         * Apply the different states for the transitions of animateChange
         * @hidden
         * @internal
         */
        this.animationAction = '';
        /**
         * Denote if the calendar view was changed with the keyboard
         *
         * @hidden
         * @internal
         */
        this.isKeydownTrigger = false;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         * @internal
         */
        this.tabindex = 0;
        /**
         * The default aria role attribute for the component.
         *
         * @hidden
         * @internal
         */
        this.role = 'grid';
        /**
         * The default aria lebelled by attribute for the component.
         *
         * @hidden
         * @internal
         */
        this.ariaLabelledBy = 'calendar';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * @internal
         */
        this.styleClass = true;
        /**
         * @hidden
         * @internal
         */
        this._monthsViewNumber = 1;
        /**
         * Continious navigation through the previous months
         * @hidden
         * @internal
         */
        this.startPrevMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.PREV;
            this.previousMonth(isKeydownTrigger);
        };
        /**
         * Continious navigation through the next months
         * @hidden
         * @internal
         */
        this.startNextMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.NEXT;
            this.nextMonth(isKeydownTrigger);
        };
        /**
         * Stop continuous navigation
         * @hidden
         * @internal
         */
        this.stopMonthScroll = (event) => {
            event.stopPropagation();
            // generally the scrolling is built on the calendar component
            // and all start/stop scrolling methods are called on the calendar
            // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
            // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
            this.daysView.stopMonthScroll$.next(true);
            this.daysView.stopMonthScroll$.complete();
            if (this.monthScrollDirection === ScrollMonth.PREV) {
                this.prevMonthBtn.nativeElement.focus();
            }
            else if (this.monthScrollDirection === ScrollMonth.NEXT) {
                this.nextMonthBtn.nativeElement.focus();
            }
            this.monthScrollDirection = ScrollMonth.NONE;
        };
    }
    /**
     * Sets/gets the number of month views displayed.
     * Default value is `1`.
     *
     * @example
     * ```html
     * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
     * ```
     */
    get monthsViewNumber() {
        return this._monthsViewNumber;
    }
    set monthsViewNumber(val) {
        if (val < 1) {
            return;
        }
        this._monthsViewNumber = val;
    }
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * @internal
     */
    get styleVerticalClass() {
        return this.vertical;
    }
    /**
     * Denote if the year view is active.
     * @hidden
     * @internal
     */
    get isYearView() {
        return this.activeView === CalendarView.YEAR;
    }
    /**
     * Gets the header template.
     *
     * @example
     * ```typescript
     * let headerTemplate =  this.calendar.headerTeamplate;
     * ```
     * @memberof IgxCalendarComponent
     */
    get headerTemplate() {
        if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the header template.
     *
     * @example
     * ```html
     * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set headerTemplate(directive) {
        this.headerTemplateDirective = directive;
    }
    /**
     * Gets the subheader template.
     *
     * @example
     * ```typescript
     * let subheaderTemplate = this.calendar.subheaderTemplate;
     * ```
     */
    get subheaderTemplate() {
        if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the subheader template.
     *
     * @example
     * ```html
     * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
     * ```
     * @memberof IgxCalendarComponent
     */
    set subheaderTemplate(directive) {
        this.subheaderTemplateDirective = directive;
    }
    /**
     * Gets the context for the template marked with the `igxCalendarHeader` directive.
     *
     * @example
     * ```typescript
     * let headerContext =  this.calendar.headerContext;
     * ```
     */
    get headerContext() {
        const date = this.headerDate;
        return this.generateContext(date);
    }
    /**
     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
     * or `igxCalendarSubHeaderYear` directive.
     *
     * @example
     * ```typescript
     * let context =  this.calendar.context;
     * ```
     */
    get context() {
        const date = this.viewDate;
        return this.generateContext(date);
    }
    /**
     * Date displayed in header
     *
     * @hidden
     * @internal
     */
    get headerDate() {
        return this.selectedDates ? this.selectedDates : new Date();
    }
    ngAfterViewInit() {
        this.setSiblingMonths(this.monthViews);
        this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {
            this.setSiblingMonths(c);
        });
        this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(() => this.scrollMonth$.pipe(skipLast(1), debounce(() => interval(300)), takeUntil(this.stopMonthScroll$)))).subscribe(() => {
            switch (this.monthScrollDirection) {
                case ScrollMonth.PREV:
                    this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    }
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @internal
     */
    formattedMonth(value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * Change to previous month
     *
     * @hidden
     * @internal
     */
    previousMonth(isKeydownTrigger = false) {
        this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
        this.animationAction = ScrollMonth.PREV;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    /**
     * Change to next month
     *
     * @hidden
     * @internal
     */
    nextMonth(isKeydownTrigger = false) {
        this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
        this.animationAction = ScrollMonth.NEXT;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecade(args, activeViewIdx) {
        super.activeViewDecade(activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewDecadeKB(event, args, activeViewIdx) {
        super.activeViewDecadeKB(event, activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    getFormattedDate() {
        const date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    }
    /**
     * Handles invoked on date selection
     * @hidden
     * @internal
     */
    childClicked(instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        this.selectDateFromClient(instance.date);
        if (this.selection === 'multi') {
            this.deselectDateInMonthViews(instance.date);
        }
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * @internal
     */
    viewChanging(args) {
        this.animationAction = args.monthAction;
        this.isKeydownTrigger = true;
        this.nextDate = args.nextDate;
        this.callback = (next) => {
            const day = this.daysView.dates.find((item) => item.date.date.getTime() === next.getTime());
            if (day) {
                this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
            }
        };
        this.viewDate = this.nextDate;
    }
    /**
     * @hidden
     * @intenal
     */
    changeMonth(event) {
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            const elem = this.monthsBtns.find((e, idx) => idx === this.activeViewIdx);
            if (elem) {
                elem.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYear(args, activeViewIdx, event) {
        this.activeView = CalendarView.YEAR;
        this.activeViewIdx = activeViewIdx;
        requestAnimationFrame(() => {
            this.monthsView.date = args;
            this.focusMonth(event.target);
        });
    }
    focusMonth(target) {
        const month = this.monthsView.monthsRef.find((e) => e.index === parseInt(target.parentElement.attributes['data-month'].value, 10));
        if (month) {
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onActiveViewYearKB(args, event, activeViewIdx) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.onActiveViewYear(args, activeViewIdx, event);
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     *
     * @example
     * ```typescript
     *  this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     */
    deselectDate(value) {
        super.deselectDate(value);
        this.monthViews.forEach((view) => {
            view.selectedDates = this.selectedDates;
            view.rangeStarted = false;
        });
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Helper method that does deselection for all month views when selection is "multi"
     * If not called, selection in other month views stays
     * @hidden
     * @internal
     */
    deselectDateInMonthViews(value) {
        this.monthViews.forEach(m => {
            m.deselectMultipleInMonth(value);
        });
    }
    /**
     * @hidden
     * @internal
     */
    getViewDate(i) {
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date;
    }
    /**
     * Getter for the context object inside the calendar templates.
     * @hidden
     * @internal
     */
    getContext(i) {
        const date = this.getViewDate(i);
        return this.generateContext(date, i);
    }
    /**
     * @hidden
     * @internal
     */
    animationDone(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
        }
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        let monthView = this.daysView;
        let date = monthView.dates.find((d) => d.selected);
        while (!date && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find((d) => d.selected);
        }
        if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(() => {
                date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
        }
        else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
        }
        this.animationAction = ScrollMonth.NONE;
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            let year = this.nextDate.getFullYear();
            let month = this.nextDate.getMonth() + step;
            if (isPageDown) {
                if (month > 11) {
                    month = 0;
                    year += step;
                }
            }
            else {
                if (month < 0) {
                    month = 11;
                    year += step;
                }
            }
            const range = monthRange(this.nextDate.getFullYear(), month);
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        if (isPageDown) {
            this.nextMonth(true);
        }
        else {
            this.previousMonth(true);
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownShiftPageUp(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        const isPageDown = event.key === 'PageDown';
        const step = isPageDown ? 1 : -1;
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
        this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
        this.isKeydownTrigger = true;
        let monthView = this.daysView;
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            const year = this.nextDate.getFullYear() + step;
            const range = monthRange(year, this.nextDate.getMonth());
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = this.daysView;
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownHome(event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * @internal
     */
    onKeydownEnd(event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    }
    /**
     * Stop continuous navigation on mouseup event
     * @hidden
     * @internal
     */
    onMouseUp(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
        }
    }
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     * @internal
     */
    generateContext(value, i) {
        const formatObject = Object.assign({ index: i, monthView: () => this.onActiveViewYear(value, i), yearView: () => this.onActiveViewDecade(value, i) }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
        return { $implicit: formatObject };
    }
    /**
     * Helper method that sets references for prev/next months for each month in the view
     * @hidden
     * @internal
     */
    setSiblingMonths(monthViews) {
        monthViews.forEach((item, index) => {
            const prevMonthView = this.getMonthView(index - 1);
            const nextMonthView = this.getMonthView(index + 1);
            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
        });
    }
    /**
     * Helper method returning previous/next day views
     * @hidden
     * @internal
     */
    getMonthView(index) {
        if (index === -1 || index === this.monthViews.length) {
            return null;
        }
        else {
            return this.monthViews.toArray()[index];
        }
    }
};
IgxCalendarComponent.ɵfac = function IgxCalendarComponent_Factory(t) { return ɵIgxCalendarComponent_BaseFactory(t || IgxCalendarComponent); };
IgxCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCalendarComponent, selectors: [["igx-calendar"]], contentQueries: function IgxCalendarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxCalendarHeaderTemplateDirective, true, IgxCalendarHeaderTemplateDirective);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxCalendarSubheaderTemplateDirective, true, IgxCalendarSubheaderTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.subheaderTemplateDirective = _t.first);
    } }, viewQuery: function IgxCalendarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c44, true, IgxMonthsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c45, true, IgxYearsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c46, true, IgxDaysViewComponent);
        ɵngcc0.ɵɵviewQuery(_c47, true);
        ɵngcc0.ɵɵviewQuery(_c48, true);
        ɵngcc0.ɵɵviewQuery(_c49, true);
        ɵngcc0.ɵɵviewQuery(_c46, true, IgxDaysViewComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dacadeView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.daysView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prevMonthBtn = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nextMonthBtn = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsBtns = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthViews = _t);
    } }, hostVars: 8, hostBindings: function IgxCalendarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.pagedown", function IgxCalendarComponent_keydown_pagedown_HostBindingHandler($event) { return ctx.onKeydownPageDown($event); })("keydown.pageup", function IgxCalendarComponent_keydown_pageup_HostBindingHandler($event) { return ctx.onKeydownPageDown($event); })("keydown.shift.pageup", function IgxCalendarComponent_keydown_shift_pageup_HostBindingHandler($event) { return ctx.onKeydownShiftPageUp($event); })("keydown.shift.pagedown", function IgxCalendarComponent_keydown_shift_pagedown_HostBindingHandler($event) { return ctx.onKeydownShiftPageUp($event); })("keydown.home", function IgxCalendarComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxCalendarComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); })("mouseup", function IgxCalendarComponent_mouseup_HostBindingHandler($event) { return ctx.onMouseUp($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabindex", ctx.tabindex)("role", ctx.role)("aria-labelledby", ctx.ariaLabelledBy);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass)("igx-calendar--vertical", ctx.styleVerticalClass);
    } }, inputs: { id: "id", hasHeader: "hasHeader", vertical: "vertical", animationAction: "animationAction", monthsViewNumber: "monthsViewNumber" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxCalendarComponent_1
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 4, consts: [["defaultHeader", ""], ["defaultMonth", ""], ["class", "igx-calendar__header", 4, "ngIf"], ["class", "igx-calendar__body", 3, "swiperight", "swipeleft", 4, "ngIf"], [3, "date", "locale", "formatView", "monthFormat", "onSelection", 4, "ngIf"], [3, "date", "locale", "formatView", "yearFormat", "onSelection", 4, "ngIf"], ["tabindex", "0", 1, "igx-calendar-picker__date", 3, "keydown", "click"], ["monthsBtn", ""], ["yearsBtn", ""], [1, "igx-calendar__header"], [1, "igx-calendar__header-year"], [1, "igx-calendar__header-date"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-calendar__body", 3, "swiperight", "swipeleft"], [1, "igx-calendar-picker"], ["tabindex", "0", "igxCalendarScrollMonth", "", 1, "igx-calendar-picker__prev", 3, "startScroll", "stopScroll", "ngStyle"], ["prevMonthBtn", ""], ["fontSet", "material"], ["class", "igx-calendar-picker__dates", 3, "width", 4, "ngFor", "ngForOf"], ["tabindex", "0", "igxCalendarScrollMonth", "", 1, "igx-calendar-picker__next", 3, "startScroll", "stopScroll", "ngStyle"], ["nextMonthBtn", ""], [2, "display", "flex"], [3, "changeDaysView", "selection", "locale", "value", "viewDate", "weekStart", "formatOptions", "formatViews", "disabledDates", "specialDates", "hideOutsideDays", "onViewChanging", "onDateSelection", 4, "ngFor", "ngForOf"], [1, "igx-calendar-picker__dates"], [3, "changeDaysView", "selection", "locale", "value", "viewDate", "weekStart", "formatOptions", "formatViews", "disabledDates", "specialDates", "hideOutsideDays", "onViewChanging", "onDateSelection"], ["days", ""], [3, "date", "locale", "formatView", "monthFormat", "onSelection"], ["months", ""], [3, "date", "locale", "formatView", "yearFormat", "onSelection"], ["decade", ""]], template: function IgxCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxCalendarComponent_ng_template_0_Template, 4, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxCalendarComponent_ng_template_2_Template, 6, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxCalendarComponent_div_4_Template, 5, 3, "div", 2);
        ɵngcc0.ɵɵtemplate(5, IgxCalendarComponent_div_5_Template, 15, 18, "div", 3);
        ɵngcc0.ɵɵtemplate(6, IgxCalendarComponent_igx_months_view_6_Template, 2, 5, "igx-months-view", 4);
        ɵngcc0.ɵɵtemplate(7, IgxCalendarComponent_igx_years_view_7_Template, 2, 5, "igx-years-view", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selection === "single" && ctx.hasHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDefaultView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isYearView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDecadeView);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxCalendarScrollMonthDirective, ɵngcc2.NgStyle, IgxIconComponent, ɵngcc2.NgForOf, IgxDaysViewComponent,
        IgxMonthsViewComponent,
        IgxYearsViewComponent]; }, pipes: function () { return [IgxMonthViewSlotsCalendar,
        IgxGetViewDateCalendar]; }, encapsulation: 2, data: { animation: [
            trigger('animateView', [
                transition('void => 0', useAnimation(fadeIn)),
                transition('void => *', useAnimation(scaleInCenter, {
                    params: {
                        duration: '.2s',
                        fromScale: .9
                    }
                }))
            ]),
            trigger('animateChange', [
                transition('* => prev', useAnimation(slideInLeft, {
                    params: {
                        fromPosition: 'translateX(-30%)'
                    }
                })),
                transition('* => next', useAnimation(slideInRight, {
                    params: {
                        fromPosition: 'translateX(30%)'
                    }
                }))
            ])
        ] } });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxCalendarComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxCalendarComponent.prototype, "hasHeader", void 0);
__decorate([
    Input()
], IgxCalendarComponent.prototype, "vertical", void 0);
__decorate([
    Input()
], IgxCalendarComponent.prototype, "monthsViewNumber", null);
__decorate([
    Input()
], IgxCalendarComponent.prototype, "animationAction", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxCalendarComponent.prototype, "tabindex", void 0);
__decorate([
    HostBinding('attr.role')
], IgxCalendarComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.aria-labelledby')
], IgxCalendarComponent.prototype, "ariaLabelledBy", void 0);
__decorate([
    HostBinding('class.igx-calendar--vertical')
], IgxCalendarComponent.prototype, "styleVerticalClass", null);
__decorate([
    HostBinding('class.igx-calendar')
], IgxCalendarComponent.prototype, "styleClass", void 0);
__decorate([
    ViewChild('months', { read: IgxMonthsViewComponent })
], IgxCalendarComponent.prototype, "monthsView", void 0);
__decorate([
    ViewChildren('monthsBtn')
], IgxCalendarComponent.prototype, "monthsBtns", void 0);
__decorate([
    ViewChild('decade', { read: IgxYearsViewComponent })
], IgxCalendarComponent.prototype, "dacadeView", void 0);
__decorate([
    ViewChild('days', { read: IgxDaysViewComponent })
], IgxCalendarComponent.prototype, "daysView", void 0);
__decorate([
    ViewChildren('days', { read: IgxDaysViewComponent })
], IgxCalendarComponent.prototype, "monthViews", void 0);
__decorate([
    ViewChild('prevMonthBtn')
], IgxCalendarComponent.prototype, "prevMonthBtn", void 0);
__decorate([
    ViewChild('nextMonthBtn')
], IgxCalendarComponent.prototype, "nextMonthBtn", void 0);
__decorate([
    ContentChild(forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true })
], IgxCalendarComponent.prototype, "headerTemplateDirective", void 0);
__decorate([
    ContentChild(forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true })
], IgxCalendarComponent.prototype, "subheaderTemplateDirective", void 0);
__decorate([
    HostListener('keydown.pagedown', ['$event']),
    HostListener('keydown.pageup', ['$event'])
], IgxCalendarComponent.prototype, "onKeydownPageDown", null);
__decorate([
    HostListener('keydown.shift.pageup', ['$event']),
    HostListener('keydown.shift.pagedown', ['$event'])
], IgxCalendarComponent.prototype, "onKeydownShiftPageUp", null);
__decorate([
    HostListener('keydown.home', ['$event'])
], IgxCalendarComponent.prototype, "onKeydownHome", null);
__decorate([
    HostListener('keydown.end', ['$event'])
], IgxCalendarComponent.prototype, "onKeydownEnd", null);
__decorate([
    HostListener('document:mouseup', ['$event'])
], IgxCalendarComponent.prototype, "onMouseUp", null);

var IgxMonthPickerComponent_1;
let NEXT_ID$e = 0;
let IgxMonthPickerComponent = IgxMonthPickerComponent_1 = class IgxMonthPickerComponent extends IgxMonthPickerBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the month picker.
         * If not set, the `id` will have value `"igx-month-picker-0"`.
         */
        this.id = `igx-month-picker-${NEXT_ID$e++}`;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * @hidden
         */
        this.yearAction = '';
    }
    /**
     * @hidden
     */
    animationDone() {
        this.yearAction = '';
    }
    /**
     * @hidden
     */
    activeViewDecadeKB(event) {
        super.activeViewDecadeKB(event);
        if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
            event.preventDefault();
            this.nextYear();
        }
        if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
            event.preventDefault();
            this.previousYear();
        }
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    activeViewDecade() {
        super.activeViewDecade();
        requestAnimationFrame(() => {
            this.dacadeView.el.nativeElement.focus();
        });
    }
    /**
     * @hidden
     */
    nextYear() {
        this.yearAction = 'next';
        this.viewDate = this.calendarModel.getNextYear(this.viewDate);
        this.selectDate(this.viewDate);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     */
    nextYearKB(event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            event.stopPropagation();
            this.nextYear();
        }
    }
    /**
     * @hidden
     */
    previousYear() {
        this.yearAction = 'prev';
        this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
        this.selectDate(this.viewDate);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     */
    previousYearKB(event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            event.stopPropagation();
            this.previousYear();
        }
    }
    /**
     * @hidden
     */
    selectYear(event) {
        this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
        this.activeView = CalendarView.DEFAULT;
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
        requestAnimationFrame(() => {
            if (this.yearsBtn) {
                this.yearsBtn.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     */
    selectMonth(event) {
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * Selects a date.
     * ```typescript
     *  this.monPicker.selectDate(new Date(`2018-06-12`));
     * ```
     */
    selectDate(value) {
        if (!value) {
            return new Date();
        }
        // TO DO: to be refactored after discussion on the desired behavior
        super.selectDate(value);
        this.viewDate = value;
    }
    /**
     * @hidden
     */
    writeValue(value) {
        // TO DO: to be refactored after discussion on the desired behavior
        if (value) {
            this.viewDate = this.selectedDates = value;
        }
    }
    /**
     * @hidden
     */
    onKeydownPageUp(event) {
        event.preventDefault();
        this.yearAction = 'prev';
        this.viewDate = this.calendarModel.getPrevYear(this.viewDate);
    }
    /**
     * @hidden
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        this.yearAction = 'next';
        this.viewDate = this.calendarModel.getNextYear(this.viewDate);
    }
    /**
     * @hidden
     */
    onKeydownHome(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownHome(event);
        }
    }
    /**
     * @hidden
     */
    onKeydownEnd(event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownEnd(event);
        }
    }
};
IgxMonthPickerComponent.ɵfac = function IgxMonthPickerComponent_Factory(t) { return ɵIgxMonthPickerComponent_BaseFactory(t || IgxMonthPickerComponent); };
IgxMonthPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxMonthPickerComponent, selectors: [["igx-month-picker"]], viewQuery: function IgxMonthPickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c44, true, IgxMonthsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c45, true, IgxYearsViewComponent);
        ɵngcc0.ɵɵviewQuery(_c46, true, IgxDaysViewComponent);
        ɵngcc0.ɵɵviewQuery(_c43, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.monthsView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dacadeView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.daysView = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.yearsBtn = _t.first);
    } }, hostVars: 3, hostBindings: function IgxMonthPickerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.pageup", function IgxMonthPickerComponent_keydown_pageup_HostBindingHandler($event) { return ctx.onKeydownPageUp($event); })("keydown.pagedown", function IgxMonthPickerComponent_keydown_pagedown_HostBindingHandler($event) { return ctx.onKeydownPageDown($event); })("keydown.home", function IgxMonthPickerComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxMonthPickerComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-calendar", ctx.styleClass);
    } }, inputs: { id: "id" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                multi: true,
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxMonthPickerComponent_1
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 2, consts: [["class", "igx-calendar__body", 3, "swiperight", "swipeleft", 4, "ngIf"], [3, "date", "locale", "formatView", "yearFormat", "onSelection", 4, "ngIf"], [1, "igx-calendar__body", 3, "swiperight", "swipeleft"], [1, "igx-calendar-picker"], ["tabindex", "0", 1, "igx-calendar-picker__prev", 3, "ngStyle", "click", "keydown"], ["fontSet", "material"], ["tabindex", "0", 1, "igx-calendar-picker__date", 3, "keydown", "click"], ["yearsBtn", ""], ["tabindex", "0", 1, "igx-calendar-picker__next", 3, "ngStyle", "click", "keydown"], [3, "date", "locale", "formatView", "monthFormat", "onSelection"], ["months", ""], [3, "date", "locale", "formatView", "yearFormat", "onSelection"], ["decade", ""]], template: function IgxMonthPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxMonthPickerComponent_div_0_Template, 14, 13, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxMonthPickerComponent_igx_years_view_1_Template, 2, 5, "igx-years-view", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDefaultView);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDecadeView);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgStyle, IgxIconComponent,
        IgxMonthsViewComponent,
        IgxYearsViewComponent], encapsulation: 2, data: { animation: [
            trigger('animateView', [
                transition('void => 0', useAnimation(fadeIn)),
                transition('void => *', useAnimation(scaleInCenter, {
                    params: {
                        duration: '.2s',
                        fromScale: .9
                    }
                }))
            ]),
            trigger('animateChange', [
                transition('* => prev', useAnimation(slideInLeft, {
                    params: {
                        fromPosition: 'translateX(-30%)'
                    }
                })),
                transition('* => next', useAnimation(slideInRight, {
                    params: {
                        fromPosition: 'translateX(30%)'
                    }
                }))
            ])
        ] } });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxMonthPickerComponent.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-calendar')
], IgxMonthPickerComponent.prototype, "styleClass", void 0);
__decorate([
    ViewChild('months', { read: IgxMonthsViewComponent })
], IgxMonthPickerComponent.prototype, "monthsView", void 0);
__decorate([
    ViewChild('decade', { read: IgxYearsViewComponent })
], IgxMonthPickerComponent.prototype, "dacadeView", void 0);
__decorate([
    ViewChild('days', { read: IgxDaysViewComponent })
], IgxMonthPickerComponent.prototype, "daysView", void 0);
__decorate([
    ViewChild('yearsBtn')
], IgxMonthPickerComponent.prototype, "yearsBtn", void 0);
__decorate([
    HostListener('keydown.pageup', ['$event'])
], IgxMonthPickerComponent.prototype, "onKeydownPageUp", null);
__decorate([
    HostListener('keydown.pagedown', ['$event'])
], IgxMonthPickerComponent.prototype, "onKeydownPageDown", null);
__decorate([
    HostListener('keydown.home', ['$event'])
], IgxMonthPickerComponent.prototype, "onKeydownHome", null);
__decorate([
    HostListener('keydown.end', ['$event'])
], IgxMonthPickerComponent.prototype, "onKeydownEnd", null);

let IgxMonthViewSlotsCalendar = class IgxMonthViewSlotsCalendar {
    transform(monthViews) {
        return new Array(monthViews);
    }
};
IgxMonthViewSlotsCalendar.ɵfac = function IgxMonthViewSlotsCalendar_Factory(t) { return new (t || IgxMonthViewSlotsCalendar)(); };
IgxMonthViewSlotsCalendar.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "IgxMonthViewSlots", type: IgxMonthViewSlotsCalendar, pure: true });
let IgxGetViewDateCalendar = class IgxGetViewDateCalendar {
    constructor() {
        this.calendar = new Calendar();
    }
    transform(index, viewDate, wholeDate = true) {
        const date = this.calendar.timedelta(viewDate, 'month', index);
        return wholeDate ? date : date.getMonth();
    }
};
IgxGetViewDateCalendar.ɵfac = function IgxGetViewDateCalendar_Factory(t) { return new (t || IgxGetViewDateCalendar)(); };
IgxGetViewDateCalendar.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "IgxGetViewDate", type: IgxGetViewDateCalendar, pure: true });

/**
 * @hidden
 */
let IgxCalendarModule = class IgxCalendarModule {
};
IgxCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCalendarModule });
IgxCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCalendarModule_Factory(t) { return new (t || IgxCalendarModule)(); }, imports: [[CommonModule, FormsModule, IgxIconModule]] });

/** @hidden */
const IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

/**
 * @hidden
 */
let DatePickerDisplayValuePipe = class DatePickerDisplayValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimEmptyPlaceholders(value);
        }
        return '';
    }
};
DatePickerDisplayValuePipe.ɵfac = function DatePickerDisplayValuePipe_Factory(t) { return new (t || DatePickerDisplayValuePipe)(ɵngcc0.ɵɵdirectiveInject(IGX_DATE_PICKER_COMPONENT)); };
DatePickerDisplayValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "displayValue", type: DatePickerDisplayValuePipe, pure: true });
DatePickerDisplayValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
DatePickerDisplayValuePipe = __decorate([ __param(0, Inject(IGX_DATE_PICKER_COMPONENT))
], DatePickerDisplayValuePipe);
/**
 * @hidden
 */
let DatePickerInputValuePipe = class DatePickerInputValuePipe {
    constructor(_datePicker) {
        this._datePicker = _datePicker;
    }
    transform(value, args) {
        /**
         * TODO(D.P.): This plugs into the mask, but constantly received display strings it can't handle at all
         * Those are almost immediately overridden by the pickers onFocus handling anyway; Refactor ASAP
         */
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return this._datePicker._getEditorDate(this._datePicker.value);
                // return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    }
};
DatePickerInputValuePipe.ɵfac = function DatePickerInputValuePipe_Factory(t) { return new (t || DatePickerInputValuePipe)(ɵngcc0.ɵɵdirectiveInject(IGX_DATE_PICKER_COMPONENT)); };
DatePickerInputValuePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "inputValue", type: DatePickerInputValuePipe, pure: true });
DatePickerInputValuePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
];
DatePickerInputValuePipe = __decorate([ __param(0, Inject(IGX_DATE_PICKER_COMPONENT))
], DatePickerInputValuePipe);

let IgxDatePickerTemplateDirective = 
/**
 * IgxDatePickerTemplateDirective can be used to re-template the date-picker input-group.
 *
 * @hidden
 */
class IgxDatePickerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxDatePickerTemplateDirective.ɵfac = function IgxDatePickerTemplateDirective_Factory(t) { return new (t || IgxDatePickerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxDatePickerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDatePickerTemplateDirective, selectors: [["", "igxDatePickerTemplate", ""]] });
IgxDatePickerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * IgxDatePickerActionsDirective can be used to re-template the dropdown/dialog action buttons.
 */
let IgxDatePickerActionsDirective = class IgxDatePickerActionsDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxDatePickerActionsDirective.ɵfac = function IgxDatePickerActionsDirective_Factory(t) { return new (t || IgxDatePickerActionsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxDatePickerActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDatePickerActionsDirective, selectors: [["", "igxDatePickerActions", ""]] });
IgxDatePickerActionsDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * This enumeration is used to configure whether the date/time picker has an editable input with drop down
 * or is readonly - the date/time is selected only through a dialog.
 */
var InteractionMode;
(function (InteractionMode) {
    InteractionMode["DropDown"] = "dropdown";
    InteractionMode["Dialog"] = "dialog";
})(InteractionMode || (InteractionMode = {}));

/**
 * @hidden
 */
let IgxCalendarContainerComponent = class IgxCalendarContainerComponent {
    constructor() {
        this.mode = InteractionMode.Dialog;
        this.vertical = false;
        this.onClose = new EventEmitter();
        this.onTodaySelection = new EventEmitter();
        this.styleClass = 'igx-date-picker';
    }
    get dropdownCSS() {
        return this.mode === InteractionMode.DropDown;
    }
    get verticalCSS() {
        return this.vertical && this.mode === InteractionMode.Dialog;
    }
    onEscape(event) {
        event.preventDefault();
        this.onClose.emit();
    }
    /**
     * Returns whether the date-picker is in readonly dialog mode.
     *
     * @hidden
     */
    get isReadonly() {
        return this.mode === InteractionMode.Dialog;
    }
    /**
     * Emits close event for the calendar.
     */
    closeCalendar() {
        this.onClose.emit();
    }
    /**
     * Emits today selection event for the calendar.
     */
    triggerTodaySelection() {
        this.onTodaySelection.emit();
    }
};
IgxCalendarContainerComponent.ɵfac = function IgxCalendarContainerComponent_Factory(t) { return new (t || IgxCalendarContainerComponent)(); };
IgxCalendarContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCalendarContainerComponent, selectors: [["igx-calendar-container"]], viewQuery: function IgxCalendarContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c53, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.calendar = _t.first);
    } }, hostVars: 6, hostBindings: function IgxCalendarContainerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function IgxCalendarContainerComponent_keydown_esc_HostBindingHandler($event) { return ctx.onEscape($event); })("keydown.alt.arrowup", function IgxCalendarContainerComponent_keydown_alt_arrowup_HostBindingHandler($event) { return ctx.onEscape($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-date-picker", ctx.styleClass)("igx-date-picker--dropdown", ctx.dropdownCSS)("igx-date-picker--vertical", ctx.verticalCSS);
    } }, inputs: { mode: "mode", vertical: "vertical", cancelButtonLabel: "cancelButtonLabel", todayButtonLabel: "todayButtonLabel", datePickerActions: "datePickerActions" }, outputs: { onClose: "onClose", onTodaySelection: "onTodaySelection" }, decls: 5, vars: 1, consts: [["defaultDatePickerActions", ""], ["calendar", ""], [4, "ngTemplateOutlet"], ["class", "igx-date-picker__buttons", 4, "ngIf"], [1, "igx-date-picker__buttons"], ["igxButton", "flat", "igxRipple", "", 3, "click", 4, "ngIf"], ["igxButton", "flat", "igxRipple", "", 3, "click"], ["closeButton", ""], ["todayButton", ""]], template: function IgxCalendarContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxCalendarContainerComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelement(2, "igx-calendar", null, 1);
        ɵngcc0.ɵɵtemplate(4, IgxCalendarContainerComponent_ng_container_4_Template, 1, 0, "ng-container", 2);
    } if (rf & 2) {
        const _r264 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.datePickerActions ? ctx.datePickerActions.template : _r264);
    } }, directives: [IgxCalendarComponent, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxButtonDirective,
        IgxRippleDirective], styles: ["[_nghost-%COMP%] {display: block;}"] });
__decorate([
    ViewChild('calendar', { static: true })
], IgxCalendarContainerComponent.prototype, "calendar", void 0);
__decorate([
    Input()
], IgxCalendarContainerComponent.prototype, "mode", void 0);
__decorate([
    Input()
], IgxCalendarContainerComponent.prototype, "vertical", void 0);
__decorate([
    Input()
], IgxCalendarContainerComponent.prototype, "cancelButtonLabel", void 0);
__decorate([
    Input()
], IgxCalendarContainerComponent.prototype, "todayButtonLabel", void 0);
__decorate([
    Input()
], IgxCalendarContainerComponent.prototype, "datePickerActions", void 0);
__decorate([
    Output()
], IgxCalendarContainerComponent.prototype, "onClose", void 0);
__decorate([
    Output()
], IgxCalendarContainerComponent.prototype, "onTodaySelection", void 0);
__decorate([
    HostBinding('class.igx-date-picker')
], IgxCalendarContainerComponent.prototype, "styleClass", void 0);
__decorate([
    HostBinding('class.igx-date-picker--dropdown')
], IgxCalendarContainerComponent.prototype, "dropdownCSS", null);
__decorate([
    HostBinding('class.igx-date-picker--vertical')
], IgxCalendarContainerComponent.prototype, "verticalCSS", null);
__decorate([
    HostListener('keydown.esc', ['$event']),
    HostListener('keydown.alt.arrowup', ['$event'])
], IgxCalendarContainerComponent.prototype, "onEscape", null);

var IgxDatePickerComponent_1;
let NEXT_ID$f = 0;
/**
 * This enumeration is used to configure the date picker to operate with pre-defined format option used in Angular DatePipe.
 * 'https://angular.io/api/common/DatePipe'
 * 'shortDate': equivalent to 'M/d/yy' (6/15/15).
 * 'mediumDate': equivalent to 'MMM d, y' (Jun 15, 2015).
 * 'longDate': equivalent to 'MMMM d, y' (June 15, 2015).
 * 'fullDate': equivalent to 'EEEE, MMMM d, y' (Monday, June 15, 2015).
 */
var PredefinedFormatOptions;
(function (PredefinedFormatOptions) {
    PredefinedFormatOptions["ShortDate"] = "shortDate";
    PredefinedFormatOptions["MediumDate"] = "mediumDate";
    PredefinedFormatOptions["LongDate"] = "longDate";
    PredefinedFormatOptions["FullDate"] = "fullDate";
})(PredefinedFormatOptions || (PredefinedFormatOptions = {}));
const noop$4 = () => { };
const ɵ0$5 = noop$4;
/**
 * Date Picker displays a popup calendar that lets users select a single date.
 * @igxModule IgxDatePickerModule
 * @igxTheme igx-calendar-theme, igx-icon-theme
 * @igxGroup Scheduling
 * @igxKeywords  datepicker, calendar, schedule, date
 * @example
 * ```html
 * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
 * ```
 */
let IgxDatePickerComponent = IgxDatePickerComponent_1 = class IgxDatePickerComponent {
    constructor(_overlayService, element, _cdr, _moduleRef, _injector) {
        this._overlayService = _overlayService;
        this.element = element;
        this._cdr = _cdr;
        this._moduleRef = _moduleRef;
        this._injector = _injector;
        /**
         * Gets/Sets the `IgxDatePickerComponent` label.
         * @remarks
         * The default label is 'Date'.
         * @example
         * ```html
         * <igx-date-picker [label]="Calendar"></igx-date-picker>
         * ```
         */
        this.label = 'Date';
        /**
         * Gets/Sets the `IgxDatePickerComponent` label visibility.
         * @remarks
         * By default the visibility is set to true.
         * @example
         * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
         */
        this.labelVisibility = true;
        /**
         * Gets/Sets on which day the week starts.
         * @example
         * ```html
         * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * Gets/Sets the number of month views displayed.
         * @remarks
         * Default value is `1`.
         * @example
         * ```html
         * <igx-date-picker [monthsViewNumber]="2"></igx-date-picker>
         * ```
         * @example
         * ```typescript
         * let monthViewsDisplayed = this.datePicker.monthsViewNumber;
         * ```
         */
        this.monthsViewNumber = 1;
        /**
         * Gets/Sets the value of `id` attribute.
         * @remarks If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.id = `igx-date-picker-${NEXT_ID$f++}`;
        /**
         * Gets/Sets the orientation of the `IgxDatePickerComponent` header.
         *  @example
         * ```html
         * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Gets/Sets the interaction mode - dialog or drop down.
         *  @example
         * ```html
         * <igx-date-picker mode="dropdown"></igx-date-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Gets/Sets whether date should spin continuously or stop when min/max is reached.
         *  @example
         * ```html
         * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * Emitted when the `IgxDatePickerComponent` calendar is opened.
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted after the `IgxDatePickerComponent` is closed.
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when the `IgxDatePickerComponent` is being closed.
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted when selection is made in the calendar.
         *  @example
         * ```html
         * <igx-date-picker (onSelection)="selection($event)"></igx-date-picker>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emitted when date picker value is changed.
         * @example
         * ```html
         * <igx-date-picker (valueChange)="valueChanged($event)" mode="dropdown"></igx-date-picker>
         * ```
         */
        this.valueChange = new EventEmitter();
        /**
         * Emitted when the user types/spins to a disabled date in the date-picker editor.
         *  @example
         * ```html
         * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
         * ```
         */
        this.onDisabledDate = new EventEmitter();
        /**
         * Emitted when the user types/spins invalid date in the date-picker editor.
         *  @example
         * ```html
         * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /** @hidden @internal */
        this.hasHeader = true;
        /** @hidden @internal */
        this.collapsed = true;
        /** @hidden @internal */
        this.displayValuePipe = new DatePickerDisplayValuePipe(this);
        /** @hidden @internal */
        this.inputValuePipe = new DatePickerInputValuePipe(this);
        /** @hidden @internal */
        this.dateFormatParts = [];
        /** @hidden @internal */
        this.isEmpty = true;
        /** @hidden @internal */
        this.invalidDate = '';
        this.spinDelta = 1;
        this.defaultLocale = 'en';
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        this._destroy$ = new Subject();
        this._disabledDates = null;
        this._specialDates = null;
        this._onOpen = new EventEmitter();
        this._onClose = new EventEmitter();
        this._ngControl = null;
        //#region ControlValueAccessor
        this._onChangeCallback = noop$4;
        this._onTouchedCallback = noop$4;
    }
    /**
     * Gets the format options of the `IgxDatePickerComponent`.
     * @example
     * ```typescript
     * let formatOptions = this.datePicker.formatOptions;
     * ```
     */
    get formatOptions() {
        return this._formatOptions;
    }
    /**
     * Sets the format options of the `IgxDatePickerComponent`.
     * @example
     * ```typescript
     * this.datePicker.formatOptions = {  day: "numeric",  month: "long", weekday: "long", year: "numeric"};
     * ```
     */
    set formatOptions(formatOptions) {
        this._formatOptions = Object.assign(this._formatOptions, formatOptions);
    }
    /**
     * Gets/Sets the date display format of the `IgxDatePickerComponent` in dropdown mode.
     * @example
     * ```typescript
     * let format = this.datePicker.format;
     * this.datePicker.format = 'yyyy-M-d';
     * ```
     */
    get format() {
        return (this._format === undefined) ? PredefinedFormatOptions.ShortDate : this._format;
    }
    set format(format) {
        this._format = format;
    }
    /**
     * Gets/Sets the format views of the `IgxDatePickerComponent`.
     * @example
     * ```typescript
     * let formatViews = this.datePicker.formatViews;
     *  this.datePicker.formatViews = {day:false, month: false, year:false};
     * ```
     */
    get formatViews() {
        return this._formatViews;
    }
    set formatViews(formatViews) {
        this._formatViews = Object.assign(this._formatViews, formatViews);
    }
    /**
     * Gets/Sets the disabled dates descriptors.
     * @example
     * ```typescript
     * let disabledDates = this.datepicker.disabledDates;
     * this.datePicker.disabledDates = [ {type: DateRangeType.Weekends}, ...];
     * ```
     */
    get disabledDates() {
        return this._disabledDates;
    }
    set disabledDates(value) {
        this._disabledDates = value;
    }
    /**
     * Gets/Sets the special dates descriptors.
     * @example
     * ```typescript
     * let specialDates = this.datepicker.specialDates;
     * this.datePicker.specialDates = [ {type: DateRangeType.Weekends}, ... ];
     * ```
     */
    get specialDates() {
        return this._specialDates;
    }
    set specialDates(value) {
        this._specialDates = value;
    }
    /**
     * Gets/Sets the modal overlay settings.
     */
    get modalOverlaySettings() {
        return this._modalOverlay;
    }
    set modalOverlaySettings(value) {
        this._modalOverlay = value;
    }
    /**
     * Gets/Sets the drop-down overlay settings.
     */
    get dropDownOverlaySettings() {
        return this._dropDownOverlaySettings || this._defaultDropDownOverlaySettings;
    }
    set dropDownOverlaySettings(value) {
        this._dropDownOverlaySettings = value;
    }
    /**
     * Gets the formatted date when `IgxDatePickerComponent` is in dialog mode.
     *  @example
     * ```typescript
     * let selectedDate = this.datePicker.displayData;
     * ```
     */
    get displayData() {
        if (this.value) {
            return this._customFormatChecker(this.formatter, this.value);
        }
        return '';
    }
    /**
     * @hidden @internal
     */
    get transformedDate() {
        if (this._value) {
            this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
            this.isEmpty = false;
        }
        else {
            this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
        }
        return this._transformedDate;
    }
    /**
     * @hidden @internal
     */
    set transformedDate(value) {
        this._transformedDate = value;
    }
    /**
     * Gets the input group template.
     * @example
     * ```typescript
     * let template = this.template();
     * ```
     */
    get template() {
        if (this.datePickerTemplateDirective) {
            return this.datePickerTemplateDirective.template;
        }
        return (this.mode === InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     */
    get context() {
        return {
            disabled: this.disabled,
            disabledDates: this.disabledDates,
            displayData: this.displayData,
            format: this.format,
            isSpinLoop: this.isSpinLoop,
            label: this.label,
            labelVisibility: this.labelVisibility,
            locale: this.locale,
            mask: this.mask,
            mode: this.mode,
            specialDates: this.specialDates,
            value: this.value,
            openDialog: () => this.openDialog()
        };
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this._ngControl.control.validator({});
            return error && error.required;
        }
        return false;
    }
    /**
     * Gets/Sets the selected date.
     *  @example
     * ```html
     * <igx-date-picker [value]="date"></igx-date-picker>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(date) {
        this._value = date;
        this._onChangeCallback(date);
    }
    /** @hidden @internal */
    writeValue(value) {
        this._value = value;
        // TODO: do we need next call
        this._cdr.markForCheck();
    }
    /** @hidden @internal */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    //#endregion
    /**
     * @hidden
     */
    onSpaceClick(event) {
        this.openDialog();
        event.preventDefault();
    }
    /** @hidden */
    getEditElement() {
        const inputDirectiveElementRef = this._inputElementRef || this._inputUserTemplateElementRef;
        return (inputDirectiveElementRef) ? inputDirectiveElementRef.nativeElement : null;
    }
    /**
     * @hidden @internal
     */
    getInputGroupElement() {
        if (this.inputGroup) {
            return this.inputGroup.element.nativeElement;
        }
        if (this.inputGroupUserTemplate) {
            return this.inputGroupUserTemplate.element.nativeElement;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        this._defaultDropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(this._positionSettings),
            outlet: this.outlet
        };
        this._modalOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true,
            outlet: this.outlet
        };
        this._overlayService.onOpening.pipe(filter((overlay) => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe((eventArgs) => {
            this._onOpening(eventArgs);
        });
        this._overlayService.onOpened.pipe(filter((overlay) => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe(() => {
            this._onOpened();
        });
        this._overlayService.onClosed.pipe(filter(overlay => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe(() => {
            this._onClosed();
        });
        this._overlayService.onClosing.pipe(filter(overlay => overlay.id === this._componentID), takeUntil(this._destroy$)).subscribe((event) => {
            this.onClosing.emit(event);
            // If canceled in a user onClosing handler
            if (event.cancel) {
                return;
            }
            // Do not focus the input if clicking outside in dropdown mode
            const input = this.getEditElement();
            if (input && !(event.event && this.mode === InteractionMode.DropDown)) {
                input.focus();
            }
            else {
                // outside click
                this._updateValidityOnBlur();
            }
        });
        if (this.mode === InteractionMode.DropDown) {
            this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
            if (this.mask === undefined) {
                this.mask = DatePickerUtil.getMask(this.dateFormatParts);
            }
            this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
        }
        this._ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
            fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy$)).subscribe((res) => this.onKeyDown(res));
        }
        if (this._ngControl) {
            this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
    }
    ngAfterViewChecked() {
        // if one sets mode at run time this forces initialization of new igxInputGroup
        // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
        // the new directive isRequired of the igxInputGroup is set again. However
        // ngAfterViewInit of date picker is not called again and we may finish with wrong
        // isRequired in igxInputGroup. This is why we should set it her, only when needed
        if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
            this.inputGroup.isRequired = this.required;
            this._cdr.detectChanges();
        }
    }
    onStatusChanged() {
        if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
            (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this._inputDirective.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                this._inputDirective.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        if (this.inputGroup && this.inputGroup.isRequired !== this.required) {
            this.inputGroup.isRequired = this.required;
        }
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        if (this._componentID) {
            this._overlayService.hide(this._componentID);
        }
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * Selects today's date from calendar.
     *  @remarks
     * Changes the input field value, @calendar.viewDate and @calendar.value.
     *  @example
     * ```typescript
     * this.datePicker.triggerTodaySelection();
     * ```
     */
    triggerTodaySelection() {
        const today = new Date(Date.now());
        this.handleSelection(today);
    }
    /**
     * Change the calendar selection.
     * @remarks
     * Calling this method will emit the @calendar.onSelection event,
     * which will fire @handleSelection method.
     * @example
     * ```typescript
     * this.datePicker.selectDate(this.date);
     * ```
     * @param date passed date that has to be set to the calendar.
     */
    selectDate(date) {
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.onSelection.emit(date);
    }
    /**
     * Deselects the calendar date.
     * @example
     * ```typescript
     * this.datePicker.deselectDate();
     * ```
     */
    deselectDate() {
        const oldValue = this.value;
        this.value = null;
        this.emitValueChangeEvent(oldValue, this.value);
        if (this.calendar) {
            this.calendar.deselectDate();
        }
    }
    /**
     * Opens the date picker drop down or dialog.
     * @param target HTMLElement - the target element to use for positioning the drop down container according to
     * @example
     * ```typescript
     * this.datePicker.openDialog(target);
     * ```
     */
    openDialog() {
        if (!this.collapsed) {
            return;
        }
        switch (this.mode) {
            case InteractionMode.Dialog: {
                this.hasHeader = true;
                const modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
            case InteractionMode.DropDown: {
                this.hasHeader = false;
                const target = this.getInputGroupElement();
                if (target) {
                    this.dropDownOverlaySettings.positionStrategy.settings.target = target;
                }
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, this.dropDownOverlaySettings, this._moduleRef);
                this._overlayService.show(this._componentID);
                break;
            }
        }
    }
    /**
     * Close the calendar.
     *
     * @hidden @internal
     */
    closeCalendar() {
        this._overlayService.hide(this._componentID);
    }
    /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden @internal
     */
    clear() {
        this.isEmpty = true;
        this.invalidDate = '';
        this.deselectDate();
        this._setCursorPosition(0);
    }
    /**
     * Evaluates when @calendar.onSelection event was fired
     * and update the input value.
     *
     * @param event selected value from calendar.
     *
     * @hidden @internal
     */
    handleSelection(date) {
        if (this.value) {
            date.setHours(this.value.getHours());
            date.setMinutes(this.value.getMinutes());
            date.setSeconds(this.value.getSeconds());
            date.setMilliseconds(this.value.getMilliseconds());
        }
        const oldValue = this.value;
        this.value = date;
        this.emitValueChangeEvent(oldValue, this.value);
        this.calendar.viewDate = date;
        this.closeCalendar();
        this.onSelection.emit(date);
    }
    /** @hidden @internal */
    onOpenClick(event) {
        event.stopPropagation();
        this.openDialog();
    }
    /**
     * @hidden @internal
     */
    onBlur(event) {
        this._isInEditMode = false;
        if (this.mode === InteractionMode.DropDown) {
            this.calculateDate(event.target.value, event.type);
        }
        if (this.collapsed) {
            this._updateValidityOnBlur();
        }
    }
    /**
     * @hidden @internal
     */
    onFocus() {
        this._isInEditMode = true;
        if (this.value && this.invalidDate === '') {
            this._transformedDate = this._getEditorDate(this.value);
        }
    }
    /**
     * @hidden @internal
     */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                event.preventDefault();
                event.stopPropagation();
                this.spinValue(event.target.value, 1, event.type);
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.openDialog();
                }
                else {
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, -1, event.type);
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    onWheel(event) {
        if (this._isInEditMode) {
            event.preventDefault();
            event.stopPropagation();
            const sign = (event.deltaY > 0) ? -1 : 1;
            this.spinValue(event.target.value, sign, event.type);
        }
    }
    /**
     * @hidden @internal
     */
    onInput(event) {
        const targetValue = event.target.value;
        const cursorPosition = this._getCursorPosition();
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
        this._isInEditMode = true;
        if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
            this.isEmpty = false;
        }
        // If all date parts are completed, change the date-picker value, stay in edit mode
        if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
            this._transformedDate = targetValue;
            this.calculateDate(targetValue, event.type);
            this._setCursorPosition(cursorPosition);
        }
        else if (checkInput === 'partial') {
            // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
            this.deselectDate();
            requestAnimationFrame(() => {
                this.getEditElement().value = targetValue;
                this._setCursorPosition(cursorPosition);
            });
        }
        else if (checkInput === 'empty') {
            // Total clean-up as input is deleted.
            this.isEmpty = true;
            this.deselectDate();
        }
    }
    emitValueChangeEvent(oldValue, newValue) {
        if (!isEqual(oldValue, newValue)) {
            this.valueChange.emit(newValue);
        }
    }
    calculateDate(dateString, invokedByEvent) {
        if (dateString !== '') {
            const prevDateValue = this.value;
            const inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
            const newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
            if (newDateArray.state === "valid" /* Valid */) {
                const newValue = newDateArray.date;
                // Restore the time part if any
                if (prevDateValue) {
                    newValue.setHours(prevDateValue.getHours());
                    newValue.setMinutes(prevDateValue.getMinutes());
                    newValue.setSeconds(prevDateValue.getSeconds());
                    newValue.setMilliseconds(prevDateValue.getMilliseconds());
                }
                if (this.disabledDates === null
                    || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                    const oldValue = this.value;
                    this.value = newValue;
                    this.emitValueChangeEvent(oldValue, this.value);
                    this.invalidDate = '';
                }
                else {
                    const args = {
                        datePicker: this,
                        currentValue: newValue,
                    };
                    this.onDisabledDate.emit(args);
                }
            }
            else {
                const args = {
                    datePicker: this,
                    prevValue: prevDateValue
                };
                this.invalidDate = dateString;
                this.onValidationFailed.emit(args);
            }
        }
    }
    spinValue(inputValue, sign, eventType) {
        this._isInEditMode = true;
        this.isEmpty = false;
        const cursorPosition = this._getCursorPosition();
        const modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
        this.getEditElement().value = modifiedInputValue;
        this._setCursorPosition(cursorPosition);
        const checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
        if (checkInput === 'complete') {
            this._isInEditMode = true;
            this.calculateDate(modifiedInputValue, eventType);
            this._setCursorPosition(cursorPosition);
        }
    }
    _onOpening(event) {
        this._initializeCalendarContainer(event.componentRef.instance);
        this.collapsed = false;
    }
    _onOpened() {
        this.onOpened.emit(this);
        if (this.calendar) {
            this._focusCalendarDate();
        }
    }
    _onClosed() {
        this.collapsed = true;
        this._componentID = null;
        this.onClosed.emit(this);
    }
    _initializeCalendarContainer(componentInstance) {
        this.calendar = componentInstance.calendar;
        const isVertical = (this.vertical && this.mode === InteractionMode.Dialog);
        this.calendar.hasHeader = this.hasHeader;
        this.calendar.formatOptions = this.formatOptions;
        this.calendar.formatViews = this.formatViews;
        this.calendar.locale = this.locale;
        this.calendar.vertical = isVertical;
        this.calendar.weekStart = this.weekStart;
        this.calendar.specialDates = this.specialDates;
        this.calendar.disabledDates = this.disabledDates;
        this.calendar.headerTemplate = this.headerTemplate;
        this.calendar.subheaderTemplate = this.subheaderTemplate;
        this.calendar.hideOutsideDays = this.hideOutsideDays;
        this.calendar.monthsViewNumber = this.monthsViewNumber;
        this.calendar.onSelection.pipe(takeUntil(this._destroy$)).subscribe((ev) => this.handleSelection(ev));
        if (this.value) {
            this.calendar.value = this.value;
            this.calendar.viewDate = this.value;
        }
        componentInstance.mode = this.mode;
        componentInstance.vertical = isVertical;
        componentInstance.cancelButtonLabel = this.cancelButtonLabel;
        componentInstance.todayButtonLabel = this.todayButtonLabel;
        componentInstance.datePickerActions = this.datePickerActionsDirective;
        componentInstance.onClose.pipe(takeUntil(this._destroy$)).subscribe(() => this.closeCalendar());
        componentInstance.onTodaySelection.pipe(takeUntil(this._destroy$)).subscribe(() => this.triggerTodaySelection());
    }
    // Focus a date, after the calendar appearance into DOM.
    _focusCalendarDate() {
        requestAnimationFrame(() => {
            this.calendar.daysView.focusActiveDate();
        });
    }
    _setLocaleToDate(value) {
        if (isIE()) {
            // this is a workaround fixing the following IE11 issue:
            // IE11 has added character code 8206 (mark for RTL) to the output of toLocaleDateString() that
            // precedes each portion that comprises the total date... For more information read this article:
            // tslint:disable-next-line: max-line-length
            // https://www.csgpro.com/blog/2016/08/a-bad-date-with-internet-explorer-11-trouble-with-new-unicode-characters-in-javascript-date-strings/
            const localeDateStrIE = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes(), value.getSeconds(), value.getMilliseconds());
            return localeDateStrIE.toLocaleDateString(this.locale);
        }
        return value.toLocaleDateString(this.locale);
    }
    _getCursorPosition() {
        return this.getEditElement().selectionStart;
    }
    _setCursorPosition(start, end = start) {
        requestAnimationFrame(() => {
            this.getEditElement().setSelectionRange(start, end);
        });
    }
    /**
     * Apply custom user formatter upon date.
     * @param formatter custom formatter function.
     * @param date passed date
     */
    _customFormatChecker(formatter, date) {
        return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
    }
    /*
    * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
    * using @angular/common formatDate method: https://angular.io/api/common/formatDate
    * @param  value: string | number | Date
    * @returns formatted string
    */
    _getDisplayDate(value) {
        if (this.format && !this.formatter) {
            const locale = this.locale || this.defaultLocale;
            return formatDate(value, this.format, locale);
        }
        else {
            return this._customFormatChecker(this.formatter, value);
        }
    }
    _getEditorDate(value) {
        const locale = this.locale || this.defaultLocale;
        const changedValue = (value) ? formatDate(value, this.mask, locale) : '';
        return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
    }
    _updateValidityOnBlur() {
        this._onTouchedCallback();
        const input = this._inputDirective || this._inputDirectiveUserTemplate;
        if (input && this._ngControl && !this._ngControl.valid) {
            input.valid = IgxInputState.INVALID;
        }
        else {
            input.valid = IgxInputState.INITIAL;
        }
    }
};
IgxDatePickerComponent.ɵfac = function IgxDatePickerComponent_Factory(t) { return new (t || IgxDatePickerComponent)(ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgModuleRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
IgxDatePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDatePickerComponent, selectors: [["igx-date-picker"]], contentQueries: function IgxDatePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputGroupComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true, ElementRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDatePickerTemplateDirective, true, IgxDatePickerTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCalendarHeaderTemplateDirective, true, IgxCalendarHeaderTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCalendarSubheaderTemplateDirective, true, IgxCalendarSubheaderTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDatePickerActionsDirective, true, IgxDatePickerActionsDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroupUserTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputUserTemplateElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirectiveUserTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datePickerTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.subheaderTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datePickerActionsDirective = _t.first);
    } }, viewQuery: function IgxDatePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c54, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c55, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxInputGroupComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.readOnlyDatePickerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editableDatePickerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirective = _t.first);
    } }, hostVars: 1, hostBindings: function IgxDatePickerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.spacebar", function IgxDatePickerComponent_keydown_spacebar_HostBindingHandler($event) { return ctx.onSpaceClick($event); })("keydown.space", function IgxDatePickerComponent_keydown_space_HostBindingHandler($event) { return ctx.onSpaceClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { label: "label", labelVisibility: "labelVisibility", weekStart: "weekStart", monthsViewNumber: "monthsViewNumber", id: "id", vertical: "vertical", mode: "mode", isSpinLoop: "isSpinLoop", formatOptions: "formatOptions", format: "format", formatViews: "formatViews", disabledDates: "disabledDates", specialDates: "specialDates", modalOverlaySettings: "modalOverlaySettings", dropDownOverlaySettings: "dropDownOverlaySettings", value: "value", disabled: "disabled", mask: "mask", locale: "locale", hideOutsideDays: "hideOutsideDays", formatter: "formatter", todayButtonLabel: "todayButtonLabel", cancelButtonLabel: "cancelButtonLabel", outlet: "outlet" }, outputs: { onOpened: "onOpened", onClosed: "onClosed", onClosing: "onClosing", onSelection: "onSelection", valueChange: "valueChange", onDisabledDate: "onDisabledDate", onValidationFailed: "onValidationFailed" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxDatePickerComponent_1,
                multi: true
            }])], decls: 5, vars: 2, consts: [["readOnlyDatePickerTemplate", ""], ["editableDatePickerTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click"], ["igxLabel", "", 4, "ngIf"], ["igxInput", "", "readonly", "", 1, "igx-date-picker__input-date", 3, "value", "disabled", "blur"], ["igxLabel", ""], ["editableInputGroup", ""], ["igxInput", "", "type", "text", 1, "igx-date-picker__input-date", 3, "igxTextSelection", "value", "igxMask", "placeholder", "disabled", "displayValuePipe", "focusedValuePipe", "blur", "wheel", "input", "focus"], [3, "click", 4, "ngIf"]], template: function IgxDatePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxDatePickerComponent_ng_template_0_Template, 6, 3, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxDatePickerComponent_ng_template_2_Template, 8, 9, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxDatePickerComponent_ng_container_4_Template, 1, 0, "ng-container", 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxInputGroupComponent,
        IgxPrefixDirective,
        IgxIconComponent, ɵngcc2.NgIf, IgxInputDirective,
        IgxLabelDirective,
        IgxTextSelectionDirective,
        IgxMaskDirective,
        IgxSuffixDirective], styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"] });
IgxDatePickerComponent.ctorParameters = () => [
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgModuleRef },
    { type: Injector }
];
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "label", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "labelVisibility", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "locale", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "weekStart", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "formatOptions", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "hideOutsideDays", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "monthsViewNumber", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "format", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "mask", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "formatViews", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "disabledDates", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "specialDates", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "modalOverlaySettings", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "dropDownOverlaySettings", null);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "value", null);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxDatePickerComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "formatter", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "vertical", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "todayButtonLabel", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "cancelButtonLabel", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "mode", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "isSpinLoop", void 0);
__decorate([
    Input()
], IgxDatePickerComponent.prototype, "outlet", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "onClosed", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "onClosing", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "onSelection", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "valueChange", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "onDisabledDate", void 0);
__decorate([
    Output()
], IgxDatePickerComponent.prototype, "onValidationFailed", void 0);
__decorate([
    ViewChild('readOnlyDatePickerTemplate', { read: TemplateRef, static: true })
], IgxDatePickerComponent.prototype, "readOnlyDatePickerTemplate", void 0);
__decorate([
    ViewChild('editableDatePickerTemplate', { read: TemplateRef, static: true })
], IgxDatePickerComponent.prototype, "editableDatePickerTemplate", void 0);
__decorate([
    ViewChild(IgxInputGroupComponent)
], IgxDatePickerComponent.prototype, "inputGroup", void 0);
__decorate([
    ContentChild(IgxInputGroupComponent)
], IgxDatePickerComponent.prototype, "inputGroupUserTemplate", void 0);
__decorate([
    ViewChild(IgxInputDirective, { read: ElementRef })
], IgxDatePickerComponent.prototype, "_inputElementRef", void 0);
__decorate([
    ContentChild(IgxInputDirective, { read: ElementRef })
], IgxDatePickerComponent.prototype, "_inputUserTemplateElementRef", void 0);
__decorate([
    ViewChild(IgxInputDirective)
], IgxDatePickerComponent.prototype, "_inputDirective", void 0);
__decorate([
    ContentChild(IgxInputDirective)
], IgxDatePickerComponent.prototype, "_inputDirectiveUserTemplate", void 0);
__decorate([
    ContentChild(IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective })
], IgxDatePickerComponent.prototype, "datePickerTemplateDirective", void 0);
__decorate([
    ContentChild(IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective })
], IgxDatePickerComponent.prototype, "headerTemplate", void 0);
__decorate([
    ContentChild(IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective })
], IgxDatePickerComponent.prototype, "subheaderTemplate", void 0);
__decorate([
    ContentChild(IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective })
], IgxDatePickerComponent.prototype, "datePickerActionsDirective", void 0);
__decorate([
    HostListener('keydown.spacebar', ['$event']),
    HostListener('keydown.space', ['$event'])
], IgxDatePickerComponent.prototype, "onSpaceClick", null);
IgxDatePickerComponent = IgxDatePickerComponent_1 = __decorate([ __param(0, Inject(IgxOverlayService))
], IgxDatePickerComponent);
/**
 * @hidden
 */
let IgxDatePickerModule = class IgxDatePickerModule {
};
IgxDatePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDatePickerModule });
IgxDatePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDatePickerModule_Factory(t) { return new (t || IgxDatePickerModule)(); }, imports: [[
            CommonModule,
            IgxIconModule,
            IgxInputGroupModule,
            IgxCalendarModule,
            IgxButtonModule,
            IgxRippleModule,
            IgxMaskModule,
            IgxTextSelectionModule
        ]] });

/**
 * @hidden
 */
let IgxExcelStyleDateExpressionComponent = class IgxExcelStyleDateExpressionComponent extends IgxExcelStyleDefaultExpressionComponent {
    get inputValuesElement() {
        return this.datePicker.getEditElement();
    }
    get inputDatePlaceholder() {
        return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
    }
};
IgxExcelStyleDateExpressionComponent.ɵfac = function IgxExcelStyleDateExpressionComponent_Factory(t) { return ɵIgxExcelStyleDateExpressionComponent_BaseFactory(t || IgxExcelStyleDateExpressionComponent); };
IgxExcelStyleDateExpressionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleDateExpressionComponent, selectors: [["igx-excel-style-date-expression"]], viewQuery: function IgxExcelStyleDateExpressionComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c56, true, IgxDatePickerComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.datePicker = _t.first);
    } }, inputs: { displayDensity: "displayDensity" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 14, vars: 16, consts: [[3, "maxHeight", "width", "displayDensity", "onSelection"], ["dropdownConditions", ""], [3, "value", "selected", 4, "ngFor", "ngForOf"], ["type", "box", 3, "displayDensity", "click"], ["inputGroupConditions", ""], ["fontSet", "filtering-icons", 3, "name", 4, "ngIf"], [4, "ngIf"], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "igxDropDownItemNavigation", "placeholder", "value", "readonly", "keydown"], ["mode", "dropdown", 3, "ngModel", "locale", "outlet", "ngModelChange"], ["datePicker", ""], ["igxDatePickerTemplate", ""], ["igxButton", "icon", 3, "displayDensity", "click", 4, "ngIf"], [3, "multiSelection", 4, "ngIf"], [3, "value", "selected"], ["fontSet", "filtering-icons", 3, "name"], ["type", "box", 3, "displayDensity"], ["dropDownTarget", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "readonly", "disabled", "click"], ["input", ""], ["igxButton", "icon", 3, "displayDensity", "click"], [3, "multiSelection"], ["logicOperatorButtonGroup", ""], ["igxButton", "", "tabindex", "0", "type", "button", 3, "displayDensity", "selected", "keydown", "click"], ["andButton", ""], ["orButton", ""]], template: function IgxExcelStyleDateExpressionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-drop-down", 0, 1);
        ɵngcc0.ɵɵlistener("onSelection", function IgxExcelStyleDateExpressionComponent_Template_igx_drop_down_onSelection_0_listener($event) { return ctx.onConditionsChanged($event); });
        ɵngcc0.ɵɵtemplate(2, IgxExcelStyleDateExpressionComponent_igx_drop_down_item_2_Template, 4, 4, "igx-drop-down-item", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "igx-input-group", 3, 4);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleDateExpressionComponent_Template_igx_input_group_click_3_listener() { return ctx.toggleCustomDialogDropDown(); });
        ɵngcc0.ɵɵelementStart(5, "igx-prefix");
        ɵngcc0.ɵɵtemplate(6, IgxExcelStyleDateExpressionComponent_igx_icon_6_Template, 1, 1, "igx-icon", 5);
        ɵngcc0.ɵɵtemplate(7, IgxExcelStyleDateExpressionComponent_igx_icon_7_Template, 2, 0, "igx-icon", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "input", 7);
        ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleDateExpressionComponent_Template_input_keydown_8_listener($event) { return ctx.onInputConditionsKeyDown($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "igx-date-picker", 8, 9);
        ɵngcc0.ɵɵlistener("ngModelChange", function IgxExcelStyleDateExpressionComponent_Template_igx_date_picker_ngModelChange_9_listener($event) { return ctx.expressionUI.expression.searchVal = $event; });
        ɵngcc0.ɵɵtemplate(11, IgxExcelStyleDateExpressionComponent_ng_template_11_Template, 5, 8, "ng-template", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(12, IgxExcelStyleDateExpressionComponent_button_12_Template, 3, 1, "button", 11);
        ɵngcc0.ɵɵtemplate(13, IgxExcelStyleDateExpressionComponent_igx_buttongroup_13_Template, 8, 7, "igx-buttongroup", 12);
    } if (rf & 2) {
        const _r297 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵproperty("maxHeight", "200px")("width", ctx.getInputWidth())("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.conditions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.expressionUI.expression.condition);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", _r297)("placeholder", ctx.inputConditionsPlaceholder)("value", ctx.getConditionName(ctx.expressionUI.expression.condition))("readonly", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngModel", ctx.expressionUI.expression.searchVal)("locale", ctx.grid.locale)("outlet", ctx.grid.outletDirective);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isSingle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isLast);
    } }, directives: [IgxDropDownComponent, ɵngcc2.NgForOf, IgxInputGroupComponent,
        IgxPrefixDirective, ɵngcc2.NgIf, IgxInputDirective,
        IgxDropDownItemNavigationDirective,
        IgxDatePickerComponent, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxDatePickerTemplateDirective,
        IgxDropDownItemComponent,
        IgxIconComponent,
        IgxButtonDirective,
        IgxButtonGroupComponent], pipes: [IgxDatePipeComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    ViewChild('datePicker', { read: IgxDatePickerComponent, static: true })
], IgxExcelStyleDateExpressionComponent.prototype, "datePicker", void 0);
__decorate([
    Input()
], IgxExcelStyleDateExpressionComponent.prototype, "displayDensity", void 0);

/**
 * @hidden
 */
let IgxExcelStyleCustomDialogComponent = class IgxExcelStyleCustomDialogComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.expressionsList = new Array();
        this._customDialogPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._customDialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._customDialogPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
    }
    ngAfterViewInit() {
        this._customDialogOverlaySettings.outlet = this.grid.outlet;
    }
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.dateExpressionTemplate;
        }
        return this.defaultExpressionTemplate;
    }
    get grid() {
        return this.filteringService.grid;
    }
    onCustomDialogOpening() {
        if (this.selectedOperator) {
            this.createInitialExpressionUIElement();
        }
    }
    onCustomDialogOpened() {
        if (this.expressionComponents.first) {
            this.expressionComponents.first.focus();
        }
    }
    open(esf) {
        this._customDialogOverlaySettings.positionStrategy.settings.target =
            this.overlayComponentId ?
                this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement :
                esf;
        this.toggle.open(this._customDialogOverlaySettings);
    }
    onClearButtonClick() {
        this.filteringService.clearFilter(this.column.field);
        this.createInitialExpressionUIElement();
        this.cdr.detectChanges();
    }
    closeDialog() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
        }
        else {
            this.toggle.close();
        }
    }
    onApplyButtonClick() {
        this.expressionsList = this.expressionsList.filter(element => element.expression.condition &&
            (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary));
        if (this.expressionsList.length > 0) {
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.filteringService.filterInternal(this.column.field, this.expressionsList);
        this.closeDialog();
    }
    onAddButtonClick() {
        const exprUI = new ExpressionUI();
        exprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;
        exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
        this.expressionsList.push(exprUI);
        this.markChildrenForCheck();
        this.scrollToBottom();
    }
    onExpressionRemoved(event) {
        const indexToRemove = this.expressionsList.indexOf(event);
        if (indexToRemove === 0 && this.expressionsList.length > 1) {
            this.expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === this.expressionsList.length - 1) {
            this.expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.expressionsList.splice(indexToRemove, 1);
        this.cdr.detectChanges();
        this.markChildrenForCheck();
    }
    onLogicOperatorChanged(event) {
        const index = this.expressionsList.indexOf(event.target);
        event.target.afterOperator = event.newValue;
        if (index + 1 < this.expressionsList.length) {
            this.expressionsList[index + 1].beforeOperator = event.newValue;
        }
    }
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
    }
    onApplyButtonKeyDown(eventArgs) {
        if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
            eventArgs.stopPropagation();
            eventArgs.preventDefault();
        }
    }
    createCondition(conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
    markChildrenForCheck() {
        this.expressionComponents.forEach(x => x.cdr.markForCheck());
        this.expressionDateComponents.forEach(x => x.cdr.markForCheck());
    }
    createInitialExpressionUIElement() {
        this.expressionsList = [];
        const firstExprUI = new ExpressionUI();
        firstExprUI.expression = {
            condition: this.createCondition(this.selectedOperator),
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        firstExprUI.afterOperator = FilteringLogic.And;
        this.expressionsList.push(firstExprUI);
        const secondExprUI = new ExpressionUI();
        secondExprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        secondExprUI.beforeOperator = FilteringLogic.And;
        this.expressionsList.push(secondExprUI);
    }
    scrollToBottom() {
        requestAnimationFrame(() => {
            this.expressionsContainer.nativeElement.scrollTop = this.expressionsContainer.nativeElement.scrollHeight;
        });
    }
};
IgxExcelStyleCustomDialogComponent.ɵfac = function IgxExcelStyleCustomDialogComponent_Factory(t) { return new (t || IgxExcelStyleCustomDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExcelStyleCustomDialogComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleCustomDialogComponent, selectors: [["igx-excel-style-custom-dialog"]], viewQuery: function IgxExcelStyleCustomDialogComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c57, true, IgxToggleDirective);
        ɵngcc0.ɵɵviewQuery(_c58, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c59, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c60, true);
        ɵngcc0.ɵɵviewQuery(IgxExcelStyleDefaultExpressionComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxExcelStyleDateExpressionComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpressionTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateExpressionTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionComponents = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionDateComponents = _t);
    } }, inputs: { expressionsList: "expressionsList", column: "column", selectedOperator: "selectedOperator", filteringService: "filteringService", overlayComponentId: "overlayComponentId", overlayService: "overlayService", displayDensity: "displayDensity" }, decls: 22, vars: 16, consts: [["igxToggle", "", 1, "igx-excel-filter__secondary", 3, "ngClass", "keydown", "onOpening", "onOpened"], ["toggle", ""], [1, "igx-excel-filter__secondary-header"], [1, "igx-typography__h6"], [1, "igx-excel-filter__secondary-main"], ["expressionsContainer", ""], [4, "ngIf"], ["igxButton", "", 1, "igx-excel-filter__add-filter", 3, "displayDensity", "click"], [1, "igx-excel-filter__secondary-footer"], ["igxButton", "", 3, "displayDensity", "click"], ["igxButton", "raised", 3, "displayDensity", "click", "keydown"], ["class", "igx-excel-filter__condition", 3, "expressionUI", "column", "grid", "displayDensity", "expressionsList", "onExpressionRemoved", "onLogicOperatorChanged", 4, "ngFor", "ngForOf"], [1, "igx-excel-filter__condition", 3, "expressionUI", "column", "grid", "displayDensity", "expressionsList", "onExpressionRemoved", "onLogicOperatorChanged"]], template: function IgxExcelStyleCustomDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "article", 0, 1);
        ɵngcc0.ɵɵlistener("keydown", function IgxExcelStyleCustomDialogComponent_Template_article_keydown_0_listener($event) { return ctx.onKeyDown($event); })("onOpening", function IgxExcelStyleCustomDialogComponent_Template_article_onOpening_0_listener() { return ctx.onCustomDialogOpening(); })("onOpened", function IgxExcelStyleCustomDialogComponent_Template_article_onOpened_0_listener() { return ctx.onCustomDialogOpened(); });
        ɵngcc0.ɵɵelementStart(2, "header", 2);
        ɵngcc0.ɵɵelementStart(3, "h4", 3);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "article", 4, 5);
        ɵngcc0.ɵɵtemplate(7, IgxExcelStyleCustomDialogComponent_ng_container_7_Template, 2, 1, "ng-container", 6);
        ɵngcc0.ɵɵtemplate(8, IgxExcelStyleCustomDialogComponent_ng_container_8_Template, 2, 1, "ng-container", 6);
        ɵngcc0.ɵɵelementStart(9, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_9_listener() { return ctx.onAddButtonClick(); });
        ɵngcc0.ɵɵelementStart(10, "igx-icon");
        ɵngcc0.ɵɵtext(11, "add");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "span");
        ɵngcc0.ɵɵtext(13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "footer", 8);
        ɵngcc0.ɵɵelementStart(15, "button", 9);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_15_listener() { return ctx.onClearButtonClick(); });
        ɵngcc0.ɵɵtext(16);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(17, "div");
        ɵngcc0.ɵɵelementStart(18, "button", 9);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_18_listener() { return ctx.closeDialog(); });
        ɵngcc0.ɵɵtext(19);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "button", 10);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleCustomDialogComponent_Template_button_click_20_listener() { return ctx.onApplyButtonClick(); })("keydown", function IgxExcelStyleCustomDialogComponent_Template_button_keydown_20_listener($event) { return ctx.onApplyButtonKeyDown($event); });
        ɵngcc0.ɵɵtext(21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(13, _c61, ctx.grid.displayDensity === "cosy", ctx.grid.displayDensity === "compact"));
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate2(" ", ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_header, "", ctx.column.header || ctx.column.field, " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.dataType === "date");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.dataType !== "date");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_add);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_custom_dialog_clear);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.grid.resourceStrings.igx_grid_excel_cancel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.grid.resourceStrings.igx_grid_excel_apply, " ");
    } }, directives: [IgxToggleDirective, ɵngcc2.NgClass, ɵngcc2.NgIf, IgxButtonDirective,
        IgxIconComponent, ɵngcc2.NgForOf, IgxExcelStyleDateExpressionComponent,
        IgxExcelStyleDefaultExpressionComponent], encapsulation: 2, changeDetection: 0 });
IgxExcelStyleCustomDialogComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "expressionsList", void 0);
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "selectedOperator", void 0);
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "filteringService", void 0);
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "overlayComponentId", void 0);
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "overlayService", void 0);
__decorate([
    Input()
], IgxExcelStyleCustomDialogComponent.prototype, "displayDensity", void 0);
__decorate([
    ViewChildren(IgxExcelStyleDefaultExpressionComponent)
], IgxExcelStyleCustomDialogComponent.prototype, "expressionComponents", void 0);
__decorate([
    ViewChildren(IgxExcelStyleDateExpressionComponent)
], IgxExcelStyleCustomDialogComponent.prototype, "expressionDateComponents", void 0);
__decorate([
    ViewChild('toggle', { read: IgxToggleDirective, static: true })
], IgxExcelStyleCustomDialogComponent.prototype, "toggle", void 0);
__decorate([
    ViewChild('defaultExpressionTemplate', { read: TemplateRef })
], IgxExcelStyleCustomDialogComponent.prototype, "defaultExpressionTemplate", void 0);
__decorate([
    ViewChild('dateExpressionTemplate', { read: TemplateRef })
], IgxExcelStyleCustomDialogComponent.prototype, "dateExpressionTemplate", void 0);
__decorate([
    ViewChild('expressionsContainer', { static: true })
], IgxExcelStyleCustomDialogComponent.prototype, "expressionsContainer", void 0);

/**
 * @hidden
 */
let IgxExcelStyleSortingComponent = class IgxExcelStyleSortingComponent {
    constructor() {
        this.destroy$ = new Subject();
    }
    ngAfterViewInit() {
        this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.updateSelectedButtons(this.column.field);
        });
        this.updateSelectedButtons(this.column.field);
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    ngOnChanges(changes) {
        if (changes.column && !changes.column.firstChange) {
            this.updateSelectedButtons(changes.column.currentValue.field);
        }
    }
    updateSelectedButtons(fieldName) {
        const sortIndex = this.grid.sortingExpressions.findIndex(s => s.fieldName === fieldName);
        this.sortButtonGroup.buttons.forEach((b, i) => {
            this.sortButtonGroup.deselectButton(i);
        });
        if (sortIndex !== -1) {
            const sortDirection = this.grid.sortingExpressions[sortIndex].dir;
            this.sortButtonGroup.selectButton(sortDirection - 1);
        }
    }
    onSortButtonClicked(sortDirection) {
        if (this.sortButtonGroup.selectedIndexes.length === 0) {
            if (this.grid.isColumnGrouped(this.column.field)) {
                this.sortButtonGroup.selectButton(sortDirection - 1);
            }
            else {
                this.grid.clearSort(this.column.field);
            }
        }
        else {
            this.grid.sort({ fieldName: this.column.field, dir: sortDirection, ignoreCase: true });
        }
    }
};
IgxExcelStyleSortingComponent.ɵfac = function IgxExcelStyleSortingComponent_Factory(t) { return new (t || IgxExcelStyleSortingComponent)(); };
IgxExcelStyleSortingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleSortingComponent, selectors: [["igx-excel-style-sorting"]], viewQuery: function IgxExcelStyleSortingComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c62, true, IgxButtonGroupComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sortButtonGroup = _t.first);
    } }, inputs: { column: "column", grid: "grid", displayDensity: "displayDensity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 14, vars: 8, consts: [[3, "multiSelection"], ["sortButtonGroup", ""], ["igxButton", "", 3, "displayDensity", "click"]], template: function IgxExcelStyleSortingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "header");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "igx-buttongroup", 0, 1);
        ɵngcc0.ɵɵelementStart(4, "button", 2);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSortingComponent_Template_button_click_4_listener() { return ctx.onSortButtonClicked(1); });
        ɵngcc0.ɵɵelementStart(5, "igx-icon");
        ɵngcc0.ɵɵtext(6, "arrow_upwards");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "span");
        ɵngcc0.ɵɵtext(8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "button", 2);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleSortingComponent_Template_button_click_9_listener() { return ctx.onSortButtonClicked(2); });
        ɵngcc0.ɵɵelementStart(10, "igx-icon");
        ɵngcc0.ɵɵtext(11, "arrow_downwards");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "span");
        ɵngcc0.ɵɵtext(13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.grid.resourceStrings.igx_grid_excel_filter_sorting_header, "\n");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("multiSelection", false);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵattribute("data-togglable", true);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayDensity === "compact" ? ctx.grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short : ctx.grid.resourceStrings.igx_grid_excel_filter_sorting_asc, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵattribute("data-togglable", true);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayDensity === "compact" ? ctx.grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short : ctx.grid.resourceStrings.igx_grid_excel_filter_sorting_desc, " ");
    } }, directives: [IgxButtonGroupComponent,
        IgxButtonDirective,
        IgxIconComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], IgxExcelStyleSortingComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxExcelStyleSortingComponent.prototype, "grid", void 0);
__decorate([
    Input()
], IgxExcelStyleSortingComponent.prototype, "displayDensity", void 0);
__decorate([
    ViewChild('sortButtonGroup', { read: IgxButtonGroupComponent, static: true })
], IgxExcelStyleSortingComponent.prototype, "sortButtonGroup", void 0);

var IgxGridExcelStyleFilteringComponent_1;
/**
 * @hidden
 */
class FilterListItem {
    constructor() {
        this.isSpecial = false;
        this.isBlanks = false;
    }
}
let IgxExcelStyleSortingTemplateDirective = class IgxExcelStyleSortingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxExcelStyleSortingTemplateDirective.ɵfac = function IgxExcelStyleSortingTemplateDirective_Factory(t) { return new (t || IgxExcelStyleSortingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStyleSortingTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleSortingTemplateDirective, selectors: [["", "igxExcelStyleSorting", ""]] });
IgxExcelStyleSortingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxExcelStyleMovingTemplateDirective = class IgxExcelStyleMovingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxExcelStyleMovingTemplateDirective.ɵfac = function IgxExcelStyleMovingTemplateDirective_Factory(t) { return new (t || IgxExcelStyleMovingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStyleMovingTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleMovingTemplateDirective, selectors: [["", "igxExcelStyleMoving", ""]] });
IgxExcelStyleMovingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxExcelStyleHidingTemplateDirective = class IgxExcelStyleHidingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxExcelStyleHidingTemplateDirective.ɵfac = function IgxExcelStyleHidingTemplateDirective_Factory(t) { return new (t || IgxExcelStyleHidingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStyleHidingTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleHidingTemplateDirective, selectors: [["", "igxExcelStyleHiding", ""]] });
IgxExcelStyleHidingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxExcelStyleSelectingTemplateDirective = class IgxExcelStyleSelectingTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxExcelStyleSelectingTemplateDirective.ɵfac = function IgxExcelStyleSelectingTemplateDirective_Factory(t) { return new (t || IgxExcelStyleSelectingTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStyleSelectingTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStyleSelectingTemplateDirective, selectors: [["", "igxExcelStyleSelecting", ""]] });
IgxExcelStyleSelectingTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxExcelStylePinningTemplateDirective = class IgxExcelStylePinningTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxExcelStylePinningTemplateDirective.ɵfac = function IgxExcelStylePinningTemplateDirective_Factory(t) { return new (t || IgxExcelStylePinningTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxExcelStylePinningTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExcelStylePinningTemplateDirective, selectors: [["", "igxExcelStylePinning", ""]] });
IgxExcelStylePinningTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * A component used for presenting Excel style filtering UI for a specific column.
 * It is used internally in the Grid, but could also be hosted in a container outside of it.
 *
 * Example:
 * ```html
 * <igx-grid-excel-style-filtering
 *     [column]="grid1.columns[0]">
 * </igx-grid-excel-style-filtering>
 * ```
 */
let IgxGridExcelStyleFilteringComponent = IgxGridExcelStyleFilteringComponent_1 = class IgxGridExcelStyleFilteringComponent {
    constructor(cdr, element) {
        this.cdr = cdr;
        this.element = element;
        this.shouldOpenSubMenu = true;
        this.expressionsList = new Array();
        this.destroy$ = new Subject();
        this.containsNullOrEmpty = false;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.filterValues = new Set();
        /**
         * @hidden @internal
         */
        this.listData = new Array();
        /**
         * @hidden @internal
         */
        this.uniqueValues = [];
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Top
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        /**
         * @hidden @internal
         */
        this.className = 'igx-excel-filter';
        /**
         * @hidden @internal
         */
        this.inline = true;
    }
    /**
     * An @Input property that sets the column.
     */
    set column(value) {
        this._column = value;
        if (this._columnPinning) {
            this._columnPinning.unsubscribe();
        }
        if (this._columnVisibilityChanged) {
            this._columnVisibilityChanged.unsubscribe();
        }
        if (this._filteringChanged) {
            this._filteringChanged.unsubscribe();
        }
        if (this._densityChanged) {
            this._densityChanged.unsubscribe();
        }
        if (this._column) {
            this._column.grid.filteringService.registerSVGIcons();
            this.isColumnPinnable = this.column.pinnable;
            this.init();
            this._columnPinning = this.grid.onColumnPinning.pipe(takeUntil(this.destroy$)).subscribe(() => {
                requestAnimationFrame(() => {
                    this.isColumnPinnable = this.column.pinnable;
                    if (!this.cdr.destroyed) {
                        this.cdr.detectChanges();
                    }
                });
            });
            this._columnVisibilityChanged = this.grid.onColumnVisibilityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
            this._filteringChanged = this.grid.filteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.init();
            });
            this._densityChanged = this.grid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.cdr.detectChanges();
            });
        }
    }
    /**
     * Returns the current column.
     */
    get column() {
        return this._column;
    }
    /**
     * @hidden @internal
     */
    get filteringService() {
        return this.grid.filteringService;
    }
    /**
     * @hidden @internal
     */
    get minHeight() {
        if (!this.inline) {
            let minHeight = 645;
            switch (this.grid.displayDensity) {
                case DisplayDensity.cosy:
                    minHeight = 465;
                    break;
                case DisplayDensity.compact:
                    minHeight = 330;
                    break;
                default: break;
            }
            return `${minHeight}px`;
        }
    }
    /**
     * @hidden @internal
     */
    get maxHeight() {
        if (!this.inline) {
            let maxHeight = 775;
            switch (this.grid.displayDensity) {
                case DisplayDensity.cosy:
                    maxHeight = 565;
                    break;
                case DisplayDensity.compact:
                    maxHeight = 405;
                    break;
                default: break;
            }
            return `${maxHeight}px`;
        }
    }
    /**
     * @hidden @internal
     */
    get grid() {
        return this.column.grid;
    }
    /**
     * @hidden @internal
     */
    get conditions() {
        return this.column.filters.conditionList();
    }
    /**
     * @hidden @internal
     */
    get subMenuText() {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return this.grid.resourceStrings.igx_grid_excel_boolean_filter;
            case DataType.Number:
                return this.grid.resourceStrings.igx_grid_excel_number_filter;
            case DataType.Date:
                return this.grid.resourceStrings.igx_grid_excel_date_filter;
            default:
                return this.grid.resourceStrings.igx_grid_excel_text_filter;
        }
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    init() {
        this.expressionsList = new Array();
        this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
        this.populateColumnData();
    }
    /**
     * @hidden @internal
     */
    clearFilterClass() {
        if (this.column.filteringExpressionsTree) {
            return 'igx-excel-filter__actions-clear';
        }
        return 'igx-excel-filter__actions-clear--disabled';
    }
    /**
     * @hidden @internal
     */
    pinClass() {
        return this.isColumnPinnable ? 'igx-excel-filter__actions-pin' : 'igx-excel-filter__actions-pin--disabled';
    }
    /**
     * @hidden @internal
     */
    selectedClass() {
        return this.column.selected ? 'igx-excel-filter__actions-selected' : 'igx-excel-filter__actions-select';
    }
    /**
     * @hidden @internal
     */
    initialize(column, overlayService, overlayComponentId) {
        this.inline = false;
        this.column = column;
        this.overlayService = overlayService;
        this.overlayComponentId = overlayComponentId;
        this._subMenuOverlaySettings.outlet = this.grid.outlet;
        requestAnimationFrame(() => {
            this.excelStyleSearch.searchInput.nativeElement.focus();
        });
        this.grid.onColumnMoving.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.closeDropdown();
        });
    }
    /**
     * @hidden @internal
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * @hidden @internal
     */
    translateCondition(value) {
        return this.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * @hidden @internal
     */
    onPin() {
        this.column.pinned = !this.column.pinned;
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    onSelect() {
        if (!this.column.selected) {
            this.grid.selectionService.selectColumn(this.column.field, this.grid.columnSelection === GridSelectionMode.single);
        }
        else {
            this.grid.selectionService.deselectColumn(this.column.field);
        }
        this.grid.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    columnSelectable() {
        return this.grid.columnSelection !== GridSelectionMode.none && this.column.selectable;
    }
    /**
     * @hidden @internal
     */
    onHideToggle() {
        this.column.hidden = !this.column.hidden;
        this.grid.onColumnVisibilityChanged.emit({ column: this.column, newValue: this.column.hidden });
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    onTextFilterClick(eventArgs) {
        if (this.shouldOpenSubMenu) {
            this._subMenuOverlaySettings.positionStrategy.settings.target = eventArgs.currentTarget;
            const gridRect = this.grid.nativeElement.getBoundingClientRect();
            const dropdownRect = this.mainDropdown.nativeElement.getBoundingClientRect();
            let x = dropdownRect.left + dropdownRect.width;
            let x1 = gridRect.left + gridRect.width;
            x += window.pageXOffset;
            x1 += window.pageXOffset;
            if (Math.abs(x - x1) < 200) {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;
            }
            else {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;
            }
            this.subMenu.open(this._subMenuOverlaySettings);
            this.shouldOpenSubMenu = false;
        }
    }
    /**
     * @hidden @internal
     */
    onTextFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.onTextFilterClick(eventArgs);
        }
    }
    /**
     * @hidden @internal
     */
    onSubMenuClosed() {
        requestAnimationFrame(() => {
            this.shouldOpenSubMenu = true;
        });
    }
    /**
     * @hidden @internal
     */
    onSubMenuSelection(eventArgs) {
        if (this.expressionsList && this.expressionsList.length &&
            this.expressionsList[0].expression.condition.name !== 'in') {
            this.customDialog.expressionsList = this.expressionsList;
        }
        this.customDialog.selectedOperator = eventArgs.newSelection.value;
        eventArgs.cancel = true;
        if (this.overlayComponentId) {
            this.element.nativeElement.style.display = 'none';
        }
        this.subMenu.close();
        this.customDialog.open(this.mainDropdown.nativeElement);
    }
    areExpressionsSelectable() {
        if (this.expressionsList.length === 1 &&
            (this.expressionsList[0].expression.condition.name === 'equals' ||
                this.expressionsList[0].expression.condition.name === 'true' ||
                this.expressionsList[0].expression.condition.name === 'false' ||
                this.expressionsList[0].expression.condition.name === 'empty' ||
                this.expressionsList[0].expression.condition.name === 'in')) {
            return true;
        }
        const selectableExpressionsCount = this.expressionsList.filter(exp => (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
            (exp.expression.condition.name === 'equals' ||
                exp.expression.condition.name === 'true' ||
                exp.expression.condition.name === 'false' ||
                exp.expression.condition.name === 'empty' ||
                exp.expression.condition.name === 'in')).length;
        return selectableExpressionsCount === this.expressionsList.length;
    }
    areExpressionsValuesInTheList() {
        if (this.column.dataType === DataType.Boolean) {
            return true;
        }
        if (this.filterValues.size === 1) {
            const firstValue = this.filterValues.values().next().value;
            if (!firstValue && firstValue !== 0) {
                return true;
            }
        }
        for (let index = 0; index < this.uniqueValues.length; index++) {
            if (this.filterValues.has(this.uniqueValues[index])) {
                return true;
            }
        }
        return false;
    }
    populateColumnData() {
        if (this.grid.uniqueColumnValuesStrategy) {
            this.cdr.detectChanges();
            this.renderColumnValuesRemotely();
        }
        else {
            this.renderColumnValuesFromData();
        }
    }
    renderColumnValuesRemotely() {
        this.excelStyleSearch.isLoading = true;
        const expressionsTree = this.getColumnFilterExpressionsTree();
        this.grid.uniqueColumnValuesStrategy(this.column, expressionsTree, (colVals) => {
            const columnValues = (this.column.dataType === DataType.Date) ?
                colVals.map(val => val ? val.toDateString() : val) : colVals;
            this.renderValues(columnValues);
            this.excelStyleSearch.isLoading = false;
            this.excelStyleSearch.refreshSize();
        });
    }
    renderColumnValuesFromData() {
        let data = this.column.gridAPI.get_all_data(this.grid.id);
        const expressionsTree = this.getColumnFilterExpressionsTree();
        if (expressionsTree.filteringOperands.length) {
            const state = { expressionsTree: expressionsTree };
            data = DataUtil.filter(cloneArray(data), state);
        }
        const columnField = this.column.field;
        const columnValues = (this.column.dataType === DataType.Date) ?
            data.map(record => record[columnField] ? record[columnField].toDateString() : record[columnField]) :
            data.map(record => record[columnField]);
        this.renderValues(columnValues);
    }
    renderValues(columnValues) {
        this.generateUniqueValues(columnValues);
        this.generateFilterValues(this.column.dataType === DataType.Date);
        this.generateListData();
    }
    generateUniqueValues(columnValues) {
        this.uniqueValues = Array.from(new Set(columnValues));
    }
    generateFilterValues(isDateColumn = false) {
        if (isDateColumn) {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(e.expression.searchVal.values()).map(v => new Date(v).toDateString())];
                }
                return [...arr, ...[e.expression.searchVal ? e.expression.searchVal.toDateString() : e.expression.searchVal]];
            }, []));
        }
        else {
            this.filterValues = new Set(this.expressionsList.reduce((arr, e) => {
                if (e.expression.condition.name === 'in') {
                    return [...arr, ...Array.from(e.expression.searchVal.values())];
                }
                return [...arr, ...[e.expression.searchVal]];
            }, []));
        }
    }
    generateListData() {
        this.listData = new Array();
        const shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
        if (this.column.dataType === DataType.Boolean) {
            this.addBooleanItems();
        }
        else {
            this.addItems(shouldUpdateSelection);
        }
        this.listData.sort((a, b) => this.sortData(a, b));
        if (this.column.dataType === DataType.Date) {
            this.uniqueValues = this.uniqueValues.map(value => new Date(value));
        }
        if (this.containsNullOrEmpty) {
            this.addBlanksItem(shouldUpdateSelection);
        }
        this.addSelectAllItem();
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    getColumnFilterExpressionsTree() {
        const gridExpressionsTree = this.grid.filteringExpressionsTree;
        const expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
        for (const operand of gridExpressionsTree.filteringOperands) {
            if (operand instanceof FilteringExpressionsTree) {
                const columnExprTree = operand;
                if (columnExprTree.fieldName === this.column.field) {
                    break;
                }
            }
            expressionsTree.filteringOperands.push(operand);
        }
        return expressionsTree;
    }
    addBooleanItems() {
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(element => {
            const filterListItem = new FilterListItem();
            if (element !== undefined && element !== null && element !== '') {
                if (this.column.filteringExpressionsTree) {
                    if (element === true && this.expressionsList.find(exp => exp.expression.condition.name === 'true')) {
                        filterListItem.isSelected = true;
                        this.selectAllIndeterminate = true;
                    }
                    else if (element === false && this.expressionsList.find(exp => exp.expression.condition.name === 'false')) {
                        filterListItem.isSelected = true;
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                }
                filterListItem.value = element;
                filterListItem.label = element;
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
            else {
                this.containsNullOrEmpty = true;
            }
        });
    }
    addItems(shouldUpdateSelection) {
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        const numberPipe = new IgxDecimalPipeComponent(this.column.grid.locale);
        const datePipe = new IgxDatePipeComponent(this.column.grid.locale);
        this.uniqueValues.forEach(element => {
            if (element !== undefined && element !== null && element !== '') {
                const filterListItem = new FilterListItem();
                if (this.column.filteringExpressionsTree) {
                    if (shouldUpdateSelection) {
                        if (this.filterValues.has(element)) {
                            filterListItem.isSelected = true;
                        }
                        else {
                            filterListItem.isSelected = false;
                        }
                        this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                        this.selectAllSelected = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                }
                if (this.column.dataType === DataType.Date) {
                    const date = new Date(element);
                    filterListItem.value = date;
                    filterListItem.label = this.column.formatter ?
                        this.column.formatter(date) :
                        datePipe.transform(date, this.column.grid.locale);
                }
                else if (this.column.dataType === DataType.Number) {
                    filterListItem.value = element;
                    filterListItem.label = this.column.formatter ?
                        this.column.formatter(element) :
                        numberPipe.transform(element, this.column.grid.locale);
                }
                else {
                    filterListItem.value = element;
                    filterListItem.label = this.column.formatter ?
                        this.column.formatter(element) :
                        element;
                }
                filterListItem.indeterminate = false;
                this.listData.push(filterListItem);
            }
            else {
                this.containsNullOrEmpty = true;
            }
        });
    }
    addSelectAllItem() {
        const selectAll = new FilterListItem();
        selectAll.isSelected = this.selectAllSelected;
        selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.indeterminate = this.selectAllIndeterminate;
        selectAll.isSpecial = true;
        this.listData.unshift(selectAll);
    }
    addBlanksItem(shouldUpdateSelection) {
        const blanks = new FilterListItem();
        if (this.column.filteringExpressionsTree) {
            if (shouldUpdateSelection) {
                if (this.filterValues.has(null)) {
                    blanks.isSelected = true;
                }
                else {
                    blanks.isSelected = false;
                }
            }
        }
        else {
            blanks.isSelected = true;
        }
        blanks.value = null;
        blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
        blanks.indeterminate = false;
        blanks.isSpecial = true;
        blanks.isBlanks = true;
        this.listData.unshift(blanks);
    }
    sortData(a, b) {
        let valueA = a.value;
        let valueB = b.value;
        if (typeof (a) === DataType.String) {
            valueA = a.value.toUpperCase();
            valueB = b.value.toUpperCase();
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
    }
    selectAllFilterItems() {
        this.listData.forEach(filterListItem => {
            filterListItem.isSelected = true;
            filterListItem.indeterminate = false;
        });
        this.excelStyleSearch.cdr.detectChanges();
    }
    // TODO: sort members by access modifier
    /**
     * @hidden @internal
     */
    get sortingTemplate() {
        if (this.grid.excelStyleSortingTemplateDirective) {
            return this.grid.excelStyleSortingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleSortingTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get movingTemplate() {
        if (this.grid.excelStyleMovingTemplateDirective) {
            return this.grid.excelStyleMovingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleMovingTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get pinningTemplate() {
        if (this.grid.excelStylePinningTemplateDirective) {
            return this.grid.excelStylePinningTemplateDirective.template;
        }
        else {
            return this.defaultExcelStylePinningTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get hidingTemplate() {
        if (this.grid.excelStyleHidingTemplateDirective) {
            return this.grid.excelStyleHidingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleHidingTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get selectingTemplate() {
        if (this.grid.excelStyleSelectingTemplateDirective) {
            return this.grid.excelStyleSelectingTemplateDirective.template;
        }
        else {
            return this.defaultExcelStyleSelectingTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    get applyButtonDisabled() {
        return this.listData[0] && !this.listData[0].isSelected && !this.listData[0].indeterminate;
    }
    /**
     * @hidden @internal
     */
    applyFilter() {
        const filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.column.field);
        const selectedItems = this.listData.slice(1, this.listData.length).filter(el => el.isSelected === true);
        const unselectedItem = this.listData.slice(1, this.listData.length).find(el => el.isSelected === false);
        if (unselectedItem) {
            if (selectedItems.length <= IgxGridExcelStyleFilteringComponent_1.filterOptimizationThreshold) {
                selectedItems.forEach(element => {
                    let condition = null;
                    if (element.value !== null && element.value !== undefined) {
                        if (this.column.dataType === DataType.Boolean) {
                            condition = this.createCondition(element.value.toString());
                        }
                        else {
                            condition = this.createCondition('equals');
                        }
                    }
                    else {
                        condition = this.createCondition('empty');
                    }
                    filterTree.filteringOperands.push({
                        condition: condition,
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: element.value
                    });
                });
            }
            else {
                const blanksItemIndex = selectedItems.findIndex(e => e.value === null || e.value === undefined);
                let blanksItem;
                if (blanksItemIndex >= 0) {
                    blanksItem = selectedItems[blanksItemIndex];
                    selectedItems.splice(blanksItemIndex, 1);
                }
                filterTree.filteringOperands.push({
                    condition: this.createCondition('in'),
                    fieldName: this.column.field,
                    ignoreCase: this.column.filteringIgnoreCase,
                    searchVal: new Set(this.column.dataType === DataType.Date ?
                        selectedItems.map(d => new Date(d.value.getFullYear(), d.value.getMonth(), d.value.getDate()).toISOString()) :
                        selectedItems.map(e => e.value))
                });
                if (blanksItem) {
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('empty'),
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: blanksItem.value
                    });
                }
            }
            this.filteringService.filterInternal(this.column.field, filterTree);
            this.expressionsList = new Array();
            this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
        }
        else {
            this.filteringService.clearFilter(this.column.field);
        }
        this.closeDropdown();
    }
    /**
     * @hidden @internal
     */
    cancel() {
        if (!this.overlayComponentId) {
            this.init();
        }
        this.closeDropdown();
    }
    closeDropdown() {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
            this.overlayComponentId = null;
        }
    }
    /**
     * @hidden @internal
     */
    onKeyDown(eventArgs) {
        if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */) {
            this.closeDropdown();
        }
        eventArgs.stopPropagation();
    }
    /**
     * @hidden @internal
     */
    clearFilter() {
        this.filteringService.clearFilter(this.column.field);
        this.selectAllFilterItems();
    }
    /**
     * @hidden @internal
     */
    onClearFilterKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.clearFilter();
        }
    }
    /**
     * @hidden @internal
     */
    showCustomFilterItem() {
        const exprTree = this.column.filteringExpressionsTree;
        return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
            !(exprTree.filteringOperands[0].condition &&
                exprTree.filteringOperands[0].condition.name === 'in');
    }
    createCondition(conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    }
};
IgxGridExcelStyleFilteringComponent.ɵfac = function IgxGridExcelStyleFilteringComponent_Factory(t) { return new (t || IgxGridExcelStyleFilteringComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxGridExcelStyleFilteringComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridExcelStyleFilteringComponent, selectors: [["igx-grid-excel-style-filtering"]], viewQuery: function IgxGridExcelStyleFilteringComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c12, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c63, true, IgxDropDownComponent);
        ɵngcc0.ɵɵviewQuery(_c64, true, IgxExcelStyleCustomDialogComponent);
        ɵngcc0.ɵɵviewQuery(_c65, true, IgxExcelStyleSearchComponent);
        ɵngcc0.ɵɵviewQuery(_c66, true, IgxExcelStyleSortingComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c67, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c68, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c69, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c70, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c71, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.mainDropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.subMenu = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customDialog = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleSearch = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleSorting = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStyleSortingTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStyleHidingTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStyleSelectingTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStyleMovingTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExcelStylePinningTemplate = _t.first);
    } }, hostVars: 6, hostBindings: function IgxGridExcelStyleFilteringComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵclassProp("igx-excel-filter", ctx.className)("igx-excel-filter--inline", ctx.inline);
    } }, inputs: { column: "column" }, decls: 13, vars: 3, consts: [["defaultExcelStyleSortingTemplate", ""], ["defaultExcelStyleMovingTemplate", ""], ["defaultExcelStylePinningTemplate", ""], ["defaultExcelStyleHidingTemplate", ""], ["defaultExcelStyleSelectingTemplate", ""], ["class", "igx-excel-filter__menu", 3, "ngClass", "id", "min-height", "max-height", "keydown", 4, "ngIf"], [3, "maxHeight", "displayDensity", "onSelection", "onClosed", 4, "ngIf"], [3, "column", "filteringService", "overlayComponentId", "overlayService", "displayDensity", 4, "ngIf"], [1, "igx-excel-filter__sort", 3, "column", "grid", "displayDensity"], ["excelStyleSorting", ""], [1, "igx-excel-filter__move", 3, "column", "grid", "isColumnPinnable", "displayDensity"], ["tabindex", "0", 3, "ngClass", "click", 4, "ngIf"], ["class", "igx-excel-filter__actions-unpin", "tabindex", "0", 3, "click", 4, "ngIf"], ["tabindex", "0", 3, "ngClass", "click"], ["fontSet", "filtering-icons", "name", "pin"], ["tabindex", "0", 1, "igx-excel-filter__actions-unpin", 3, "click"], ["fontSet", "filtering-icons", "name", "unpin"], ["tabindex", "0", 1, "igx-excel-filter__actions-hide", 3, "click"], ["fontSet", "material"], [1, "igx-excel-filter__menu", 3, "ngClass", "id", "keydown"], ["dropdown", ""], [1, "igx-excel-filter__menu-header"], ["class", "igx-excel-filter__menu-header-actions", 4, "ngIf"], [4, "ngIf"], [1, "igx-excel-filter__actions"], ["tabindex", "0", 3, "ngClass", "keydown", "click"], ["tabindex", "0", 1, "igx-excel-filter__actions-filter", 3, "igxDropDownItemNavigation", "keydown", "click"], [1, "igx-excel-filter__menu-main", 3, "column", "data", "grid", "inline", "displayDensity"], ["excelStyleSearch", ""], [1, "igx-excel-filter__menu-footer"], ["igxButton", "", 3, "displayDensity", "click"], ["igxButton", "raised", 3, "displayDensity", "disabled", "click"], [1, "igx-excel-filter__menu-header-actions"], ["igxButton", "icon", "tabindex", "0", 3, "displayDensity", "ngClass", "click", 4, "ngIf"], ["igxButton", "icon", "tabindex", "0", 3, "displayDensity", "disabled", "click", 4, "ngIf"], ["igxButton", "icon", "tabindex", "0", 3, "displayDensity", "click", 4, "ngIf"], ["igxButton", "icon", "tabindex", "0", 3, "displayDensity", "ngClass", "click"], ["igxButton", "icon", "tabindex", "0", 3, "displayDensity", "disabled", "click"], ["igxButton", "icon", "tabindex", "0", 3, "displayDensity", "click"], [4, "ngTemplateOutlet"], [3, "maxHeight", "displayDensity", "onSelection", "onClosed"], ["subMenu", ""], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], ["fontSet", "filtering-icons", 3, "name"], [2, "margin-left", "16px"], [3, "column", "filteringService", "overlayComponentId", "overlayService", "displayDensity"], ["customDialog", ""]], template: function IgxGridExcelStyleFilteringComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridExcelStyleFilteringComponent_ng_template_0_Template, 2, 3, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridExcelStyleFilteringComponent_ng_template_2_Template, 1, 4, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridExcelStyleFilteringComponent_ng_template_4_Template, 2, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridExcelStyleFilteringComponent_ng_template_6_Template, 5, 2, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxGridExcelStyleFilteringComponent_ng_template_8_Template, 5, 2, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxGridExcelStyleFilteringComponent_article_10_Template, 29, 30, "article", 5);
        ɵngcc0.ɵɵtemplate(11, IgxGridExcelStyleFilteringComponent_igx_drop_down_11_Template, 5, 4, "igx-drop-down", 6);
        ɵngcc0.ɵɵtemplate(12, IgxGridExcelStyleFilteringComponent_igx_excel_style_custom_dialog_12_Template, 2, 5, "igx-excel-style-custom-dialog", 7);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxExcelStyleSortingComponent,
        IgxExcelStyleColumnMovingComponent, ɵngcc2.NgClass, IgxIconComponent,
        IgxDropDownItemNavigationDirective,
        IgxExcelStyleSearchComponent,
        IgxButtonDirective, ɵngcc2.NgTemplateOutlet, IgxDropDownComponent, ɵngcc2.NgForOf, IgxDropDownItemComponent,
        IgxExcelStyleCustomDialogComponent]; }, encapsulation: 2, changeDetection: 0 });
IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold = 2;
IgxGridExcelStyleFilteringComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
__decorate([
    Input()
], IgxGridExcelStyleFilteringComponent.prototype, "column", null);
__decorate([
    HostBinding('style.max-height')
], IgxGridExcelStyleFilteringComponent.prototype, "maxHeight", null);
__decorate([
    HostBinding('class.igx-excel-filter')
], IgxGridExcelStyleFilteringComponent.prototype, "className", void 0);
__decorate([
    HostBinding('class.igx-excel-filter--inline')
], IgxGridExcelStyleFilteringComponent.prototype, "inline", void 0);
__decorate([
    ViewChild('dropdown', { read: ElementRef })
], IgxGridExcelStyleFilteringComponent.prototype, "mainDropdown", void 0);
__decorate([
    ViewChild('subMenu', { read: IgxDropDownComponent })
], IgxGridExcelStyleFilteringComponent.prototype, "subMenu", void 0);
__decorate([
    ViewChild('customDialog', { read: IgxExcelStyleCustomDialogComponent })
], IgxGridExcelStyleFilteringComponent.prototype, "customDialog", void 0);
__decorate([
    ViewChild('excelStyleSearch', { read: IgxExcelStyleSearchComponent })
], IgxGridExcelStyleFilteringComponent.prototype, "excelStyleSearch", void 0);
__decorate([
    ViewChild('excelStyleSorting', { read: IgxExcelStyleSortingComponent })
], IgxGridExcelStyleFilteringComponent.prototype, "excelStyleSorting", void 0);
__decorate([
    ViewChild('defaultExcelStyleSortingTemplate', { read: TemplateRef, static: true })
], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleSortingTemplate", void 0);
__decorate([
    ViewChild('defaultExcelStyleHidingTemplate', { read: TemplateRef, static: true })
], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleHidingTemplate", void 0);
__decorate([
    ViewChild('defaultExcelStyleSelectingTemplate', { read: TemplateRef, static: true })
], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleSelectingTemplate", void 0);
__decorate([
    ViewChild('defaultExcelStyleMovingTemplate', { read: TemplateRef, static: true })
], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStyleMovingTemplate", void 0);
__decorate([
    ViewChild('defaultExcelStylePinningTemplate', { read: TemplateRef, static: true })
], IgxGridExcelStyleFilteringComponent.prototype, "defaultExcelStylePinningTemplate", void 0);

/** @hidden */
let IgxGridNavigationService = class IgxGridNavigationService {
    constructor() {
        this.pendingNavigation = false;
    }
    handleNavigation(event) {
        const key = event.key.toLowerCase();
        if (event.repeat && SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) {
            event.preventDefault();
        }
        event.repeat ? setTimeout(() => this.dispatchEvent(event), 1) : this.dispatchEvent(event);
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell))) {
            return;
        }
        const shift = event.shiftKey;
        const ctrl = event.ctrlKey;
        if (NAVIGATION_KEYS.has(key) && this.pendingNavigation) {
            event.preventDefault();
            return;
        }
        const type = this.isDataRow(this.activeNode.row) ? GridKeydownTargetType.dataCell :
            this.isDataRow(this.activeNode.row, true) ? GridKeydownTargetType.summaryCell : GridKeydownTargetType.groupRow;
        if (this.emitKeyDown(type, this.activeNode.row, event)) {
            return;
        }
        if (event.altKey) {
            this.handleAlt(key, event);
            return;
        }
        if ([' ', 'spacebar', 'space'].indexOf(key) === -1) {
            this.grid.selectionService.keyboardStateOnKeydown(this.activeNode, shift, shift && key === 'tab');
        }
        if (this.grid.crudService.cell && NAVIGATION_KEYS.has(key)) {
            return;
        }
        const position = this.getNextPosition(this.activeNode.row, this.activeNode.column, key, shift, ctrl, event);
        if (NAVIGATION_KEYS.has(key)) {
            event.preventDefault();
            this.navigateInBody(position.rowIndex, position.colIndex, (obj) => { obj.target.activate(event); });
        }
        this.grid.cdr.detectChanges();
    }
    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {
        if (!this.isDataRow(rowIndex, true) && (key.indexOf('down') < 0 || key.indexOf('up') < 0) && ctrl) {
            return { rowIndex, colIndex };
        }
        switch (key) {
            case 'pagedown':
            case 'pageup':
                event.preventDefault();
                key === 'pagedown' ? this.grid.verticalScrollContainer.scrollNextPage() :
                    this.grid.verticalScrollContainer.scrollPrevPage();
                break;
            case 'tab':
                this.handleEditing(shift, event);
                break;
            case 'end':
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                colIndex = this.lastColumnIndex;
                break;
            case 'home':
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                colIndex = 0;
                break;
            case 'arrowleft':
            case 'left':
                colIndex = ctrl ? 0 : this.activeNode.column - 1;
                break;
            case 'arrowright':
            case 'right':
                colIndex = ctrl ? this.lastColumnIndex : this.activeNode.column + 1;
                break;
            case 'arrowup':
            case 'up':
                if (ctrl && !this.isDataRow(rowIndex)) {
                    break;
                }
                colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row - 1;
                break;
            case 'arrowdown':
            case 'down':
                if (ctrl && !this.isDataRow(rowIndex)) {
                    break;
                }
                colIndex = this.activeNode.column !== undefined ? this.activeNode.column : 0;
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row + 1;
                break;
            case 'enter':
            case 'f2':
                const cell = this.grid.getCellByColumnVisibleIndex(this.activeNode.row, this.activeNode.column);
                if (!this.isDataRow(rowIndex) || !cell.editable) {
                    break;
                }
                this.grid.crudService.enterEditMode(cell);
                break;
            case 'escape':
            case 'esc':
                if (!this.isDataRow(rowIndex)) {
                    break;
                }
                this.grid.crudService.exitEditMode();
                break;
            case ' ':
            case 'spacebar':
            case 'space':
                const rowObj = this.grid.getRowByIndex(this.activeNode.row);
                if (this.grid.isRowSelectable && this.isDataRow(rowIndex)) {
                    rowObj && rowObj.selected ? this.grid.selectionService.deselectRow(rowObj.rowID, event) :
                        this.grid.selectionService.selectRowById(rowObj.rowID, false, event);
                }
                break;
            default:
                return;
        }
        return { rowIndex, colIndex };
    }
    summaryNav(event) {
        this.horizontalNav(event, event.key.toLowerCase(), this.grid.dataView.length);
    }
    headerNavigation(event) {
        const key = event.key.toLowerCase();
        if (!HEADER_KEYS.has(key)) {
            return;
        }
        event.preventDefault();
        const ctrl = event.ctrlKey;
        const shift = event.shiftKey;
        const alt = event.altKey;
        this.performHeaderKeyCombination(this.currentActiveColumn, key, shift, ctrl, alt, event);
        if (shift || alt || (ctrl && (key.includes('down') || key.includes('down')))) {
            return;
        }
        !this.grid.hasColumnGroups ? this.horizontalNav(event, key, -1) : this.handleMCHeaderNav(key, ctrl);
    }
    horizontalNav(event, key, rowIndex) {
        const ctrl = event.ctrlKey;
        if (!HORIZONTAL_NAV_KEYS.has(event.key.toLowerCase())) {
            return;
        }
        event.preventDefault();
        this.activeNode.row = rowIndex;
        if (rowIndex > 0) {
            if (this.emitKeyDown(GridKeydownTargetType.summaryCell, this.activeNode.row, event)) {
                return;
            }
        }
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            this.activeNode.column = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
        }
        if ((key.includes('right') || key === 'end') && this.activeNode.column < this.lastColumnIndex) {
            this.activeNode.column = ctrl || key === 'end' ? this.lastColumnIndex : this.activeNode.column + 1;
        }
        this.performHorizontalScrollToCell(this.activeNode.column);
    }
    focusTbody(event) {
        var _a;
        const gridRows = (_a = this.grid.verticalScrollContainer.totalItemCount) !== null && _a !== void 0 ? _a : this.grid.dataView.length;
        if (!this.activeNode || this.activeNode.row < 0 || this.activeNode.row > gridRows - 1) {
            this.activeNode = { row: 0, column: 0 };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
    }
    focusFirstCell(header = true) {
        if (this.activeNode && (this.activeNode.row === -1 || this.activeNode.row === this.grid.dataView.length)) {
            return;
        }
        this.activeNode = { row: header ? -1 : this.grid.dataView.length, column: 0,
            level: this.grid.hasColumnLayouts ? 1 : 0, mchCache: { level: 0, visibleIndex: 0 } };
        this.performHorizontalScrollToCell(0);
    }
    get lastColumnIndex() {
        return Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex));
    }
    get displayContainerWidth() {
        return Math.round(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth);
    }
    get displayContainerScrollLeft() {
        return Math.ceil(this.grid.headerContainer.scrollPosition);
    }
    get containerTopOffset() {
        return parseInt(this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement.style.top, 10);
    }
    isColumnFullyVisible(columnIndex) {
        if (columnIndex < 0 || this.isColumnPinned(columnIndex, this.forOfDir())) {
            return true;
        }
        const index = this.getColumnUnpinnedIndex(columnIndex);
        const width = this.forOfDir().getColumnScrollLeft(index + 1) - this.forOfDir().getColumnScrollLeft(index);
        if (this.displayContainerWidth < width && this.displayContainerScrollLeft === this.forOfDir().getColumnScrollLeft(index)) {
            return true;
        }
        return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
    }
    getColumnUnpinnedIndex(visibleColumnIndex) {
        const column = this.grid.unpinnedColumns.find((col) => !col.columnGroup && col.visibleIndex === visibleColumnIndex);
        return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter((c) => !c.columnGroup).indexOf(column) :
            visibleColumnIndex;
    }
    forOfDir() {
        const forOfDir = this.grid.dataRowList.length > 0 ? this.grid.dataRowList.first.virtDirRow : this.grid.headerContainer;
        return forOfDir;
    }
    handleAlt(key, event) {
        event.preventDefault();
        const row = this.grid.getRowByIndex(this.activeNode.row);
        if (!this.isToggleKey(key) || !row) {
            return;
        }
        if (!row.expanded && ROW_EXPAND_KEYS.has(key)) {
            row.rowID === undefined ? row.toggle() :
                this.grid.gridAPI.set_row_expansion_state(row.rowID, true, event);
        }
        else if (row.expanded && ROW_COLLAPSE_KEYS.has(key)) {
            row.rowID === undefined ? row.toggle() :
                this.grid.gridAPI.set_row_expansion_state(row.rowID, false, event);
        }
        this.grid.notifyChanges();
    }
    handleEditing(shift, event) {
        const next = shift ? this.grid.getPreviousCell(this.activeNode.row, this.activeNode.column, col => col.editable) :
            this.grid.getNextCell(this.activeNode.row, this.activeNode.column, col => col.editable);
        if (!this.grid.rowInEditMode && this.isActiveNode(next.rowIndex, next.visibleColumnIndex)) {
            this.grid.endEdit(true);
            return;
        }
        event.preventDefault();
        if ((this.grid.rowInEditMode && this.grid.rowEditTabs.length) &&
            (this.activeNode.row !== next.rowIndex || this.isActiveNode(next.rowIndex, next.visibleColumnIndex))) {
            this.grid.gridAPI.submit_value();
            shift ? this.grid.rowEditTabs.last.element.nativeElement.focus() :
                this.grid.rowEditTabs.first.element.nativeElement.focus();
            return;
        }
        if (this.grid.rowInEditMode && !this.grid.rowEditTabs.length) {
            if (shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                next.visibleColumnIndex = this.grid.lastEditableColumnIndex;
            }
            else if (!shift && next.rowIndex === this.activeNode.row && next.visibleColumnIndex === this.activeNode.column) {
                next.visibleColumnIndex = this.grid.firstEditableColumnIndex;
            }
            else {
                next.rowIndex = this.activeNode.row;
            }
        }
        this.navigateInBody(next.rowIndex, next.visibleColumnIndex, (obj) => {
            obj.target.activate(event);
            this.grid.cdr.detectChanges();
        });
    }
    shouldPerformHorizontalScroll(visibleColIndex, rowIndex = -1) {
        if (visibleColIndex < 0 || visibleColIndex > this.grid.visibleColumns.length - 1) {
            return false;
        }
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return !this.isColumnFullyVisible(visibleColIndex);
        }
        const row = this.grid.dataView[rowIndex];
        return row.expression || row.detailsData ? false : !this.isColumnFullyVisible(visibleColIndex);
    }
    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {
        if (this.grid.isRecordPinnedByViewIndex(targetRowIndex)) {
            return false;
        }
        const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
            targetRowIndex - this.grid.pinnedDataView.length : targetRowIndex;
        const targetRow = this.getRowElementByIndex(targetRowIndex);
        const rowHeight = this.grid.verticalScrollContainer.getSizeAt(scrollRowIndex);
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const endTopOffset = targetRow ? targetRow.offsetTop + rowHeight + this.containerTopOffset : containerHeight + rowHeight;
        // this is workaround: endTopOffset - containerHeight > 5 and should be replaced with: containerHeight < endTopOffset
        // when the page is zoomed the grid does not scroll the row completely in the view
        return !targetRow || targetRow.offsetTop < Math.abs(this.containerTopOffset)
            || containerHeight && endTopOffset - containerHeight > 5;
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        if (!this.isValidPosition(rowIndex, visibleColIndex) || this.isActiveNode(rowIndex, visibleColIndex)) {
            return;
        }
        this.grid.navigateTo(this.activeNode.row = rowIndex, this.activeNode.column = visibleColIndex, cb);
    }
    performVerticalScrollToCell(rowIndex, visibleColIndex = -1, cb) {
        if (!this.shouldPerformVerticalScroll(rowIndex, visibleColIndex)) {
            return;
        }
        this.pendingNavigation = true;
        // Only for top pinning we need to subtract pinned count because virtualization indexing doesn't count pinned rows.
        const scrollRowIndex = this.grid.hasPinnedRecords && this.grid.isRowPinningToTop ?
            rowIndex - this.grid.pinnedDataView.length : rowIndex;
        this.grid.verticalScrollContainer.scrollTo(scrollRowIndex);
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(first$1()).subscribe(() => {
            this.pendingNavigation = false;
            if (cb) {
                cb();
            }
        });
    }
    performHorizontalScrollToCell(visibleColumnIndex, cb) {
        if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
            return;
        }
        this.pendingNavigation = true;
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first$1())
            .subscribe(() => {
            this.pendingNavigation = false;
            if (cb) {
                cb();
            }
        });
        this.forOfDir().scrollTo(this.getColumnUnpinnedIndex(visibleColumnIndex));
    }
    isDataRow(rowIndex, includeSummary = false) {
        if (rowIndex < 0 || rowIndex > this.grid.dataView.length - 1) {
            return true;
        }
        const curRow = this.grid.dataView[rowIndex];
        return curRow && !this.grid.isGroupByRecord(curRow) && !this.grid.isDetailRecord(curRow)
            && !curRow.childGridsData && (includeSummary || !curRow.summaries);
    }
    emitKeyDown(type, rowIndex, event) {
        var _a, _b;
        const row = this.grid.summariesRowList.toArray().concat(this.grid.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            return;
        }
        const target = type === GridKeydownTargetType.groupRow ? row :
            type === GridKeydownTargetType.dataCell ? (_a = row.cells) === null || _a === void 0 ? void 0 : _a.find(c => c.visibleColumnIndex === this.activeNode.column) : (_b = row.summaryCells) === null || _b === void 0 ? void 0 : _b.find(c => c.visibleColumnIndex === this.activeNode.column);
        const keydownArgs = { targetType: type, event: event, cancel: false, target: target };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel && type === GridKeydownTargetType.dataCell) {
            this.grid.selectionService.clear();
            this.grid.selectionService.keyboardState.active = true;
            return keydownArgs.cancel;
        }
    }
    isColumnPinned(columnIndex, forOfDir) {
        var _a;
        const horizontalScroll = forOfDir.getScroll();
        return (!horizontalScroll.clientWidth || ((_a = this.grid.getColumnByVisibleIndex(columnIndex)) === null || _a === void 0 ? void 0 : _a.pinned));
    }
    findFirstDataRowIndex() {
        return this.grid.dataView.findIndex(rec => !this.grid.isGroupByRecord(rec) && !this.grid.isDetailRecord(rec));
    }
    findLastDataRowIndex() {
        let i = this.grid.dataView.length;
        while (i--) {
            if (this.isDataRow(i)) {
                return i;
            }
        }
    }
    getRowElementByIndex(index) {
        var _a;
        if (this.grid.hasDetails) {
            const detail = this.grid.nativeElement.querySelector(`[detail="true"][data-rowindex="${index}"]`);
            if (detail) {
                return detail;
            }
        }
        return (_a = this.grid.rowList.toArray().concat(this.grid.summariesRowList.toArray()).find(r => r.index === index)) === null || _a === void 0 ? void 0 : _a.nativeElement;
    }
    isValidPosition(rowIndex, colIndex) {
        if (rowIndex < 0 || colIndex < 0 || this.grid.dataView.length - 1 < rowIndex || this.lastColumnIndex < colIndex) {
            return false;
        }
        return this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true) ? false : true;
    }
    performHeaderKeyCombination(column, key, shift, ctrl, alt, event) {
        var _a;
        let direction = (_a = this.grid.sortingExpressions.find(expr => expr.fieldName === column.field)) === null || _a === void 0 ? void 0 : _a.dir;
        if (ctrl && key.includes('up') && column.sortable && !column.columnGroup) {
            direction = direction === SortingDirection.Asc ? SortingDirection.None : SortingDirection.Asc;
            this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
            return;
        }
        if (ctrl && key.includes('down') && column.sortable && !column.columnGroup) {
            direction = direction === SortingDirection.Desc ? SortingDirection.None : SortingDirection.Desc;
            this.grid.sort({ fieldName: column.field, dir: direction, ignoreCase: false });
            return;
        }
        if (shift && alt && this.isToggleKey(key) && !column.columnGroup && column.groupable) {
            direction = direction ? SortingDirection.Desc : SortingDirection.Asc;
            key.includes('right') ? this.grid.groupBy({ fieldName: column.field, dir: direction, ignoreCase: false }) :
                this.grid.clearGrouping(column.field);
            this.activeNode.column = key.includes('right') && this.grid.hideGroupedColumns &&
                column.visibleIndex === this.lastColumnIndex ? this.lastColumnIndex - 1 : this.activeNode.column;
            return;
        }
        if (alt && (ROW_EXPAND_KEYS.has(key) || ROW_COLLAPSE_KEYS.has(key))) {
            this.handleMCHExpandCollapse(key, column);
            return;
        }
        if ([' ', 'spacebar', 'space'].indexOf(key) !== -1) {
            this.handleColumnSelection(column, event);
        }
        if (alt && key === 'l' && this.grid.allowAdvancedFiltering) {
            this.grid.openAdvancedFilteringDialog();
        }
        if (ctrl && shift && key === 'l' && this.grid.allowFiltering && !column.columnGroup && column.filterable) {
            if (this.grid.filterMode === FilterMode.excelStyleFilter) {
                const headerEl = this.grid.nativeElement.querySelector(`.igx-grid__th--active`);
                this.grid.filteringService.toggleFilterDropdown(headerEl, column, IgxGridExcelStyleFilteringComponent);
            }
            else {
                this.performHorizontalScrollToCell(column.visibleIndex);
                this.grid.filteringService.filteredColumn = column;
                this.grid.filteringService.isFilterRowVisible = true;
            }
        }
    }
    handleMCHeaderNav(key, ctrl) {
        const activeCol = this.currentActiveColumn;
        const lastGroupIndex = Math.max(...this.grid.visibleColumns.
            filter(c => c.level <= this.activeNode.level).map(col => col.visibleIndex));
        let nextCol = activeCol;
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            const index = ctrl || key === 'home' ? 0 : this.activeNode.column - 1;
            nextCol = this.getNextColumnMCH(index);
            this.activeNode.mchCache.visibleIndex = nextCol.visibleIndex;
        }
        if ((key.includes('right') || key === 'end') && activeCol.visibleIndex < lastGroupIndex) {
            const nextVIndex = activeCol.children ? Math.max(...activeCol.allChildren.map(c => c.visibleIndex)) + 1 :
                activeCol.visibleIndex + 1;
            nextCol = ctrl || key === 'end' ? this.getNextColumnMCH(this.lastColumnIndex) : this.getNextColumnMCH(nextVIndex);
            this.activeNode.mchCache.visibleIndex = nextCol.visibleIndex;
        }
        if (!ctrl && key.includes('up') && this.activeNode.level > 0) {
            nextCol = activeCol.parent;
            this.activeNode.mchCache.level = nextCol.level;
        }
        if (!ctrl && key.includes('down') && activeCol.children) {
            nextCol = activeCol.children.find(c => c.visibleIndex === this.activeNode.mchCache.visibleIndex) ||
                activeCol.children.toArray().sort((a, b) => b.visibleIndex - a.visibleIndex)
                    .filter(col => col.visibleIndex < this.activeNode.mchCache.visibleIndex)[0];
            this.activeNode.mchCache.level = nextCol.level;
        }
        this.activeNode.column = nextCol.visibleIndex;
        this.activeNode.level = nextCol.level;
        this.performHorizontalScrollToCell(this.activeNode.column);
    }
    handleMCHExpandCollapse(key, column) {
        if (!column.children || !column.collapsible) {
            return;
        }
        if (!column.expanded && ROW_EXPAND_KEYS.has(key)) {
            column.expanded = true;
        }
        else if (column.expanded && ROW_COLLAPSE_KEYS.has(key)) {
            column.expanded = false;
        }
    }
    handleColumnSelection(column, event) {
        if (!column.selectable || this.grid.columnSelection === GridSelectionMode.none) {
            return;
        }
        const clearSelection = this.grid.columnSelection === GridSelectionMode.single;
        const columnsToSelect = !column.children ? [column.field] :
            column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);
        column.selected ? this.grid.selectionService.deselectColumns(columnsToSelect, event) :
            this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, false, event);
    }
    getNextColumnMCH(visibleIndex) {
        let col = this.grid.getColumnByVisibleIndex(visibleIndex);
        let parent = col.parent;
        while (parent && col.level > this.activeNode.mchCache.level) {
            col = col.parent;
            parent = col.parent;
        }
        return col;
    }
    get currentActiveColumn() {
        return this.grid.visibleColumns.find(c => c.visibleIndex === this.activeNode.column && c.level === this.activeNode.level);
    }
    isActiveNode(rIndex, cIndex) {
        return this.activeNode ? this.activeNode.row === rIndex && this.activeNode.column === cIndex : false;
    }
    isToggleKey(key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    }
};
IgxGridNavigationService.ɵfac = function IgxGridNavigationService_Factory(t) { return new (t || IgxGridNavigationService)(); };
IgxGridNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridNavigationService, factory: IgxGridNavigationService.ɵfac });

/**
 * @hidden
 * @internal
 */
let IgxColumnResizingService = class IgxColumnResizingService {
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     */
    get resizerHeight() {
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        let columnHeightMultiplier = 1;
        if (this.column.columnLayoutChild) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     */
    get restrictResizeMin() {
        const actualMinWidth = parseFloat(this.column.minWidth);
        const minWidth = actualMinWidth < parseFloat(this.column.width) ? actualMinWidth : parseFloat(this.column.width);
        return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     */
    get restrictResizeMax() {
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        if (this.column.maxWidth) {
            return parseFloat(this.column.maxWidth) - actualWidth;
        }
        else {
            return Number.MAX_SAFE_INTEGER;
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    autosizeColumnOnDblClick() {
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        const size = this.column.getLargestCellWidth();
        if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.minWidth)) {
            this.column.width = parseFloat(this.column.minWidth) + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(() => { });
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    resizeColumn(event) {
        this.showResizer = false;
        const diff = event.clientX - this.startResizePos;
        let currentColWidth = parseFloat(this.column.width);
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const colMinWidth = this.getColMinWidth(this.column);
        const colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(() => { });
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    getColMinWidth(column) {
        let currentColWidth = parseFloat(column.width);
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        const actualMinWidth = parseFloat(column.minWidth);
        return actualMinWidth < currentColWidth ? actualMinWidth : currentColWidth;
    }
    getColMaxWidth(column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    }
    resizeColumnLayoutFor(column, diff) {
        const relativeColumns = column.getResizableColUnderEnd();
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        // Resize first those who might reach min/max width
        let columnsToResize = [...relativeColumns];
        let updatedDiff = diff;
        let updatedCombinedSpan = combinedSpan;
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            let newCombinedSpan = updatedCombinedSpan;
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                const minWidth = this.getColMinWidth(col.target);
                const maxWidth = this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            const currentResizeWidth = parseFloat(col.target.calcWidth);
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    }
};
IgxColumnResizingService.ɵfac = function IgxColumnResizingService_Factory(t) { return new (t || IgxColumnResizingService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
IgxColumnResizingService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxColumnResizingService, factory: IgxColumnResizingService.ɵfac });
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];

/**
 * @hidden
 */
let IgxGridHeaderComponent = class IgxGridHeaderComponent {
    constructor(gridAPI, colResizingService, cdr, elementRef, zone) {
        this.gridAPI = gridAPI;
        this.colResizingService = colResizingService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.zone = zone;
        this._destroy$ = new Subject();
        this.hostRole = 'columnheader';
        this.sortDirection = SortingDirection.None;
    }
    /**
     * Returns the `aria-selected` of the header.
     */
    get ariaSelected() {
        return this.column.selected;
    }
    get styleClasses() {
        const defaultClasses = [
            'igx-grid__th--fw',
            this.column.headerClasses
        ];
        const classList = {
            'igx-grid__th': !this.column.columnGroup,
            'asc': this.ascending,
            'desc': this.descending,
            'igx-grid__th--number': this.column.dataType === DataType.Number,
            'igx-grid__th--sortable': this.column.sortable,
            'igx-grid__th--selectable': this.selectable,
            'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
            'igx-grid__th--sorted': this.sorted,
            'igx-grid__th--selected': this.selected
        };
        for (const klass of Object.keys(classList)) {
            if (classList[klass]) {
                defaultClasses.push(klass);
            }
        }
        return defaultClasses.join(' ');
    }
    get height() {
        if (this.grid.hasColumnGroups) {
            return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight / this.grid._baseFontSize;
        }
        return null;
    }
    get ascending() {
        return this.sortDirection === SortingDirection.Asc;
    }
    get descending() {
        return this.sortDirection === SortingDirection.Desc;
    }
    get sortingIcon() {
        if (this.sortDirection !== SortingDirection.None) {
            // arrow_downward and arrow_upward
            // are material icons ligature strings
            return this.sortDirection === SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
        }
        return 'arrow_upward';
    }
    get sorted() {
        return this.sortDirection !== SortingDirection.None;
    }
    get filterIconClassName() {
        return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
    }
    get selectable() {
        return this.grid.columnSelection !== GridSelectionMode.none &&
            this.column.applySelectableClass &&
            !this.column.selected &&
            !this.grid.filteringService.isFilterRowVisible;
    }
    get selected() {
        return this.column.selected
            && (!this.grid.filteringService.isFilterRowVisible || this.grid.filteringService.filteredColumn !== this.column);
    }
    get columnTitle() {
        return this.column.elementRef.nativeElement.getAttribute('title') ||
            this.column.header || this.column.field;
    }
    get headerID() {
        return `${this.gridID}_${this.column.field}`;
    }
    ngOnInit() {
        this.grid.filteringService.initFilteringSettings();
    }
    ngDoCheck() {
        this.getSortDirection();
        this.cdr.markForCheck();
    }
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
        this.grid.filteringService.hideExcelFiltering();
    }
    onClick(event) {
        if (!this.colResizingService.isColumnResizing) {
            if (this.grid.filteringService.isFilterRowVisible) {
                if (this.column.filterCellTemplate) {
                    this.grid.filteringRow.close();
                    return;
                }
                if (this.column.filterable && !this.column.columnGroup &&
                    !this.grid.filteringService.isFilterComplex(this.column.field)) {
                    this.grid.filteringService.filteredColumn = this.column;
                }
            }
            else if (this.grid.columnSelection !== GridSelectionMode.none && this.column.selectable) {
                const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
                const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
                if (!this.column.selected || (this.grid.selectionService.getSelectedColumns().length > 1 && clearSelection)) {
                    this.grid.selectionService.selectColumn(this.column.field, clearSelection, rangeSelection, event);
                }
                else {
                    this.grid.selectionService.deselectColumn(this.column.field, event);
                }
            }
        }
        this.grid.theadRow.nativeElement.focus();
    }
    onFilteringIconClick(event) {
        event.stopPropagation();
        this.grid.filteringService.toggleFilterDropdown(this.elementRef.nativeElement, this.column, IgxGridExcelStyleFilteringComponent);
    }
    get grid() {
        return this.gridAPI.grid;
    }
    getSortDirection() {
        const expr = this.gridAPI.grid.sortingExpressions.find((x) => x.fieldName === this.column.field);
        this.sortDirection = expr ? expr.dir : SortingDirection.None;
    }
    onSortingIconClick(event) {
        event.stopPropagation();
        this.triggerSort();
    }
    triggerSort() {
        const groupingExpr = this.grid.groupingExpressions ?
            this.grid.groupingExpressions.find((expr) => expr.fieldName === this.column.field) : null;
        const sortDir = groupingExpr ?
            this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc
            : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;
        this.sortDirection = sortDir;
        this.grid.sort({
            fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
            strategy: this.column.sortStrategy
        });
    }
    /**
     * @hidden
     */
    onPinterEnter() {
        this.column.applySelectableClass = true;
    }
    /**
     * @hidden
     */
    onPointerLeave() {
        this.column.applySelectableClass = false;
    }
};
IgxGridHeaderComponent.ɵfac = function IgxGridHeaderComponent_Factory(t) { return new (t || IgxGridHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxGridHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridHeaderComponent, selectors: [["igx-grid-header"]], hostVars: 7, hostBindings: function IgxGridHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxGridHeaderComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("pointerenter", function IgxGridHeaderComponent_pointerenter_HostBindingHandler() { return ctx.onPinterEnter(); })("pointerleave", function IgxGridHeaderComponent_pointerleave_HostBindingHandler() { return ctx.onPointerLeave(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.hostRole)("aria-selected", ctx.ariaSelected)("id", ctx.headerID);
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
        ɵngcc0.ɵɵstyleProp("height", ctx.height, "rem");
    } }, inputs: { column: "column", gridID: "gridID" }, decls: 5, vars: 6, consts: [["defaultColumn", ""], [1, "igx-grid__th-title"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-grid__th-icons", 4, "ngIf"], [1, "igx-grid__th-icons"], ["class", "sort-icon", 3, "click", 4, "ngIf"], [3, "ngClass", "click", 4, "ngIf"], [1, "sort-icon", 3, "click"], [3, "ngClass", "click"]], template: function IgxGridHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridHeaderComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(2, "span", 1);
        ɵngcc0.ɵɵtemplate(3, IgxGridHeaderComponent_ng_container_3_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, IgxGridHeaderComponent_div_4_Template, 3, 2, "div", 3);
    } if (rf & 2) {
        const _r403 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.column.headerTemplate ? ctx.column.headerTemplate : _r403)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction2(3, _c73, ctx.column, ctx.column));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.column.columnGroup);
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent, ɵngcc2.NgClass], encapsulation: 2, changeDetection: 0 });
IgxGridHeaderComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxColumnResizingService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input()
], IgxGridHeaderComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxGridHeaderComponent.prototype, "gridID", void 0);
__decorate([
    HostBinding('attr.aria-selected')
], IgxGridHeaderComponent.prototype, "ariaSelected", null);
__decorate([
    HostBinding('class')
], IgxGridHeaderComponent.prototype, "styleClasses", null);
__decorate([
    HostBinding('style.height.rem')
], IgxGridHeaderComponent.prototype, "height", null);
__decorate([
    HostBinding('attr.role')
], IgxGridHeaderComponent.prototype, "hostRole", void 0);
__decorate([
    HostBinding('attr.id')
], IgxGridHeaderComponent.prototype, "headerID", null);
__decorate([
    HostListener('click', ['$event'])
], IgxGridHeaderComponent.prototype, "onClick", null);
__decorate([
    HostListener('pointerenter')
], IgxGridHeaderComponent.prototype, "onPinterEnter", null);
__decorate([
    HostListener('pointerleave')
], IgxGridHeaderComponent.prototype, "onPointerLeave", null);

let CHIP_ID = 0;
/**
 * Chip is compact visual component that displays information in an obround.
 *
 * @igxModule IgxChipsModule
 *
 * @igxTheme igx-chip-theme
 *
 * @igxKeywords chip
 *
 * @igxGroup display
 *
 * @remarks
 * The Ignite UI Chip can be templated, deleted, and selected.
 * Multiple chips can be reordered and visually connected to each other.
 * Chips reside in a container called chips area which is responsible for managing the interactions between the chips.
 *
 * @example
 * ```html
 * <igx-chip class="chipStyle" [id]="901" [draggable]="true" [removable]="true" (onRemove)="chipRemoved($event)">
 *    <igx-avatar class="chip-avatar-resized" igxPrefix fontSet="material" roundShape="true"></igx-avatar>
 * </igx-chip>
 * ```
 */
let IgxChipComponent = class IgxChipComponent extends DisplayDensityBase {
    constructor(cdr, elementRef, renderer, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'"></igx-chip>
         * ```
         */
        this.id = `igx-chip-${CHIP_ID++}`;
        /**
         * An @Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
         * ```
         */
        this.draggable = false;
        /**
         * An @Input property that enables/disables the draggable element animation when the element is released.
         * By default it's set to true.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [animateOnRelease]="false"></igx-chip>
         * ```
         */
        this.animateOnRelease = true;
        /**
         * An @Input property that enables/disables the hiding of the base element that has been dragged.
         * By default it's set to true.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [hideBaseOnDrag]="false"></igx-chip>
         * ```
         */
        this.hideBaseOnDrag = true;
        /**
         * An @Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
         * ```
         */
        this.removable = false;
        /**
         * An @Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
         * ```
         */
        this.selectable = false;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * An @Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
         * like focusing on click or tab, selection on click or Space, dragging.
         * By default it is set to false.
         * @example
         * ```html
         * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
         * ```
         */
        this.disabled = false;
        /**
         * @hidden
         * @internal
         */
        this.selectedChange = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving starts.
         * Returns the moving `IgxChipComponent`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveStart)="moveStarted($event)">
         * ```
         */
        this.onMoveStart = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving ends.
         * Returns the moved `IgxChipComponent`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveEnd)="moveEnded($event)">
         * ```
         */
        this.onMoveEnd = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is removed.
         * Returns the removed `IgxChipComponent`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onRemove)="remove($event)">
         * ```
         */
        this.onRemove = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is clicked.
         * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onClick)="chipClick($event)">
         * ```
         */
        this.onClick = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected.
         * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
         * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelection)="chipSelect($event)">
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected and any related animations and transitions also end.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" (onSelectionDone)="chipSelectEnd($event)">
         * ```
         */
        this.onSelectionDone = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
         * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
         * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onKeyDown)="chipKeyDown($event)">
         * ```
         */
        this.onKeyDown = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
         * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
         * the original drop event arguments.
         * @example
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
         * ```
         */
        this.onDragEnter = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.hostTabIndex = null;
        /**
         * @hidden
         * @internal
         */
        this.hideBaseElement = false;
        this._tabIndex = null;
        this._selected = false;
        this._selectedItemClass = 'igx-chip__item--selected';
        this._movedWhileRemoving = false;
    }
    /**
     * An @Input property that sets the value of `tabindex` attribute. If not provided it will use the element's tabindex if set.
     * @example
     * ```html
     * <igx-chip [id]="'igx-chip-1'" [tabIndex]="1"></igx-chip>
     * ```
     */
    set tabIndex(value) {
        this._tabIndex = value;
    }
    get tabIndex() {
        if (this._tabIndex !== null) {
            return this._tabIndex;
        }
        return !this.disabled ? 0 : null;
    }
    /**
     * Sets the `IgxChipComponent` selected state.
     * @example
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [(selected)]="model.isSelected">
     * ```
     */
    set selected(newValue) {
        this.changeSelection(newValue);
    }
    /**
     * Returns if the `IgxChipComponent` is selected.
     * @example
     * ```typescript
     * @ViewChild('myChip')
     * public chip: IgxChipComponent;
     * selectedChip(){
     *     let selectedChip = this.chip.selected;
     * }
     * ```
     */
    get selected() {
        return this._selected;
    }
    /**
     * An @Input property that sets the `IgxChipComponent` background color.
     * The `color` property supports string, rgb, hex.
     * @example
     * ```html
     * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
     * ```
     */
    set color(newColor) {
        this.chipArea.nativeElement.style.backgroundColor = newColor;
    }
    /**
     * Returns the background color of the `IgxChipComponent`.
     * @example
     * ```typescript
     * @ViewChild('myChip')
     * public chip: IgxChipComponent;
     * ngAfterViewInit(){
     *     let chipColor = this.chip.color;
     * }
     * ```
     */
    get color() {
        return this.chipArea.nativeElement.style.backgroundColor;
    }
    /**
     * @hidden
     * @internal
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-chip')];
        classes.push(this.disabled ? 'igx-chip--disabled' : '');
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    get removeButtonTemplate() {
        return this.removeIcon || this.defaultRemoveIcon;
    }
    /**
     * @hidden
     * @internal
     */
    get selectIconTemplate() {
        return this.selectIcon || this.defaultSelectIcon;
    }
    /**
     * @hidden
     * @internal
     */
    get ghostClass() {
        return this.getComponentDensityClass('igx-chip__ghost');
    }
    /**
     * @hidden
     * @internal
     */
    selectClass(condition) {
        const SELECT_CLASS = 'igx-chip__select';
        return {
            [SELECT_CLASS]: condition,
            [`${SELECT_CLASS}--hidden`]: !condition
        };
    }
    changeSelection(newValue, srcEvent = null) {
        const onSelectArgs = {
            originalEvent: srcEvent,
            owner: this,
            selected: false,
            cancel: false
        };
        fromEvent(this.selectContainer.nativeElement, 'transitionend')
            .pipe(filter(event => event.propertyName === 'width'), take(1))
            .subscribe(event => this.onSelectTransitionDone(event));
        if (newValue && !this._selected) {
            onSelectArgs.selected = true;
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
        else if (!newValue && this._selected) {
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
                this.selectedChange.emit(this._selected);
            }
        }
    }
    onSelectTransitionDone(event) {
        if (!!event.target.tagName) {
            // Trigger onSelectionDone on when `width` property is changed and the target is valid element(not comment).
            this.onSelectionDone.emit({
                owner: this,
                originalEvent: event
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipKeyDown(event) {
        const keyDownArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onKeyDown.emit(keyDownArgs);
        if (keyDownArgs.cancel) {
            return;
        }
        if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
        }
        if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
        if (event.key !== 'Tab') {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveBtnKeyDown(event) {
        if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
            event.preventDefault();
            event.stopPropagation();
        }
    }
    onRemoveMouseDown(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveClick(event) {
        this.onRemove.emit({
            originalEvent: event,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveTouchMove() {
        // We don't remove chip if user starting touch interacting on the remove button moves the chip
        this._movedWhileRemoving = true;
    }
    /**
     * @hidden
     * @internal
     */
    onRemoveTouchEnd(event) {
        if (!this._movedWhileRemoving) {
            this.onRemoveClick(event);
        }
        this._movedWhileRemoving = false;
    }
    /**
     * @hidden
     * @internal
     */
    // -----------------------------
    // Start chip igxDrag behavior
    onChipDragStart(event) {
        this.onMoveStart.emit({
            originalEvent: event,
            owner: this
        });
        event.cancel = !this.draggable || this.disabled;
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragEnd() {
        if (this.animateOnRelease) {
            this.dragDirective.transitionToOrigin();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveEnd(event) {
        // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
        this.onMoveEnd.emit({
            originalEvent: event,
            owner: this
        });
        if (this.selected) {
            this.chipArea.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipGhostCreate() {
        this.hideBaseElement = this.hideBaseOnDrag;
    }
    /**
     * @hidden
     * @internal
     */
    onChipGhostDestroy() {
        this.hideBaseElement = false;
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragClicked(event) {
        const clickEventArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onClick.emit(clickEventArgs);
        if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
    }
    // End chip igxDrag behavior
    /**
     * @hidden
     * @internal
     */
    // -----------------------------
    // Start chip igxDrop behavior
    onChipDragEnterHandler(event) {
        if (this.dragDirective === event.drag || !event.drag.data || !event.drag.data.chip) {
            return;
        }
        const eventArgs = {
            owner: this,
            dragChip: event.drag.data.chip,
            originalEvent: event
        };
        this.onDragEnter.emit(eventArgs);
    }
    /**
     * @hidden
     * @internal
     */
    onChipDrop(event) {
        // Cancel the default drop logic
        event.cancel = true;
    }
};
IgxChipComponent.ɵfac = function IgxChipComponent_Factory(t) { return new (t || IgxChipComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxChipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxChipComponent, selectors: [["igx-chip"]], viewQuery: function IgxChipComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c74, true, IgxDragDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c74, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c75, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c76, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c77, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultRemoveIcon = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultSelectIcon = _t.first);
    } }, hostVars: 3, hostBindings: function IgxChipComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabIndex", ctx.hostTabIndex)("class", ctx.hostClass);
    } }, inputs: { id: "id", draggable: "draggable", animateOnRelease: "animateOnRelease", hideBaseOnDrag: "hideBaseOnDrag", removable: "removable", selectable: "selectable", class: "class", disabled: "disabled", tabIndex: "tabIndex", selected: "selected", color: "color", data: "data", removeIcon: "removeIcon", selectIcon: "selectIcon" }, outputs: { selectedChange: "selectedChange", onMoveStart: "onMoveStart", onMoveEnd: "onMoveEnd", onRemove: "onRemove", onClick: "onClick", onSelection: "onSelection", onSelectionDone: "onSelectionDone", onKeyDown: "onKeyDown", onDragEnter: "onDragEnter" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c80, decls: 14, vars: 10, consts: [["igxDrop", "", 1, "igx-chip__item", 3, "igxDrag", "ghostClass", "keydown", "dragStart", "ghostCreate", "ghostDestroy", "dragEnd", "transitioned", "dragClick", "enter", "dropped"], ["chipArea", ""], [3, "ngClass"], ["selectContainer", ""], [4, "ngTemplateOutlet"], [1, "igx-chip__content"], ["class", "igx-chip__remove", 3, "keydown", "pointerdown", "mousedown", "click", "touchmove", "touchend", 4, "ngIf"], ["defaultSelectIcon", ""], ["defaultRemoveIcon", ""], [1, "igx-chip__remove", 3, "keydown", "pointerdown", "mousedown", "click", "touchmove", "touchend"]], template: function IgxChipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c78);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("keydown", function IgxChipComponent_Template_div_keydown_0_listener($event) { return ctx.onChipKeyDown($event); })("dragStart", function IgxChipComponent_Template_div_dragStart_0_listener($event) { return ctx.onChipDragStart($event); })("ghostCreate", function IgxChipComponent_Template_div_ghostCreate_0_listener() { return ctx.onChipGhostCreate(); })("ghostDestroy", function IgxChipComponent_Template_div_ghostDestroy_0_listener() { return ctx.onChipGhostDestroy(); })("dragEnd", function IgxChipComponent_Template_div_dragEnd_0_listener() { return ctx.onChipDragEnd(); })("transitioned", function IgxChipComponent_Template_div_transitioned_0_listener($event) { return ctx.onChipMoveEnd($event); })("dragClick", function IgxChipComponent_Template_div_dragClick_0_listener($event) { return ctx.onChipDragClicked($event); })("enter", function IgxChipComponent_Template_div_enter_0_listener($event) { return ctx.onChipDragEnterHandler($event); })("dropped", function IgxChipComponent_Template_div_dropped_0_listener($event) { return ctx.onChipDrop($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵtemplate(4, IgxChipComponent_ng_container_4_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementStart(6, "div", 5);
        ɵngcc0.ɵɵprojection(7, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(8, 2);
        ɵngcc0.ɵɵtemplate(9, IgxChipComponent_div_9_Template, 2, 2, "div", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxChipComponent_ng_template_10_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(12, IgxChipComponent_ng_template_12_Template, 2, 0, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("visibility", ctx.hideBaseElement ? "hidden" : "visible");
        ɵngcc0.ɵɵproperty("igxDrag", ɵngcc0.ɵɵpureFunction1(8, _c79, ctx))("ghostClass", ctx.ghostClass);
        ɵngcc0.ɵɵattribute("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ctx.selectClass(ctx.selected));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.selectIconTemplate);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.removable);
    } }, directives: [IgxDropDirective,
        IgxDragDirective, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxChipComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxChipComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "tabIndex", null);
__decorate([
    Input()
], IgxChipComponent.prototype, "data", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "draggable", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "animateOnRelease", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "hideBaseOnDrag", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "removable", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "removeIcon", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "selectable", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "selectIcon", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "class", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "selected", null);
__decorate([
    Output()
], IgxChipComponent.prototype, "selectedChange", void 0);
__decorate([
    Input()
], IgxChipComponent.prototype, "color", null);
__decorate([
    Output()
], IgxChipComponent.prototype, "onMoveStart", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onMoveEnd", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onRemove", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onClick", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onSelection", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onSelectionDone", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onKeyDown", void 0);
__decorate([
    Output()
], IgxChipComponent.prototype, "onDragEnter", void 0);
__decorate([
    HostBinding('attr.tabIndex')
], IgxChipComponent.prototype, "hostTabIndex", void 0);
__decorate([
    HostBinding('attr.class')
], IgxChipComponent.prototype, "hostClass", null);
__decorate([
    ViewChild('chipArea', { read: IgxDragDirective, static: true })
], IgxChipComponent.prototype, "dragDirective", void 0);
__decorate([
    ViewChild('chipArea', { read: ElementRef, static: true })
], IgxChipComponent.prototype, "chipArea", void 0);
__decorate([
    ViewChild('selectContainer', { read: ElementRef, static: true })
], IgxChipComponent.prototype, "selectContainer", void 0);
__decorate([
    ViewChild('defaultRemoveIcon', { read: TemplateRef, static: true })
], IgxChipComponent.prototype, "defaultRemoveIcon", void 0);
__decorate([
    ViewChild('defaultSelectIcon', { read: TemplateRef, static: true })
], IgxChipComponent.prototype, "defaultSelectIcon", void 0);
IgxChipComponent = __decorate([ __param(3, Optional()), __param(3, Inject(DisplayDensityToken))
], IgxChipComponent);

/**
 * The chip area allows you to perform more complex scenarios with chips that require interaction,
 * like dragging, selection, navigation, etc.
 *
 * @igxModule IgxChipsModule
 *
 * @igxTheme igx-chip-theme
 *
 * @igxKeywords chip area, chip
 *
 * @igxGroup display
 *
 * @example
 * ```html
 * <igx-chips-area>
 *    <igx-chip *ngFor="let chip of chipList" [id]="chip.id">
 *        <span>{{chip.text}}</span>
 *    </igx-chip>
 * </igx-chips-area>
 * ```
 */
let IgxChipsAreaComponent = class IgxChipsAreaComponent {
    constructor(cdr, element, _iterableDiffers) {
        this.cdr = cdr;
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
         * Returns an array of `IgxChipComponent`s.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
         * ```
         */
        this.onReorder = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
         * Fired after the chips area is initialized if there are initially selected chips as well.
         * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onSelection)="selection($event)"></igx-chips-area>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveStart)="moveStart($event)"></igx-chips-area>
         * ```
         */
        this.onMoveStart = new EventEmitter();
        /**
         * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * @example
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveEnd)="moveEnd($event)"></igx-chips-area>
         * ```
         */
        this.onMoveEnd = new EventEmitter();
        this._differ = null;
        this.destroy$ = new Subject();
        this._differ = this._iterableDiffers.find([]).create(null);
    }
    /**
     * @hidden
     * @internal
     */
    get hostClass() {
        const classes = ['igx-chip-area'];
        classes.push(this.class);
        return classes.join(' ');
    }
    /**
     * @hidden
     * @internal
     */
    ngAfterViewInit() {
        // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
        if (this.chipsList.length) {
            const selectedChips = this.chipsList.filter((item) => item.selected);
            if (selectedChips.length) {
                this.onSelection.emit({
                    originalEvent: null,
                    newSelection: selectedChips,
                    owner: this
                });
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngDoCheck() {
        if (this.chipsList) {
            const changes = this._differ.diff(this.chipsList.toArray());
            if (changes) {
                changes.forEachAddedItem((addedChip) => {
                    addedChip.item.onMoveStart.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipMoveStart(args);
                    });
                    addedChip.item.onMoveEnd.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipMoveEnd(args);
                    });
                    addedChip.item.onDragEnter.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipDragEnter(args);
                    });
                    addedChip.item.onKeyDown.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                        this.onChipKeyDown(args);
                    });
                    if (addedChip.item.selectable) {
                        addedChip.item.onSelection.pipe(takeUntil(this.destroy$)).subscribe((args) => {
                            this.onChipSelectionChange(args);
                        });
                    }
                });
                this.modifiedChipsArray = this.chipsList.toArray();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     * @internal
     */
    onChipKeyDown(event) {
        let orderChanged = false;
        const chipsArray = this.chipsList.toArray();
        const dragChipIndex = chipsArray.findIndex((el) => el === event.owner);
        if (event.originalEvent.shiftKey === true) {
            if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                if (orderChanged) {
                    setTimeout(() => {
                        this.chipsList.toArray()[dragChipIndex - 1].chipArea.nativeElement.focus();
                    });
                }
            }
            else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
            }
        }
        else {
            if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                chipsArray[dragChipIndex - 1].chipArea.nativeElement.focus();
            }
            else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                dragChipIndex < chipsArray.length - 1) {
                chipsArray[dragChipIndex + 1].chipArea.nativeElement.focus();
            }
        }
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveStart(event) {
        this.onMoveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onChipMoveEnd(event) {
        this.onMoveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    }
    /**
     * @hidden
     * @internal
     */
    onChipDragEnter(event) {
        const dropChipIndex = this.chipsList.toArray().findIndex((el) => el === event.owner);
        const dragChipIndex = this.chipsList.toArray().findIndex((el) => el === event.dragChip);
        if (dragChipIndex < dropChipIndex) {
            // from the left to right
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
        }
        else {
            // from the right to left
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
        }
    }
    /**
     * @hidden
     * @internal
     */
    positionChipAtIndex(chipIndex, targetIndex, shiftRestLeft, originalEvent) {
        if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
            targetIndex < 0 || this.chipsList.length <= targetIndex) {
            return false;
        }
        const chipsArray = this.chipsList.toArray();
        const result = [];
        for (let i = 0; i < chipsArray.length; i++) {
            if (shiftRestLeft) {
                if (chipIndex <= i && i < targetIndex) {
                    result.push(chipsArray[i + 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
            else {
                if (targetIndex < i && i <= chipIndex) {
                    result.push(chipsArray[i - 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
        }
        this.modifiedChipsArray = result;
        const eventData = {
            chipsArray: this.modifiedChipsArray,
            originalEvent: originalEvent,
            owner: this
        };
        this.onReorder.emit(eventData);
        return true;
    }
    /**
     * @hidden
     * @internal
     */
    onChipSelectionChange(event) {
        let selectedChips = this.chipsList.filter((chip) => chip.selected);
        if (event.selected && !selectedChips.includes(event.owner)) {
            selectedChips.push(event.owner);
        }
        else if (!event.selected && selectedChips.includes(event.owner)) {
            selectedChips = selectedChips.filter((chip) => {
                return chip.id !== event.owner.id;
            });
        }
        this.onSelection.emit({
            originalEvent: event.originalEvent,
            newSelection: selectedChips,
            owner: this
        });
    }
};
IgxChipsAreaComponent.ɵfac = function IgxChipsAreaComponent_Factory(t) { return new (t || IgxChipsAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers)); };
IgxChipsAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxChipsAreaComponent, selectors: [["igx-chips-area"]], contentQueries: function IgxChipsAreaComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxChipComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipsList = _t);
    } }, hostVars: 5, hostBindings: function IgxChipsAreaComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("class", ctx.hostClass);
        ɵngcc0.ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
    } }, inputs: { class: "class", width: "width", height: "height" }, outputs: { onReorder: "onReorder", onSelection: "onSelection", onMoveStart: "onMoveStart", onMoveEnd: "onMoveEnd" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxChipsAreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxChipsAreaComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: IterableDiffers }
];
__decorate([
    Input()
], IgxChipsAreaComponent.prototype, "class", void 0);
__decorate([
    HostBinding('attr.class')
], IgxChipsAreaComponent.prototype, "hostClass", null);
__decorate([
    HostBinding('style.width.px'),
    Input()
], IgxChipsAreaComponent.prototype, "width", void 0);
__decorate([
    HostBinding('style.height.px'),
    Input()
], IgxChipsAreaComponent.prototype, "height", void 0);
__decorate([
    Output()
], IgxChipsAreaComponent.prototype, "onReorder", void 0);
__decorate([
    Output()
], IgxChipsAreaComponent.prototype, "onSelection", void 0);
__decorate([
    Output()
], IgxChipsAreaComponent.prototype, "onMoveStart", void 0);
__decorate([
    Output()
], IgxChipsAreaComponent.prototype, "onMoveEnd", void 0);
__decorate([
    ContentChildren(IgxChipComponent, { descendants: true })
], IgxChipsAreaComponent.prototype, "chipsList", void 0);

let NEXT_ID$g = 0;
var IgxAvatarSize;
(function (IgxAvatarSize) {
    IgxAvatarSize["SMALL"] = "small";
    IgxAvatarSize["MEDIUM"] = "medium";
    IgxAvatarSize["LARGE"] = "large";
})(IgxAvatarSize || (IgxAvatarSize = {}));
var IgxAvatarType;
(function (IgxAvatarType) {
    IgxAvatarType["INITIALS"] = "initials";
    IgxAvatarType["IMAGE"] = "image";
    IgxAvatarType["ICON"] = "icon";
    IgxAvatarType["CUSTOM"] = "custom";
})(IgxAvatarType || (IgxAvatarType = {}));
/**
 * Avatar provides a way to display an image, icon or initials to the user.
 *
 * @igxModule IgxAvatarModule
 *
 * @igxTheme igx-avatar-theme, igx-icon-theme
 *
 * @igxKeywords avatar, profile, picture, initials
 *
 * @igxGroup Layouts
 *
 * @remarks
 *
 * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
 * image, someone's initials or a material icon from the Google Material icon set.
 *
 * @example
 * ```html
 * <igx-avatar initials="MS" roundShape="true" size="large">
 * </igx-avatar>
 * ```
 */
let IgxAvatarComponent = class IgxAvatarComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Returns the `aria-label` attribute of the avatar.
         *
         * @example
         * ```typescript
         * let ariaLabel = this.avatar.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'avatar';
        /**
         * Returns the `role` attribute of the avatar.
         *
         * @example
         * ```typescript
         * let avatarRole = this.avatar.role;
         * ```
         */
        this.role = 'img';
        /**
         * Host `class.igx-avatar` binding.
         *
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-avatar';
        /**
         * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
         *
         * @example
         * ```html
         * <igx-avatar id="my-first-avatar"></igx-avatar>
         * ```
         */
        this.id = `igx-avatar-${NEXT_ID$g++}`;
        /**
         * Sets a round shape to the avatar, if `roundShape` is set to `true`.
         * By default the shape of the avatar is a square.
         *
         * @example
         * ```html
         * <igx-avatar roundShape="true" ></igx-avatar>
         * ```
         */
        this.roundShape = false;
        /**
         * @hidden
         * @internal
         */
        this._size = IgxAvatarSize.SMALL;
    }
    /**
     * Returns the size of the avatar.
     *
     * @example
     * ```typescript
     * let avatarSize = this.avatar.size;
     * ```
     */
    get size() {
        return this._size;
    }
    /**
     * Sets the size  of the avatar.
     * By default, the size is `"small"`. It can be set to `"medium"` or `"large"`.
     *
     * @example
     * ```html
     * <igx-avatar size="large"></igx-avatar>
     * ```
     */
    set size(value) {
        switch (value) {
            case 'small':
            case 'medium':
            case 'large':
                this._size = value;
                break;
            default:
                this._size = 'small';
        }
    }
    /** @hidden @internal */
    get _isSmallSize() {
        return this.size === 'small';
    }
    /** @hidden @internal */
    get _isMediumSize() {
        return this.size === 'medium';
    }
    /** @hidden @internal */
    get _isLargeSize() {
        return this.size === 'large';
    }
    /**
     * Returns the type of the avatar.
     *
     * @example
     * ```typescript
     * let avatarType = this.avatar.type;
     * ```
     */
    get type() {
        if (this.src) {
            return IgxAvatarType.IMAGE;
        }
        if (this.icon) {
            return IgxAvatarType.ICON;
        }
        if (this.initials) {
            return IgxAvatarType.INITIALS;
        }
        return IgxAvatarType.CUSTOM;
    }
    /** @hidden @internal */
    get _isImageType() {
        return this.type === IgxAvatarType.IMAGE;
    }
    /** @hidden @internal */
    get _isIconType() {
        return this.type === IgxAvatarType.ICON;
    }
    /** @hidden @internal */
    get _isInitialsType() {
        return this.type === IgxAvatarType.INITIALS;
    }
    /**
     * Returns the template of the avatar.
     *
     * @hidden
     * @internal
     */
    get template() {
        switch (this.type) {
            case IgxAvatarType.IMAGE:
                return this.imageTemplate;
            case IgxAvatarType.INITIALS:
                return this.initialsTemplate;
            case IgxAvatarType.ICON:
                return this.iconTemplate;
            default:
                return this.defaultTemplate;
        }
    }
    /** @hidden @internal */
    ngOnInit() {
        this.roleDescription = this.getRole();
    }
    /** @hidden @internal */
    getRole() {
        switch (this.type) {
            case IgxAvatarType.IMAGE:
                return 'image avatar';
            case IgxAvatarType.ICON:
                return 'icon avatar';
            case IgxAvatarType.INITIALS:
                return 'initials avatar';
            default:
                return 'custom avatar';
        }
    }
    /**
     * Returns the css url of the image.
     *
     * @hidden
     * @internal
     */
    getSrcUrl() {
        return `url(${this.src})`;
    }
};
IgxAvatarComponent.ɵfac = function IgxAvatarComponent_Factory(t) { return new (t || IgxAvatarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxAvatarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxAvatarComponent, selectors: [["igx-avatar"]], viewQuery: function IgxAvatarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c81, true);
        ɵngcc0.ɵɵstaticViewQuery(_c82, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c83, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c84, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c85, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.image = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.imageTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.initialsTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
    } }, hostVars: 24, hostBindings: function IgxAvatarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.ariaLabel)("role", ctx.role)("id", ctx.id)("aria-roledescription", ctx.roleDescription);
        ɵngcc0.ɵɵstyleProp("color", ctx.color)("background", ctx.bgColor, ɵngcc0.ɵɵdefaultStyleSanitizer);
        ɵngcc0.ɵɵclassProp("igx-avatar", ctx.cssClass)("igx-avatar--rounded", ctx.roundShape)("igx-avatar--small", ctx._isSmallSize)("igx-avatar--medium", ctx._isMediumSize)("igx-avatar--large", ctx._isLargeSize)("igx-avatar--image", ctx._isImageType)("igx-avatar--icon", ctx._isIconType)("igx-avatar--initials", ctx._isInitialsType);
    } }, inputs: { id: "id", roundShape: "roundShape", size: "size", color: "color", bgColor: "bgColor", initials: "initials", icon: "icon", src: "src" }, ngContentSelectors: _c2, decls: 9, vars: 1, consts: [["defaultTemplate", ""], ["imageTemplate", ""], ["initialsTemplate", ""], ["iconTemplate", ""], [4, "ngTemplateOutlet"], [1, "igx-avatar__image"], ["image", ""]], template: function IgxAvatarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxAvatarComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxAvatarComponent_ng_template_2_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxAvatarComponent_ng_template_4_Template, 2, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxAvatarComponent_ng_template_6_Template, 2, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(8, IgxAvatarComponent_ng_container_8_Template, 1, 0, "ng-container", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxIconComponent], encapsulation: 2 });
IgxAvatarComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    ViewChild('image')
], IgxAvatarComponent.prototype, "image", void 0);
__decorate([
    ViewChild('defaultTemplate', { read: TemplateRef, static: true })
], IgxAvatarComponent.prototype, "defaultTemplate", void 0);
__decorate([
    ViewChild('imageTemplate', { read: TemplateRef, static: true })
], IgxAvatarComponent.prototype, "imageTemplate", void 0);
__decorate([
    ViewChild('initialsTemplate', { read: TemplateRef, static: true })
], IgxAvatarComponent.prototype, "initialsTemplate", void 0);
__decorate([
    ViewChild('iconTemplate', { read: TemplateRef, static: true })
], IgxAvatarComponent.prototype, "iconTemplate", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxAvatarComponent.prototype, "ariaLabel", void 0);
__decorate([
    HostBinding('attr.role')
], IgxAvatarComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-avatar')
], IgxAvatarComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.aria-roledescription')
], IgxAvatarComponent.prototype, "roleDescription", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxAvatarComponent.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-avatar--rounded'),
    Input()
], IgxAvatarComponent.prototype, "roundShape", void 0);
__decorate([
    HostBinding('style.color'),
    Input()
], IgxAvatarComponent.prototype, "color", void 0);
__decorate([
    HostBinding('style.background'),
    Input()
], IgxAvatarComponent.prototype, "bgColor", void 0);
__decorate([
    Input()
], IgxAvatarComponent.prototype, "initials", void 0);
__decorate([
    Input()
], IgxAvatarComponent.prototype, "icon", void 0);
__decorate([
    Input()
], IgxAvatarComponent.prototype, "src", void 0);
__decorate([
    Input()
], IgxAvatarComponent.prototype, "size", null);
__decorate([
    HostBinding('class.igx-avatar--small')
], IgxAvatarComponent.prototype, "_isSmallSize", null);
__decorate([
    HostBinding('class.igx-avatar--medium')
], IgxAvatarComponent.prototype, "_isMediumSize", null);
__decorate([
    HostBinding('class.igx-avatar--large')
], IgxAvatarComponent.prototype, "_isLargeSize", null);
__decorate([
    HostBinding('class.igx-avatar--image')
], IgxAvatarComponent.prototype, "_isImageType", null);
__decorate([
    HostBinding('class.igx-avatar--icon')
], IgxAvatarComponent.prototype, "_isIconType", null);
__decorate([
    HostBinding('class.igx-avatar--initials')
], IgxAvatarComponent.prototype, "_isInitialsType", null);
/**
 * @hidden
 */
let IgxAvatarModule = class IgxAvatarModule {
};
IgxAvatarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxAvatarModule });
IgxAvatarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxAvatarModule_Factory(t) { return new (t || IgxAvatarModule)(); }, imports: [[CommonModule, IgxIconModule]] });

/**
 * @hidden
 */
let IgxChipsModule = class IgxChipsModule {
};
IgxChipsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxChipsModule });
IgxChipsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxChipsModule_Factory(t) { return new (t || IgxChipsModule)(); }, imports: [[
            CommonModule,
            IgxRippleModule,
            IgxIconModule,
            IgxButtonModule,
            IgxAvatarModule,
            IgxDragDropModule,
            IgxPrefixModule,
            IgxSuffixModule
        ]] });

/**
 * @hidden
 */
let IgxGridFilteringCellComponent = class IgxGridFilteringCellComponent {
    constructor(cdr, filteringService) {
        this.cdr = cdr;
        this.filteringService = filteringService;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.moreFiltersCount = 0;
        this.filteringService.subscribeToEvents();
    }
    get styleClasses() {
        if (this.column && this.column.selected) {
            return 'igx-grid__filtering-cell--selected';
        }
        return 'igx-grid__filtering-cell';
    }
    ngOnInit() {
        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
    }
    ngAfterViewInit() {
        this.updateFilterCellArea();
    }
    ngDoCheck() {
        this.updateFilterCellArea();
    }
    /**
     * Returns whether a chip with a given index is visible or not.
     */
    isChipVisible(index) {
        const expression = this.expressionsList[index];
        return !!(expression && expression.isVisible);
    }
    /**
     * Updates the filtering cell area.
     */
    updateFilterCellArea() {
        this.expressionsList = this.filteringService.getExpressions(this.column.field);
        this.updateVisibleFilters();
    }
    get template() {
        if (!this.column.filterable) {
            return null;
        }
        if (this.column.filterCellTemplate) {
            return this.column.filterCellTemplate;
        }
        const expressionTree = this.column.filteringExpressionsTree;
        if (!expressionTree || expressionTree.filteringOperands.length === 0) {
            return this.emptyFilter;
        }
        if (this.filteringService.isFilterComplex(this.column.field)) {
            return this.complexFilter;
        }
        return this.defaultFilter;
    }
    /**
     * Gets the context passed to the filter template.
     * @memberof IgxGridFilteringCellComponent
     */
    get context() {
        return { column: this.column };
    }
    /**
     * Chip clicked event handler.
     */
    onChipClicked(expression) {
        if (expression) {
            this.expressionsList.forEach((item) => {
                item.isSelected = (item.expression === expression);
            });
        }
        else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach((item) => {
                item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
        }
        this.filteringService.grid.navigation.performHorizontalScrollToCell(this.column.visibleIndex);
        this.filteringService.filteredColumn = this.column;
        this.filteringService.isFilterRowVisible = true;
        this.filteringService.selectedExpression = expression;
    }
    /**
     * Chip removed event handler.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove);
        this.filteringService.grid.theadRow.nativeElement.focus();
    }
    /**
     * Clears the filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.cdr.detectChanges();
    }
    /**
     * Returns the filtering indicator class.
     */
    filteringIndicatorClass() {
        return {
            [this.baseClass]: !this.isMoreIconHidden(),
            [`${this.baseClass}--hidden`]: this.isMoreIconHidden()
        };
    }
    removeExpression(indexToRemove) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.updateVisibleFilters();
        this.filteringService.filterInternal(this.column.field);
    }
    isMoreIconHidden() {
        return this.filteringService.columnToMoreIconHidden.get(this.column.field);
    }
    updateVisibleFilters() {
        this.expressionsList.forEach((ex) => ex.isVisible = true);
        if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        this.cdr.detectChanges();
        if (this.chipsArea && this.expressionsList.length > 1) {
            const areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            let viewWidth = 0;
            const chipsAreaElements = this.chipsArea.element.nativeElement.children;
            let visibleChipsCount = 0;
            const moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
            for (let index = 0; index < chipsAreaElements.length - 1; index++) {
                if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                    viewWidth += chipsAreaElements[index].offsetWidth;
                    if (index % 2 === 0) {
                        visibleChipsCount++;
                    }
                    else {
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                    }
                }
                else {
                    if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                    this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                    break;
                }
            }
            for (let i = visibleChipsCount; i < this.expressionsList.length; i++) {
                this.expressionsList[i].isVisible = false;
            }
            this.cdr.detectChanges();
        }
    }
};
IgxGridFilteringCellComponent.ɵfac = function IgxGridFilteringCellComponent_Factory(t) { return new (t || IgxGridFilteringCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService)); };
IgxGridFilteringCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridFilteringCellComponent, selectors: [["igx-grid-filtering-cell"]], viewQuery: function IgxGridFilteringCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c86, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c87, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c88, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c89, true, IgxChipsAreaComponent);
        ɵngcc0.ɵɵviewQuery(_c90, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c91, true, IgxChipComponent);
        ɵngcc0.ɵɵviewQuery(_c92, true, IgxChipComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyFilter = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultFilter = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.complexFilter = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipsArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.moreIcon = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ghostChip = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.complexChip = _t.first);
    } }, hostVars: 2, hostBindings: function IgxGridFilteringCellComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
    } }, inputs: { column: "column" }, decls: 7, vars: 2, consts: [["emptyFilter", ""], ["defaultFilter", ""], ["complexFilter", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-filtering-chips"], ["tabIndex", "-1", 3, "displayDensity", "click"], ["ghostChip", ""], ["igxPrefix", ""], ["chipsArea", ""], [4, "ngFor", "ngForOf"], [3, "ngClass", "click"], ["moreIcon", ""], [3, "value"], ["tabIndex", "-1", 3, "removable", "displayDensity", "click", "onRemove", 4, "ngIf"], ["class", "igx-filtering-chips__connector", 4, "ngIf"], ["tabIndex", "-1", 3, "removable", "displayDensity", "click", "onRemove"], ["igxPrefix", "", "fontSet", "filtering-icons", 3, "name"], ["label", ""], [1, "igx-filtering-chips__connector"], ["tabIndex", "-1", 3, "removable", "displayDensity", "onRemove"], ["complexChip", ""]], template: function IgxGridFilteringCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridFilteringCellComponent_ng_template_0_Template, 7, 6, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridFilteringCellComponent_ng_template_2_Template, 8, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridFilteringCellComponent_ng_template_4_Template, 6, 3, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridFilteringCellComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: function () { return [ɵngcc2.NgTemplateOutlet, IgxChipsAreaComponent,
        IgxChipComponent,
        IgxIconComponent,
        IgxPrefixDirective, ɵngcc2.NgForOf, ɵngcc2.NgClass, IgxBadgeComponent, ɵngcc2.NgIf]; }, encapsulation: 2, changeDetection: 0 });
IgxGridFilteringCellComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: IgxFilteringService }
];
__decorate([
    Input()
], IgxGridFilteringCellComponent.prototype, "column", void 0);
__decorate([
    ViewChild('emptyFilter', { read: TemplateRef, static: true })
], IgxGridFilteringCellComponent.prototype, "emptyFilter", void 0);
__decorate([
    ViewChild('defaultFilter', { read: TemplateRef, static: true })
], IgxGridFilteringCellComponent.prototype, "defaultFilter", void 0);
__decorate([
    ViewChild('complexFilter', { read: TemplateRef, static: true })
], IgxGridFilteringCellComponent.prototype, "complexFilter", void 0);
__decorate([
    ViewChild('chipsArea', { read: IgxChipsAreaComponent })
], IgxGridFilteringCellComponent.prototype, "chipsArea", void 0);
__decorate([
    ViewChild('moreIcon', { read: ElementRef })
], IgxGridFilteringCellComponent.prototype, "moreIcon", void 0);
__decorate([
    ViewChild('ghostChip', { read: IgxChipComponent })
], IgxGridFilteringCellComponent.prototype, "ghostChip", void 0);
__decorate([
    ViewChild('complexChip', { read: IgxChipComponent })
], IgxGridFilteringCellComponent.prototype, "complexChip", void 0);
__decorate([
    HostBinding('class')
], IgxGridFilteringCellComponent.prototype, "styleClasses", null);

var IgxGridHeaderGroupComponent_1;
const Z_INDEX = 9999;
/**
 * @hidden
 */
let IgxGridHeaderGroupComponent = IgxGridHeaderGroupComponent_1 = class IgxGridHeaderGroupComponent {
    constructor(cdr, gridAPI, element, colResizingService, filteringService) {
        this.cdr = cdr;
        this.gridAPI = gridAPI;
        this.element = element;
        this.colResizingService = colResizingService;
        this.filteringService = filteringService;
    }
    get gridRowSpan() {
        return this.column.gridRowSpan;
    }
    get gridColumnSpan() {
        return this.column.gridColumnSpan;
    }
    get rowEnd() {
        return this.column.rowEnd;
    }
    get colEnd() {
        return this.column.colEnd;
    }
    get rowStart() {
        return this.column.rowStart;
    }
    get colStart() {
        return this.column.colStart;
    }
    get active() {
        const node = this.grid.navigation.activeNode;
        return node && !this.column.columnGroup ?
            node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
    }
    get activeGroup() {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === -1 && node.column === this.column.visibleIndex && node.level === this.column.level : false;
    }
    /**
     * Gets the width of the header group.
     * @memberof IgxGridHeaderGroupComponent
     */
    get width() {
        return this.grid.getHeaderGroupWidth(this.column);
    }
    /**
     * Gets the style classes of the header group.
     * @memberof IgxGridHeaderGroupComponent
     */
    get styleClasses() {
        const defaultClasses = [
            'igx-grid__thead-item',
            this.column.headerGroupClasses
        ];
        const classList = {
            'igx-grid__th--pinned': this.isPinned,
            'igx-grid__th--pinned-last': this.isLastPinned,
            'igx-grid__th--pinned-first': this.isFirstPinned,
            'igx-grid__drag-col-header': this.isHeaderDragged,
            'igx-grid__th--filtering': this.isFiltered
        };
        for (const className of Object.keys(classList)) {
            if (classList[className]) {
                defaultClasses.push(className);
            }
        }
        return defaultClasses.join(' ');
    }
    /**
     * @hidden
     */
    get zIndex() {
        if (!this.column.pinned) {
            return null;
        }
        return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
    }
    /**
     * Gets the grid of the header group.
     * @memberof IgxGridHeaderGroupComponent
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * Gets whether the header group belongs to a column that is filtered.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isFiltered() {
        return this.filteringService.filteredColumn === this.column;
    }
    /**
     * Gets whether the header group is stored in the last column in the pinned area.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isLastPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
    }
    /**
     * Gets whether the header group is stored in the first column of the right pinned area.
     */
    get isFirstPinned() {
        return !this.grid.hasColumnLayouts ? this.column.isFirstPinned : false;
    }
    get groupDisplayStyle() {
        return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
    }
    /**
     * Gets whether the header group is stored in a pinned column.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isPinned() {
        return this.column.pinned;
    }
    /**
     * Gets whether the header group belongs to a column that is moved.
     * @memberof IgxGridHeaderGroupComponent
     */
    get isHeaderDragged() {
        return this.grid.draggedColumn === this.column;
    }
    /**
     * @hidden
     */
    get hasLastPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isLastPinned);
    }
    /**
     * @hidden
     */
    get hasFirstPinnedChildColumn() {
        return this.column.allChildren.some(child => child.isFirstPinned);
    }
    /**
     * @hidden
     */
    get selectable() {
        const selectableChildren = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup);
        return this.grid.columnSelection !== GridSelectionMode.none &&
            this.column.applySelectableClass
            && !this.selected && selectableChildren.length > 0
            && !this.grid.filteringService.isFilterRowVisible;
    }
    /**
     * @hidden
     */
    get selected() {
        return this.column.selected;
    }
    /**
     * @hidden
     */
    get height() {
        return this.element.nativeElement.getBoundingClientRect().height;
    }
    /**
     * @hidden
     */
    get columnTitle() {
        return this.column.elementRef.nativeElement.getAttribute('title') || this.column.header;
    }
    /**
     * @hidden
     */
    groupClicked(event) {
        const columnsToSelect = this.column.allChildren.filter(c => !c.hidden && c.selectable && !c.columnGroup).map(c => c.field);
        if (this.grid.columnSelection !== GridSelectionMode.none
            && columnsToSelect.length > 0 && !this.grid.filteringService.isFilterRowVisible) {
            const clearSelection = this.grid.columnSelection === GridSelectionMode.single || !event.ctrlKey;
            const rangeSelection = this.grid.columnSelection === GridSelectionMode.multiple && event.shiftKey;
            if (!this.selected) {
                this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
            }
            else {
                const selectedFields = this.grid.selectionService.getSelectedColumns();
                if ((selectedFields.length === columnsToSelect.length) && selectedFields.every(el => columnsToSelect.includes(el))
                    || !clearSelection) {
                    this.grid.selectionService.deselectColumns(columnsToSelect, event);
                }
                else {
                    this.grid.selectionService.selectColumns(columnsToSelect, clearSelection, rangeSelection, event);
                }
            }
        }
    }
    /**
     * @hidden
     */
    toggleExpandState(event) {
        event.stopPropagation();
        this.column.expanded = !this.column.expanded;
    }
    /**
     * @hidden
     */
    onMouseDown(event) {
        // hack for preventing text selection in IE and Edge while dragging the resizer
        event.preventDefault();
    }
    /**
     * @hidden
     */
    pointerdown(event) {
        event.stopPropagation();
        this.activate();
        this.grid.theadRow.nativeElement.focus();
    }
    /*
     * This method is necessary due to some specifics related with implementation of column moving
     * @hidden
     */
    activate() {
        this.grid.navigation.activeNode = this.activeNode;
        this.grid.theadRow.nativeElement.focus();
    }
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @hidden
     */
    onPinterEnter() {
        this.column.applySelectableClass = true;
    }
    /**
     * @hidden
     */
    onPointerLeave() {
        this.column.applySelectableClass = false;
    }
    get activeNode() {
        return { row: -1, column: this.column.visibleIndex, level: this.column.level,
            mchCache: { level: this.column.level, visibleIndex: this.column.visibleIndex },
            layout: this.column.columnLayoutChild ? {
                rowStart: this.column.rowStart,
                colStart: this.column.colStart,
                rowEnd: this.column.rowEnd,
                colEnd: this.column.colEnd,
                columnVisibleIndex: this.column.visibleIndex
            } : null };
    }
};
IgxGridHeaderGroupComponent.ɵfac = function IgxGridHeaderGroupComponent_Factory(t) { return new (t || IgxGridHeaderGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService)); };
IgxGridHeaderGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridHeaderGroupComponent, selectors: [["igx-grid-header-group"]], viewQuery: function IgxGridHeaderGroupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxGridHeaderComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxGridFilteringCellComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxGridHeaderGroupComponent_1, true, IgxGridHeaderGroupComponent_1);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filterCell = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, hostVars: 24, hostBindings: function IgxGridHeaderGroupComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mousedown", function IgxGridHeaderGroupComponent_mousedown_HostBindingHandler($event) { return ctx.onMouseDown($event); })("pointerdown", function IgxGridHeaderGroupComponent_pointerdown_HostBindingHandler($event) { return ctx.pointerdown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
        ɵngcc0.ɵɵstyleProp("-ms-grid-row-span", ctx.gridRowSpan)("-ms-grid-column-span", ctx.gridColumnSpan)("grid-row-end", ctx.rowEnd)("grid-column-end", ctx.colEnd)("-ms-grid-row", ctx.rowStart)("grid-row-start", ctx.rowStart)("-ms-grid-column", ctx.colStart)("grid-column-start", ctx.colStart)("z-index", ctx.zIndex)("display", ctx.groupDisplayStyle);
        ɵngcc0.ɵɵclassProp("igx-grid__th--active", ctx.active);
    } }, inputs: { column: "column", gridID: "gridID" }, decls: 7, vars: 3, consts: [[4, "ngIf"], ["defaultColumn", ""], ["defaultCollapseIndicator", ""], ["class", "igx-grid__th-drop-indicator-left", 4, "ngIf"], [1, "igx-grid__thead-group", "igx-grid__mrl-block", 3, "ngClass", "ngStyle"], [4, "ngFor", "ngForOf"], ["class", "igx-grid__th-drop-indicator-right", 4, "ngIf"], [1, "igx-grid__th-drop-indicator-left"], ["class", "igx-grid__thead-subgroup", 3, "column", "gridID", "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop", 4, "ngIf"], [1, "igx-grid__thead-subgroup", 3, "column", "gridID", "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop"], [1, "igx-grid__th-drop-indicator-right"], [1, "igx-grid__th-group-title"], ["role", "columnheader", 1, "igx-grid__thead-title", 3, "ngClass", "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop", "pointerdown", "click", "pointerenter", "pointerleave"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-grid__thead-group"], [1, "igx-grid__th-expander", 3, "click"], ["class", "igx-grid__thead-subgroup", 3, "column", "gridID", "min-width", "flex-basis", 4, "ngIf"], [1, "igx-grid__thead-subgroup", 3, "column", "gridID"], [3, "igxColumnMovingDrag", "ghostHost", "igxColumnMovingDrop", "gridID", "column", "pointerdown"], [3, "column", 4, "ngIf"], ["class", "igx-grid__th-resize-handle", 3, "igxResizeHandle", "cursor", 4, "ngIf"], [3, "column"], [1, "igx-grid__th-resize-handle", 3, "igxResizeHandle"]], template: function IgxGridHeaderGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridHeaderGroupComponent_ng_container_0_Template, 5, 13, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridHeaderGroupComponent_ng_template_1_Template, 2, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxGridHeaderGroupComponent_ng_template_3_Template, 2, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxGridHeaderGroupComponent_ng_container_5_Template, 8, 24, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(6, IgxGridHeaderGroupComponent_ng_container_6_Template, 6, 10, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.hasColumnLayouts && ctx.column.columnGroup);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.grid.hasColumnLayouts && ctx.column.columnGroup);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.column.columnGroup);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgStyle, ɵngcc2.NgForOf, IgxGridHeaderGroupComponent,
        IgxColumnMovingDragDirective,
        IgxColumnMovingDropDirective,
        IgxIconComponent, ɵngcc2.NgTemplateOutlet, IgxGridHeaderComponent,
        IgxGridFilteringCellComponent,
        IgxResizeHandleDirective]; }, encapsulation: 2, changeDetection: 0 });
IgxGridHeaderGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: IgxColumnResizingService },
    { type: IgxFilteringService }
];
__decorate([
    HostBinding('style.-ms-grid-row-span')
], IgxGridHeaderGroupComponent.prototype, "gridRowSpan", null);
__decorate([
    HostBinding('style.-ms-grid-column-span')
], IgxGridHeaderGroupComponent.prototype, "gridColumnSpan", null);
__decorate([
    HostBinding('style.grid-row-end')
], IgxGridHeaderGroupComponent.prototype, "rowEnd", null);
__decorate([
    HostBinding('style.grid-column-end')
], IgxGridHeaderGroupComponent.prototype, "colEnd", null);
__decorate([
    HostBinding('style.-ms-grid-row'),
    HostBinding('style.grid-row-start')
], IgxGridHeaderGroupComponent.prototype, "rowStart", null);
__decorate([
    HostBinding('style.-ms-grid-column'),
    HostBinding('style.grid-column-start')
], IgxGridHeaderGroupComponent.prototype, "colStart", null);
__decorate([
    Input()
], IgxGridHeaderGroupComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxGridHeaderGroupComponent.prototype, "gridID", void 0);
__decorate([
    HostBinding('class.igx-grid__th--active')
], IgxGridHeaderGroupComponent.prototype, "active", null);
__decorate([
    ViewChild(IgxGridHeaderComponent)
], IgxGridHeaderGroupComponent.prototype, "headerCell", void 0);
__decorate([
    ViewChild(IgxGridFilteringCellComponent)
], IgxGridHeaderGroupComponent.prototype, "filterCell", void 0);
__decorate([
    ViewChildren(forwardRef(() => IgxGridHeaderGroupComponent_1), { read: IgxGridHeaderGroupComponent_1 })
], IgxGridHeaderGroupComponent.prototype, "children", void 0);
__decorate([
    HostBinding('class')
], IgxGridHeaderGroupComponent.prototype, "styleClasses", null);
__decorate([
    HostBinding('style.z-index')
], IgxGridHeaderGroupComponent.prototype, "zIndex", null);
__decorate([
    HostBinding('style.display')
], IgxGridHeaderGroupComponent.prototype, "groupDisplayStyle", null);
__decorate([
    HostListener('mousedown', ['$event'])
], IgxGridHeaderGroupComponent.prototype, "onMouseDown", null);
__decorate([
    HostListener('pointerdown', ['$event'])
], IgxGridHeaderGroupComponent.prototype, "pointerdown", null);

const DateRangePickerResourceStringsEN = {
    igx_date_range_picker_date_separator: 'to'
};

const GridResourceStringsEN = {
    igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
    igx_grid_emptyFilteredGrid_message: 'No records found.',
    igx_grid_emptyGrid_message: 'Grid has no data.',
    igx_grid_filter: 'Filter',
    igx_grid_filter_row_close: 'Close',
    igx_grid_filter_row_reset: 'Reset',
    igx_grid_filter_row_placeholder: 'Add filter value',
    igx_grid_filter_row_boolean_placeholder: 'All',
    igx_grid_filter_row_date_placeholder: 'Pick up date',
    igx_grid_filter_operator_and: 'And',
    igx_grid_filter_operator_or: 'Or',
    igx_grid_complex_filter: 'Complex Filter',
    igx_grid_filter_contains: 'Contains',
    igx_grid_filter_doesNotContain: 'Does Not Contain',
    igx_grid_filter_startsWith: 'Starts With',
    igx_grid_filter_endsWith: 'Ends With',
    igx_grid_filter_equals: 'Equals',
    igx_grid_filter_doesNotEqual: 'Does Not Equal',
    igx_grid_filter_empty: 'Empty',
    igx_grid_filter_notEmpty: 'Not Empty',
    igx_grid_filter_null: 'Null',
    igx_grid_filter_notNull: 'Not Null',
    igx_grid_filter_before: 'Before',
    igx_grid_filter_after: 'After',
    igx_grid_filter_today: 'Today',
    igx_grid_filter_yesterday: 'Yesterday',
    igx_grid_filter_thisMonth: 'This Month',
    igx_grid_filter_lastMonth: 'Last Month',
    igx_grid_filter_nextMonth: 'Next Month',
    igx_grid_filter_thisYear: 'This Year',
    igx_grid_filter_lastYear: 'Last Year',
    igx_grid_filter_nextYear: 'Next Year',
    igx_grid_filter_greaterThan: 'Greater Than',
    igx_grid_filter_lessThan: 'Less Than',
    igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
    igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
    igx_grid_filter_true: 'True',
    igx_grid_filter_false: 'False',
    igx_grid_filter_all: 'All',
    igx_grid_filter_condition_placeholder: 'Select filter',
    igx_grid_summary_count: 'Count',
    igx_grid_summary_min: 'Min',
    igx_grid_summary_max: 'Max',
    igx_grid_summary_sum: 'Sum',
    igx_grid_summary_average: 'Avg',
    igx_grid_summary_earliest: 'Earliest',
    igx_grid_summary_latest: 'Latest',
    igx_grid_excel_filter_moving_left: 'move left',
    igx_grid_excel_filter_moving_left_short: 'left',
    igx_grid_excel_filter_moving_right: 'move right',
    igx_grid_excel_filter_moving_right_short: 'right',
    igx_grid_excel_filter_moving_header: 'move',
    igx_grid_excel_filter_sorting_asc: 'ascending',
    igx_grid_excel_filter_sorting_asc_short: 'asc',
    igx_grid_excel_filter_sorting_desc: 'descending',
    igx_grid_excel_filter_sorting_desc_short: 'desc',
    igx_grid_excel_filter_sorting_header: 'sort',
    igx_grid_excel_filter_clear: 'Clear column filters',
    igx_grid_excel_custom_dialog_add: 'add filter',
    igx_grid_excel_custom_dialog_clear: 'Clear filter',
    igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
    igx_grid_excel_cancel: 'cancel',
    igx_grid_excel_apply: 'apply',
    igx_grid_excel_search_placeholder: 'Search',
    igx_grid_excel_select_all: 'Select All',
    igx_grid_excel_blanks: '(Blanks)',
    igx_grid_excel_hide: 'Hide column',
    igx_grid_excel_show: 'Show column',
    igx_grid_excel_pin: 'Pin column',
    igx_grid_excel_unpin: 'Unpin column',
    igx_grid_excel_select: 'Select column',
    igx_grid_excel_text_filter: 'Text filter',
    igx_grid_excel_number_filter: 'Number filter',
    igx_grid_excel_date_filter: 'Date filter',
    igx_grid_excel_boolean_filter: 'Boolean filter',
    igx_grid_excel_custom_filter: 'Custom filter...',
    igx_grid_advanced_filter_title: 'Advanced Filtering',
    igx_grid_advanced_filter_and_group: '"And" Group',
    igx_grid_advanced_filter_or_group: '"Or" Group',
    igx_grid_advanced_filter_end_group: 'End Group',
    igx_grid_advanced_filter_create_and_group: 'Create "And" Group',
    igx_grid_advanced_filter_create_or_group: 'Create "Or" Group',
    igx_grid_advanced_filter_and_label: 'and',
    igx_grid_advanced_filter_or_label: 'or',
    igx_grid_advanced_filter_add_condition: 'Condition',
    igx_grid_advanced_filter_ungroup: 'Ungroup',
    igx_grid_advanced_filter_delete: 'Delete',
    igx_grid_advanced_filter_delete_filters: 'Delete filters',
    igx_grid_advanced_filter_initial_text: 'Start with creating a group of conditions linked with "And" or "Or"',
    igx_grid_advanced_filter_column_placeholder: 'Select column',
    igx_grid_advanced_filter_value_placeholder: 'Value',
    igx_grid_pinned_row_indicator: 'Pinned'
};

const TimePickerResourceStringsEN = {
    igx_time_picker_ok: 'OK',
    igx_time_picker_cancel: 'Cancel'
};

const PaginatorResourceStringsEN = {
    igx_paginator_label: 'Items per page',
    igx_paginator_pager_text: 'of',
    igx_paginator_first_page_button_text: 'Go to first page',
    igx_paginator_previous_page_button_text: 'Previous page',
    igx_paginator_last_page_button_text: 'Go to last page',
    igx_paginator_next_page_button_text: 'Next page',
};

const CarouselResourceStringsEN = {
    igx_carousel_of: 'of'
};

/**
 * @hidden
 */
const CurrentResourceStrings = {
    GridResStrings: cloneValue(GridResourceStringsEN),
    PaginatorResStrings: cloneValue(PaginatorResourceStringsEN),
    TimePickerResStrings: cloneValue(TimePickerResourceStringsEN),
    DateRangePickerResStrings: cloneValue(DateRangePickerResourceStringsEN),
    CarouselResStrings: cloneValue(CarouselResourceStringsEN),
};
function updateResourceStrings(currentStrings, newStrings) {
    for (const key of Object.keys(newStrings)) {
        if (key in currentStrings) {
            currentStrings[key] = newStrings[key];
        }
    }
}
/**
 * Changes the resource strings for all components in the application
 * ```
 * @param resourceStrings to be applied
 */
function changei18n(resourceStrings) {
    for (const key of Object.keys(CurrentResourceStrings)) {
        updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
    }
}
/**
 * Returns current resource strings for all components
 */
function getCurrentResourceStrings() {
    return Object.assign(Object.assign({}, CurrentResourceStrings.GridResStrings), CurrentResourceStrings.TimePickerResStrings);
}

/** @hidden */
let IgxGridSummaryService = class IgxGridSummaryService {
    constructor() {
        this.summaryCacheMap = new Map();
        this.rootSummaryID = 'igxGridRootSummary';
        this.summaryHeight = 0;
        this.maxSummariesLenght = 0;
        this.groupingExpressions = [];
        this.retriggerRootPipe = 0;
        this.deleteOperation = false;
    }
    recalculateSummaries() {
        this.resetSummaryHeight();
        this.grid.notifyChanges(true);
    }
    clearSummaryCache(args) {
        if (!this.summaryCacheMap.size) {
            return;
        }
        if (!args) {
            this.summaryCacheMap.clear();
            if (this.grid && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
            return;
        }
        if (args.data) {
            const rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
            this.removeSummaries(rowID);
        }
        if (args.rowID !== undefined && args.rowID !== null) {
            let columnName = args.cellID ? this.grid.columnList.find(col => col.index === args.cellID.columnID).field : undefined;
            if (columnName && this.grid.rowEditable) {
                return;
            }
            const isGroupedColumn = this.grid.groupingExpressions &&
                this.grid.groupingExpressions.map(expr => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && isGroupedColumn) {
                columnName = undefined;
            }
            this.removeSummaries(args.rowID, columnName);
        }
    }
    removeSummaries(rowID, columnName) {
        this.deleteSummaryCache(this.rootSummaryID, columnName);
        if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
            return;
        }
        if (this.isTreeGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                // TODO: this.removeChildRowSummaries(rowID, columnName);
                this.summaryCacheMap.clear();
                return;
            }
            this.removeAllTreeGridSummaries(rowID, columnName);
        }
        else if (this.isHierarchicalGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                this.summaryCacheMap.clear();
            }
        }
        else {
            const summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
            summaryIds.forEach(id => {
                this.deleteSummaryCache(id, columnName);
            });
        }
    }
    removeSummariesCachePerColumn(columnName) {
        this.summaryCacheMap.forEach((cache) => {
            if (cache.get(columnName)) {
                cache.delete(columnName);
            }
        });
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    calcMaxSummaryHeight() {
        if (this.summaryHeight) {
            return this.summaryHeight;
        }
        if (!this.grid.data) {
            return this.summaryHeight = 0;
        }
        let maxSummaryLength = 0;
        this.grid.columnList.filter((col) => col.hasSummary && !col.hidden).forEach((column) => {
            const getCurrentSummaryColumn = column.summaries.operate([], [], column.field).length;
            if (getCurrentSummaryColumn) {
                if (maxSummaryLength < getCurrentSummaryColumn) {
                    maxSummaryLength = getCurrentSummaryColumn;
                }
            }
        });
        this.maxSummariesLenght = maxSummaryLength;
        this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
        return this.summaryHeight;
    }
    calculateSummaries(rowID, data) {
        let rowSummaries = this.summaryCacheMap.get(rowID);
        if (!rowSummaries) {
            rowSummaries = new Map();
            this.summaryCacheMap.set(rowID, rowSummaries);
        }
        if (!this.hasSummarizedColumns || !data) {
            return rowSummaries;
        }
        this.grid.columnList.filter(col => col.hasSummary).forEach((column) => {
            if (!rowSummaries.get(column.field)) {
                rowSummaries.set(column.field, column.summaries.operate(data.map(r => r[column.field]), data, column.field));
            }
        });
        return rowSummaries;
    }
    resetSummaryHeight() {
        this.summaryHeight = 0;
        this.grid._summaryPipeTrigger++;
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    }
    updateSummaryCache(groupingArgs) {
        if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
            return;
        }
        if (this.groupingExpressions.length === 0) {
            this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
            return;
        }
        if (groupingArgs.length === 0) {
            this.groupingExpressions = [];
            this.clearSummaryCache();
            return;
        }
        this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
        this.groupingExpressions = groupingArgs.expressions.map(record => record.fieldName);
    }
    get hasSummarizedColumns() {
        const summarizedColumns = this.grid.columnList.filter(col => col.hasSummary && !col.hidden);
        return summarizedColumns.length > 0;
    }
    deleteSummaryCache(id, columnName) {
        if (this.summaryCacheMap.get(id)) {
            const filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                this.grid.filteringExpressionsTree.filteringOperands.map((expr) => expr.fieldName).indexOf(columnName) !== -1;
            if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                this.summaryCacheMap.get(id).delete(columnName);
            }
            else {
                this.summaryCacheMap.delete(id);
            }
            if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        }
    }
    getSummaryID(rowID, groupingExpressions) {
        if (groupingExpressions.length === 0) {
            return [];
        }
        const summaryIDs = [];
        let data = this.grid.data;
        if (this.grid.transactions.enabled) {
            data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
        }
        const rowData = this.grid.primaryKey ? data.find(rec => rec[this.grid.primaryKey] === rowID) : rowID;
        let id = '{ ';
        groupingExpressions.forEach(expr => {
            id += `'${expr.fieldName}': '${rowData[expr.fieldName]}'`;
            summaryIDs.push(id.concat(' }'));
            id += ', ';
        });
        return summaryIDs;
    }
    removeAllTreeGridSummaries(rowID, columnName) {
        let row = this.grid.records.get(rowID);
        if (!row) {
            return;
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowID = row.rowID;
            this.deleteSummaryCache(rowID, columnName);
            row = row.parent;
        }
    }
    // TODO: remove only deleted rows
    removeChildRowSummaries(rowID, columnName) {
    }
    compareGroupingExpressions(current, groupingArgs) {
        const newExpressions = groupingArgs.expressions.map(record => record.fieldName);
        const removedCols = groupingArgs.ungroupedColumns;
        if (current.length <= newExpressions.length) {
            const newExpr = newExpressions.slice(0, current.length).toString();
            if (current.toString() !== newExpr) {
                this.clearSummaryCache();
            }
        }
        else {
            const currExpr = current.slice(0, newExpressions.length).toString();
            if (currExpr !== newExpressions.toString()) {
                this.clearSummaryCache();
                return;
            }
            removedCols.map(col => col.field).forEach(colName => {
                this.summaryCacheMap.forEach((cache, id) => {
                    if (id.indexOf(colName) !== -1) {
                        this.summaryCacheMap.delete(id);
                    }
                });
            });
        }
    }
    get isTreeGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
    }
    get isHierarchicalGrid() {
        return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
};
IgxGridSummaryService.ɵfac = function IgxGridSummaryService_Factory(t) { return new (t || IgxGridSummaryService)(); };
IgxGridSummaryService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridSummaryService, factory: IgxGridSummaryService.ɵfac });

let IgxSummaryCellComponent = class IgxSummaryCellComponent {
    constructor(element) {
        this.element = element;
        this.firstCellIndentation = 0;
        this.hasSummary = false;
    }
    get visibleColumnIndex() {
        return this.column.visibleIndex;
    }
    get describeby() {
        return `Summary_${this.column.field}`;
    }
    get attrCellID() {
        return `${this.grid.id}_${this.rowIndex}_${this.visibleColumnIndex}`;
    }
    activate() {
        this.grid.navigation.activeNode = { row: this.rowIndex, column: this.visibleColumnIndex };
        this.grid.cdr.detectChanges();
    }
    get selectionNode() {
        return {
            row: this.rowIndex,
            column: this.column.columnLayoutChild ? this.column.parent.visibleIndex : this.visibleColumnIndex,
            isSummaryRow: true
        };
    }
    get width() {
        return this.column.getCellWidth();
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    get columnDatatype() {
        return this.column.dataType;
    }
    get itemHeight() {
        return this.column.grid.defaultSummaryHeight;
    }
    /**
     * @hidden
     */
    get grid() {
        return this.column.grid;
    }
    translateSummary(summary) {
        return this.grid.resourceStrings[`igx_grid_summary_${summary.key}`] || summary.label;
    }
};
IgxSummaryCellComponent.ɵfac = function IgxSummaryCellComponent_Factory(t) { return new (t || IgxSummaryCellComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSummaryCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSummaryCellComponent, selectors: [["igx-grid-summary-cell"]], hostVars: 6, hostBindings: function IgxSummaryCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerdown", function IgxSummaryCellComponent_pointerdown_HostBindingHandler() { return ctx.activate(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-visibleIndex", ctx.visibleColumnIndex)("aria-describedby", ctx.describeby)("id", ctx.attrCellID)("data-rowIndex", ctx.rowIndex);
        ɵngcc0.ɵɵclassProp("igx-grid-summary--active", ctx.active);
    } }, inputs: { firstCellIndentation: "firstCellIndentation", hasSummary: "hasSummary", summaryResults: "summaryResults", column: "column", density: "density", active: "active", rowIndex: "rowIndex" }, decls: 1, vars: 1, consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [1, "igx-grid-summary__item"], [1, "igx-grid-summary__label", 3, "title"], [1, "igx-grid-summary__result", 3, "title"], [1, "igx-grid__tree-grouping-indicator", 2, "visibility", "hidden"], ["indicator", ""], ["fontSet", "material"]], template: function IgxSummaryCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxSummaryCellComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummary);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxIconComponent], pipes: [IgxDecimalPipeComponent,
        IgxDatePipeComponent], encapsulation: 2, changeDetection: 0 });
IgxSummaryCellComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], IgxSummaryCellComponent.prototype, "summaryResults", void 0);
__decorate([
    Input()
], IgxSummaryCellComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxSummaryCellComponent.prototype, "firstCellIndentation", void 0);
__decorate([
    Input()
], IgxSummaryCellComponent.prototype, "hasSummary", void 0);
__decorate([
    Input()
], IgxSummaryCellComponent.prototype, "density", void 0);
__decorate([
    Input(),
    HostBinding('class.igx-grid-summary--active')
], IgxSummaryCellComponent.prototype, "active", void 0);
__decorate([
    Input(),
    HostBinding('attr.data-rowIndex')
], IgxSummaryCellComponent.prototype, "rowIndex", void 0);
__decorate([
    HostBinding('attr.data-visibleIndex')
], IgxSummaryCellComponent.prototype, "visibleColumnIndex", null);
__decorate([
    HostBinding('attr.aria-describedby')
], IgxSummaryCellComponent.prototype, "describeby", null);
__decorate([
    HostBinding('attr.id')
], IgxSummaryCellComponent.prototype, "attrCellID", null);
__decorate([
    HostListener('pointerdown')
], IgxSummaryCellComponent.prototype, "activate", null);

let IgxSummaryRowComponent = class IgxSummaryRowComponent {
    constructor(gridAPI, element, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        this.firstCellIndentation = -1;
    }
    get dataRowIndex() {
        return this.index;
    }
    get minHeight() {
        return this.grid.summaryService.calcMaxSummaryHeight() - 1;
    }
    get summaryCells() {
        const res = new QueryList();
        if (!this._summaryCells) {
            return res;
        }
        const cList = this._summaryCells.filter(c => c.nativeElement.isConnected);
        res.reset(cList);
        return res;
    }
    set summaryCells(cells) { }
    ngDoCheck() {
        this.cdr.markForCheck();
    }
    get grid() {
        return this.gridAPI.grid;
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    getColumnSummaries(columnName) {
        if (!this.summaries.get(columnName)) {
            return [];
        }
        return this.summaries.get(columnName);
    }
    /**
     * @hidden
     * @internal
     */
    isCellActive(visibleColumnIndex) {
        const node = this.grid.navigation.activeNode;
        return node ? node.row === this.index && node.column === visibleColumnIndex : false;
    }
    /**
     * @hidden
     */
    get pinnedColumns() {
        return this.grid.pinnedColumns;
    }
    /**
     * @hidden
     */
    get unpinnedColumns() {
        return this.grid.unpinnedColumns;
    }
    getContext(row) {
        return {
            $implicit: row
        };
    }
};
IgxSummaryRowComponent.ɵfac = function IgxSummaryRowComponent_Factory(t) { return new (t || IgxSummaryRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxSummaryRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSummaryRowComponent, selectors: [["igx-grid-summary-row"]], viewQuery: function IgxSummaryRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c19, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵviewQuery(IgxSummaryCellComponent, true, IgxSummaryCellComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDirRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._summaryCells = _t);
    } }, hostVars: 1, hostBindings: function IgxSummaryRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-rowIndex", ctx.dataRowIndex);
    } }, inputs: { firstCellIndentation: "firstCellIndentation", summaries: "summaries", gridID: "gridID", index: "index" }, features: [ɵngcc0.ɵɵProvidersFeature([IgxForOfSyncService])], decls: 3, vars: 1, consts: [[4, "ngIf"], ["summaryCellTemplate", ""], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForScrollOrientation", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["igxDirRef", ""], [1, "igx-grid__summaries-patch"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "cell", 1, "igx-grid-summary", "igx-grid-summary--fw", 3, "column", "rowIndex", "firstCellIndentation", "summaryResults", "hasSummary", "density", "active"], ["role", "cell", "class", "igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned", 3, "igx-grid-summary--cosy", "igx-grid-summary--compact", "igx-grid-summary--empty", "igx-grid-summary--pinned-first", "igx-grid-summary--pinned-last", "column", "firstCellIndentation", "rowIndex", "summaryResults", "hasSummary", "density", "active", "max-height", "min-height", "min-width", "max-width", "flex-basis", "left", 4, "ngFor", "ngForOf"], ["role", "cell", 1, "igx-grid-summary", "igx-grid-summary--fw", "igx-grid-summary--pinned", 3, "column", "firstCellIndentation", "rowIndex", "summaryResults", "hasSummary", "density", "active"]], template: function IgxSummaryRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxSummaryRowComponent_ng_container_0_Template, 7, 11, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxSummaryRowComponent_ng_template_1_Template, 2, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.summaries.size);
    } }, directives: [ɵngcc2.NgIf, IgxGridForOfDirective, ɵngcc2.NgTemplateOutlet, IgxSummaryCellComponent, ɵngcc2.NgForOf], pipes: [IgxGridNotGroupedPipe], encapsulation: 2, changeDetection: 0 });
IgxSummaryRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxSummaryRowComponent.prototype, "summaries", void 0);
__decorate([
    Input()
], IgxSummaryRowComponent.prototype, "gridID", void 0);
__decorate([
    Input()
], IgxSummaryRowComponent.prototype, "index", void 0);
__decorate([
    Input()
], IgxSummaryRowComponent.prototype, "firstCellIndentation", void 0);
__decorate([
    HostBinding('attr.data-rowIndex')
], IgxSummaryRowComponent.prototype, "dataRowIndex", null);
__decorate([
    ViewChildren(IgxSummaryCellComponent, { read: IgxSummaryCellComponent })
], IgxSummaryRowComponent.prototype, "_summaryCells", void 0);
__decorate([
    ViewChild('igxDirRef', { read: IgxGridForOfDirective })
], IgxSummaryRowComponent.prototype, "virtDirRow", void 0);

var DragScrollDirection;
(function (DragScrollDirection) {
    DragScrollDirection[DragScrollDirection["NONE"] = 0] = "NONE";
    DragScrollDirection[DragScrollDirection["LEFT"] = 1] = "LEFT";
    DragScrollDirection[DragScrollDirection["TOP"] = 2] = "TOP";
    DragScrollDirection[DragScrollDirection["RIGHT"] = 3] = "RIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOM"] = 4] = "BOTTOM";
    DragScrollDirection[DragScrollDirection["TOPLEFT"] = 5] = "TOPLEFT";
    DragScrollDirection[DragScrollDirection["TOPRIGHT"] = 6] = "TOPRIGHT";
    DragScrollDirection[DragScrollDirection["BOTTOMLEFT"] = 7] = "BOTTOMLEFT";
    DragScrollDirection[DragScrollDirection["BOTTOMRIGHT"] = 8] = "BOTTOMRIGHT";
})(DragScrollDirection || (DragScrollDirection = {}));
let IgxGridDragSelectDirective = class IgxGridDragSelectDirective {
    constructor(ref, zone) {
        this.ref = ref;
        this.zone = zone;
        this.onDragStop = new EventEmitter();
        this.onDragScroll = new EventEmitter();
        this.end$ = new Subject();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = (ev) => {
            if (!this.activeDrag) {
                return;
            }
            const x = ev.clientX;
            const y = ev.clientY;
            const direction = this._measureDimensions(x, y);
            if (direction === this.lastDirection) {
                return;
            }
            this.unsubscribe();
            this._sub = this._interval$.subscribe(() => this.onDragScroll.emit(direction));
            this.lastDirection = direction;
        };
        this.stopDragSelection = () => {
            if (!this.activeDrag) {
                return;
            }
            this.onDragStop.emit(false);
            this.unsubscribe();
            this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = interval(100).pipe(takeUntil(this.end$), filter(() => this.activeDrag));
    }
    get activeDrag() {
        return this._activeDrag;
    }
    set activeDrag(val) {
        if (val !== this._activeDrag) {
            this.unsubscribe();
            this._activeDrag = val;
        }
    }
    get nativeElement() {
        return this.ref.nativeElement;
    }
    get clientRect() {
        return this.nativeElement.getBoundingClientRect();
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.addEventListener('pointerover', this.startDragSelection);
            this.nativeElement.addEventListener('pointerleave', this.stopDragSelection);
        });
    }
    ngOnDestroy() {
        this.zone.runOutsideAngular(() => {
            this.nativeElement.removeEventListener('pointerover', this.startDragSelection);
            this.nativeElement.removeEventListener('pointerleave', this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    }
    _measureDimensions(x, y) {
        let direction;
        const rect = this.clientRect;
        const RATIO = 0.15;
        const offsetX = Math.trunc(x - rect.left);
        const offsetY = Math.trunc(y - rect.top);
        const left = offsetX <= rect.width * RATIO;
        const right = offsetX >= rect.width * (1 - RATIO);
        const top = offsetY <= rect.height * RATIO;
        const bottom = offsetY >= rect.height * (1 - RATIO);
        if (top && left) {
            direction = DragScrollDirection.TOPLEFT;
        }
        else if (top && right) {
            direction = DragScrollDirection.TOPRIGHT;
        }
        else if (bottom && left) {
            direction = DragScrollDirection.BOTTOMLEFT;
        }
        else if (bottom && right) {
            direction = DragScrollDirection.BOTTOMRIGHT;
        }
        else if (top) {
            direction = DragScrollDirection.TOP;
        }
        else if (bottom) {
            direction = DragScrollDirection.BOTTOM;
        }
        else if (left) {
            direction = DragScrollDirection.LEFT;
        }
        else if (right) {
            direction = DragScrollDirection.RIGHT;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return direction;
    }
    unsubscribe() {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    }
};
IgxGridDragSelectDirective.ɵfac = function IgxGridDragSelectDirective_Factory(t) { return new (t || IgxGridDragSelectDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxGridDragSelectDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridDragSelectDirective, selectors: [["", "igxGridDragSelect", ""]], inputs: { activeDrag: ["igxGridDragSelect", "activeDrag"] }, outputs: { onDragStop: "onDragStop", onDragScroll: "onDragScroll" } });
IgxGridDragSelectDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input('igxGridDragSelect')
], IgxGridDragSelectDirective.prototype, "activeDrag", null);
__decorate([
    Output()
], IgxGridDragSelectDirective.prototype, "onDragStop", void 0);
__decorate([
    Output()
], IgxGridDragSelectDirective.prototype, "onDragScroll", void 0);

/**
 * @hidden
 */
let IgxTemplateOutletDirective = class IgxTemplateOutletDirective {
    constructor(_viewContainerRef, _zone, cdr) {
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this.cdr = cdr;
        /**
         * The embedded views cache. Collection is key-value paired.
         * Key is the template id, value is the embedded view for the related template.
         */
        this._embeddedViewsMap = new Map();
        this.onViewCreated = new EventEmitter();
        this.onViewMoved = new EventEmitter();
        this.onCachedViewLoaded = new EventEmitter();
        this.onBeforeViewDetach = new EventEmitter();
    }
    ngOnChanges(changes) {
        const actionType = this._getActionType(changes);
        switch (actionType) {
            case TemplateOutletAction.CreateView:
                this._recreateView();
                break;
            case TemplateOutletAction.MoveView:
                this._moveView();
                break;
            case TemplateOutletAction.UseCachedView:
                this._useCachedView();
                break;
            case TemplateOutletAction.UpdateViewContext:
                this._updateExistingContext(this.igxTemplateOutletContext);
                break;
        }
    }
    cleanCache() {
        this._embeddedViewsMap.forEach((item) => {
            if (!item.destroyed) {
                item.destroy();
            }
        });
        this._embeddedViewsMap.clear();
    }
    cleanView(tmplID) {
        const embView = this._embeddedViewsMap.get(tmplID);
        if (embView) {
            embView.destroy();
            this._embeddedViewsMap.delete(tmplID);
        }
    }
    _recreateView() {
        const prevIndex = this._viewRef ? this._viewContainerRef.indexOf(this._viewRef) : -1;
        // detach old and create new
        if (prevIndex !== -1) {
            this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            this._viewContainerRef.detach(prevIndex);
        }
        if (this.igxTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
            this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            const tmplId = this.igxTemplateOutletContext['templateID'];
            if (tmplId) {
                // if context contains a template id, check if we have a view for that template already stored in the cache
                // if not create a copy and add it to the cache in detached state.
                // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                const res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                if (!res) {
                    this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                }
            }
        }
    }
    _moveView() {
        // using external view and inserting it in current view.
        const view = this.igxTemplateOutletContext['moveView'];
        const owner = this.igxTemplateOutletContext['owner'];
        if (view !== this._viewRef) {
            if (owner._viewContainerRef.indexOf(view) !== -1) {
                // detach in case view it is attached somewhere else at the moment.
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
            }
            if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = view;
            this._viewContainerRef.insert(view, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
        }
        else {
            this._updateExistingContext(this.igxTemplateOutletContext);
        }
    }
    _useCachedView() {
        // use view for specific template cached in the current template outlet
        const tmplID = this.igxTemplateOutletContext['templateID'];
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        // if view exists, but template has been changed and there is a view in the cache with the related template
        // then detach old view and insert the stored one with the matching template
        // after that update its context.
        if (this._viewContainerRef.length > 0) {
            this.onBeforeViewDetach.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        }
        this._viewRef = cachedView;
        const oldContext = this._cloneContext(cachedView.context);
        this._viewContainerRef.insert(this._viewRef, 0);
        this._updateExistingContext(this.igxTemplateOutletContext);
        this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext });
    }
    _shouldRecreateView(changes) {
        const ctxChange = changes['igxTemplateOutletContext'];
        return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
    }
    _hasContextShapeChanged(ctxChange) {
        const prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        const currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            for (const propName of currCtxKeys) {
                if (prevCtxKeys.indexOf(propName) === -1) {
                    return true;
                }
            }
            return false;
        }
        else {
            return true;
        }
    }
    _updateExistingContext(ctx) {
        for (const propName of Object.keys(ctx)) {
            this._viewRef.context[propName] = this.igxTemplateOutletContext[propName];
        }
    }
    _cloneContext(ctx) {
        const clone = {};
        for (const propName of Object.keys(ctx)) {
            clone[propName] = ctx[propName];
        }
        return clone;
    }
    _getActionType(changes) {
        const movedView = this.igxTemplateOutletContext['moveView'];
        const tmplID = this.igxTemplateOutletContext['templateID'];
        const cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        const shouldRecreate = this._shouldRecreateView(changes);
        if (movedView) {
            // view is moved from external source
            return TemplateOutletAction.MoveView;
        }
        else if (shouldRecreate && cachedView) {
            // should recreate (template or context change) and there is a matching template in cache
            return TemplateOutletAction.UseCachedView;
        }
        else if (!this._viewRef || shouldRecreate) {
            // no view or should recreate
            return TemplateOutletAction.CreateView;
        }
        else if (this.igxTemplateOutletContext) {
            // has context, update context
            return TemplateOutletAction.UpdateViewContext;
        }
    }
};
IgxTemplateOutletDirective.ɵfac = function IgxTemplateOutletDirective_Factory(t) { return new (t || IgxTemplateOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxTemplateOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTemplateOutletDirective, selectors: [["", "igxTemplateOutlet", ""]], inputs: { igxTemplateOutletContext: "igxTemplateOutletContext", igxTemplateOutlet: "igxTemplateOutlet" }, outputs: { onViewCreated: "onViewCreated", onViewMoved: "onViewMoved", onCachedViewLoaded: "onCachedViewLoaded", onBeforeViewDetach: "onBeforeViewDetach" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
IgxTemplateOutletDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxTemplateOutletDirective.prototype, "igxTemplateOutletContext", void 0);
__decorate([
    Input()
], IgxTemplateOutletDirective.prototype, "igxTemplateOutlet", void 0);
__decorate([
    Output()
], IgxTemplateOutletDirective.prototype, "onViewCreated", void 0);
__decorate([
    Output()
], IgxTemplateOutletDirective.prototype, "onViewMoved", void 0);
__decorate([
    Output()
], IgxTemplateOutletDirective.prototype, "onCachedViewLoaded", void 0);
__decorate([
    Output()
], IgxTemplateOutletDirective.prototype, "onBeforeViewDetach", void 0);
var TemplateOutletAction;
(function (TemplateOutletAction) {
    TemplateOutletAction[TemplateOutletAction["CreateView"] = 0] = "CreateView";
    TemplateOutletAction[TemplateOutletAction["MoveView"] = 1] = "MoveView";
    TemplateOutletAction[TemplateOutletAction["UseCachedView"] = 2] = "UseCachedView";
    TemplateOutletAction[TemplateOutletAction["UpdateViewContext"] = 3] = "UpdateViewContext";
})(TemplateOutletAction || (TemplateOutletAction = {}));
/**
 * @hidden
 */
let IgxTemplateOutletModule = class IgxTemplateOutletModule {
};
IgxTemplateOutletModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTemplateOutletModule });
IgxTemplateOutletModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTemplateOutletModule_Factory(t) { return new (t || IgxTemplateOutletModule)(); }, imports: [[CommonModule]] });

/**
 * @hidden
 * @internal
 */
let IgxColumnResizerDirective = class IgxColumnResizerDirective {
    constructor(element, document, zone) {
        this.element = element;
        this.document = document;
        this.zone = zone;
        this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
        this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
        this.resizeEnd = new Subject();
        this.resizeStart = new Subject();
        this.resize = new Subject();
        this._destroy = new Subject();
        this.resizeStart.pipe(map((event) => event.clientX), takeUntil(this._destroy), switchMap((offset) => this.resize.pipe(map((event) => event.clientX - offset), takeUntil(this.resizeEnd), takeUntil(this._destroy)))).subscribe((pos) => {
            const left = this._left + pos;
            const min = this._left - this.restrictHResizeMin;
            const max = this._left + this.restrictHResizeMax;
            this.left = left < min ? min : left;
            if (left > max) {
                this.left = max;
            }
        });
    }
    ngOnInit() {
        this.zone.runOutsideAngular(() => {
            fromEvent(this.document.defaultView, 'mousemove').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy)).subscribe((res) => this.onMousemove(res));
            fromEvent(this.document.defaultView, 'mouseup').pipe(takeUntil(this._destroy))
                .subscribe((res) => this.onMouseup(res));
        });
    }
    ngOnDestroy() {
        this._destroy.next(true);
        this._destroy.complete();
    }
    set left(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.left = val + 'px');
    }
    set top(val) {
        requestAnimationFrame(() => this.element.nativeElement.style.top = val + 'px');
    }
    onMouseup(event) {
        this.resizeEnd.next(event);
        this.resizeEnd.complete();
    }
    onMousedown(event) {
        event.preventDefault();
        const parent = this.element.nativeElement.parentElement.parentElement;
        this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
        this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
        this.resizeStart.next(event);
    }
    onMousemove(event) {
        event.preventDefault();
        this.resize.next(event);
    }
};
IgxColumnResizerDirective.ɵfac = function IgxColumnResizerDirective_Factory(t) { return new (t || IgxColumnResizerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxColumnResizerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnResizerDirective, selectors: [["", "igxResizer", ""]], inputs: { restrictHResizeMin: "restrictHResizeMin", restrictHResizeMax: "restrictHResizeMax" }, outputs: { resizeEnd: "resizeEnd", resizeStart: "resizeStart", resize: "resize" } });
IgxColumnResizerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
__decorate([
    Input()
], IgxColumnResizerDirective.prototype, "restrictHResizeMin", void 0);
__decorate([
    Input()
], IgxColumnResizerDirective.prototype, "restrictHResizeMax", void 0);
__decorate([
    Output()
], IgxColumnResizerDirective.prototype, "resizeEnd", void 0);
__decorate([
    Output()
], IgxColumnResizerDirective.prototype, "resizeStart", void 0);
__decorate([
    Output()
], IgxColumnResizerDirective.prototype, "resize", void 0);
IgxColumnResizerDirective = __decorate([ __param(1, Inject(DOCUMENT))
], IgxColumnResizerDirective);

let IgxGridColumnResizerComponent = class IgxGridColumnResizerComponent {
    constructor(colResizingService) {
        this.colResizingService = colResizingService;
    }
};
IgxGridColumnResizerComponent.ɵfac = function IgxGridColumnResizerComponent_Factory(t) { return new (t || IgxGridColumnResizerComponent)(ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService)); };
IgxGridColumnResizerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridColumnResizerComponent, selectors: [["igx-grid-column-resizer"]], viewQuery: function IgxGridColumnResizerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(IgxColumnResizerDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizer = _t.first);
    } }, decls: 1, vars: 6, consts: [["igxResizer", "", 1, "igx-grid__th-resize-line", 3, "restrictHResizeMax", "restrictHResizeMin", "resizeEnd"]], template: function IgxGridColumnResizerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("resizeEnd", function IgxGridColumnResizerComponent_Template_div_resizeEnd_0_listener($event) { return ctx.colResizingService.resizeColumn($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("left", 0 - 99999, "px")("height", ctx.colResizingService.resizerHeight, "px");
        ɵngcc0.ɵɵproperty("restrictHResizeMax", ctx.colResizingService.restrictResizeMax)("restrictHResizeMin", ctx.colResizingService.restrictResizeMin);
    } }, directives: [IgxColumnResizerDirective], encapsulation: 2, changeDetection: 0 });
IgxGridColumnResizerComponent.ctorParameters = () => [
    { type: IgxColumnResizingService }
];
__decorate([
    ViewChild(IgxColumnResizerDirective, { static: true })
], IgxGridColumnResizerComponent.prototype, "resizer", void 0);

/**
 * @hidden
 */
let IgxGridFilteringRowComponent = class IgxGridFilteringRowComponent {
    constructor(filteringService, element, cdr) {
        this.filteringService = filteringService;
        this.element = element;
        this.cdr = cdr;
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._conditionsOverlaySettings = {
            excludePositionTarget: true,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this._operatorsOverlaySettings = {
            excludePositionTarget: true,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this.chipAreaScrollOffset = 0;
        this._column = null;
        this.isKeyPressed = false;
        this.isComposing = false;
        this._cancelChipClick = false;
        this.cssClass = 'igx-grid__filtering-row';
    }
    get column() {
        return this._column;
    }
    set column(val) {
        if (this._column) {
            this.expressionsList.forEach(exp => exp.isSelected = false);
        }
        if (val) {
            this._column = val;
            this.expressionsList = this.filteringService.getExpressions(this._column.field);
            this.resetExpression();
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    get value() {
        return this.expression ? this.expression.searchVal : null;
    }
    set value(val) {
        if (!val && val !== 0) {
            this.expression.searchVal = null;
            this.showHideArrowButtons();
        }
        else {
            this.expression.searchVal = DataUtil.parseValue(this.column.dataType, val);
            if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
                this.addExpression(true);
            }
        }
        this.filter();
    }
    ngAfterViewInit() {
        this._conditionsOverlaySettings.outlet = this.column.grid.outletDirective;
        this._operatorsOverlaySettings.outlet = this.column.grid.outletDirective;
        const selectedItem = this.expressionsList.find(expr => expr.isSelected === true);
        if (selectedItem) {
            this.expression = selectedItem.expression;
        }
        this.input.nativeElement.focus();
    }
    onEscHandler(evt) {
        evt.preventDefault();
        evt.stopPropagation();
        this.close();
    }
    get disabled() {
        return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
    }
    get template() {
        if (this.column.dataType === DataType.Date) {
            return this.defaultDateUI;
        }
        return this.defaultFilterUI;
    }
    get type() {
        switch (this.column.dataType) {
            case DataType.String:
            case DataType.Boolean:
                return 'text';
            case DataType.Number:
                return 'number';
        }
    }
    get conditions() {
        return this.column.filters.conditionList();
    }
    get isUnaryCondition() {
        if (this.expression.condition) {
            return this.expression.condition.isUnary;
        }
        else {
            return true;
        }
    }
    get placeholder() {
        if (this.expression.condition && this.expression.condition.isUnary) {
            return this.filteringService.getChipLabel(this.expression);
        }
        else if (this.column.dataType === DataType.Date) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
        }
        else if (this.column.dataType === DataType.Boolean) {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
        }
        else {
            return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
        }
    }
    /**
     * Event handler for keydown on the input group's prefix.
     */
    onPrefixKeyDown(event) {
        if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            event.stopImmediatePropagation();
        }
        else if (event.key === "Tab" /* TAB */ && !this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for keydown on the input.
     */
    onInputKeyDown(event) {
        this.isKeyPressed = true;
        event.stopPropagation();
        if (this.column.dataType === DataType.Boolean) {
            if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                return;
            }
        }
        if (event.key === "Enter" /* ENTER */) {
            if (this.isComposing) {
                return;
            }
            this.commitInput();
        }
        else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
        else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */) {
            this.close();
        }
    }
    /**
     * Event handler for keyup on the input.
     */
    onInputKeyUp(eventArgs) {
        this.isKeyPressed = false;
    }
    /**
     * Event handler for input on the input.
     */
    onInput(eventArgs) {
        // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
        // when you have a japanese character as a placeholder, on init the value here is empty string .
        const target = eventArgs.target;
        if (isEdge() && target.type !== 'number' || this.isKeyPressed && isIE() || target.value || target.checkValidity()) {
            this.value = target.value;
        }
    }
    /**
     * Event handler for compositionstart on the input.
     */
    onCompositionStart() {
        this.isComposing = true;
    }
    /**
     * Event handler for compositionend on the input.
     */
    onCompositionEnd() {
        this.isComposing = false;
    }
    /**
     * Event handler for input click event.
     */
    onInputClick() {
        if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    }
    /**
     * Event handler for datepicker's close.
     */
    datePickerClose() {
        this.input.nativeElement.focus();
    }
    /**
     * Returns the filtering operation condition for a given value.
     */
    getCondition(value) {
        return this.column.filters.condition(value);
    }
    /**
     * Returns the translated condition name for a given value.
     */
    translateCondition(value) {
        return this.filteringService.grid.resourceStrings[`igx_grid_filter_${this.getCondition(value).name}`] || value;
    }
    /**
     * Returns the icon name of the current condition.
     */
    getIconName() {
        if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else {
            return this.expression.condition.iconName;
        }
    }
    /**
     * Returns whether a given condition is selected in dropdown.
     */
    isConditionSelected(conditionName) {
        if (this.expression.condition) {
            return this.expression.condition.name === conditionName;
        }
        else {
            return false;
        }
    }
    /**
     * Clears the current filtering.
     */
    clearFiltering() {
        this.filteringService.clearFilter(this.column.field);
        this.resetExpression();
        if (this.input) {
            this.input.nativeElement.focus();
        }
        this.cdr.detectChanges();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /**
     * Commits the value of the input.
     */
    commitInput() {
        const selectedItem = this.expressionsList.filter(ex => ex.isSelected === true);
        selectedItem.forEach(e => e.isSelected = false);
        let indexToDeselect = -1;
        for (let index = 0; index < this.expressionsList.length; index++) {
            const expression = this.expressionsList[index].expression;
            if (expression.searchVal === null && !expression.condition.isUnary) {
                indexToDeselect = index;
            }
        }
        if (indexToDeselect !== -1) {
            this.removeExpression(indexToDeselect, this.expression);
        }
        this.resetExpression();
        this.scrollChipsWhenAddingExpression();
    }
    /**
     * Clears the value of the input.
     */
    clearInput() {
        this.value = null;
    }
    /**
     * Event handler for keydown on clear button.
     */
    onClearKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.clearInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on clear button.
     */
    onClearClick() {
        this.clearInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for keydown on commit button.
     */
    onCommitKeyDown(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.commitInput();
            this.input.nativeElement.focus();
        }
    }
    /**
     * Event handler for click on commit button.
     */
    onCommitClick() {
        this.commitInput();
        this.input.nativeElement.focus();
    }
    /**
     * Event handler for focusout on the input group.
     */
    onInputGroupFocusout() {
        if (!this.value && this.value !== 0 &&
            this.expression.condition && !this.expression.condition.isUnary) {
            return;
        }
        requestAnimationFrame(() => {
            const focusedElement = document.activeElement;
            if (focusedElement.className === 'igx-chip__remove' || focusedElement.tagName === 'IGX-DAY-ITEM') {
                return;
            }
            if (!(focusedElement && this.inputGroup.nativeElement.contains(focusedElement))
                && this.dropDownConditions.collapsed) {
                this.commitInput();
            }
        });
    }
    /**
     * Closes the filtering edit row.
     */
    close() {
        if (this.expressionsList.length === 1 &&
            this.expressionsList[0].expression.searchVal === null &&
            this.expressionsList[0].expression.condition.isUnary === false) {
            this.filteringService.getExpressions(this.column.field).pop();
            this.filter();
        }
        else {
            const condToRemove = this.expressionsList.filter(ex => ex.expression.searchVal === null && !ex.expression.condition.isUnary);
            if (condToRemove && condToRemove.length > 0) {
                condToRemove.forEach(c => this.filteringService.removeExpression(this.column.field, this.expressionsList.indexOf(c)));
                this.filter();
            }
        }
        this.filteringService.isFilterRowVisible = false;
        this.filteringService.updateFilteringCell(this.column);
        this.filteringService.filteredColumn = null;
        this.filteringService.selectedExpression = null;
        this.filteringService.grid.theadRow.nativeElement.focus();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    }
    /*
    * noop
    */
    noop() { }
    /**
     *  Event handler for date picker's selection.
     */
    onDateSelected(value) {
        this.value = value;
    }
    /** @hidden @internal */
    inputGroupPrefixClick(event) {
        event.stopPropagation();
        event.currentTarget.focus();
        this.toggleConditionsDropDown(event.currentTarget);
    }
    /**
     * Opens the conditions dropdown.
     */
    toggleConditionsDropDown(target) {
        this._conditionsOverlaySettings.positionStrategy.settings.target = target;
        this.dropDownConditions.toggle(this._conditionsOverlaySettings);
    }
    /**
     * Opens the logic operators dropdown.
     */
    toggleOperatorsDropDown(eventArgs, index) {
        this._operatorsOverlaySettings.positionStrategy.settings.target = eventArgs.target.parentElement;
        this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
    }
    /**
     * Event handler for change event in conditions dropdown.
     */
    onConditionsChanged(eventArgs) {
        const value = eventArgs.newSelection.value;
        this.expression.condition = this.getCondition(value);
        if (this.expression.condition.isUnary) {
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.unaryConditionChangedCallback());
        }
        else {
            requestAnimationFrame(() => this.conditionChangedCallback());
        }
        if (this.input) {
            // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
            // if it has been focused and then set to readonly.
            requestAnimationFrame(() => this.input.nativeElement.focus());
        }
    }
    onChipPointerdown(args, chip) {
        const activeElement = document.activeElement;
        this._cancelChipClick = chip.selected && activeElement &&
            this.inputGroup.nativeElement.contains(activeElement);
    }
    onChipClick(args, item) {
        if (this._cancelChipClick) {
            this._cancelChipClick = false;
            return;
        }
        this.expressionsList.forEach(ex => ex.isSelected = false);
        this.toggleChip(item);
    }
    toggleChip(item) {
        item.isSelected = !item.isSelected;
        if (item.isSelected) {
            this.expression = item.expression;
            if (this.input) {
                this.input.nativeElement.focus();
            }
        }
    }
    /**
     * Event handler for chip keydown event.
     */
    onChipKeyDown(eventArgs, item) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            this.toggleChip(item);
        }
    }
    /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     */
    onLeftArrowKeyDown(event) {
        if (event.key === "Tab" /* TAB */) {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * Event handler for chip removed event.
     */
    onChipRemoved(eventArgs, item) {
        const indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove, item.expression);
        this.scrollChipsOnRemove();
    }
    /**
     * Event handler for logic operator changed event.
     */
    onLogicOperatorChanged(eventArgs, expression) {
        if (eventArgs.oldSelection) {
            expression.afterOperator = eventArgs.newSelection.value;
            this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(() => this.filter());
        }
    }
    /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     */
    scrollChipsOnArrowPress(arrowPosition) {
        let count = 0;
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        if (arrowPosition === 'right') {
            for (let index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                    count++;
                }
            }
            if (count < chipAraeChildren.length) {
                this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                    Math.ceil(containerRect.right) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
        if (arrowPosition === 'left') {
            for (let index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                    count++;
                }
            }
            if (count > 0) {
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                    Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
    }
    showHideArrowButtons() {
        requestAnimationFrame(() => {
            if (this.filteringService.isFilterRowVisible) {
                const containerWidth = this.container.nativeElement.getBoundingClientRect().width;
                this.chipsAreaWidth = this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                this.showArrows = this.chipsAreaWidth >= containerWidth && this.isColumnFiltered;
                // TODO: revise the cdr.detectChanges() usage here
                if (!this.cdr.destroyed) {
                    this.cdr.detectChanges();
                }
            }
        });
    }
    addExpression(isSelected) {
        const exprUI = new ExpressionUI();
        exprUI.expression = this.expression;
        exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;
        exprUI.isSelected = isSelected;
        this.expressionsList.push(exprUI);
        const length = this.expressionsList.length;
        if (this.expressionsList[length - 2]) {
            this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
        }
        this.showHideArrowButtons();
    }
    removeExpression(indexToRemove, expression) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.filter();
        if (this.expression === expression) {
            this.resetExpression();
        }
        this.showHideArrowButtons();
    }
    resetExpression() {
        this.expression = {
            fieldName: this.column.field,
            condition: null,
            searchVal: null,
            ignoreCase: this.column.filteringIgnoreCase
        };
        if (this.column.dataType !== DataType.Boolean) {
            this.expression.condition = this.getCondition(this.conditions[0]);
        }
        if (this.column.dataType === DataType.Date && this.input) {
            this.input.nativeElement.value = null;
        }
        this.showHideArrowButtons();
    }
    scrollChipsWhenAddingExpression() {
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        if (!chipAraeChildren || chipAraeChildren.length === 0) {
            return;
        }
        const containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
        const lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
        if (lastChipRectRight >= containerRectRight) {
            this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
            this.transform(this.chipAreaScrollOffset);
        }
    }
    /**
     * @hidden
     * Resets the chips area
     * @memberof IgxGridFilteringRowComponent
     */
    resetChipsArea() {
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
        this.showHideArrowButtons();
    }
    transform(offset) {
        requestAnimationFrame(() => {
            this.chipsArea.element.nativeElement.style.transform = `translate(${offset}px)`;
        });
    }
    scrollChipsOnRemove() {
        let count = 0;
        const chipAraeChildren = this.chipsArea.element.nativeElement.children;
        const containerRect = this.container.nativeElement.getBoundingClientRect();
        for (let index = 0; index < chipAraeChildren.length; index++) {
            if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.left)) {
                count++;
            }
        }
        if (count <= 2) {
            this.chipAreaScrollOffset = 0;
        }
        else {
            const dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
            this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
        }
        this.transform(this.chipAreaScrollOffset);
    }
    conditionChangedCallback() {
        if (!!this.expression.searchVal || this.expression.searchVal === 0) {
            this.filter();
        }
        else if (this.value) {
            this.value = null;
        }
    }
    unaryConditionChangedCallback() {
        if (this.value) {
            this.value = null;
        }
        if (this.expressionsList.find(item => item.expression === this.expression) === undefined) {
            this.addExpression(true);
        }
        this.filter();
    }
    filter() {
        this.filteringService.filterInternal(this.column.field);
    }
    get isColumnFiltered() {
        return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
    }
};
IgxGridFilteringRowComponent.ɵfac = function IgxGridFilteringRowComponent_Factory(t) { return new (t || IgxGridFilteringRowComponent)(ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxGridFilteringRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridFilteringRowComponent, selectors: [["igx-grid-filtering-row"]], viewQuery: function IgxGridFilteringRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c96, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c97, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c33, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c39, true, IgxDropDownComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c89, true, IgxChipsAreaComponent);
        ɵngcc0.ɵɵviewQuery(_c98, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c99, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c5, true);
        ɵngcc0.ɵɵviewQuery(_c100, true);
        ɵngcc0.ɵɵstaticViewQuery(_c101, true);
        ɵngcc0.ɵɵviewQuery(_c102, true, IgxDropDownComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultFilterUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultDateUI = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropDownConditions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chipsArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroupPrefix = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.operand = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.closeButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropDownOperators = _t);
    } }, hostVars: 2, hostBindings: function IgxGridFilteringRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.esc", function IgxGridFilteringRowComponent_keydown_esc_HostBindingHandler($event) { return ctx.onEscHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-grid__filtering-row", ctx.cssClass);
    } }, inputs: { column: "column", value: "value" }, decls: 23, vars: 13, consts: [[3, "height", "onSelection"], ["inputGroupConditions", ""], [3, "value", "selected", 4, "ngFor", "ngForOf"], ["defaultFilterUI", ""], ["defaultDateUI", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["igxButton", "icon", "class", "igx-grid__filtering-row-scroll-start", 3, "keydown", "click", 4, "ngIf"], [1, "igx-grid__filtering-row-main"], ["container", ""], ["chipsArea", ""], ["tabindex", "0", 4, "ngFor", "ngForOf"], ["igxButton", "icon", "class", "igx-grid__filtering-row-scroll-end", 3, "click", 4, "ngIf"], [1, "igx-grid__filtering-row-editing-buttons"], ["buttonsContainer", ""], ["igxButton", "", "igxRipple", "", 3, "disabled", "tabindex", "click"], ["igxButton", "", "igxRipple", "", 3, "click"], ["closeButton", ""], [3, "value", "selected"], ["fontSet", "filtering-icons", 3, "name"], [2, "margin-left", "16px"], ["type", "box", 3, "displayDensity", "focusout"], ["inputGroup", ""], ["tabindex", "0", 3, "igxDropDownItemNavigation", "click", "keydown"], ["inputGroupPrefix", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "type", "readonly", "input", "click", "compositionstart", "compositionend", "keydown", "keyup"], ["input", ""], [4, "ngIf"], ["tabindex", "0", 3, "keydown", "click"], ["tabindex", "0", "mode", "dropdown", 3, "value", "outlet", "locale", "onSelection", "onClosed"], ["igxDatePickerTemplate", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "readonly", "click", "keydown"], ["igxButton", "icon", 1, "igx-grid__filtering-row-scroll-start", 3, "keydown", "click"], ["tabindex", "0"], ["id", "chip", 3, "selectable", "selected", "displayDensity", "removable", "pointerdown", "click", "keydown", "onRemove"], ["chip", ""], ["igxPrefix", "", "fontSet", "filtering-icons", 3, "name"], ["id", "operand", 4, "ngIf"], ["id", "operand"], ["igxButton", "", 3, "igxDropDownItemNavigation", "click"], [3, "onSelection"], ["operators", ""], ["igxButton", "icon", 1, "igx-grid__filtering-row-scroll-end", 3, "click"]], template: function IgxGridFilteringRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "igx-drop-down", 0, 1);
        ɵngcc0.ɵɵlistener("onSelection", function IgxGridFilteringRowComponent_Template_igx_drop_down_onSelection_0_listener($event) { return ctx.onConditionsChanged($event); });
        ɵngcc0.ɵɵtemplate(2, IgxGridFilteringRowComponent_igx_drop_down_item_2_Template, 4, 4, "igx-drop-down-item", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, IgxGridFilteringRowComponent_ng_template_3_Template, 8, 8, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxGridFilteringRowComponent_ng_template_5_Template, 2, 3, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxGridFilteringRowComponent_ng_container_7_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵtemplate(8, IgxGridFilteringRowComponent_button_8_Template, 3, 0, "button", 6);
        ɵngcc0.ɵɵelementStart(9, "div", 7, 8);
        ɵngcc0.ɵɵelementStart(11, "div");
        ɵngcc0.ɵɵelementStart(12, "igx-chips-area", null, 9);
        ɵngcc0.ɵɵtemplate(14, IgxGridFilteringRowComponent_ng_container_14_Template, 7, 7, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(15, IgxGridFilteringRowComponent_button_15_Template, 3, 0, "button", 11);
        ɵngcc0.ɵɵelementStart(16, "div", 12, 13);
        ɵngcc0.ɵɵelementStart(18, "button", 14);
        ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_Template_button_click_18_listener() { return ctx.clearFiltering(); });
        ɵngcc0.ɵɵtext(19);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "button", 15, 16);
        ɵngcc0.ɵɵlistener("click", function IgxGridFilteringRowComponent_Template_button_click_20_listener() { return ctx.close(); });
        ɵngcc0.ɵɵtext(22);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("height", "200px");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.conditions);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(11, _c13, ctx));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showArrows);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.expressionsList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showArrows);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("tabindex", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.filteringService.grid.resourceStrings.igx_grid_filter_row_reset);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.filteringService.grid.resourceStrings.igx_grid_filter_row_close);
    } }, directives: [IgxDropDownComponent, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxChipsAreaComponent,
        IgxButtonDirective,
        IgxRippleDirective,
        IgxDropDownItemComponent,
        IgxIconComponent,
        IgxInputGroupComponent,
        IgxPrefixDirective,
        IgxDropDownItemNavigationDirective,
        IgxInputDirective,
        IgxSuffixDirective,
        IgxDatePickerComponent,
        IgxDatePickerTemplateDirective,
        IgxChipComponent], pipes: [IgxDatePipeComponent], encapsulation: 2, changeDetection: 0 });
IgxGridFilteringRowComponent.ctorParameters = () => [
    { type: IgxFilteringService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxGridFilteringRowComponent.prototype, "column", null);
__decorate([
    Input()
], IgxGridFilteringRowComponent.prototype, "value", null);
__decorate([
    ViewChild('defaultFilterUI', { read: TemplateRef, static: true })
], IgxGridFilteringRowComponent.prototype, "defaultFilterUI", void 0);
__decorate([
    ViewChild('defaultDateUI', { read: TemplateRef, static: true })
], IgxGridFilteringRowComponent.prototype, "defaultDateUI", void 0);
__decorate([
    ViewChild('input', { read: ElementRef })
], IgxGridFilteringRowComponent.prototype, "input", void 0);
__decorate([
    ViewChild('inputGroupConditions', { read: IgxDropDownComponent, static: true })
], IgxGridFilteringRowComponent.prototype, "dropDownConditions", void 0);
__decorate([
    ViewChild('chipsArea', { read: IgxChipsAreaComponent, static: true })
], IgxGridFilteringRowComponent.prototype, "chipsArea", void 0);
__decorate([
    ViewChildren('operators', { read: IgxDropDownComponent })
], IgxGridFilteringRowComponent.prototype, "dropDownOperators", void 0);
__decorate([
    ViewChild('inputGroup', { read: ElementRef })
], IgxGridFilteringRowComponent.prototype, "inputGroup", void 0);
__decorate([
    ViewChild('inputGroupPrefix', { read: ElementRef })
], IgxGridFilteringRowComponent.prototype, "inputGroupPrefix", void 0);
__decorate([
    ViewChild('container', { static: true })
], IgxGridFilteringRowComponent.prototype, "container", void 0);
__decorate([
    ViewChild('operand')
], IgxGridFilteringRowComponent.prototype, "operand", void 0);
__decorate([
    ViewChild('closeButton', { static: true })
], IgxGridFilteringRowComponent.prototype, "closeButton", void 0);
__decorate([
    HostBinding('class.igx-grid__filtering-row')
], IgxGridFilteringRowComponent.prototype, "cssClass", void 0);
__decorate([
    HostListener('keydown.esc', ['$event'])
], IgxGridFilteringRowComponent.prototype, "onEscHandler", null);

/**
 * @hidden
 * @internal
 */
var DropPosition;
(function (DropPosition) {
    DropPosition[DropPosition["BeforeDropTarget"] = 0] = "BeforeDropTarget";
    DropPosition[DropPosition["AfterDropTarget"] = 1] = "AfterDropTarget";
    DropPosition[DropPosition["None"] = 2] = "None";
})(DropPosition || (DropPosition = {}));
/**
 * @hidden
 * @internal
 */
let IgxColumnMovingService = class IgxColumnMovingService {
    get column() {
        return this._column;
    }
    set column(val) {
        if (val) {
            this._column = val;
        }
    }
    get icon() {
        return this._icon;
    }
    set icon(val) {
        if (val) {
            this._icon = val;
        }
    }
};
IgxColumnMovingService.ɵfac = function IgxColumnMovingService_Factory(t) { return new (t || IgxColumnMovingService)(); };
IgxColumnMovingService.ɵprov = ɵɵdefineInjectable({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });

/**
 * @hidden
 * @internal
 */
let IgxColumnMovingDragDirective = class IgxColumnMovingDragDirective extends IgxDragDirective {
    constructor(element, viewContainer, zone, renderer, cdr, cms) {
        super(cdr, element, viewContainer, zone, renderer);
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.cdr = cdr;
        this.cms = cms;
        this._ghostClass = 'igx-grid__drag-ghost-image';
        this.ghostImgIconClass = 'igx-grid__drag-ghost-image-icon';
        this.ghostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
        this.columnSelectedClass = 'igx-grid__th--selected';
    }
    set data(val) {
        this._column = val;
    }
    get column() {
        return this._column;
    }
    get draggable() {
        return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
    }
    get icon() {
        return this.cms.icon;
    }
    ngOnDestroy() {
        this._unsubscribe();
    }
    onEscape(event) {
        this.cms.cancelDrop = true;
        this.onPointerUp(event);
    }
    onPointerDown(event) {
        if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._removeOnDestroy = false;
        this.cms.column = this.column;
        this.ghostClass = this._ghostClass;
        super.onPointerDown(event);
        this.cms.isColumnMoving = true;
        this.column.grid.cdr.detectChanges();
        const args = {
            source: this.column
        };
        this.column.grid.onColumnMovingStart.emit(args);
        this.subscription$ = fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe((ev) => {
            if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                this.onEscape(ev);
            }
        });
    }
    onPointerMove(event) {
        event.preventDefault();
        super.onPointerMove(event);
        if (this._dragStarted && this.ghostElement && !this.column.grid.draggedColumn) {
            this.column.grid.draggedColumn = this.column;
            this.column.grid.cdr.detectChanges();
        }
        if (this.cms.isColumnMoving) {
            const args = {
                source: this.column,
                cancel: false
            };
            this.column.grid.onColumnMoving.emit(args);
            if (args.cancel) {
                this.onEscape(event);
            }
        }
    }
    onPointerUp(event) {
        // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
        this.zone.run(() => {
            super.onPointerUp(event);
            this.cms.isColumnMoving = false;
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        });
        this._unsubscribe();
    }
    createGhost(pageX, pageY) {
        super.createGhost(pageX, pageY);
        this.ghostElement.style.height = null;
        this.ghostElement.style.minWidth = null;
        this.ghostElement.style.flexBasis = null;
        this.ghostElement.style.position = null;
        this.renderer.removeClass(this.ghostElement, this.columnSelectedClass);
        const icon = document.createElement('i');
        const text = document.createTextNode('block');
        icon.appendChild(text);
        icon.classList.add('material-icons');
        this.cms.icon = icon;
        if (!this.column.columnGroup) {
            this.renderer.addClass(icon, this.ghostImgIconClass);
            this.ghostElement.insertBefore(icon, this.ghostElement.firstElementChild);
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
        else {
            this.ghostElement.insertBefore(icon, this.ghostElement.childNodes[0]);
            this.renderer.addClass(icon, this.ghostImgIconGroupClass);
            this.ghostElement.children[0].style.paddingLeft = '0px';
            this.ghostLeft = this._ghostStartX = pageX - ((this.ghostElement.getBoundingClientRect().width / 3) * 2);
            this.ghostTop = this._ghostStartY = pageY - ((this.ghostElement.getBoundingClientRect().height / 3) * 2);
        }
    }
    _unsubscribe() {
        if (this.subscription$) {
            this.subscription$.unsubscribe();
            this.subscription$ = null;
        }
    }
};
IgxColumnMovingDragDirective.ɵfac = function IgxColumnMovingDragDirective_Factory(t) { return new (t || IgxColumnMovingDragDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxColumnMovingService)); };
IgxColumnMovingDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnMovingDragDirective, selectors: [["", "igxColumnMovingDrag", ""]], inputs: { data: ["igxColumnMovingDrag", "data"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnMovingDragDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: NgZone },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: IgxColumnMovingService }
];
__decorate([
    Input('igxColumnMovingDrag')
], IgxColumnMovingDragDirective.prototype, "data", null);

/**
 * @hidden
 */
let IgxGroupByRowTemplateDirective = class IgxGroupByRowTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxGroupByRowTemplateDirective.ɵfac = function IgxGroupByRowTemplateDirective_Factory(t) { return new (t || IgxGroupByRowTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxGroupByRowTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGroupByRowTemplateDirective, selectors: [["", "igxGroupByRow", ""]] });
IgxGroupByRowTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 */
let IgxGridDetailTemplateDirective = class IgxGridDetailTemplateDirective {
};
IgxGridDetailTemplateDirective.ɵfac = function IgxGridDetailTemplateDirective_Factory(t) { return new (t || IgxGridDetailTemplateDirective)(); };
IgxGridDetailTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridDetailTemplateDirective, selectors: [["", "igxGridDetail", ""]] });
/**
 * @hidden
 */
let IgxRowExpandedIndicatorDirective = class IgxRowExpandedIndicatorDirective {
};
IgxRowExpandedIndicatorDirective.ɵfac = function IgxRowExpandedIndicatorDirective_Factory(t) { return new (t || IgxRowExpandedIndicatorDirective)(); };
IgxRowExpandedIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowExpandedIndicatorDirective, selectors: [["", "igxRowExpandedIndicator", ""]] });
/**
 * @hidden
 */
let IgxRowCollapsedIndicatorDirective = class IgxRowCollapsedIndicatorDirective {
};
IgxRowCollapsedIndicatorDirective.ɵfac = function IgxRowCollapsedIndicatorDirective_Factory(t) { return new (t || IgxRowCollapsedIndicatorDirective)(); };
IgxRowCollapsedIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowCollapsedIndicatorDirective, selectors: [["", "igxRowCollapsedIndicator", ""]] });
/**
 * @hidden
 */
let IgxHeaderExpandIndicatorDirective = class IgxHeaderExpandIndicatorDirective {
};
IgxHeaderExpandIndicatorDirective.ɵfac = function IgxHeaderExpandIndicatorDirective_Factory(t) { return new (t || IgxHeaderExpandIndicatorDirective)(); };
IgxHeaderExpandIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHeaderExpandIndicatorDirective, selectors: [["", "igxHeaderExpandedIndicator", ""]] });
/**
 * @hidden
 */
let IgxHeaderCollapseIndicatorDirective = class IgxHeaderCollapseIndicatorDirective {
};
IgxHeaderCollapseIndicatorDirective.ɵfac = function IgxHeaderCollapseIndicatorDirective_Factory(t) { return new (t || IgxHeaderCollapseIndicatorDirective)(); };
IgxHeaderCollapseIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHeaderCollapseIndicatorDirective, selectors: [["", "igxHeaderCollapsedIndicator", ""]] });
/**
 * @hidden
 */
let IgxGroupAreaDropDirective = class IgxGroupAreaDropDirective extends IgxDropDirective {
    constructor(elementRef, renderer, zone) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.hovered = false;
    }
    onDragEnter(event) {
        const drag = event.detail.owner;
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        const grid = column.grid;
        const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
        if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
            drag.icon.innerText = 'group_work';
            this.hovered = true;
        }
        else {
            drag.icon.innerText = 'block';
            this.hovered = false;
        }
    }
    onDragLeave(event) {
        const drag = event.detail.owner;
        const column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        event.detail.owner.icon.innerText = 'block';
        this.hovered = false;
    }
    onDragDrop(event) {
        const drag = event.detail.owner;
        if (drag instanceof IgxColumnMovingDragDirective) {
            const column = drag.column;
            if (!this.columnBelongsToGrid(column)) {
                return;
            }
            const grid = column.grid;
            const isGrouped = grid.groupingExpressions.findIndex((item) => item.fieldName === column.field) !== -1;
            if (column.groupable && !isGrouped && !column.columnGroup && !!column.field) {
                grid.groupBy({ fieldName: column.field, dir: SortingDirection.Asc, ignoreCase: column.sortingIgnoreCase,
                    strategy: column.sortStrategy, groupingComparer: column.groupingComparer });
            }
        }
    }
    closestParentByAttr(elem, attr) {
        return elem.hasAttribute(attr) ?
            elem :
            this.closestParentByAttr(elem.parentElement, attr);
    }
    columnBelongsToGrid(column) {
        const elem = this.elementRef.nativeElement;
        const closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
        if (!column) {
            return false;
        }
        else {
            const grid = column.grid;
            if (!grid || grid.id !== closestGridID) {
                return false;
            }
            return true;
        }
    }
};
IgxGroupAreaDropDirective.ɵfac = function IgxGroupAreaDropDirective_Factory(t) { return new (t || IgxGroupAreaDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxGroupAreaDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGroupAreaDropDirective, selectors: [["", "igxGroupAreaDrop", ""]], hostVars: 2, hostBindings: function IgxGroupAreaDropDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-drop-area--hover", ctx.hovered);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxGroupAreaDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
__decorate([
    HostBinding('class.igx-drop-area--hover')
], IgxGroupAreaDropDirective.prototype, "hovered", void 0);

let IgxSelectItemComponent = class IgxSelectItemComponent extends IgxDropDownItemComponent {
    /**
     * An @Input property that gets/sets the item's text to be displayed in the select component's input when the item is selected.
     *
     * ```typescript
     *  //get
     *  let mySelectedItem = this.dropDown.selectedItem;
     *  let selectedItemText = mySelectedItem.text;
     * ```
     *
     * ```html
     * // set
     * <igx-select-item [text]="'London'"></igx-select-item>
     * ```
     */
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
    }
    /** @hidden @internal */
    get itemText() {
        if (this._text !== undefined) {
            return this._text;
        }
        // If text @Input is undefined, try extract a meaningful item text out of the item template
        return this.elementRef.nativeElement.textContent.trim();
    }
    /**
     * Sets/Gets if the item is the currently selected one in the select
     *
     * ```typescript
     *  let mySelectedItem = this.select.selectedItem;
     *  let isMyItemSelected = mySelectedItem.selected; // true
     * ```
     */
    get selected() {
        return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
    }
    set selected(value) {
        if (value && !this.isHeader && !this.disabled) {
            this.dropDown.selectItem(this);
        }
    }
    ngDoCheck() {
    }
};
IgxSelectItemComponent.ɵfac = function IgxSelectItemComponent_Factory(t) { return ɵIgxSelectItemComponent_BaseFactory(t || IgxSelectItemComponent); };
IgxSelectItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSelectItemComponent, selectors: [["igx-select-item"]], inputs: { text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxSelectItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    Input()
], IgxSelectItemComponent.prototype, "text", null);

/** @hidden @internal */
class SelectPositioningStrategy extends BaseFitPositionStrategy {
    constructor(select, settings) {
        super();
        this.select = select;
        this._selectDefaultSettings = {
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Top,
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        // Global variables required for cases of !initialCall (page scroll/overlay repositionAll)
        this.global_yOffset = 0;
        this.global_xOffset = 0;
        this.global_styles = {};
        this.settings = Object.assign({}, this._selectDefaultSettings, settings);
    }
    /** @inheritdoc */
    position(contentElement, size, document, initialCall) {
        this.select.scrollContainer.scrollTop = 0;
        const rects = super.calculateElementRectangles(contentElement);
        // selectFit obj, to be used for both cases of initialCall and !initialCall(page scroll/overlay repositionAll)
        const selectFit = {
            verticalOffset: this.global_yOffset,
            horizontalOffset: this.global_xOffset,
            targetRect: rects.targetRect,
            contentElementRect: rects.elementRect,
            styles: this.global_styles,
            scrollContainer: this.select.scrollContainer,
            scrollContainerRect: this.select.scrollContainer.getBoundingClientRect()
        };
        if (initialCall) {
            // Fill in the required selectFit object properties.
            selectFit.viewPortRect = Util.getViewportRect(document);
            selectFit.itemElement = this.getInteractionItemElement();
            selectFit.itemRect = selectFit.itemElement.getBoundingClientRect();
            // Calculate input and selected item elements style related variables
            selectFit.styles = this.calculateStyles(selectFit);
            selectFit.scrollAmount = this.calculateScrollAmount(selectFit);
            // Calculate how much to offset the overlay container.
            this.calculateYoffset(selectFit);
            this.calculateXoffset(selectFit);
            super.updateViewPortFit(selectFit);
            // container does not fit in viewPort and is out on Top or Bottom
            if (selectFit.fitVertical.back < 0 || selectFit.fitVertical.forward < 0) {
                this.fitInViewport(contentElement, selectFit);
            }
            this.select.scrollContainer.scrollTop = selectFit.scrollAmount;
        }
        this.setStyles(contentElement, selectFit);
    }
    /**
     * Calculate selected item scroll position.
     */
    calculateScrollAmount(selectFit) {
        const itemElementRect = selectFit.itemRect;
        const scrollContainer = selectFit.scrollContainer;
        const scrollContainerRect = selectFit.scrollContainerRect;
        const scrollDelta = scrollContainerRect.top - itemElementRect.top;
        let scrollPosition = scrollContainer.scrollTop - scrollDelta;
        const dropDownHeight = scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += itemElementRect.height / 2;
        return Math.round(Math.min(Math.max(0, scrollPosition), scrollContainer.scrollHeight - scrollContainerRect.height));
    }
    /**
     * Position the items outer container so selected item text is positioned over input text and if header
     * And/OR footer - both header/footer are visible
     * @param selectFit selectFit to use for computation.
     */
    fitInViewport(contentElement, selectFit) {
        const footer = selectFit.scrollContainerRect.bottom - selectFit.contentElementRect.bottom;
        const header = selectFit.scrollContainerRect.top - selectFit.contentElementRect.top;
        const lastItemFitSize = selectFit.targetRect.bottom + selectFit.styles.itemTextToInputTextDiff - footer;
        const firstItemFitSize = selectFit.targetRect.top - selectFit.styles.itemTextToInputTextDiff - header;
        // out of viewPort on Top
        if (selectFit.fitVertical.back < 0) {
            const possibleScrollAmount = selectFit.scrollContainer.scrollHeight -
                selectFit.scrollContainerRect.height - selectFit.scrollAmount;
            if (possibleScrollAmount + selectFit.fitVertical.back > 0 && firstItemFitSize > selectFit.viewPortRect.top) {
                selectFit.scrollAmount -= selectFit.fitVertical.back;
                selectFit.verticalOffset -= selectFit.fitVertical.back;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = 0;
                this.global_yOffset = 0;
            }
            // out of viewPort on Bottom
        }
        else if (selectFit.fitVertical.forward < 0) {
            if (selectFit.scrollAmount + selectFit.fitVertical.forward > 0 && lastItemFitSize < selectFit.viewPortRect.bottom) {
                selectFit.scrollAmount += selectFit.fitVertical.forward;
                selectFit.verticalOffset += selectFit.fitVertical.forward;
                this.global_yOffset = selectFit.verticalOffset;
            }
            else {
                selectFit.verticalOffset = -selectFit.contentElementRect.height + selectFit.targetRect.height;
                this.global_yOffset = selectFit.verticalOffset;
            }
        }
    }
    /**
     * Sets element's style which effectively positions the provided element
     * @param element Element to position
     * @param selectFit selectFit to use for computation.
     * @param initialCall should be true if this is the initial call to the position method calling setStyles
     */
    setStyles(contentElement, selectFit) {
        super.setStyle(contentElement, selectFit.targetRect, selectFit.contentElementRect, selectFit);
        contentElement.style.width = `${selectFit.styles.contentElementNewWidth}px`; // manage container based on paddings?
        this.global_styles.contentElementNewWidth = selectFit.styles.contentElementNewWidth;
    }
    /**
     * Calculate the necessary input and selected item styles to be used for positioning item text over input text.
     * Calculate & Set default items container width.
     * @param selectFit selectFit to use for computation.
     */
    calculateStyles(selectFit) {
        const styles = {};
        const inputElementStyles = window.getComputedStyle(this.settings.target);
        const itemElementStyles = window.getComputedStyle(selectFit.itemElement);
        const numericInputFontSize = parseFloat(inputElementStyles.fontSize);
        const numericItemFontSize = parseFloat(itemElementStyles.fontSize);
        const inputTextToInputTop = (selectFit.targetRect.bottom - selectFit.targetRect.top - numericInputFontSize) / 2;
        const itemTextToItemTop = (selectFit.itemRect.height - numericItemFontSize) / 2;
        // Adjust for input top padding
        const negateInputPaddings = (parseFloat(inputElementStyles.paddingTop) -
            parseFloat(inputElementStyles.paddingBottom)) / 2;
        styles.itemTextToInputTextDiff = Math.round(itemTextToItemTop - inputTextToInputTop + negateInputPaddings);
        const numericLeftPadding = parseFloat(itemElementStyles.paddingLeft);
        const numericTextIndent = parseFloat(itemElementStyles.textIndent);
        styles.itemTextPadding = numericLeftPadding;
        styles.itemTextIndent = numericTextIndent;
        // 24 is the input's toggle ddl icon width
        styles.contentElementNewWidth = selectFit.targetRect.width + 24 + numericLeftPadding * 2;
        return styles;
    }
    /**
     * Obtain the selected item if there is such one or otherwise use the first one
     */
    getInteractionItemElement() {
        let itemElement;
        if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement;
            // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
            if (isIE()) {
                this.select.scrollContainer.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
            }
        }
        else {
            itemElement = this.select.getFirstItemElement();
        }
        return itemElement;
    }
    /**
     * Calculate how much to offset the overlay container for Y-axis.
     */
    calculateYoffset(selectFit) {
        selectFit.verticalOffset = -(selectFit.itemRect.top - selectFit.contentElementRect.top +
            selectFit.styles.itemTextToInputTextDiff - selectFit.scrollAmount);
        this.global_yOffset = selectFit.verticalOffset;
    }
    /**
     * Calculate how much to offset the overlay container for X-axis.
     */
    calculateXoffset(selectFit) {
        selectFit.horizontalOffset = selectFit.styles.itemTextIndent - selectFit.styles.itemTextPadding;
        this.global_xOffset = selectFit.horizontalOffset;
    }
}

var IgxSelectComponent_1;
/** @hidden @internal */
let IgxSelectToggleIconDirective = class IgxSelectToggleIconDirective {
};
IgxSelectToggleIconDirective.ɵfac = function IgxSelectToggleIconDirective_Factory(t) { return new (t || IgxSelectToggleIconDirective)(); };
IgxSelectToggleIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectToggleIconDirective, selectors: [["", "igxSelectToggleIcon", ""]] });
/** @hidden @internal */
let IgxSelectHeaderDirective = class IgxSelectHeaderDirective {
};
IgxSelectHeaderDirective.ɵfac = function IgxSelectHeaderDirective_Factory(t) { return new (t || IgxSelectHeaderDirective)(); };
IgxSelectHeaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectHeaderDirective, selectors: [["", "igxSelectHeader", ""]] });
/** @hidden @internal */
let IgxSelectFooterDirective = class IgxSelectFooterDirective {
};
IgxSelectFooterDirective.ɵfac = function IgxSelectFooterDirective_Factory(t) { return new (t || IgxSelectFooterDirective)(); };
IgxSelectFooterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectFooterDirective, selectors: [["", "igxSelectFooter", ""]] });
const noop$5 = () => { };
const ɵ0$6 = noop$5;
/**
 * **Ignite UI for Angular Select** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select.html)
 *
 * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
 *
 * Example:
 * ```html
 * <igx-select #select1 [placeholder]="'Pick One'">
 *   <label igxLabel>Select Label</label>
 *   <igx-select-item *ngFor="let item of items" [value]="item.field">
 *     {{ item.field }}
 *   </igx-select-item>
 * </igx-select>
 * ```
 */
let IgxSelectComponent = IgxSelectComponent_1 = class IgxSelectComponent extends IgxDropDownComponent {
    constructor(elementRef, cdr, selection, _displayDensityOptions, _injector) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this._displayDensityOptions = _displayDensityOptions;
        this._injector = _injector;
        this.ngControl = null;
        /** @hidden @internal do not use the drop-down container class */
        this.cssClass = false;
        /** @hidden @internal */
        this.allowItemsFocus = false;
        /**
         * An @Input property that disables the `IgxSelectComponent`.
         * ```html
         * <igx-select [disabled]="'true'"></igx-select>
         * ```
         */
        this.disabled = false;
        /** @hidden @internal */
        this.maxHeight = '256px';
        /**
         * An @Input property that sets how the select will be styled.
         * The allowed values are `line`, `box` and `border`. The default is `line`.
         * ```html
         * <igx-select [type]="'box'"></igx-select>
         * ```
         */
        this.type = 'line';
        /**
         * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the select items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectHeader>
         *          <div class="select__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the select items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectFooter>
         *          <div class="select__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        this.footerTemplate = null;
        //#region ControlValueAccessor
        /** @hidden @internal */
        this._onChangeCallback = noop$5;
        /** @hidden @internal */
        this._onTouchedCallback = noop$5;
        /** @hidden @internal */
        this.writeValue = (value) => {
            this.value = value;
        };
    }
    /**
     * An @Input property that gets/sets the component value.
     *
     * ```typescript
     * // get
     * let selectValue = this.select.value;
     * ```
     *
     * ```typescript
     * // set
     * this.select.value = 'London';
     * ```
     * ```html
     * <igx-select [value]="value"></igx-select>
     * ```
     */
    get value() {
        return this._value;
    }
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.setSelection(this.items.find(x => x.value === this.value));
    }
    /** @hidden @internal */
    get selectionValue() {
        const selectedItem = this.selectedItem;
        return selectedItem ? selectedItem.itemText : '';
    }
    /** @hidden @internal */
    get selectedItem() {
        return this.selection.first_item(this.id);
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    //#endregion
    /** @hidden @internal */
    getEditElement() {
        return this.input.nativeElement;
    }
    /** @hidden @internal */
    selectItem(newSelection, event) {
        const oldSelection = this.selectedItem;
        if (event) {
            this.toggleDirective.close();
        }
        if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
            return;
        }
        const args = { oldSelection, newSelection, cancel: false };
        this.onSelection.emit(args);
        if (args.cancel) {
            return;
        }
        this.setSelection(newSelection);
        this._value = newSelection.value;
        this.cdr.detectChanges();
        this._onChangeCallback(this.value);
    }
    /** @hidden @internal */
    getFirstItemElement() {
        return this.children.first.element.nativeElement;
    }
    /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     */
    open(overlaySettings) {
        if (this.disabled || this.items.length === 0) {
            return;
        }
        if (!this.selectedItem) {
            this.navigateFirst();
        }
        super.open(Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this._overlayDefaults = {
            modal: false,
            closeOnOutsideClick: false,
            positionStrategy: new SelectPositioningStrategy(this, { target: this.getEditElement() }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            excludePositionTarget: true
        };
        this.children.changes.subscribe(() => {
            this.setSelection(this.items.find(x => x.value === this.value));
            this.cdr.detectChanges();
        });
        Promise.resolve().then(() => this.children.notifyOnChanges());
    }
    /** @hidden @internal */
    onToggleOpening(event) {
        this.onOpening.emit(event);
        if (event.cancel) {
            return;
        }
        this.scrollToItem(this.selectedItem);
    }
    navigate(direction, currentIndex) {
        if (this.collapsed && this.selectedItem) {
            this.navigateItem(this.selectedItem.itemIndex);
        }
        super.navigate(direction, currentIndex);
    }
    manageRequiredAsterisk() {
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this.ngControl.control.validator({});
            this.inputGroup.isRequired = error && error.required;
            this.cdr.markForCheck();
        }
    }
    setSelection(item) {
        if (item && item.value !== undefined && item.value !== null) {
            this.selection.set(this.id, new Set([item]));
        }
        else {
            this.selection.clear(this.id);
        }
    }
    /** @hidden @internal */
    onBlur() {
        this._onTouchedCallback();
        if (this.ngControl && !this.ngControl.valid) {
            this.input.valid = IgxInputState.INVALID;
        }
        else {
            this.input.valid = IgxInputState.INITIAL;
        }
        if (!this.collapsed) {
            this.toggleDirective.close();
        }
    }
    /** @hidden @internal */
    onFocus() {
        this._onTouchedCallback();
    }
    onStatusChanged() {
        if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
            (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
            if (this.inputGroup.isFocused) {
                this.input.valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                this.input.valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        this.manageRequiredAsterisk();
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this.ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            this.manageRequiredAsterisk();
        }
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.selection.clear(this.id);
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    }
    /**
     * @hidden @internal
     * Prevent input blur - closing the items container on Header/Footer Template click.
     */
    mousedownHandler(event) {
        event.preventDefault();
    }
};
IgxSelectComponent.ɵfac = function IgxSelectComponent_Factory(t) { return new (t || IgxSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
IgxSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSelectComponent, selectors: [["igx-select"]], contentQueries: function IgxSelectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectToggleIconDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectHeaderDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectFooterDirective, true, TemplateRef);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxLabelDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSelectItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleIconTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, viewQuery: function IgxSelectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c98, true, IgxInputGroupComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c33, true, IgxInputDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);
    } }, hostVars: 2, hostBindings: function IgxSelectComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
    } }, inputs: { disabled: "disabled", type: "type", value: "value", placeholder: "placeholder", overlaySettings: "overlaySettings" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent_1, multi: true },
            { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent_1 }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c104, decls: 19, vars: 17, consts: [[1, "input-group", 3, "type", "displayDensity", "click"], ["inputGroup", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["ngProjectAs", "igx-prefix", 5, ["igx-prefix"]], ["type", "text", "igxInput", "", "readonly", "true", "role", "combobox", "aria-haspopup", "listbox", 1, "input", 3, "igxSelectItemNavigation", "disabled", "value", "blur", "focus"], ["input", ""], ["ngProjectAs", "igx-suffix", 5, ["igx-suffix"]], [4, "ngIf"], ["fontSet", "material", 4, "ngIf"], ["igxToggle", "", 1, "igx-drop-down__list", 3, "mousedown", "onOpening", "onOpened", "onClosing", "onClosed"], ["class", "igx-drop-down__select-header", 4, "ngIf"], ["unselectable", "on", "role", "listbox", 1, "igx-drop-down__list-scroll"], ["scrollContainer", ""], ["class", "igx-drop-down__select-footer", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["fontSet", "material"], [1, "igx-drop-down__select-header"], [4, "ngTemplateOutlet"], [1, "igx-drop-down__select-footer"]], template: function IgxSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c103);
        ɵngcc0.ɵɵelementStart(0, "igx-input-group", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxSelectComponent_Template_igx_input_group_click_0_listener() { return ctx.toggle(); });
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainerStart(4, 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(6, "input", 4, 5);
        ɵngcc0.ɵɵlistener("blur", function IgxSelectComponent_Template_input_blur_6_listener() { return ctx.onBlur(); })("focus", function IgxSelectComponent_Template_input_focus_6_listener() { return ctx.onFocus(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerStart(8, 6);
        ɵngcc0.ɵɵprojection(9, 2);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(10, "igx-suffix");
        ɵngcc0.ɵɵtemplate(11, IgxSelectComponent_ng_container_11_Template, 2, 4, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(12, IgxSelectComponent_igx_icon_12_Template, 2, 1, "igx-icon", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(13, "div", 9);
        ɵngcc0.ɵɵlistener("mousedown", function IgxSelectComponent_Template_div_mousedown_13_listener($event) { return ctx.mousedownHandler($event); })("onOpening", function IgxSelectComponent_Template_div_onOpening_13_listener($event) { return ctx.onToggleOpening($event); })("onOpened", function IgxSelectComponent_Template_div_onOpened_13_listener() { return ctx.onToggleOpened(); })("onClosing", function IgxSelectComponent_Template_div_onClosing_13_listener($event) { return ctx.onToggleClosing($event); })("onClosed", function IgxSelectComponent_Template_div_onClosed_13_listener() { return ctx.onToggleClosed(); });
        ɵngcc0.ɵɵtemplate(14, IgxSelectComponent_div_14_Template, 2, 1, "div", 10);
        ɵngcc0.ɵɵelementStart(15, "div", 11, 12);
        ɵngcc0.ɵɵprojection(17, 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(18, IgxSelectComponent_div_18_Template, 2, 1, "div", 13);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("type", ctx.type)("displayDensity", ctx.displayDensity);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("igxSelectItemNavigation", ctx)("disabled", ctx.disabled)("value", ctx.selectionValue);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder)("aria-labelledby", ctx.label ? ctx.label.id : "")("aria-expanded", !ctx.collapsed)("aria-owns", ctx.listId)("aria-activedescendant", !ctx.collapsed ? ctx.focusedItem == null ? null : ctx.focusedItem.id : null);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.headerTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵattribute("id", ctx.listId);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.footerTemplate);
    } }, directives: function () { return [IgxInputGroupComponent,
        IgxInputDirective,
        IgxSelectItemNavigationDirective,
        IgxSuffixDirective, ɵngcc2.NgIf, IgxToggleDirective, ɵngcc2.NgTemplateOutlet, IgxIconComponent]; }, styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"] });
IgxSelectComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: Injector }
];
__decorate([
    ViewChild('inputGroup', { read: IgxInputGroupComponent, static: true })
], IgxSelectComponent.prototype, "inputGroup", void 0);
__decorate([
    ViewChild('input', { read: IgxInputDirective, static: true })
], IgxSelectComponent.prototype, "input", void 0);
__decorate([
    ContentChildren(forwardRef(() => IgxSelectItemComponent), { descendants: true })
], IgxSelectComponent.prototype, "children", void 0);
__decorate([
    ContentChild(forwardRef(() => IgxLabelDirective), { static: true })
], IgxSelectComponent.prototype, "label", void 0);
__decorate([
    Input()
], IgxSelectComponent.prototype, "value", null);
__decorate([
    Input()
], IgxSelectComponent.prototype, "placeholder", void 0);
__decorate([
    Input()
], IgxSelectComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxSelectComponent.prototype, "overlaySettings", void 0);
__decorate([
    HostBinding('style.maxHeight')
], IgxSelectComponent.prototype, "maxHeight", void 0);
__decorate([
    Input()
], IgxSelectComponent.prototype, "type", void 0);
__decorate([
    ContentChild(IgxSelectToggleIconDirective, { read: TemplateRef })
], IgxSelectComponent.prototype, "toggleIconTemplate", void 0);
__decorate([
    ContentChild(IgxSelectHeaderDirective, { read: TemplateRef, static: false })
], IgxSelectComponent.prototype, "headerTemplate", void 0);
__decorate([
    ContentChild(IgxSelectFooterDirective, { read: TemplateRef, static: false })
], IgxSelectComponent.prototype, "footerTemplate", void 0);
IgxSelectComponent = IgxSelectComponent_1 = __decorate([ __param(3, Optional()), __param(3, Inject(DisplayDensityToken))
], IgxSelectComponent);

/**
 * @hidden
 */
class ExpressionItem {
    constructor(parent) {
        this.parent = parent;
    }
}
/**
 * @hidden
 */
class ExpressionGroupItem extends ExpressionItem {
    constructor(operator, parent) {
        super(parent);
        this.operator = operator;
        this.children = [];
    }
}
/**
 * @hidden
 */
class ExpressionOperandItem extends ExpressionItem {
    constructor(expression, parent) {
        super(parent);
        this.expression = expression;
    }
}
/**
 * A component used for presenting advanced filtering UI for a Grid.
 * It is used internally in the Grid, but could also be hosted in a container outside of it.
 *
 * Example:
 * ```html
 * <igx-advanced-filtering-dialog
 *     [grid]="grid1">
 * </igx-advanced-filtering-dialog>
 * ```
 */
let IgxAdvancedFilteringDialogComponent = class IgxAdvancedFilteringDialogComponent {
    constructor(cdr) {
        this.cdr = cdr;
        /**
         * @hidden @internal
         */
        this.inline = true;
        /**
         * @hidden @internal
         */
        this.selectedExpressions = [];
        /**
         * @hidden @internal
         */
        this.selectedGroups = [];
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalStartPoint: VerticalAlignment.Top
        };
        this._overlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings),
            scrollStrategy: new CloseScrollStrategy()
        };
        /**
         * @hidden @internal
         */
        this.columnSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            excludePositionTarget: true
        };
        /**
         * @hidden @internal
         */
        this.conditionSelectOverlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            excludePositionTarget: true
        };
        /**
         * @hidden @internal
         */
        this.display = 'block';
        this.destroy$ = new Subject();
        this._dblClickDelay = 200;
        this._preventChipClick = false;
    }
    /**
     * @hidden @internal
     */
    set editingInputsContainer(value) {
        if ((value && !this._editingInputsContainer) ||
            (value && this._editingInputsContainer && this._editingInputsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._editingInputsContainer = value;
    }
    /**
     * @hidden @internal
     */
    get editingInputsContainer() {
        return this._editingInputsContainer;
    }
    /**
     * @hidden @internal
     */
    set addModeContainer(value) {
        if ((value && !this._addModeContainer) ||
            (value && this._addModeContainer && this._addModeContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._addModeContainer = value;
    }
    /**
     * @hidden @internal
     */
    get addModeContainer() {
        return this._addModeContainer;
    }
    /**
     * @hidden @internal
     */
    set currentGroupButtonsContainer(value) {
        if ((value && !this._currentGroupButtonsContainer) ||
            (value && this._currentGroupButtonsContainer && this._currentGroupButtonsContainer.nativeElement !== value.nativeElement)) {
            requestAnimationFrame(() => {
                this.scrollElementIntoView(value.nativeElement);
            });
        }
        this._currentGroupButtonsContainer = value;
    }
    /**
     * @hidden @internal
     */
    get currentGroupButtonsContainer() {
        return this._currentGroupButtonsContainer;
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        this._overlaySettings.outlet = this.overlayOutlet;
        this.columnSelectOverlaySettings.outlet = this.overlayOutlet;
        this.conditionSelectOverlaySettings.outlet = this.overlayOutlet;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden @internal
     */
    get displayDensity() {
        return this.grid.displayDensity;
    }
    /**
     * @hidden @internal
     */
    get selectedColumn() {
        return this._selectedColumn;
    }
    /**
     * @hidden @internal
     */
    set selectedColumn(value) {
        const oldValue = this._selectedColumn;
        if (this._selectedColumn !== value) {
            this._selectedColumn = value;
            if (oldValue && this._selectedColumn && this._selectedColumn.dataType !== oldValue.dataType) {
                this.selectedCondition = null;
                this.searchValue = null;
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * An @Input property that sets the grid.
     */
    set grid(grid) {
        this._grid = grid;
        if (this._filteringChange) {
            this._filteringChange.unsubscribe();
        }
        if (this._grid) {
            this._grid.filteringService.registerSVGIcons();
            this._filteringChange = this._grid.advancedFilteringExpressionsTreeChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this.init();
            });
            this.init();
        }
    }
    /**
     * Returns the grid.
     */
    get grid() {
        return this._grid;
    }
    /**
     * @hidden @internal
     */
    get filterableColumns() {
        return this.grid.columns.filter((col) => !col.columnGroup && col.filterable);
    }
    /**
     * @hidden @internal
     */
    dragStart(dragArgs) {
        if (!this._overlayComponentId) {
            dragArgs.cancel = true;
            return;
        }
        if (!this.contextMenuToggle.collapsed) {
            this.contextMenuToggle.element.style.display = 'none';
        }
    }
    /**
     * @hidden @internal
     */
    dragEnd(dragArgs) {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
            this.contextMenuToggle.element.style.display = '';
        }
    }
    /**
     * @hidden @internal
     */
    onDragMove(e) {
        const deltaX = e.nextPageX - e.pageX;
        const deltaY = e.nextPageY - e.pageY;
        e.cancel = true;
        this._overlayService.setOffset(this._overlayComponentId, deltaX, deltaY);
    }
    /**
     * @hidden @internal
     */
    addCondition(parent, afterExpression) {
        this.cancelOperandAdd();
        const operandItem = new ExpressionOperandItem({
            fieldName: null,
            condition: null,
            ignoreCase: true,
            searchVal: null
        }, parent);
        if (afterExpression) {
            const index = parent.children.indexOf(afterExpression);
            parent.children.splice(index + 1, 0, operandItem);
        }
        else {
            parent.children.push(operandItem);
        }
        this.enterExpressionEdit(operandItem);
    }
    /**
     * @hidden @internal
     */
    addAndGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.And, parent, afterExpression);
    }
    /**
     * @hidden @internal
     */
    addOrGroup(parent, afterExpression) {
        this.addGroup(FilteringLogic.Or, parent, afterExpression);
    }
    /**
     * @hidden @internal
     */
    endGroup(groupItem) {
        this.currentGroup = groupItem.parent;
    }
    /**
     * @hidden @internal
     */
    commitOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.expression.fieldName = this.selectedColumn.field;
            this.editedExpression.expression.condition = this.selectedColumn.filters.condition(this.selectedCondition);
            this.editedExpression.expression.searchVal = DataUtil.parseValue(this.selectedColumn.dataType, this.searchValue);
            this.editedExpression.columnHeader = this.selectedColumn.header;
            this.editedExpression.inEditMode = false;
            this.editedExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    cancelOperandAdd() {
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
            this.addModeExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    cancelOperandEdit() {
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
            if (!this.editedExpression.expression.fieldName) {
                this.deleteItem(this.editedExpression);
            }
            this.editedExpression = null;
        }
    }
    /**
     * @hidden @internal
     */
    operandCanBeCommitted() {
        return this.selectedColumn && this.selectedCondition &&
            (!!this.searchValue || this.selectedColumn.filters.condition(this.selectedCondition).isUnary);
    }
    /**
     * @hidden @internal
     */
    exitOperandEdit() {
        if (!this.editedExpression) {
            return;
        }
        if (this.operandCanBeCommitted()) {
            this.commitOperandEdit();
        }
        else {
            this.cancelOperandEdit();
        }
    }
    /**
     * @hidden @internal
     */
    isExpressionGroup(expression) {
        return expression instanceof ExpressionGroupItem;
    }
    addGroup(operator, parent, afterExpression) {
        this.cancelOperandAdd();
        const groupItem = new ExpressionGroupItem(operator, parent);
        if (parent) {
            if (afterExpression) {
                const index = parent.children.indexOf(afterExpression);
                parent.children.splice(index + 1, 0, groupItem);
            }
            else {
                parent.children.push(groupItem);
            }
        }
        else {
            this.rootGroup = groupItem;
        }
        this.addCondition(groupItem);
        this.currentGroup = groupItem;
    }
    createExpressionGroupItem(expressionTree, parent) {
        let groupItem;
        if (expressionTree) {
            groupItem = new ExpressionGroupItem(expressionTree.operator, parent);
            for (const expr of expressionTree.filteringOperands) {
                if (expr instanceof FilteringExpressionsTree) {
                    groupItem.children.push(this.createExpressionGroupItem(expr, groupItem));
                }
                else {
                    const filteringExpr = expr;
                    const exprCopy = {
                        fieldName: filteringExpr.fieldName,
                        condition: filteringExpr.condition,
                        searchVal: filteringExpr.searchVal,
                        ignoreCase: filteringExpr.ignoreCase
                    };
                    const operandItem = new ExpressionOperandItem(exprCopy, groupItem);
                    const column = this.grid.getColumnByName(filteringExpr.fieldName);
                    operandItem.columnHeader = column.header;
                    groupItem.children.push(operandItem);
                }
            }
        }
        return groupItem;
    }
    createExpressionsTreeFromGroupItem(groupItem) {
        if (!groupItem) {
            return null;
        }
        const expressionsTree = new FilteringExpressionsTree(groupItem.operator);
        for (const item of groupItem.children) {
            if (item instanceof ExpressionGroupItem) {
                const subTree = this.createExpressionsTreeFromGroupItem(item);
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                expressionsTree.filteringOperands.push(item.expression);
            }
        }
        return expressionsTree;
    }
    /**
     * @hidden @internal
     */
    onChipRemove(expressionItem) {
        this.deleteItem(expressionItem);
    }
    /**
     * @hidden @internal
     */
    onChipClick(expressionItem) {
        this._clickTimer = setTimeout(() => {
            if (!this._preventChipClick) {
                this.onToggleExpression(expressionItem);
            }
            this._preventChipClick = false;
        }, this._dblClickDelay);
    }
    /**
     * @hidden @internal
     */
    onChipDblClick(expressionItem) {
        clearTimeout(this._clickTimer);
        this._preventChipClick = true;
        this.enterExpressionEdit(expressionItem);
    }
    /**
     * @hidden @internal
     */
    enterExpressionEdit(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        this.cancelOperandAdd();
        if (this.editedExpression) {
            this.editedExpression.inEditMode = false;
        }
        expressionItem.hovered = false;
        this.selectedColumn = expressionItem.expression.fieldName ?
            this.grid.getColumnByName(expressionItem.expression.fieldName) : null;
        this.selectedCondition = expressionItem.expression.condition ?
            expressionItem.expression.condition.name : null;
        this.searchValue = expressionItem.expression.searchVal;
        expressionItem.inEditMode = true;
        this.editedExpression = expressionItem;
        this.cdr.detectChanges();
        this.columnSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({ target: this.columnSelect.element });
        this.conditionSelectOverlaySettings.positionStrategy = new AutoPositionStrategy({ target: this.conditionSelect.element });
        if (!this.selectedColumn) {
            this.columnSelect.input.nativeElement.focus();
        }
        else if (this.selectedColumn.filters.condition(this.selectedCondition).isUnary) {
            this.conditionSelect.input.nativeElement.focus();
        }
        else {
            this.searchValueInput.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    clearSelection() {
        for (const group of this.selectedGroups) {
            group.selected = false;
        }
        this.selectedGroups = [];
        for (const expr of this.selectedExpressions) {
            expr.selected = false;
        }
        this.selectedExpressions = [];
        this.toggleContextMenu();
    }
    /**
     * @hidden @internal
     */
    enterExpressionAdd(expressionItem) {
        this.clearSelection();
        this.exitOperandEdit();
        if (this.addModeExpression) {
            this.addModeExpression.inAddMode = false;
        }
        expressionItem.inAddMode = true;
        this.addModeExpression = expressionItem;
        if (expressionItem.selected) {
            this.toggleExpression(expressionItem);
        }
    }
    onToggleExpression(expressionItem) {
        this.exitOperandEdit();
        this.toggleExpression(expressionItem);
        this.toggleContextMenu();
    }
    toggleExpression(expressionItem) {
        expressionItem.selected = !expressionItem.selected;
        if (expressionItem.selected) {
            this.selectedExpressions.push(expressionItem);
        }
        else {
            const index = this.selectedExpressions.indexOf(expressionItem);
            this.selectedExpressions.splice(index, 1);
            this.deselectParentRecursive(expressionItem);
        }
    }
    /**
     * @hidden @internal
     */
    contextMenuClosed() {
        this.contextualGroup = null;
    }
    toggleContextMenu() {
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            if (contextualGroup) {
                this.filteringLogics = [
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_and,
                        selected: contextualGroup.operator === FilteringLogic.And
                    },
                    {
                        label: this.grid.resourceStrings.igx_grid_filter_operator_or,
                        selected: contextualGroup.operator === FilteringLogic.Or
                    }
                ];
            }
        }
        else if (this.contextMenuToggle) {
            this.contextMenuToggle.close();
        }
    }
    findSingleSelectedGroup() {
        for (const group of this.selectedGroups) {
            const containsAllSelectedExpressions = this.selectedExpressions.every(op => this.isInsideGroup(op, group));
            if (containsAllSelectedExpressions) {
                return group;
            }
        }
        return null;
    }
    isInsideGroup(item, group) {
        if (!item) {
            return false;
        }
        if (item.parent === group) {
            return true;
        }
        return this.isInsideGroup(item.parent, group);
    }
    deleteItem(expressionItem) {
        if (!expressionItem.parent) {
            this.rootGroup = null;
            this.currentGroup = null;
            return;
        }
        if (expressionItem === this.currentGroup) {
            this.currentGroup = this.currentGroup.parent;
        }
        const children = expressionItem.parent.children;
        const index = children.indexOf(expressionItem);
        children.splice(index, 1);
        if (!children.length) {
            this.deleteItem(expressionItem.parent);
        }
    }
    /**
     * @hidden @internal
     */
    onKeyDown(eventArgs) {
        eventArgs.stopPropagation();
        const key = eventArgs.key;
        if (!this.contextMenuToggle.collapsed && (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */)) {
            this.clearSelection();
        }
        else if (key === "Escape" /* ESCAPE */ || key === "Esc" /* ESCAPE_IE */) {
            this.closeDialog();
        }
    }
    /**
     * @hidden @internal
     */
    createAndGroup() {
        this.createGroup(FilteringLogic.And);
    }
    /**
     * @hidden @internal
     */
    createOrGroup() {
        this.createGroup(FilteringLogic.Or);
    }
    createGroup(operator) {
        const chips = this.chips.toArray();
        const minIndex = this.selectedExpressions.reduce((i, e) => Math.min(i, chips.findIndex(c => c.data === e)), Number.MAX_VALUE);
        const firstExpression = chips[minIndex].data;
        const parent = firstExpression.parent;
        const groupItem = new ExpressionGroupItem(operator, parent);
        const index = parent.children.indexOf(firstExpression);
        parent.children.splice(index, 0, groupItem);
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
            groupItem.children.push(expr);
            expr.parent = groupItem;
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    deleteFilters() {
        for (const expr of this.selectedExpressions) {
            this.deleteItem(expr);
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    onGroupClick(groupItem) {
        this.toggleGroup(groupItem);
    }
    toggleGroup(groupItem) {
        this.exitOperandEdit();
        if (groupItem.children && groupItem.children.length) {
            this.toggleGroupRecursive(groupItem, !groupItem.selected);
            if (!groupItem.selected) {
                this.deselectParentRecursive(groupItem);
            }
            this.toggleContextMenu();
        }
    }
    toggleGroupRecursive(groupItem, selected) {
        if (groupItem.selected !== selected) {
            groupItem.selected = selected;
            if (groupItem.selected) {
                this.selectedGroups.push(groupItem);
            }
            else {
                const index = this.selectedGroups.indexOf(groupItem);
                this.selectedGroups.splice(index, 1);
            }
        }
        for (const expr of groupItem.children) {
            if (expr instanceof ExpressionGroupItem) {
                this.toggleGroupRecursive(expr, selected);
            }
            else {
                const operandExpression = expr;
                if (operandExpression.selected !== selected) {
                    this.toggleExpression(operandExpression);
                }
            }
        }
    }
    deselectParentRecursive(expressionItem) {
        const parent = expressionItem.parent;
        if (parent) {
            if (parent.selected) {
                parent.selected = false;
                const index = this.selectedGroups.indexOf(parent);
                this.selectedGroups.splice(index, 1);
            }
            this.deselectParentRecursive(parent);
        }
    }
    calculateContextMenuTarget() {
        const containerRect = this.expressionsContainer.nativeElement.getBoundingClientRect();
        const chips = this.chips.filter(c => this.selectedExpressions.indexOf(c.data) !== -1);
        let minTop = chips.reduce((t, c) => Math.min(t, c.elementRef.nativeElement.getBoundingClientRect().top), Number.MAX_VALUE);
        minTop = Math.max(containerRect.top, minTop);
        minTop = Math.min(containerRect.bottom, minTop);
        let maxRight = chips.reduce((r, c) => Math.max(r, c.elementRef.nativeElement.getBoundingClientRect().right), 0);
        maxRight = Math.max(maxRight, containerRect.left);
        maxRight = Math.min(maxRight, containerRect.right);
        this._overlaySettings.positionStrategy.settings.target = new Point(maxRight, minTop);
    }
    scrollElementIntoView(target) {
        const container = this.expressionsContainer.nativeElement;
        const targetOffset = target.offsetTop - container.offsetTop;
        const delta = 10;
        if (container.scrollTop + delta > targetOffset) {
            container.scrollTop = targetOffset - delta;
        }
        else if (container.scrollTop + container.clientHeight < targetOffset + target.offsetHeight + delta) {
            container.scrollTop = targetOffset + target.offsetHeight + delta - container.clientHeight;
        }
    }
    /**
     * @hidden @internal
     */
    ungroup() {
        const selectedGroup = this.contextualGroup;
        const parent = selectedGroup.parent;
        if (parent) {
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1, ...selectedGroup.children);
            for (const expr of selectedGroup.children) {
                expr.parent = parent;
            }
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    deleteGroup() {
        const selectedGroup = this.contextualGroup;
        const parent = selectedGroup.parent;
        if (parent) {
            const index = parent.children.indexOf(selectedGroup);
            parent.children.splice(index, 1);
        }
        else {
            this.rootGroup = null;
        }
        this.clearSelection();
    }
    /**
     * @hidden @internal
     */
    selectFilteringLogic(event) {
        this.contextualGroup.operator = event.index;
    }
    /**
     * @hidden @internal
     */
    getConditionFriendlyName(name) {
        return this.grid.resourceStrings[`igx_grid_filter_${name}`] || name;
    }
    /**
     * @hidden @internal
     */
    isDate(value) {
        return value instanceof Date;
    }
    /**
     * @hidden @internal
     */
    onExpressionsScrolled() {
        if (!this.contextMenuToggle.collapsed) {
            this.calculateContextMenuTarget();
            this.contextMenuToggle.reposition();
        }
    }
    /**
     * @hidden @internal
     */
    invokeClick(eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            eventArgs.currentTarget.click();
        }
    }
    /**
     * @hidden @internal
     */
    onOutletPointerDown(event) {
        // This prevents closing the select's dropdown when clicking the scroll
        event.preventDefault();
    }
    /**
     * @hidden @internal
     */
    getConditionList() {
        return this.selectedColumn ? this.selectedColumn.filters.conditionList() : [];
    }
    /**
     * @hidden @internal
     */
    initialize(grid, overlayService, overlayComponentId) {
        this.inline = false;
        this.grid = grid;
        this._overlayService = overlayService;
        this._overlayComponentId = overlayComponentId;
    }
    /**
     * @hidden @internal
     */
    setAddButtonFocus() {
        if (this.addRootAndGroupButton) {
            this.addRootAndGroupButton.nativeElement.focus();
        }
        else if (this.addConditionButton) {
            this.addConditionButton.nativeElement.focus();
        }
    }
    init() {
        this.clearSelection();
        this.cancelOperandAdd();
        this.cancelOperandEdit();
        this.rootGroup = this.createExpressionGroupItem(this.grid.advancedFilteringExpressionsTree);
        this.currentGroup = this.rootGroup;
    }
    /**
     * @hidden @internal
     */
    context(expression, afterExpression) {
        return {
            $implicit: expression,
            afterExpression
        };
    }
    /**
     * @hidden @internal
     */
    onClearButtonClick() {
        this.grid.endEdit(false);
        this.grid.advancedFilteringExpressionsTree = null;
    }
    /**
     * @hidden @internal
     */
    closeDialog() {
        if (this._overlayComponentId) {
            this._overlayService.hide(this._overlayComponentId);
        }
        if (this.grid.navigation.activeNode && this.grid.navigation.activeNode.row === -1) {
            this.grid.theadRow.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    applyChanges() {
        this.grid.endEdit(false);
        this.exitOperandEdit();
        this.grid.advancedFilteringExpressionsTree = this.createExpressionsTreeFromGroupItem(this.rootGroup);
    }
    /**
     * @hidden @internal
     */
    cancelChanges() {
        if (!this._overlayComponentId) {
            this.init();
        }
        this.closeDialog();
    }
    /**
     * @hidden @internal
     */
    onApplyButtonClick() {
        this.applyChanges();
        this.closeDialog();
    }
    /**
     * @hidden @internal
     */
    onChipSelectionEnd() {
        const contextualGroup = this.findSingleSelectedGroup();
        if (contextualGroup || this.selectedExpressions.length > 1) {
            this.contextualGroup = contextualGroup;
            this.calculateContextMenuTarget();
            if (this.contextMenuToggle.collapsed) {
                this.contextMenuToggle.open(this._overlaySettings);
            }
            else {
                this.contextMenuToggle.reposition();
            }
        }
    }
};
IgxAdvancedFilteringDialogComponent.ɵfac = function IgxAdvancedFilteringDialogComponent_Factory(t) { return new (t || IgxAdvancedFilteringDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxAdvancedFilteringDialogComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxAdvancedFilteringDialogComponent, selectors: [["igx-advanced-filtering-dialog"]], viewQuery: function IgxAdvancedFilteringDialogComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c105, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c106, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c107, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c108, true, IgxSelectComponent);
        ɵngcc0.ɵɵviewQuery(_c109, true, IgxSelectComponent);
        ɵngcc0.ɵɵviewQuery(_c110, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c111, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c112, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵviewQuery(_c60, true);
        ɵngcc0.ɵɵstaticViewQuery(_c113, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵviewQuery(IgxChipComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.editingInputsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addModeContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.currentGroupButtonsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnSelect = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.conditionSelect = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchValueInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addRootAndGroupButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addConditionButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contextMenuToggle = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expressionsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayOutlet = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chips = _t);
    } }, hostVars: 2, hostBindings: function IgxAdvancedFilteringDialogComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.display);
    } }, inputs: { grid: "grid" }, decls: 3, vars: 1, consts: [["class", "igx-advanced-filter", "igxDrag", "", 3, "ghost", "dragTolerance", "ngClass", "dragStart", "dragEnd", "dragMove", "keydown", 4, "ngIf"], ["igxOverlayOutlet", "", 1, "igx-advanced-filter__outlet", 3, "pointerdown"], ["overlayOutlet", ""], ["igxDrag", "", 1, "igx-advanced-filter", 3, "ghost", "dragTolerance", "ngClass", "dragStart", "dragEnd", "dragMove", "keydown"], ["igxDragHandle", "", 1, "igx-advanced-filter__header"], [1, "igx-typography__h6", 2, "pointer-events", "none"], [1, "igx-filter-legend"], [1, "igx-filter-legend__item--and"], [1, "igx-filter-legend__item--or"], [1, "igx-advanced-filter__main", 3, "scroll"], ["expressionsContainer", ""], [4, "ngIf"], ["addExpressionsTemplate", ""], ["filterOperandTemplate", ""], ["expressionTreeTemplate", ""], ["igxToggle", "", 1, "igx-filter-contextual-menu", 3, "ngClass", "keydown", "onClosed"], ["igxButton", "icon", 1, "igx-filter-contextual-menu__close-btn", 3, "click"], [1, "igx-excel-filter__secondary-footer"], ["igxButton", "", 3, "displayDensity", "click"], ["igxButton", "raised", 3, "displayDensity", "click"], ["igxButton", "outlined", 3, "displayDensity", "click"], ["addRootAndGroupButton", ""], ["fontSet", "material"], [1, "igx-filter-empty"], [1, "igx-filter-empty__title"], ["igxButton", "outlined", 3, "displayDensity", "disabled", "click"], ["addConditionButton", ""], ["class", "igx-filter-tree__expression-item", 3, "mouseenter", "mouseleave", 4, "ngIf"], ["class", "igx-filter-tree__inputs", 4, "ngIf"], ["class", "igx-filter-tree__buttons", 4, "ngIf"], [1, "igx-filter-tree__expression-item", 3, "mouseenter", "mouseleave"], [3, "data", "displayDensity", "removable", "selected", "keydown", "click", "dblclick", "onRemove", "onSelectionDone"], ["igxPrefix", "", 1, "igx-filter-tree__expression-column"], ["igxPrefix", "", "fontSet", "filtering-icons", 3, "name"], [1, "igx-filter-tree__expression-condition"], ["igxSuffix", "", 4, "ngIf"], ["class", "igx-filter-tree__expression-actions", 4, "ngIf"], ["igxSuffix", ""], [1, "igx-filter-tree__expression-actions"], ["tabindex", "0", 3, "keydown", "click"], ["tabindex", "0", 3, "keydown", "click", 4, "ngIf"], [1, "igx-filter-tree__inputs"], ["editingInputsContainer", ""], ["type", "box", 3, "displayDensity", "overlaySettings", "placeholder", "ngModel", "ngModelChange"], ["columnSelect", ""], [3, "value", 4, "ngFor", "ngForOf"], ["type", "box", 3, "displayDensity", "overlaySettings", "placeholder", "ngModel", "disabled", "ngModelChange"], ["conditionSelect", ""], ["igxPrefix", "", "fontSet", "filtering-icons", 3, "name", 4, "ngIf"], ["type", "box", 3, "disabled", "displayDensity", 4, "ngIf"], ["mode", "dropdown", 3, "ngModel", "locale", "outlet", "ngModelChange", 4, "ngIf"], [1, "igx-filter-tree__inputs-actions"], ["igxButton", "icon", 3, "displayDensity", "disabled", "click"], ["igxButton", "icon", 3, "displayDensity", "click"], [3, "value"], ["fontSet", "filtering-icons", 3, "name"], ["type", "box", 3, "disabled", "displayDensity"], ["igxInput", "", 3, "type", "placeholder", "ngModel", "ngModelChange"], ["searchValueInput", ""], ["mode", "dropdown", 3, "ngModel", "locale", "outlet", "ngModelChange"], ["igxDatePickerTemplate", ""], ["type", "box", 3, "displayDensity"], ["dropDownTarget", ""], ["igxInput", "", "tabindex", "0", "autocomplete", "off", 3, "placeholder", "value", "readonly", "disabled", "keydown", "click"], [1, "igx-filter-tree__buttons"], ["addModeContainer", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-filter-tree"], ["tabindex", "0", 1, "igx-filter-tree__line", 3, "ngClass", "keydown", "click"], [1, "igx-filter-tree__expression"], [4, "ngFor", "ngForOf"], ["currentGroupButtonsContainer", ""], ["igxButton", "outlined", 3, "displayDensity", "disabled", "click", 4, "ngIf"], ["type", "outline", 3, "displayDensity", "multiSelection", "values", "onSelect"], ["fontSet", "filtering-icons", "name", "ungroup"], ["igxButton", "outlined", 1, "igx-filter-contextual-menu__delete-btn", 3, "displayDensity", "click"]], template: function IgxAdvancedFilteringDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxAdvancedFilteringDialogComponent_article_0_Template, 35, 24, "article", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵlistener("pointerdown", function IgxAdvancedFilteringDialogComponent_Template_div_pointerdown_1_listener($event) { return ctx.onOutletPointerDown($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid);
    } }, directives: [ɵngcc2.NgIf, IgxOverlayOutletDirective,
        IgxDragDirective, ɵngcc2.NgClass, IgxDragHandleDirective,
        IgxToggleDirective,
        IgxButtonDirective,
        IgxIconComponent,
        IgxChipComponent,
        IgxPrefixDirective,
        IgxSuffixDirective,
        IgxSelectComponent, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, ɵngcc2.NgForOf, IgxSelectItemComponent,
        IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective,
        IgxDatePickerComponent,
        IgxDatePickerTemplateDirective, ɵngcc2.NgTemplateOutlet, IgxButtonGroupComponent], pipes: [IgxDatePipeComponent], encapsulation: 2 });
IgxAdvancedFilteringDialogComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
__decorate([
    ViewChild('columnSelect', { read: IgxSelectComponent })
], IgxAdvancedFilteringDialogComponent.prototype, "columnSelect", void 0);
__decorate([
    ViewChild('conditionSelect', { read: IgxSelectComponent })
], IgxAdvancedFilteringDialogComponent.prototype, "conditionSelect", void 0);
__decorate([
    ViewChild('searchValueInput', { read: ElementRef })
], IgxAdvancedFilteringDialogComponent.prototype, "searchValueInput", void 0);
__decorate([
    ViewChild('addRootAndGroupButton', { read: ElementRef })
], IgxAdvancedFilteringDialogComponent.prototype, "addRootAndGroupButton", void 0);
__decorate([
    ViewChild('addConditionButton', { read: ElementRef })
], IgxAdvancedFilteringDialogComponent.prototype, "addConditionButton", void 0);
__decorate([
    ViewChild('editingInputsContainer', { read: ElementRef })
], IgxAdvancedFilteringDialogComponent.prototype, "editingInputsContainer", null);
__decorate([
    ViewChild('addModeContainer', { read: ElementRef })
], IgxAdvancedFilteringDialogComponent.prototype, "addModeContainer", null);
__decorate([
    ViewChild('currentGroupButtonsContainer', { read: ElementRef })
], IgxAdvancedFilteringDialogComponent.prototype, "currentGroupButtonsContainer", null);
__decorate([
    ViewChild(IgxToggleDirective)
], IgxAdvancedFilteringDialogComponent.prototype, "contextMenuToggle", void 0);
__decorate([
    ViewChildren(IgxChipComponent)
], IgxAdvancedFilteringDialogComponent.prototype, "chips", void 0);
__decorate([
    ViewChild('expressionsContainer')
], IgxAdvancedFilteringDialogComponent.prototype, "expressionsContainer", void 0);
__decorate([
    ViewChild('overlayOutlet', { read: IgxOverlayOutletDirective, static: true })
], IgxAdvancedFilteringDialogComponent.prototype, "overlayOutlet", void 0);
__decorate([
    HostBinding('style.display')
], IgxAdvancedFilteringDialogComponent.prototype, "display", void 0);
__decorate([
    Input()
], IgxAdvancedFilteringDialogComponent.prototype, "grid", null);

/**
 * @hidden
 * @internal
 */
let IgxRowSelectorDirective = class IgxRowSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
IgxRowSelectorDirective.ɵfac = function IgxRowSelectorDirective_Factory(t) { return new (t || IgxRowSelectorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxRowSelectorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowSelectorDirective, selectors: [["", "igxRowSelector", ""]] });
IgxRowSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * @hidden
 * @internal
 */
let IgxHeadSelectorDirective = class IgxHeadSelectorDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
IgxHeadSelectorDirective.ɵfac = function IgxHeadSelectorDirective_Factory(t) { return new (t || IgxHeadSelectorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxHeadSelectorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHeadSelectorDirective, selectors: [["", "igxHeadSelector", ""]] });
IgxHeadSelectorDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * The IgxGridToolbarCustomContentDirective directive is used to mark an 'ng-template' (with
 * the 'igxToolbarCustomContent' selector) defined in the IgxGrid which is used to provide
 * custom content for cener part of the IgxGridToolbar.
 */
let IgxGridToolbarCustomContentDirective = class IgxGridToolbarCustomContentDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxGridToolbarCustomContentDirective.ɵfac = function IgxGridToolbarCustomContentDirective_Factory(t) { return new (t || IgxGridToolbarCustomContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxGridToolbarCustomContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridToolbarCustomContentDirective, selectors: [["", "igxToolbarCustomContent", ""]] });
IgxGridToolbarCustomContentDirective.ctorParameters = () => [
    { type: TemplateRef }
];

var IgxColumnGroupComponent_1;
let IgxColumnGroupComponent = IgxColumnGroupComponent_1 = class IgxColumnGroupComponent extends IgxColumnComponent {
    constructor() {
        super(...arguments);
        this.children = new QueryList();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * @memberof IgxColumnGroupComponent
         */
        this.searchable = true;
        /**
         * @hidden
         */
        this.hiddenChange = new EventEmitter();
        // constructor(public gridAPI: GridBaseAPIService<IgxGridBaseDirective & IGridDataBindable>, public cdr: ChangeDetectorRef) {
        //     // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        //     super(gridAPI, cdr);
        // }
    }
    /**
     * Set if the column group is collapsible.
     * Default value is `false`
     * ```html
     *  <igx-column-group [collapsible] = "true"></igx-column-group>
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set collapsible(value) {
        this._collapsible = value;
        this.collapsibleChange.emit(this._collapsible);
        if (this.children && !this.hidden) {
            if (this._collapsible) {
                this.setExpandCollapseState();
            }
            else {
                this.children.forEach(child => child.hidden = false);
            }
        }
    }
    get collapsible() {
        return this._collapsible && this.checkCollapsibleState();
    }
    /**
     * Set whether the group is expanded or collapsed initially.
     * Applied only if the collapsible property is set to `true`
     * Default value is `true`
     * ```html
     *  const state = false
     *  <igx-column-group [(expand)] = "state"></igx-column-group>
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set expanded(value) {
        this._expanded = value;
        this.expandedChange.emit(this._expanded);
        if (!this.collapsible) {
            return;
        }
        if (!this.hidden && this.children) {
            this.setExpandCollapseState();
        }
    }
    get expanded() {
        return this._expanded;
    }
    /**
     * Gets the column group `summaries`.
     * ```typescript
     * let columnGroupSummaries = this.columnGroup.summaries;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get summaries() {
        return this._summaries;
    }
    /**
     * Sets the column group `summaries`.
     * ```typescript
     * this.columnGroup.summaries = IgxNumberSummaryOperand;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set summaries(classRef) { }
    /**
     * Gets the column group `filters`.
     * ```typescript
     * let columnGroupFilters = this.columnGroup.filters;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get filters() {
        return this._filters;
    }
    /**
     * Sets the column group `filters`.
     * ```typescript
     * this.columnGroup.filters = IgxStringFilteringOperand;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set filters(classRef) { }
    /**
     * Returns if the column group is selectable
     * ```typescript
     * let columnGroupSelectable = this.columnGroup.selectable;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get selectable() {
        return this.children && this.children.some(child => child.selectable);
    }
    set selectable(value) { }
    /**
     * Returns a reference to the body template.
     * ```typescript
     * let bodyTemplate = this.columnGroup.bodyTemplate;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get bodyTemplate() {
        return this._bodyTemplate;
    }
    /**
     * @hidden
     */
    set bodyTemplate(template) { }
    /**
     * Allows you to define a custom template for expand/collapse indicator
     * @memberof IgxColumnGroupComponent
     */
    get collapsibleIndicatorTemplate() {
        return this._collapseIndicatorTemplate;
    }
    set collapsibleIndicatorTemplate(template) {
        this._collapseIndicatorTemplate = template;
    }
    /**
     * Returns a reference to the inline editor template.
     * ```typescript
     * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get inlineEditorTemplate() {
        return this._inlineEditorTemplate;
    }
    /**
     * @hidden
     */
    set inlineEditorTemplate(template) { }
    /**
     * Gets the column group cells.
     * ```typescript
     * let columnCells = this.columnGroup.cells;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get cells() {
        return [];
    }
    /**
     * Gets whether the column group is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get hidden() {
        return this.allChildren.every(c => c.hidden);
    }
    /**
     * Sets the column group hidden property.
     * ```html
     * <igx-column [hidden] = "true"></igx-column>
     * ```
     *
     * Two-way data binding
     * ```html
     * <igx-column [(hidden)] = "model.columns[0].isHidden"></igx-column>
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set hidden(value) {
        this._hidden = value;
        this.hiddenChange.emit(this._hidden);
        if (this._hidden || !this.collapsible) {
            this.children.forEach(child => child.hidden = this._hidden);
        }
        else {
            this.children.forEach(c => {
                if (c.visibleWhenCollapsed === undefined) {
                    c.hidden = false;
                    return;
                }
                c.hidden = this.expanded ? c.visibleWhenCollapsed : !c.visibleWhenCollapsed;
            });
        }
    }
    /**
     * Returns if the column group is selected.
     * ```typescript
     * let isSelected = this.columnGroup.selected;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get selected() {
        const selectableChildren = this.allChildren.filter(c => !c.columnGroup && c.selectable && !c.hidden);
        return selectableChildren.length > 0 && selectableChildren.every(c => c.selected);
    }
    /**
     * Select/deselect the column group.
     * ```typescript
     * this.columnGroup.selected = true;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set selected(value) {
        if (this.selectable) {
            this.children.forEach(c => {
                c.selected = value;
            });
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        if (this.headTemplate && this.headTemplate.length) {
            this._headerTemplate = this.headTemplate.toArray()[0].template;
        }
        if (this.collapseIndicatorTemplate) {
            this._collapseIndicatorTemplate = this.collapseIndicatorTemplate.template;
        }
        // currently only ivy fixes the issue, we have to slice only if the first child is group
        if (this.children.first === this) {
            this.children.reset(this.children.toArray().slice(1));
        }
        this.children.forEach(child => {
            child.parent = this;
        });
        if (this.collapsible) {
            this.setExpandCollapseState();
        }
    }
    /**
     * Returns the children columns collection.
     * ```typescript
     * let columns =  this.columnGroup.allChildren;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get allChildren() {
        return flatten(this.children.toArray());
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnGroup`.
     * ```typescript
     * let isColumnGroup =  this.columnGroup.columnGroup
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get columnGroup() {
        return true;
    }
    /**
     * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
     * ```typescript
     * let columnGroup =  this.column.columnGroup;
     * ```
     * @memberof IgxColumnComponent
     */
    get columnLayout() {
        return false;
    }
    /**
     * Gets the width of the column group.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get width() {
        let isChildrenWidthInPercent = false, width;
        width = `${this.children.reduce((acc, val) => {
            if (val.hidden) {
                return acc;
            }
            if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
                isChildrenWidthInPercent = true;
                return acc + parseInt(val.width, 10);
            }
            return acc + parseInt(val.calcWidth, 10);
        }, 0)}`;
        return isChildrenWidthInPercent ? width + '%' : width + 'px';
    }
    set width(val) { }
    /**
     * @hidden
     */
    get applySelectableClass() {
        return this._applySelectableClass;
    }
    /**
     * @hidden
     */
    set applySelectableClass(value) {
        if (this.selectable) {
            this._applySelectableClass = value;
            this.children.forEach(c => {
                c.applySelectableClass = value;
            });
        }
    }
};
IgxColumnGroupComponent.ɵfac = function IgxColumnGroupComponent_Factory(t) { return ɵIgxColumnGroupComponent_BaseFactory(t || IgxColumnGroupComponent); };
IgxColumnGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnGroupComponent, selectors: [["igx-column-group"]], contentQueries: function IgxColumnGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, false, IgxColumnComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, inputs: { searchable: "searchable", collapsible: "collapsible", expanded: "expanded", summaries: "summaries", filters: "filters", collapsibleIndicatorTemplate: "collapsibleIndicatorTemplate", hidden: "hidden" }, outputs: { hiddenChange: "hiddenChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnGroupComponent_1) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IgxColumnGroupComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ContentChildren(IgxColumnComponent, { read: IgxColumnComponent })
], IgxColumnGroupComponent.prototype, "children", void 0);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "collapsible", null);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "expanded", null);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "summaries", null);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "searchable", void 0);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "filters", null);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "collapsibleIndicatorTemplate", null);
__decorate([
    Input()
], IgxColumnGroupComponent.prototype, "hidden", null);
__decorate([
    Output()
], IgxColumnGroupComponent.prototype, "hiddenChange", void 0);

const ghostBackgroundClass = 'igx-grid__tr--ghost';
const gridCellClass = 'igx-grid__td';
const rowSelectedClass = 'igx-grid__tr--selected';
const cellSelectedClass = 'igx-grid__td--selected';
const cellActiveClass = 'igx-grid__td--active';
/**
 * @hidden
 */
let IgxRowDragDirective = class IgxRowDragDirective extends IgxDragDirective {
    constructor() {
        super(...arguments);
        this._rowDragStarted = false;
        this.transitionEndEvent = (evt) => {
            if (this.ghostElement) {
                this.ghostElement.removeEventListener('transitionend', this.transitionEndEvent, false);
            }
            this.endDragging();
        };
    }
    set data(val) {
        this.row = val;
    }
    get data() {
        return this.row;
    }
    onPointerDown(event) {
        event.preventDefault();
        this._rowDragStarted = false;
        this._removeOnDestroy = false;
        super.onPointerDown(event);
    }
    onPointerMove(event) {
        super.onPointerMove(event);
        if (this._dragStarted && !this._rowDragStarted) {
            this._rowDragStarted = true;
            const args = {
                dragDirective: this,
                dragData: this.row,
                cancel: false,
                owner: this.row.grid
            };
            this.row.grid.onRowDragStart.emit(args);
            if (args.cancel) {
                this.ghostElement.parentNode.removeChild(this.ghostElement);
                this.ghostElement = null;
                this._dragStarted = false;
                this._clicked = false;
                return;
            }
            this.row.dragging = true;
            this.row.grid.rowDragging = true;
            this.row.grid.markForCheck();
            this.subscription$ = fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe((ev) => {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    this._lastDropArea = false;
                    this.onPointerUp(event);
                }
            });
        }
    }
    onPointerUp(event) {
        if (!this._clicked) {
            return;
        }
        const args = {
            dragDirective: this,
            dragData: this.row,
            animation: false,
            owner: this.row.grid
        };
        this.zone.run(() => {
            this.row.grid.onRowDragEnd.emit(args);
        });
        const dropArea = this._lastDropArea;
        super.onPointerUp(event);
        if (!dropArea && this.ghostElement) {
            this.ghostElement.addEventListener('transitionend', this.transitionEndEvent, false);
        }
        else {
            this.endDragging();
        }
    }
    createGhost(pageX, pageY) {
        this.row.grid.endEdit(true);
        this.row.grid.markForCheck();
        this.ghostContext = {
            $implicit: this.row.rowData,
            data: this.row.rowData,
            grid: this.row.grid
        };
        super.createGhost(pageX, pageY, this.row.nativeElement);
        // check if there is an expander icon and create the ghost at the corresponding position
        if (this.isHierarchicalGrid) {
            const row = this.row;
            if (row.expander) {
                const expanderWidth = row.expander.nativeElement.getBoundingClientRect().width;
                this._ghostHostX += expanderWidth;
            }
        }
        const ghost = this.ghostElement;
        const gridRect = this.row.grid.nativeElement.getBoundingClientRect();
        const rowRect = this.row.nativeElement.getBoundingClientRect();
        ghost.style.overflow = 'hidden';
        ghost.style.width = gridRect.width + 'px';
        ghost.style.height = rowRect.height + 'px';
        this.renderer.addClass(ghost, ghostBackgroundClass);
        this.renderer.removeClass(ghost, rowSelectedClass);
        const ghostCells = ghost.getElementsByClassName(gridCellClass);
        for (let index = 0; index < ghostCells.length; index++) {
            this.renderer.removeClass(ghostCells[index], cellSelectedClass);
            this.renderer.removeClass(ghostCells[index], cellActiveClass);
        }
    }
    _unsubscribe() {
        if (this.subscription$ && !this.subscription$.closed) {
            this.subscription$.unsubscribe();
        }
    }
    endDragging() {
        this.onTransitionEnd(null);
        this.row.dragging = false;
        this.row.grid.rowDragging = false;
        this.row.grid.markForCheck();
        this._unsubscribe();
    }
    get isHierarchicalGrid() {
        return this.row.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
    }
};
IgxRowDragDirective.ɵfac = function IgxRowDragDirective_Factory(t) { return ɵIgxRowDragDirective_BaseFactory(t || IgxRowDragDirective); };
IgxRowDragDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowDragDirective, selectors: [["", "igxRowDrag", ""]], inputs: { data: ["igxRowDrag", "data"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input('igxRowDrag')
], IgxRowDragDirective.prototype, "data", null);
/**
 * @hidden
 */
let IgxDragIndicatorIconDirective = class IgxDragIndicatorIconDirective {
};
IgxDragIndicatorIconDirective.ɵfac = function IgxDragIndicatorIconDirective_Factory(t) { return new (t || IgxDragIndicatorIconDirective)(); };
IgxDragIndicatorIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDragIndicatorIconDirective, selectors: [["", "igxDragIndicatorIcon", ""]] });
/**
 * @hidden
 */
let IgxRowDragGhostDirective = class IgxRowDragGhostDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
IgxRowDragGhostDirective.ɵfac = function IgxRowDragGhostDirective_Factory(t) { return new (t || IgxRowDragGhostDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxRowDragGhostDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowDragGhostDirective, selectors: [["", "igxRowDragGhost", ""]] });
IgxRowDragGhostDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxRowDragModule = class IgxRowDragModule {
};
IgxRowDragModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxRowDragModule });
IgxRowDragModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxRowDragModule_Factory(t) { return new (t || IgxRowDragModule)(); }, imports: [[]] });

const MINIMUM_COLUMN_WIDTH = 136;
const FILTER_ROW_HEIGHT = 50;
// By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
// In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
// Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
// More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
// but in the same time we need to set row editing overlay outlet before opening the overlay itself.
const MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
const IgxGridTransaction = new InjectionToken('IgxGridTransaction');
let IgxGridBaseDirective = class IgxGridBaseDirective extends DisplayDensityBase {
    constructor(selectionService, crudService, colResizingService, gridAPI, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        super(_displayDensityOptions);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.colResizingService = colResizingService;
        this.gridAPI = gridAPI;
        this._transactions = _transactions;
        this.elementRef = elementRef;
        this.zone = zone;
        this.document = document;
        this.cdr = cdr;
        this.resolver = resolver;
        this.differs = differs;
        this.viewRef = viewRef;
        this.navigation = navigation;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this._init = true;
        this._cdrRequests = false;
        this._cdrRequestRepaint = false;
        this._resourceStrings = CurrentResourceStrings.GridResStrings;
        this._emptyGridMessage = null;
        this._emptyFilteredGridMessage = null;
        this._isLoading = false;
        this._locale = null;
        this._destroyed = false;
        this.overlayIDs = [];
        this._pinning = { columns: ColumnPinningPosition.Start };
        this._advancedFilteringPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._advancedFilteringOverlaySettings = {
            closeOnOutsideClick: false,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._advancedFilteringPositionSettings),
        };
        /**
         * Gets/Sets whether to autogenerate the columns.
         * @remarks
         * The default value is false. When set to true, it will override all columns declared through code or in markup.
         * @example
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.autoGenerate = false;
        /**
         * Emitted after filtering is performed.
         * @remarks
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *              (filteringExpressionsTreeChange)="filteringExprTreeChange($event)"></igx-grid>
         * ```
         */
        this.filteringExpressionsTreeChange = new EventEmitter();
        /**
         * Emitted after advanced filtering is performed.
         * @remarks
         * Returns the advanced filtering expressions tree.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true"
         *           (advancedFilteringExpressionsTreeChange)="advancedFilteringExprTreeChange($event)"></igx-grid>
         * ```
         */
        this.advancedFilteringExpressionsTreeChange = new EventEmitter();
        /**
         * Emitted after the current page is changed.
         * @example
         * ```html
         * <igx-grid (pageChange)="onPageChange($event)"></igx-grid>
         * ```
         * ```typescript
         * public onPageChange(page: number) {
         *   this.currentPage = page;
         * }
         * ```
         */
        this.pageChange = new EventEmitter();
        /**
         * Emitted when `perPage` property value of the grid is changed.
         * @example
         * ```html
         * <igx-grid #grid (perPageChange)="onPerPageChange($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onPerPageChange(perPage: number) {
         *   this.perPage = perPage;
         * }
         * ```
         */
        this.perPageChange = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this.rowDragging = false;
        /**
         * @hidden
         * @internal
         */
        this.class = '';
        /**
         * Gets/Sets the styling classes applied to all even `IgxGridRowComponent`s in the grid.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.evenRowCSS = 'igx-grid__tr--even';
        /**
         * Gets/Sets the styling classes applied to all odd `IgxGridRowComponent`s in the grid.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.oddRowCSS = 'igx-grid__tr--odd';
        /**
         * Gets/Sets the title to be displayed in the built-in column hiding UI.
         * @example
         * ```html
         * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
         * ```
         */
        this.columnHidingTitle = '';
        /**
         * Gets/Sets the title to be displayed in the UI of the column pinning.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.columnPinningTitle = '';
        /**
         * Emitted when `IgxGridCellComponent` is clicked.
         * @remarks
         * Returns the `IgxGridCellComponent`.
         * @example
         * ```html
         * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onCellClick = new EventEmitter();
        /**
         * Emitted when `IgxGridCellComponent` is selected.
         * @remarks
         *  Returns the `IgxGridCellComponent`.
         * @example
         * ```html
         * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         *  Emitted when `IgxGridRowComponent` is selected.
         * @example
         * ```html
         * <igx-grid #grid (onRowSelectionChange)="onCellClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowSelectionChange = new EventEmitter();
        /**
         *  Emitted when `IgxColumnComponent` is selected.
         * @example
         * ```html
         * <igx-grid #grid (onColumnSelectionChange)="onColumnSelectionChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnSelectionChange = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` is pinned.
         * @remarks
         * The index that the column is inserted at may be changed through the `insertAtIndex` property.
         * @example
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         */
        this.onColumnPinning = new EventEmitter();
        /**
         * Emitted when editing and **not** submitting the value.
         * @remarks
         * (e.g. `Esc` key was pressed)
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (onCellEditCancel)="editCancel($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.onCellEditCancel = new EventEmitter();
        /**
         * Emitted when cell enters edit mode.
         * @remarks
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (onCellEditEnter)="editStart($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.onCellEditEnter = new EventEmitter();
        /**
         * Emitted when cell has been edited.
         * @remarks
         * Event is fired after editing is completed, when the cell is exiting edit mode.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (onCellEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'">
         * </igx-grid>
         * ```
         */
        this.onCellEdit = new EventEmitter();
        /**
         * Emitted when a row enters edit mode.
         * @remarks
         * Emitted when [rowEditable]="true".
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (onRowEditEnter)="editStart($event)" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.onRowEditEnter = new EventEmitter();
        /**
         * Emitted when exiting edit mode for a row.
         * @remarks
         * Emitted when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting  `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (onRowEdit)="editDone($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.onRowEdit = new EventEmitter();
        /**
         * Emitted when row editing is canceled.
         * @remarks
         * Emits when [rowEditable]="true" & `endEdit(false)` is called.
         * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
         * in the row editing overlay.
         * This event is cancelable.
         * @example
         * ```html
         * <igx-grid #grid3 (onRowEditCancel)="editCancel($event)" [data]="data" [primaryKey]="'ProductID'" [rowEditable]="true">
         * </igx-grid>
         * ```
         */
        this.onRowEditCancel = new EventEmitter();
        /**
         * Emitted when a column is initialized.
         * @remarks
         * Returns the column object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnInit = new EventEmitter();
        /**
         * Emitted when sorting is performed through the UI.
         * @remarks
         * Returns the sorting expression.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
         * ```
         */
        this.onSortingDone = new EventEmitter();
        /**
         * Emitted when filtering is performed through the UI.
         * @remarks
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
         * ```
         */
        this.onFilteringDone = new EventEmitter();
        /**
         * Emitted when paging is performed.
         * @remarks
         * Returns an object consisting of the previous and next pages.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
         * ```
         */
        this.onPagingDone = new EventEmitter();
        /**
         * Emitted when a row added through the API.
         * @remarks
         * Returns the data for the new `IgxGridRowComponent` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowAdded = new EventEmitter();
        /**
         * Emitted when a row is deleted through API.
         * @remarks
         * Returns an `IRowDataEventArgs` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowDeleted = new EventEmitter();
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         * @example
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        /**
         * Emitted when column is resized.
         * @remarks
         * Returns the `IgxColumnComponent` object's old and new width.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onColumnResized = new EventEmitter();
        /**
         * Emitted when a cell is right clicked.
         * @remarks
         * Returns the `IgxGridCellComponent` object.
         * ```html
         * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onContextMenu = new EventEmitter();
        /**
         * Emitted when a cell is double clicked.
         * @remarks
         * Returns the `IgxGridCellComponent` object.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onDoubleClick = new EventEmitter();
        /**
         * Emitted when column visibility is changed.
         * @remarks
         * Args: { column: any, newValue: boolean }
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
         * ```
         */
        this.onColumnVisibilityChanged = new EventEmitter();
        /**
         * Emitted when column moving starts.
         * @remarks
         * Returns the moved `IgxColumnComponent` object.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
         * ```
         */
        this.onColumnMovingStart = new EventEmitter();
        /**
         * Emitted during the column moving operation.
         * @remarks
         * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
         * ```
         */
        this.onColumnMoving = new EventEmitter();
        /**
         * Emitted when column moving ends.
         * @remarks
         * Returns the source and target `IgxColumnComponent` objects.
         * @example
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
         * ```
         */
        this.onColumnMovingEnd = new EventEmitter();
        /**
         * Emitted when keydown is triggered over element inside grid's body.
         * @remarks
         * This event is fired only if the key combination is supported in the grid.
         * Return the target type, target object and the original event. This event is cancelable.
         * @example
         * ```html
         *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
         * ```
         */
        this.onGridKeydown = new EventEmitter();
        /**
         * Emitted when start dragging a row.
         * @remarks
         * Return the dragged row.
         */
        this.onRowDragStart = new EventEmitter();
        /**
         * Emitted when dropping a row.
         * @remarks
         * Return the dropped row.
         */
        this.onRowDragEnd = new EventEmitter();
        /**
         * Emitted when a copy operation is executed.
         * @remarks
         * Fired only if copy behavior is enabled through the [`clipboardOptions`]{@link IgxGridBaseDirective#clipboardOptions}.
         */
        this.onGridCopy = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.expansionStatesChange = new EventEmitter();
        /**
         * Emitted when the expanded state of a row gets changed.
         * @example
         * ```html
         * <igx-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowToggle = new EventEmitter();
        /**
         * Emitted when the pinned state of a row is changed.
         * @example
         * ```html
         * <igx-grid [data]="employeeData" (onRowPinning)="rowPin($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onRowPinning = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnList = new QueryList();
        /**
         * @hidden @internal
         */
        this.tmpOutlets = new QueryList();
        /**
         * The custom template, if any, that should be used when rendering a row expand indicator.
         */
        this.rowExpandedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a row collapse indicator.
         */
        this.rowCollapsedIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header expand indicator.
         */
        this.headerExpandIndicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering a header collapse indicator.
         */
        this.headerCollapseIndicatorTemplate = null;
        /**
         * @hidden @internal
         */
        this.tabindex = 0;
        /**
         * @hidden @internal
         */
        this.hostRole = 'grid';
        /**
         * Emitted before sorting is performed.
         * @remarks
         * Returns the sorting expressions.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (sortingExpressionsChange)="sortingExprChange($event)"></igx-grid>
         * ```
         */
        this.sortingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.columnsWithNoSetWidths = null;
        /* Toolbar related definitions */
        this._showToolbar = false;
        this._exportExcel = false;
        this._exportCsv = false;
        this._toolbarTitle = null;
        this._exportText = null;
        this._exportExcelText = null;
        this._exportCsvText = null;
        this._rowEditable = false;
        this._filteredSortedData = null;
        /**
         * Provides access to the `IgxToolbarComponent`.
         * @example
         * ```typescript
         * const gridToolbar = this.grid.toolbar;
         * ```
         */
        this.toolbar = null;
        this.toolbarHtml = null;
        /**
         * Controls the copy behavior of the grid.
         */
        this.clipboardOptions = {
            /**
             * Enables/disables the copy behavior
             */
            enabled: true,
            /**
             * Include the columns headers in the clipboard output.
             */
            copyHeaders: true,
            /**
             * Apply the columns formatters (if any) on the data in the clipboard output.
             */
            copyFormatters: true,
            /**
             * The separator used for formatting the copy output. Defaults to `\t`.
             */
            separator: '\t'
        };
        /**
         * Emitted when an export process is initiated by the user.
         * @example
         * ```typescript
         * toolbarExporting(event: IGridToolbarExportEventArgs){
         *     const toolbarExporting = event;
         * }
         * ```
         */
        this.onToolbarExporting = new EventEmitter();
        /* End of toolbar related definitions */
        /**
         * Emitted when making a range selection.
         * @remarks
         * Range selection can be made either through drag selection or through keyboard selection.
         */
        this.onRangeSelection = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.calcHeight = 0;
        /**
         * @hidden @internal
         */
        this.chipsGoupingExpressions = [];
        /**
         * @hidden @internal
         */
        this.disableTransitions = false;
        /**
         * @hidden @internal
         */
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        /**
         * @hidden @internal
         */
        this.columnWidthSetByUser = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        /**
         * @hidden
         */
        this._perPage = 15;
        /**
         * @hidden
         */
        this._page = 0;
        /**
         * @hidden
         */
        this._paging = false;
        /**
         * @hidden
         */
        this._hideRowSelectors = false;
        /**
         * @hidden
         */
        this._rowDrag = false;
        /**
         * @hidden
         */
        this._pipeTrigger = 0;
        /**
         * @hidden
         */
        this._filteringPipeTrigger = 0;
        /**
         * @hidden
         */
        this._summaryPipeTrigger = 0;
        /**
         * @hidden
         */
        this._columns = [];
        /**
         * @hidden
         */
        this._pinnedColumns = [];
        /**
         * @hidden
         */
        this._unpinnedColumns = [];
        /**
         * @hidden
         */
        this._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        /**
         * @hidden
         */
        this._sortingExpressions = [];
        /**
         * @hidden
         */
        this._maxLevelHeaderDepth = null;
        /**
         * @hidden
         */
        this._columnHiding = false;
        /**
         * @hidden
         */
        this._columnPinning = false;
        this._pinnedRecordIDs = [];
        this._allowFiltering = false;
        this._allowAdvancedFiltering = false;
        this._filterMode = FilterMode.quickFilter;
        this.observer = new ResizeObserver(() => { });
        this.resizeNotify = new Subject();
        this._hiddenColumnsText = '';
        this._pinnedColumnsText = '';
        this._height = '100%';
        this._width = '100%';
        this._horizontalForOfs = [];
        this._multiRowLayoutRowSize = 1;
        this._expansionStates = new Map();
        this._defaultExpandState = false;
        // Caches
        this._totalWidth = NaN;
        this._pinnedVisible = [];
        this._unpinnedVisible = [];
        this._pinnedWidth = NaN;
        this._unpinnedWidth = NaN;
        this._visibleColumns = [];
        this._columnGroups = false;
        this._autoGeneratedCols = [];
        this._headerFeaturesWidth = NaN;
        this._defaultTargetRecordNumber = 10;
        this._summaryPosition = GridSummaryPosition.bottom;
        this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
        this._cellSelectionMode = GridSelectionMode.multiple;
        this._rowSelectionMode = GridSelectionMode.none;
        this._columnSelectionMode = GridSelectionMode.none;
        this.rowEditPositioningStrategy = new RowEditPositionStrategy({
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: null
        });
        this.rowEditSettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            outlet: this.rowOutletDirective,
            positionStrategy: this.rowEditPositioningStrategy
        };
        this.verticalScrollHandler = (event) => {
            this.verticalScrollContainer.onScroll(event);
            this.disableTransitions = true;
            this.zone.run(() => {
                this.zone.onStable.pipe(first$1()).subscribe(() => {
                    this.verticalScrollContainer.onChunkLoad.emit(this.verticalScrollContainer.state);
                    if (this.rowEditable) {
                        this.changeRowEditingOverlayStateOnScroll(this.rowInEditMode);
                    }
                });
            });
            this.disableTransitions = false;
            this.hideOverlays();
        };
        this.horizontalScrollHandler = (event) => {
            const scrollLeft = event.target.scrollLeft;
            this.headerContainer.onHScroll(scrollLeft);
            this._horizontalForOfs.forEach(vfor => vfor.onHScroll(scrollLeft));
            this.cdr.markForCheck();
            this.zone.run(() => {
                this.zone.onStable.pipe(first$1()).subscribe(() => {
                    this.parentVirtDir.onChunkLoad.emit(this.headerContainer.state);
                });
            });
            this.hideOverlays();
        };
        /**
         * @hidden @internal
         */
        this.preventContainerScroll = (evt) => {
            if (evt.target.scrollTop !== 0) {
                this.verticalScrollContainer.addScrollTop(evt.target.scrollTop);
                evt.target.scrollTop = 0;
            }
            if (evt.target.scrollLeft !== 0) {
                this.headerContainer.scrollPosition += evt.target.scrollLeft;
                evt.target.scrollLeft = 0;
            }
        };
        /**
         * @hidden
         */
        this.rowEditingWheelHandler = (event) => {
            if (event.deltaY > 0) {
                this.verticalScrollContainer.scrollNext();
            }
            else {
                this.verticalScrollContainer.scrollPrev();
            }
        };
        this.cdr.detach();
    }
    get scrollWidth() {
        return this.verticalScrollContainer.getScrollbarWidth();
    }
    /**
     * Gets/Sets the resource strings.
     * @remarks
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * Gets/Sets the filtering logic of the `IgxGridComponent`.
     * @remarks
     * The default is AND.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
     * ```
     */
    get filteringLogic() {
        return this._filteringExpressionsTree.operator;
    }
    set filteringLogic(value) {
        this._filteringExpressionsTree.operator = value;
    }
    /**
     * Gets/Sets the filtering state.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(filteringExpressionsTree)]="model.filteringExpressions"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get filteringExpressionsTree() {
        return this._filteringExpressionsTree;
    }
    set filteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            const val = value;
            for (let index = 0; index < val.filteringOperands.length; index++) {
                if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                    const newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);
                    newExpressionsTree.filteringOperands.push(val.filteringOperands[index]);
                    val.filteringOperands[index] = newExpressionsTree;
                }
            }
            value.type = FilteringExpressionsTreeType.Regular;
            this._filteringExpressionsTree = value;
            this._filteringPipeTrigger++;
            this.filteringExpressionsTreeChange.emit(this._filteringExpressionsTree);
            if (this.filteringService.isFilteringExpressionsTreeEmpty(this._filteringExpressionsTree) &&
                !this.advancedFilteringExpressionsTree) {
                this.filteredData = null;
            }
            this.filteringService.refreshExpressions();
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this.notifyChanges();
        }
    }
    /**
     * Gets/Sets the advanced filtering state.
     * @example
     * ```typescript
     * let advancedFilteringExpressionsTree = this.grid.advancedFilteringExpressionsTree;
     * this.grid.advancedFilteringExpressionsTree = logic;
     * ```
     */
    get advancedFilteringExpressionsTree() {
        return this._advancedFilteringExpressionsTree;
    }
    set advancedFilteringExpressionsTree(value) {
        if (value && value instanceof FilteringExpressionsTree) {
            value.type = FilteringExpressionsTreeType.Advanced;
            this._advancedFilteringExpressionsTree = value;
            this._filteringPipeTrigger++;
        }
        else {
            this._advancedFilteringExpressionsTree = null;
        }
        this.advancedFilteringExpressionsTreeChange.emit(this._advancedFilteringExpressionsTree);
        if (this.filteringService.isFilteringExpressionsTreeEmpty(this._advancedFilteringExpressionsTree) &&
            !this.advancedFilteringExpressionsTree) {
            this.filteredData = null;
        }
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache();
        this.notifyChanges();
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(() => this.onFilteringDone.emit(this._advancedFilteringExpressionsTree));
    }
    /**
     * Gets/Sets the locale.
     * @remarks
     * If not set, returns browser's language.
     */
    get locale() {
        if (this._locale) {
            return this._locale;
        }
        else {
            return 'en';
        }
    }
    set locale(value) {
        this._locale = value;
    }
    /**
     * Gets/Sets whether the paging feature is enabled.
     * @remarks
     * The default state is disabled (false).
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
     * ```
     */
    get paging() {
        return this._paging;
    }
    set paging(value) {
        this._paging = value;
        this._pipeTrigger++;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets the current page index.
     * @example
     * ```html
     *  <igx-grid #grid [data]="Data" [paging]="true" [(page)]="model.page" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * Supports two-way binding.
     */
    get page() {
        return this._page;
    }
    set page(val) {
        if (val === this._page || val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.selectionService.clear(true);
        this.onPagingDone.emit({ previous: this._page, current: val });
        this._page = val;
        this.pageChange.emit(this._page);
        this.navigateTo(0);
        this.notifyChanges();
    }
    /**
     * Gets/Sets the number of visible items per page.
     * @remarks
     * The default is 15.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [paging]="true" [(perPage)]="model.perPage" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get perPage() {
        return this._perPage;
    }
    set perPage(val) {
        if (val < 0) {
            return;
        }
        this.selectionService.clear(true);
        this._perPage = val;
        this.perPageChange.emit(this._perPage);
        this.page = 0;
        this.endEdit(true);
        this.notifyChanges();
    }
    /**
     * Gets/Sets whether the column hiding UI is enabled.
     * @remarks
     * By default it is disabled (false). In order for the UI to work, you need to enable the toolbar as shown in the example below.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
     * ```
     */
    get columnHiding() {
        return this._columnHiding;
    }
    set columnHiding(value) {
        if (this._columnHiding !== value) {
            this._columnHiding = value;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets if the row selectors are hidden.
     * @remarks
     *  By default row selectors are shown
     */
    get hideRowSelectors() {
        return this._hideRowSelectors;
    }
    set hideRowSelectors(value) {
        this._hideRowSelectors = value;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether rows can be moved.
     * @example
     * ```html
     * <igx-grid #grid [rowDraggable]="true"></igx-grid>
     * ```
     */
    get rowDraggable() {
        return this._rowDrag && this.hasVisibleColumns;
    }
    set rowDraggable(val) {
        this._rowDrag = val;
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets whether the rows are editable.
     * @remarks
     * By default it is set to false.
     * @example
     * ```html
     * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
     * ```
     */
    get rowEditable() {
        return this._rowEditable;
    }
    set rowEditable(val) {
        if (!this._init) {
            this.refreshGridState();
        }
        this._rowEditable = val;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the height.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get height() {
        return this._height;
    }
    set height(value) {
        if (this._height !== value) {
            this._height = value;
            this.nativeElement.style.height = value;
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden @internal
     */
    get hostWidth() {
        return this._width || this._hostWidth;
    }
    /**
     * Gets/Sets the width of the grid.
     * @example
     * ```typescript
     * let gridWidth = this.grid.width;
     * ```
     */
    get width() {
        return this._width;
    }
    set width(value) {
        if (this._width !== value) {
            this._width = value;
            this.nativeElement.style.width = value;
            this.notifyChanges(true);
        }
    }
    /**
     * Gets the width of the header.
     * @example
     * ```html
     * let gridHeaderWidth = this.grid.headerWidth;
     * ```
     */
    get headerWidth() {
        return parseInt(this.width, 10) - 17;
    }
    /**
     * Gets/Sets the row height.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get rowHeight() {
        return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
    }
    set rowHeight(value) {
        this._rowHeight = parseInt(value, 10);
    }
    /**
     * Gets/Sets the default width of the columns.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnWidth() {
        return this._columnWidth;
    }
    set columnWidth(value) {
        this._columnWidth = value;
        this.columnWidthSetByUser = true;
        this.notifyChanges(true);
    }
    /**
     * Get/Sets the message displayed when there are no records.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyGridMessage(value) {
        this._emptyGridMessage = value;
    }
    get emptyGridMessage() {
        return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
    }
    /**
     * Gets/Sets whether the grid is going to show a loading indicator.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set isLoading(value) {
        if (this._isLoading !== value) {
            this._isLoading = value;
            this.evaluateLoadingState();
        }
        Promise.resolve().then(() => {
            // wait for the current detection cycle to end before triggering a new one.
            this.notifyChanges();
        });
    }
    get isLoading() {
        return this._isLoading;
    }
    /**
     * Gets/Sets the message displayed when there are no records and the grid is filtered.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    set emptyFilteredGridMessage(value) {
        this._emptyFilteredGridMessage = value;
    }
    get emptyFilteredGridMessage() {
        return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
    }
    /**
     * Gets/Sets the initial pinning configuration.
     * @remarks
     * Allows to apply pinning the columns to the start or the end.
     * Note that pinning to both sides at a time is not allowed.
     * @example
     * ```html
     * <igx-grid [pinning]="pinningConfig"></igx-grid>
     * ```
     */
    get pinning() {
        return this._pinning;
    }
    set pinning(value) {
        if (value !== this._pinning) {
            this.resetCaches();
        }
        this._pinning = value;
    }
    /**
     * Gets/Sets if the built-in column pinning UI should be shown in the toolbar.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get columnPinning() {
        return this._columnPinning;
    }
    set columnPinning(value) {
        if (this._columnPinning !== value) {
            this._columnPinning = value;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets if the filtering is enabled.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowFiltering]="true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowFiltering() {
        return this._allowFiltering;
    }
    set allowFiltering(value) {
        if (this._allowFiltering !== value) {
            this._allowFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.calcGridHeadRow();
            }
            this.filteringService.isFilterRowVisible = false;
            this.filteringService.filteredColumn = null;
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets a value indicating whether the advanced filtering is enabled.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [allowAdvancedFiltering]="true" [showToolbar]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get allowAdvancedFiltering() {
        return this._allowAdvancedFiltering;
    }
    set allowAdvancedFiltering(value) {
        if (this._allowAdvancedFiltering !== value) {
            this._allowAdvancedFiltering = value;
            this.filteringService.registerSVGIcons();
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the filter mode.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it's set to FilterMode.quickFilter.
     */
    get filterMode() {
        return this._filterMode;
    }
    set filterMode(value) {
        this._filterMode = value;
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.close();
        }
        this.notifyChanges(true);
    }
    /**
     * Gets/Sets the summary position.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is bottom.
     */
    get summaryPosition() {
        return this._summaryPosition;
    }
    set summaryPosition(value) {
        this._summaryPosition = value;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the summary calculation mode.
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
     * ```
     * @remarks
     * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
     */
    get summaryCalculationMode() {
        return this._summaryCalculationMode;
    }
    set summaryCalculationMode(value) {
        this._summaryCalculationMode = value;
        if (!this._init) {
            this.endEdit(true);
            this.summaryService.resetSummaryHeight();
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets the filtering strategy of the grid.
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [filterStrategy]="filterStrategy"></igx-grid>
     * ```
     */
    get filterStrategy() {
        return this._filteringStrategy;
    }
    set filterStrategy(classRef) {
        this._filteringStrategy = classRef;
    }
    /**
     * Gets/Sets the sorting strategy of the grid.
     * @example
     * ```html
     *  <igx-grid #grid [data]="localData" [sortStrategy]="sortStrategy"></igx-grid>
     * ```
     */
    get sortStrategy() {
        return this._sortingStrategy;
    }
    set sortStrategy(value) {
        this._sortingStrategy = value;
    }
    /**
     * A list of all `IgxGridHeaderGroupComponent`.
     * @example
     * ```typescript
     * const headerGroupsList = this.grid.headerGroupsList;
     * ```
     */
    get headerGroupsList() {
        return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
    }
    /**
     * A list of all `IgxGridHeaderComponent`.
     * @example
     * ```typescript
     * const headers = this.grid.headerCellList;
     * ```
     */
    get headerCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.headerCell).filter((headerCell) => headerCell);
    }
    /**
     * A list of all `IgxGridFilteringCellComponent`.
     * @example
     * ```typescript
     * const filterCells = this.grid.filterCellList;
     * ```
     */
    get filterCellList() {
        return this.headerGroupsList.map((headerGroup) => headerGroup.filterCell).filter((filterCell) => filterCell);
    }
    /**
     * @hidden @internal
     */
    get summariesRowList() {
        const res = new QueryList();
        if (!this._summaryRowList) {
            return res;
        }
        const sumList = this._summaryRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        });
        res.reset(sumList);
        return res;
    }
    /**
     * A list of `IgxGridRowComponent`.
     * @example
     * ```typescript
     * const rowList = this.grid.rowList;
     * ```
     */
    get rowList() {
        const res = new QueryList();
        if (!this._rowList) {
            return res;
        }
        const rList = this._rowList
            .filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        })
            .sort((a, b) => {
            return a.index - b.index;
        });
        res.reset(rList);
        return res;
    }
    /**
     * A list of currently rendered `IgxGridRowComponent`'s.
     * @example
     * ```typescript
     * const dataList = this.grid.dataRowList;
     * ```
     */
    get dataRowList() {
        const res = new QueryList();
        if (!this._dataRowList) {
            return res;
        }
        const rList = this._dataRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        }).sort((a, b) => {
            return a.index - b.index;
        });
        res.reset(rList);
        return res;
    }
    /**
     * Returns the template which will be used by the toolbar to show custom content.
     * @example
     * ```typescript
     * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
     * ```
     */
    get toolbarCustomContentTemplate() {
        return this.toolbarCustomContentTemplates.first;
    }
    /**
     * @hidden
     * @internal
     */
    get headSelectorTemplate() {
        if (this.headSelectorsTemplates && this.headSelectorsTemplates.first) {
            return this.headSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden
     * @internal
     */
    get isPinningToStart() {
        return this.pinning.columns !== ColumnPinningPosition.End;
    }
    /**
     * @hidden
     * @internal
     */
    get isRowPinningToTop() {
        return this.pinning.rows !== RowPinningPosition.Bottom;
    }
    /**
     * @hidden
     * @internal
     */
    get rowSelectorTemplate() {
        if (this.rowSelectorsTemplates && this.rowSelectorsTemplates.first) {
            return this.rowSelectorsTemplates.first.templateRef;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    get outletDirective() {
        return this._outletDirective;
    }
    /**
     * @hidden @internal
     */
    get rowOutletDirective() {
        return this.rowEditingOutletDirective;
    }
    /**
     * @hidden @internal
     */
    get parentRowOutletDirective() {
        return this.outletDirective;
    }
    /**
     * @hidden @internal
     */
    get rowEditContainer() {
        return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
    }
    /**
     * The custom template, if any, that should be used when rendering the row drag indicator icon
     */
    get dragIndicatorIconTemplate() {
        return this._customDragIndicatorIconTemplate || this.dragIndicatorIconTemplates.first;
    }
    set dragIndicatorIconTemplate(val) {
        this._customDragIndicatorIconTemplate = val;
    }
    /**
     * @hidden @internal
     */
    get rowInEditMode() {
        const editRowState = this.crudService.row;
        return editRowState !== null ? this.rowList.find(e => e.rowID === editRowState.id) : null;
    }
    /**
     * @hidden @internal
     */
    get firstEditableColumnIndex() {
        const index = this.visibleColumns.filter(col => col.editable)
            .map(c => c.visibleIndex).sort((a, b) => a - b);
        return index.length ? index[0] : null;
    }
    /**
     * @hidden @internal
     */
    get lastEditableColumnIndex() {
        const index = this.visibleColumns.filter(col => col.editable)
            .map(c => c.visibleIndex).sort((a, b) => a > b ? -1 : 1);
        return index.length ? index[0] : null;
    }
    /**
     * @hidden @internal
     * TODO: Nav service logic doesn't handle 0 results from this querylist
     */
    get rowEditTabs() {
        return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
    }
    get activeDescendant() {
        const activeElem = this.navigation.activeNode;
        if (activeElem) {
            return !this.navigation.isDataRow(activeElem.row, true) ? this.id + '_' + activeElem.row :
                this.id + '_' + activeElem.row + '_' + activeElem.column;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    get hostClass() {
        const classes = [this.getComponentDensityClass('igx-grid')];
        // The custom classes should be at the end.
        classes.push(this.class);
        return classes.join(' ');
    }
    get bannerClass() {
        const position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
        return `${this.getComponentDensityClass('igx-banner')} ${position}`;
    }
    /**
     * @hidden @internal
     */
    get pipeTrigger() {
        return this._pipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get filteringPipeTrigger() {
        return this._filteringPipeTrigger;
    }
    /**
     * @hidden @internal
     */
    get summaryPipeTrigger() {
        return this._summaryPipeTrigger;
    }
    /**
     * Gets/Sets the sorting state.
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(sortingExpressions)]="model.sortingExpressions"></igx-grid>
     * ```
     */
    get sortingExpressions() {
        return this._sortingExpressions;
    }
    set sortingExpressions(value) {
        this._sortingExpressions = cloneArray(value);
        this.sortingExpressionsChange.emit(this._sortingExpressions);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                this.columnList.reduce((acc, col) => Math.max(acc, col.rowStart), 0) :
                this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * Gets the number of hidden columns.
     * @example
     * ```typescript
     * const hiddenCol = this.grid.hiddenColumnsCount;
     * ``
     */
    get hiddenColumnsCount() {
        return this.columnList.filter((col) => col.columnGroup === false && col.hidden === true).length;
    }
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     * @remarks
     * Used for the built-in column hiding UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
     * ```
     */
    get hiddenColumnsText() {
        return this._hiddenColumnsText;
    }
    set hiddenColumnsText(value) {
        this._hiddenColumnsText = value;
    }
    /**
     * Gets/Sets the text to be displayed inside the toggle button.
     * @remarks
     * Used for the built-in column pinning UI of the`IgxColumnComponent`.
     * @example
     * ```html
     * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
     * ```
     */
    get pinnedColumnsText() {
        return this._pinnedColumnsText;
    }
    set pinnedColumnsText(value) {
        this._pinnedColumnsText = value;
    }
    /**
     * Get transactions service for the grid.
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * @hidden @internal
     */
    get currentRowState() {
        return this._currentRowState;
    }
    /**
     * Gets/Sets whether the toolbar is shown.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
     * ```
     */
    get showToolbar() {
        return this._showToolbar;
    }
    set showToolbar(newValue) {
        if (this._showToolbar !== newValue) {
            this._showToolbar = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the toolbar's title.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
     * ```
     */
    get toolbarTitle() {
        return this._toolbarTitle;
    }
    set toolbarTitle(newValue) {
        if (this._toolbarTitle !== newValue) {
            this._toolbarTitle = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets whether exporting to MS Excel is enabled or disabled.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportExcel() {
        return this.getExportExcel();
    }
    set exportExcel(newValue) {
        if (this._exportExcel !== newValue) {
            this._exportExcel = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets whether the option for exporting to CSV is enabled or disabled.
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportCsv() {
        return this.getExportCsv();
    }
    set exportCsv(newValue) {
        if (this._exportCsv !== newValue) {
            this._exportCsv = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the textual content for the main export button.
     * @example
     * ```html
     * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportText() {
        return this._exportText;
    }
    set exportText(newValue) {
        if (this._exportText !== newValue) {
            this._exportText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the textual content for the MS Excel export button.
     * ```html
     * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
     * ```
     */
    get exportExcelText() {
        return this._exportExcelText;
    }
    set exportExcelText(newValue) {
        if (this._exportExcelText !== newValue) {
            this._exportExcelText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets the textual content for the CSV export button.
     * @example
     * ```html
     * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
     * ```
     */
    get exportCsvText() {
        return this._exportCsvText;
    }
    set exportCsvText(newValue) {
        if (this._exportCsvText !== newValue) {
            this._exportCsvText = newValue;
            if (!this._init) {
                this.notifyChanges(true);
            }
        }
    }
    /**
     * Gets/Sets cell selection mode.
     * @remarks
     * By default the cell selection mode is multiple
     * @param selectionMode: GridSelectionMode
     */
    get cellSelection() {
        return this._cellSelectionMode;
    }
    set cellSelection(selectionMode) {
        this._cellSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clear(true);
            this.notifyChanges();
        }
    }
    /**
     * Gets/Sets row selection mode
     * @remarks
     * By default the row selection mode is none
     * @param selectionMode: GridSelectionMode
     */
    get rowSelection() {
        return this._rowSelectionMode;
    }
    set rowSelection(selectionMode) {
        this._rowSelectionMode = selectionMode;
        if (this.gridAPI.grid && this.columnList) {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges(true);
        }
    }
    /**
     * Gets/Sets column selection mode
     * @remarks
     * By default the row selection mode is none
     * @param selectionMode: GridSelectionMode
     */
    get columnSelection() {
        return this._columnSelectionMode;
    }
    set columnSelection(selectionMode) {
        this._columnSelectionMode = selectionMode;
        if (this.gridAPI.grid) {
            this.selectionService.clearAllSelectedColumns();
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     * @internal
     */
    get headerFeaturesWidth() {
        return this._headerFeaturesWidth;
    }
    /**
     * @hidden
     * @internal
     */
    isDetailRecord(rec) {
        return false;
    }
    /**
     * @hidden
     * @internal
     */
    isGroupByRecord(rec) {
        return false;
    }
    /**
     * @hidden @internal
     */
    isGhostRecord(record) {
        return record.ghostRecord !== undefined;
    }
    /**
     * @hidden
     * Returns the row index of a row that takes into account the full view data like pinning.
     */
    getDataViewIndex(rowIndex, pinned) {
        if (pinned && !this.isRowPinningToTop) {
            rowIndex = rowIndex + this.unpinnedDataView.length;
        }
        else if (!pinned && this.isRowPinningToTop) {
            rowIndex = rowIndex + this.pinnedDataView.length;
        }
        return rowIndex;
    }
    /**
     * @hidden
     * @internal
     */
    get hasDetails() {
        return false;
    }
    /**
     * Returns the state of the grid virtualization.
     * @remarks
     * Includes the start index and how many records are rendered.
     * @example
     * ```typescript
     * const gridVirtState = this.grid1.virtualizationState;
     * ```
     */
    get virtualizationState() {
        return this.verticalScrollContainer.state;
    }
    /**
     * @hidden
     */
    set virtualizationState(state) {
        this.verticalScrollContainer.state = state;
    }
    /**
     * @hidden
     * @internal
     */
    hideOverlays() {
        this.overlayIDs.forEach(overlayID => {
            this.overlayService.hide(overlayID);
            this.overlayService.onClosed.pipe(filter(o => o.id === overlayID), takeUntil(this.destroy$)).subscribe(() => {
                this.nativeElement.focus();
            });
        });
    }
    /**
     * Returns whether the record is pinned or not.
     *
     * @param rowIndex Index of the record in the `dataView` collection.
     *
     * @hidden
     * @internal
     */
    isRecordPinnedByViewIndex(rowIndex) {
        return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this.pinnedDataView.length) ||
            (!this.isRowPinningToTop && rowIndex >= this.unpinnedDataView.length);
    }
    /**
     * Returns whether the record is pinned or not.
     *
     * @param rowIndex Index of the record in the `filteredSortedData` collection.
     */
    isRecordPinnedByIndex(rowIndex) {
        return this.hasPinnedRecords && (this.isRowPinningToTop && rowIndex < this._filteredSortedPinnedData.length) ||
            (!this.isRowPinningToTop && rowIndex >= this._filteredSortedUnpinnedData.length);
    }
    /**
     * @hidden
     * @internal
     */
    isRecordPinned(rec) {
        return this.getInitialPinnedIndex(rec) !== -1;
    }
    /**
     * @hidden
     * @internal
     * Returns the record index in order of pinning by the user. Does not consider sorting/filtering.
     */
    getInitialPinnedIndex(rec) {
        const id = this.gridAPI.get_row_id(rec);
        return this._pinnedRecordIDs.indexOf(id);
    }
    /**
     * @hidden
     * @internal
     */
    get hasPinnedRecords() {
        return this._pinnedRecordIDs.length > 0;
    }
    /**
     * @hidden
     * @internal
     */
    get pinnedRecordsCount() {
        return this._pinnedRecordIDs.length;
    }
    _setupServices() {
        this.gridAPI.grid = this;
        this.crudService.grid = this;
        this.selectionService.grid = this;
        this.navigation.grid = this;
        this.filteringService.grid = this;
        this.summaryService.grid = this;
    }
    _setupListeners() {
        const destructor = takeUntil(this.destroy$);
        this.onRowAdded.pipe(destructor).subscribe(args => this.refreshGridState(args));
        this.onRowDeleted.pipe(destructor).subscribe(args => {
            this.summaryService.deleteOperation = true;
            this.summaryService.clearSummaryCache(args);
        });
        this.transactions.onStateUpdate.pipe(destructor).subscribe(() => {
            this.selectionService.clearHeaderCBState();
            this.summaryService.clearSummaryCache();
            this._pipeTrigger++;
            this.notifyChanges();
            if (this.transactions.getAggregatedChanges(false).length === 0) {
                // Needs better check, calling 'transactions.clear()' will also trigger this
                if (this.gridAPI.atInexistingPage()) {
                    this.page--;
                }
            }
        });
        this.resizeNotify.pipe(destructor, filter(() => !this._init), throttleTime(100, undefined, { leading: true, trailing: true }))
            .subscribe(() => {
            this.zone.run(() => {
                this.notifyChanges(true);
            });
        });
        this.onPagingDone.pipe(destructor).subscribe(() => {
            this.endEdit(true);
            this.selectionService.clear(true);
        });
        this.onColumnMoving.pipe(destructor).subscribe(() => this.endEdit(true));
        this.onColumnResized.pipe(destructor).subscribe(() => this.endEdit(true));
        this.overlayService.onOpening.pipe(destructor).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                const instance = event.componentRef.instance;
                if (instance) {
                    instance.initialize(this, this.overlayService, event.id);
                }
            }
        });
        this.overlayService.onOpened.pipe(destructor).subscribe((event) => {
            var _a, _b;
            // do not hide the advanced filtering overlay on scroll
            if (this._advancedFilteringOverlayId === event.id) {
                const instance = event.componentRef.instance;
                if (instance) {
                    instance.setAddButtonFocus();
                }
                return;
            }
            if (((_b = (_a = this.overlayService.getOverlayById(event.id)) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.outlet) === this.outletDirective &&
                this.overlayIDs.indexOf(event.id) < 0) {
                this.overlayIDs.push(event.id);
            }
        });
        this.overlayService.onClosed.pipe(destructor, filter(() => !this._init)).subscribe((event) => {
            if (this._advancedFilteringOverlayId === event.id) {
                this._advancedFilteringOverlayId = null;
                return;
            }
            const ind = this.overlayIDs.indexOf(event.id);
            if (ind !== -1) {
                this.overlayIDs.splice(ind, 1);
            }
        });
        this.verticalScrollContainer.onDataChanging.pipe(destructor, filter(() => !this._init)).subscribe(($event) => {
            const shouldRecalcSize = this.isPercentHeight &&
                (!this.calcHeight || this.calcHeight === this.getDataBasedBodyHeight() ||
                    this.calcHeight === this.renderedRowHeight * this._defaultTargetRecordNumber);
            if (shouldRecalcSize) {
                this.calculateGridHeight();
                $event.containerSize = this.calcHeight;
            }
            this.evaluateLoadingState();
        });
        this.verticalScrollContainer.onScrollbarVisibilityChanged.pipe(destructor, filter(() => !this._init)).subscribe(() => {
            // called to recalc all widths that may have changes as a result of
            // the vert. scrollbar showing/hiding
            this.notifyChanges(true);
        });
        this.verticalScrollContainer.onContentSizeChange.pipe(destructor, filter(() => !this._init)).subscribe(($event) => {
            this.calculateGridSizes(false);
        });
        this.onDensityChanged.pipe(destructor).subscribe(() => {
            this.endEdit(true);
            this.summaryService.summaryHeight = 0;
            this.notifyChanges(true);
        });
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this._setupServices();
        this._setupListeners();
        this.rowListDiffer = this.differs.find([]).create(null);
        this.columnListDiffer = this.differs.find([]).create(null);
        this.calcWidth = this.width && this.width.indexOf('%') === -1 ? parseInt(this.width, 10) : 0;
        this.shouldGenerate = this.autoGenerate;
    }
    setupColumns() {
        if (this.autoGenerate) {
            this.autogenerateColumns();
        }
        this.initColumns(this.columnList, (col) => this.onColumnInit.emit(col));
        this.columnListDiffer.diff(this.columnList);
        this.columnList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.onColumnsChanged(change);
        });
    }
    /**
     * @hidden
     * @internal
     */
    resetColumnsCaches() {
        this.columnList.forEach(column => column.resetCaches());
    }
    /**
     * @hidden
     * @internal
     */
    resetForOfCache() {
        const firstVirtRow = this.dataRowList.first;
        if (firstVirtRow) {
            if (this._cdrRequests) {
                firstVirtRow.virtDirRow.cdr.detectChanges();
            }
            firstVirtRow.virtDirRow.assumeMaster();
        }
    }
    setFilterData(data, pinned) {
        if (this.hasPinnedRecords && pinned) {
            this._filteredPinnedData = data || [];
            const filteredUnpinned = this._filteredUnpinnedData || [];
            const filteredData = [...this._filteredPinnedData, ...filteredUnpinned];
            this.filteredData = filteredData.length > 0 ? filteredData : this._filteredUnpinnedData;
        }
        else if (this.hasPinnedRecords && !pinned) {
            this._filteredUnpinnedData = data;
        }
        else {
            this.filteredData = data;
        }
    }
    /**
     * @hidden
     * @internal
     */
    resetColumnCollections() {
        this._visibleColumns.length = 0;
        this._pinnedVisible.length = 0;
        this._unpinnedVisible.length = 0;
    }
    /**
     * @hidden
     * @internal
     */
    resetCachedWidths() {
        this._unpinnedWidth = NaN;
        this._pinnedWidth = NaN;
        this._totalWidth = NaN;
    }
    /**
     * @hidden
     * @internal
     */
    resetCaches(recalcFeatureWidth = true) {
        if (recalcFeatureWidth) {
            this._headerFeaturesWidth = NaN;
        }
        this.resetForOfCache();
        this.resetColumnsCaches();
        this.resetColumnCollections();
        this.resetCachedWidths();
        this.hasVisibleColumns = undefined;
        this._columnGroups = this.columnList.some(col => col.columnGroup);
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.setupColumns();
    }
    /**
     * @hidden
     * @internal
     */
    setFilteredSortedData(data, pinned) {
        data = data || [];
        if (this.pinnedRecordsCount > 0 && pinned) {
            this._filteredSortedPinnedData = data;
            this.pinnedRecords = data;
            this.filteredSortedData = this.isRowPinningToTop ? [...this._filteredSortedPinnedData, ...this._filteredSortedUnpinnedData] :
                [...this._filteredSortedUnpinnedData, ...this._filteredSortedPinnedData];
        }
        else if (this.pinnedRecordsCount > 0 && !pinned) {
            this._filteredSortedUnpinnedData = data;
        }
        else {
            this.filteredSortedData = data;
        }
    }
    /**
     * @hidden @internal
     */
    _setupRowObservers() {
        const elementFilter = (item) => this.isDefined(item.nativeElement.parentElement);
        const extractForOfs = pipe(map((collection) => collection.filter(elementFilter).map(item => item.virtDirRow)));
        const rowListObserver = extractForOfs(this._dataRowList.changes);
        const summaryRowObserver = extractForOfs(this._summaryRowList.changes);
        const resetHorizontalForOfs = () => {
            this._horizontalForOfs = [
                ...this._dataRowList.filter(elementFilter).map(item => item.virtDirRow),
                ...this._summaryRowList.filter(elementFilter).map(item => item.virtDirRow)
            ];
        };
        rowListObserver.pipe(takeUntil(this.destroy$)).subscribe(resetHorizontalForOfs);
        summaryRowObserver.pipe(takeUntil(this.destroy$)).subscribe(resetHorizontalForOfs);
        resetHorizontalForOfs();
    }
    /**
     * @hidden @internal
     */
    _zoneBegoneListeners() {
        this.zone.runOutsideAngular(() => {
            this.verticalScrollContainer.getScroll().addEventListener('scroll', this.verticalScrollHandler);
            this.headerContainer.getScroll().addEventListener('scroll', this.horizontalScrollHandler);
            this.observer = new ResizeObserver(() => this.resizeNotify.next());
            this.observer.observe(this.nativeElement);
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.initPinning();
        this.calculateGridSizes();
        this._init = false;
        this.cdr.reattach();
        this._setupRowObservers();
        this._zoneBegoneListeners();
        const vertScrDC = this.verticalScrollContainer.displayContainer;
        vertScrDC.addEventListener('scroll', this.preventContainerScroll);
        this._pinnedRowList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.onPinnedRowsChanged(change);
        });
    }
    /**
     * @hidden @internal
     */
    notifyChanges(repaint = false) {
        this._cdrRequests = true;
        this._cdrRequestRepaint = repaint;
        this.cdr.markForCheck();
    }
    resetNotifyChanges() {
        this._cdrRequestRepaint = false;
        this._cdrRequests = false;
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        super.ngDoCheck();
        if (this._init) {
            return;
        }
        if (this._cdrRequestRepaint) {
            this.resetNotifyChanges();
            this.calculateGridSizes();
            this.refreshSearch(true);
            return;
        }
        if (this._cdrRequests) {
            this.resetNotifyChanges();
            this.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     * @internal
     */
    getDragGhostCustomTemplate() {
        if (this.dragGhostCustomTemplates && this.dragGhostCustomTemplates.first) {
            return this.dragGhostCustomTemplates.first;
        }
        return null;
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.tmpOutlets.forEach((tmplOutlet) => {
            tmplOutlet.cleanCache();
        });
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        if (this._advancedFilteringOverlayId) {
            this.overlayService.hide(this._advancedFilteringOverlayId);
        }
        this.zone.runOutsideAngular(() => {
            this.observer.disconnect();
            this.verticalScrollContainer.getScroll().removeEventListener('scroll', this.verticalScrollHandler);
            this.headerContainer.getScroll().removeEventListener('scroll', this.horizontalScrollHandler);
            const vertScrDC = this.verticalScrollContainer.displayContainer;
            vertScrDC.removeEventListener('scroll', this.preventContainerScroll);
        });
    }
    /**
     * @hidden @internal
     */
    dataLoading(event) {
        this.onDataPreLoad.emit(event);
    }
    /**
     * Toggles the specified column's visibility.
     * @example
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     */
    toggleColumnVisibility(args) {
        const col = args.column ? this.columnList.find((c) => c === args.column) : undefined;
        if (!col) {
            return;
        }
        col.hidden = args.newValue;
        this.onColumnVisibilityChanged.emit(args);
    }
    /**
     * Gets/Sets a list of key-value pairs [row ID, expansion state].
     * @remarks
     * Includes only states that differ from the default one.
     * Supports two-way binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="data" [(expansionStates)]="model.expansionStates">
     * </igx-grid>
     * ```
     */
    get expansionStates() {
        return this._expansionStates;
    }
    set expansionStates(value) {
        this._expansionStates = new Map(value);
        this.expansionStatesChange.emit(this._expansionStates);
        this.notifyChanges(true);
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Expands all rows.
     * @example
     * ```typescript
     * this.grid.expandAll();
     * ```
     */
    expandAll() {
        this._defaultExpandState = true;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     * @example
     * ```typescript
     * this.grid.collapseAll();
     * ```
     */
    collapseAll() {
        this._defaultExpandState = false;
        this.expansionStates = new Map();
    }
    /**
     * Expands the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.expandRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    expandRow(rowID) {
        this.gridAPI.set_row_expansion_state(rowID, true);
    }
    /**
     * Collapses the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.collapseRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    collapseRow(rowID) {
        this.gridAPI.set_row_expansion_state(rowID, false);
    }
    /**
     * Toggles the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.toggleRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    toggleRow(rowID) {
        const rec = this.gridAPI.get_rec_by_id(rowID);
        const state = this.gridAPI.get_row_expansion_state(rec);
        this.gridAPI.set_row_expansion_state(rowID, !state);
    }
    /**
     * @hidden
     * @internal
     */
    getDefaultExpandState(rec) {
        return this._defaultExpandState;
    }
    /**
     * Gets the native element.
     * @example
     * ```typescript
     * const nativeEl = this.grid.nativeElement.
     * ```
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden @internal
     */
    get outlet() {
        return this.outletDirective;
    }
    /**
     * Gets the default row height.
     * @example
     * ```typescript
     * const rowHeigh = this.grid.defaultRowHeight;
     * ```
     */
    get defaultRowHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 40;
            case DisplayDensity.compact:
                return 32;
            default:
                return 50;
        }
    }
    /**
     * @hidden @internal
     */
    get defaultSummaryHeight() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 30;
            case DisplayDensity.compact:
                return 24;
            default:
                return 36;
        }
    }
    /**
     * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
     * @remarks
     * Used internally for restricting header group component width.
     * The values below depend on the header cell default right/left padding values.
     */
    get defaultHeaderGroupMinWidth() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 32;
            case DisplayDensity.compact:
                return 24;
            default:
                return 48;
        }
    }
    /**
     * @hidden @internal
     */
    paginatorClassName() {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 'igx-paginator--cosy';
            case DisplayDensity.compact:
                return 'igx-paginator--compact';
            default:
                return 'igx-paginator';
        }
    }
    /**
     * Gets the current width of the container for the pinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth;
     * ```
     */
    get pinnedWidth() {
        if (!isNaN(this._pinnedWidth)) {
            return this._pinnedWidth;
        }
        this._pinnedWidth = this.getPinnedWidth();
        return this._pinnedWidth;
    }
    /**
     * Gets the current width of the container for the unpinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const unpinnedWidth = this.grid.getUnpinnedWidth;
     * ```
     */
    get unpinnedWidth() {
        if (!isNaN(this._unpinnedWidth)) {
            return this._unpinnedWidth;
        }
        this._unpinnedWidth = this.getUnpinnedWidth();
        return this._unpinnedWidth;
    }
    /**
     * @hidden @internal
     */
    get isHorizontalScrollHidden() {
        const diff = this.unpinnedWidth - this.totalWidth;
        return this.width === null || diff >= 0;
    }
    /**
     * @hidden @internal
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     */
    featureColumnsWidth(expander) {
        if (Number.isNaN(this._headerFeaturesWidth)) {
            const rowSelectArea = this.headerSelectorContainer ?
                this.headerSelectorContainer.nativeElement.getBoundingClientRect().width : 0;
            const rowDragArea = this.rowDraggable && this.headerDragContainer ?
                this.headerDragContainer.nativeElement.getBoundingClientRect().width : 0;
            const groupableArea = this.headerGroupContainer ?
                this.headerGroupContainer.nativeElement.getBoundingClientRect().width : 0;
            const expanderWidth = expander ? expander.nativeElement.getBoundingClientRect().width : 0;
            this._headerFeaturesWidth = rowSelectArea + rowDragArea + groupableArea + expanderWidth;
        }
        return this._headerFeaturesWidth;
    }
    /**
     * @hidden @internal
     */
    get summariesMargin() {
        return this.featureColumnsWidth();
    }
    /**
     * Gets an array of `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const colums = this.grid.columns.
     * ```
     */
    get columns() {
        return this._columns;
    }
    /**
     * Gets an array of the pinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const pinnedColumns = this.grid.pinnedColumns.
     * ```
     */
    get pinnedColumns() {
        if (this._pinnedVisible.length) {
            return this._pinnedVisible;
        }
        this._pinnedVisible = this._pinnedColumns.filter(col => !col.hidden);
        return this._pinnedVisible;
    }
    /**
     * Gets an array of the pinned `IgxRowComponent`s.
     * @example
     * ```typescript
     * const pinnedRow = this.grid.pinnedRows;
     * ```
     */
    get pinnedRows() {
        return this._pinnedRowList.toArray().sort((a, b) => {
            return a.index - b.index;
        });
    }
    /**
     * Gets an array of unpinned `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const unpinnedColumns = this.grid.unpinnedColumns.
     * ```
     */
    get unpinnedColumns() {
        if (this._unpinnedVisible.length) {
            return this._unpinnedVisible;
        }
        this._unpinnedVisible = this._unpinnedColumns.filter((col) => !col.hidden);
        return this._unpinnedVisible;
    }
    /**
     * Gets the `width` to be set on `IgxGridHeaderGroupComponent`.
     */
    getHeaderGroupWidth(column) {
        if (this.hasColumnLayouts) {
            return '';
        }
        const colWidth = column.width;
        const minWidth = this.defaultHeaderGroupMinWidth;
        const isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (!isPercentageWidth && parseInt(colWidth, 10) < minWidth) {
            return minWidth + 'px';
        }
        return colWidth;
    }
    /**
     * Returns the `IgxColumnComponent` by field name.
     * @example
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * @param name
     */
    getColumnByName(name) {
        return this.columnList.find((col) => col.field === name);
    }
    getColumnByVisibleIndex(index) {
        return this.visibleColumns.find((col) => !col.columnGroup && !col.columnLayout && col.visibleIndex === index);
    }
    /**
     * Returns the `IgxRowDirective` by index.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * @param index
     */
    getRowByIndex(index) {
        return this.gridAPI.get_row_by_index(index);
    }
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * @param keyValue
     */
    getRowByKey(keyValue) {
        return this.gridAPI.get_row_by_key(keyValue);
    }
    /**
     * Returns an array of visible `IgxColumnComponent`s.
     * @example
     * ```typescript
     * const visibleColumns = this.grid.visibleColumns.
     * ```
     */
    get visibleColumns() {
        if (this._visibleColumns.length) {
            return this._visibleColumns;
        }
        this._visibleColumns = this.columnList.filter(c => !c.hidden);
        return this._visibleColumns;
    }
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * @example
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     */
    getCellByColumn(rowIndex, columnField) {
        const columnId = this.columnList.map((column) => column.field).indexOf(columnField);
        if (columnId !== -1) {
            return this.gridAPI.get_cell_by_index(rowIndex, columnId);
        }
    }
    getCellByColumnVisibleIndex(rowIndex, index) {
        return this.gridAPI.get_cell_by_visible_index(rowIndex, index);
    }
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * @remarks
     * Requires that the primaryKey property is set.
     * @example
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     */
    getCellByKey(rowSelector, columnField) {
        return this.gridAPI.get_cell_by_key(rowSelector, columnField);
    }
    /**
     * Gets the total number of pages.
     * @example
     * ```typescript
     * const totalPages = this.grid.totalPages;
     * ```
     */
    get totalPages() {
        if (this.pagingState) {
            return this.pagingState.metadata.countPages;
        }
        return -1;
    }
    /**
     * Gets if the current page is the first page.
     * @example
     * ```typescript
     * const firstPage = this.grid.isFirstPage;
     * ```
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Goes to the next page, if the grid is not already at the last page.
     * @example
     * ```typescript
     * this.grid1.nextPage();
     * ```
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page, if the grid is not already at the first page.
     * @example
     * ```typescript
     * this.grid1.previousPage();
     * ```
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Returns the total number of records.
     * @remarks
     * Only functions when paging is enabled.
     * @example
     * ```typescript
     * const totalRecords = this.grid.totalRecords;
     * ```
     */
    get totalRecords() {
        if (this.pagingState) {
            return this.pagingState.metadata.countRecords;
        }
    }
    /**
     * Returns if the current page is the last page.
     * @example
     * ```typescript
     * const lastPage = this.grid.isLastPage;
     * ```
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns the total width of the `IgxGridComponent`.
     * @example
     * ```typescript
     * const gridWidth = this.grid.totalWidth;
     * ```
     */
    get totalWidth() {
        if (!isNaN(this._totalWidth)) {
            return this._totalWidth;
        }
        // Take only top level columns
        const cols = this.visibleColumns.filter(col => col.level === 0 && !col.pinned);
        let totalWidth = 0;
        let i = 0;
        for (i; i < cols.length; i++) {
            totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
        }
        this._totalWidth = totalWidth;
        return totalWidth;
    }
    /**
     * @hidden
     * @internal
     */
    get showRowSelectors() {
        return this.isRowSelectable && this.hasVisibleColumns && !this.hideRowSelectors;
    }
    /**
     * @hidden
     * @internal
     */
    get showDragIcons() {
        return this.rowDraggable && this.columns.length > this.hiddenColumnsCount;
    }
    /**
     * @hidden
     */
    _moveColumns(from, to, pos) {
        const list = this.columnList.toArray();
        const fromIndex = list.indexOf(from);
        let toIndex = list.indexOf(to);
        if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
            if (toIndex < 0) {
                toIndex = 0;
            }
        }
        if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
        }
        list.splice(toIndex, 0, ...list.splice(fromIndex, 1));
        const newList = this._resetColumnList(list);
        this.columnList.reset(newList);
        this.columnList.notifyOnChanges();
        this._columns = this.columnList.toArray();
    }
    /**
     * @hidden
     */
    _resetColumnList(list) {
        if (!list) {
            list = this.columnList.toArray();
        }
        let newList = [];
        list.filter(c => c.level === 0).forEach(p => {
            newList.push(p);
            if (p.columnGroup) {
                newList = newList.concat(p.allChildren);
            }
        });
        return newList;
    }
    /**
     * @hidden
     */
    _reorderColumns(from, to, position, columnCollection) {
        let dropIndex = columnCollection.indexOf(to);
        if (to.columnGroup) {
            dropIndex += to.allChildren.length;
        }
        if (position === DropPosition.BeforeDropTarget) {
            dropIndex--;
        }
        if (position === DropPosition.AfterDropTarget) {
            dropIndex++;
        }
        columnCollection.splice(dropIndex, 0, ...columnCollection.splice(columnCollection.indexOf(from), 1));
    }
    /**
     * @hidden
     */
    _moveChildColumns(parent, from, to, pos) {
        const buffer = parent.children.toArray();
        const fromIndex = buffer.indexOf(from);
        let toIndex = buffer.indexOf(to);
        if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
        }
        if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
        }
        buffer.splice(toIndex, 0, ...buffer.splice(fromIndex, 1));
        parent.children.reset(buffer);
    }
    /**
     * Moves a column to the specified drop target.
     * @example
     * ```typescript
     * grid.moveColumn(compName, persDetails);
     * ```
     */
    moveColumn(column, dropTarget, pos = DropPosition.None) {
        let position = pos;
        const fromIndex = column.visibleIndex;
        const toIndex = dropTarget.visibleIndex;
        if (pos === DropPosition.BeforeDropTarget && fromIndex < toIndex) {
            position = DropPosition.BeforeDropTarget;
        }
        else if (pos === DropPosition.AfterDropTarget && fromIndex > toIndex) {
            position = DropPosition.AfterDropTarget;
        }
        else {
            position = DropPosition.None;
        }
        if ((column.level !== dropTarget.level) ||
            (column.topLevelParent !== dropTarget.topLevelParent)) {
            return;
        }
        this.endEdit(true);
        if (column.level) {
            this._moveChildColumns(column.parent, column, dropTarget, position);
        }
        if (dropTarget.pinned && column.pinned) {
            this._reorderColumns(column, dropTarget, position, this._pinnedColumns);
        }
        if (dropTarget.pinned && !column.pinned) {
            column.pin();
            if (!this.isPinningToStart) {
                if (pos === DropPosition.AfterDropTarget) {
                    position = DropPosition.AfterDropTarget;
                }
                else {
                    position = DropPosition.None;
                }
            }
            this._reorderColumns(column, dropTarget, position, this._pinnedColumns);
        }
        if (!dropTarget.pinned && column.pinned) {
            column.unpin();
            let list = [];
            if (this.pinnedColumns.indexOf(column) === -1 && this.pinnedColumns.indexOf(dropTarget) === -1) {
                list = this._unpinnedColumns;
            }
            else {
                list = this._pinnedColumns;
            }
            const fi = list.indexOf(column);
            const ti = list.indexOf(dropTarget);
            if (pos === DropPosition.BeforeDropTarget && fi < ti) {
                position = DropPosition.BeforeDropTarget;
            }
            else if (pos === DropPosition.AfterDropTarget && fi > ti) {
                position = DropPosition.AfterDropTarget;
            }
            else {
                position = DropPosition.None;
            }
        }
        if (!dropTarget.pinned) {
            this._reorderColumns(column, dropTarget, position, this._unpinnedColumns);
        }
        this._moveColumns(column, dropTarget, position);
        this.notifyChanges();
        if (this.hasColumnLayouts) {
            this.columns.filter(x => x.columnLayout).forEach(x => x.populateVisibleIndexes());
        }
        const args = {
            source: column,
            target: dropTarget
        };
        this.onColumnMovingEnd.emit(args);
    }
    /**
     * Goes to the desired page index.
     * @example
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * @param val
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     * @example
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     */
    markForCheck() {
        this.cdr.detectChanges();
    }
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * @example
     * ```typescript
     * this.grid1.addRow(record);
     * ```
     * @param data
     */
    addRow(data) {
        // commit pending states prior to adding a row
        this.endEdit(true);
        this.gridAPI.addRowToData(data);
        this.onRowAdded.emit({ data });
        this._pipeTrigger++;
        this.notifyChanges();
    }
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * @remarks
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * @example
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * @param rowSelector
     */
    deleteRow(rowSelector) {
        if (this.primaryKey !== undefined && this.primaryKey !== null) {
            this.deleteRowById(rowSelector);
        }
    }
    /** @hidden */
    deleteRowById(rowId) {
        this.gridAPI.deleteRowById(rowId);
    }
    /**
     * @hidden
     */
    deleteRowFromData(rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        if (index !== -1) {
            if (this.transactions.enabled) {
                const transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                this.transactions.add(transaction, this.data[index]);
            }
            else {
                this.data.splice(index, 1);
            }
        }
        else {
            const state = this.transactions.getState(rowID);
            this.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state && state.recordRef);
        }
    }
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * @remarks
     * Requires that the `primaryKey` property is set.
     * @example
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * @param value the new value which is to be set.
     * @param rowSelector corresponds to rowID.
     * @param column corresponds to column field.
     */
    updateCell(value, rowSelector, column) {
        if (this.isDefined(this.primaryKey)) {
            const col = this.columnList.toArray().find(c => c.field === column);
            if (col) {
                // Simplify
                const rowData = this.gridAPI.getRowData(rowSelector);
                const index = this.gridAPI.get_row_index_in_data(rowSelector);
                // If row passed is invalid
                if (index < 0) {
                    return;
                }
                const id = {
                    rowID: rowSelector,
                    columnID: col.index,
                    rowIndex: index
                };
                const cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData);
                const args = this.gridAPI.update_cell(cell, value);
                if (this.crudService.cell && this.crudService.sameCell(cell)) {
                    if (args.cancel) {
                        return;
                    }
                    this.gridAPI.escape_editMode();
                }
                this.cdr.detectChanges();
            }
        }
    }
    /**
     * Updates the `IgxGridRowComponent`
     * @remarks
     * The row is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * @example
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * @param value
     * @param rowSelector correspond to rowID
     */
    updateRow(value, rowSelector) {
        if (this.isDefined(this.primaryKey)) {
            const editableCell = this.crudService.cell;
            if (editableCell && editableCell.id.rowID === rowSelector) {
                this.gridAPI.escape_editMode();
            }
            const row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector));
            this.gridAPI.update_row(row, value);
            // TODO: fix for #5934 and probably break for #5763
            // consider adding of third optional boolean parameter in updateRow.
            // If developer set this parameter to true we should call notifyChanges(true), and
            // vise-versa if developer set it to false we should call notifyChanges(false).
            // The parameter should default to false
            this.notifyChanges();
        }
    }
    /**
     * Sort a single `IgxColumnComponent`.
     * @remarks
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * @example
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     */
    sort(expression) {
        this.endEdit(false);
        if (expression instanceof Array) {
            this.gridAPI.sort_multiple(expression);
        }
        else {
            this.gridAPI.sort(expression);
        }
        requestAnimationFrame(() => this.onSortingDone.emit(expression));
    }
    /**
     * Filters a single `IgxColumnComponent`.
     * @example
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * @param name
     * @param value
     * @param conditionOrExpressionTree
     * @param ignoreCase
     */
    filter(name, value, conditionOrExpressionTree, ignoreCase) {
        this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
    }
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * @example
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * @param value
     * @param condition
     * @param ignoreCase
     */
    filterGlobal(value, condition, ignoreCase) {
        this.filteringService.filterGlobal(value, condition, ignoreCase);
    }
    /**
     * Enables summaries for the specified column and applies your customSummary.
     * @remarks
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * @example
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * @param rest
     */
    enableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._multipleSummaries(rest[0], true);
        }
        else {
            this._summaries(rest[0], true, rest[1]);
        }
    }
    /**
     * Disable summaries for the specified column.
     * @example
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     * @remarks
     * Disable summaries for the listed columns.
     * @example
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     */
    disableSummaries(...rest) {
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._disableMultipleSummaries(rest[0]);
        }
        else {
            this._summaries(rest[0], false);
        }
    }
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`.
     * @remarks
     * Otherwise clears the filtering state of all `IgxColumnComponent`s.
     * @example
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * @param name
     */
    clearFilter(name) {
        this.filteringService.clearFilter(name);
    }
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`.
     * @remarks
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * @example
     * ```typescript
     * this.grid.clearSort();
     * ```
     * @param name
     */
    clearSort(name) {
        if (!name) {
            this.sortingExpressions = [];
            return;
        }
        if (!this.gridAPI.get_column_by_name(name)) {
            return;
        }
        this.gridAPI.clear_sort(name);
    }
    /**
     * @hidden @internal
     */
    refreshGridState(args) {
        this.endEdit(true);
        this.selectionService.clearHeaderCBState();
        this.summaryService.clearSummaryCache(args);
    }
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name.
     * @remarks
     * Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     */
    pinColumn(columnName, index) {
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.pin(index);
    }
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * @example
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     */
    unpinColumn(columnName, index) {
        const col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.unpin(index);
    }
    /**
     * Pin the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.pinRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     * @param index The index at which to insert the row in the pinned collection.
     */
    pinRow(rowID, index) {
        if (this._pinnedRecordIDs.indexOf(rowID) !== -1) {
            return false;
        }
        const row = this.gridAPI.get_row_by_key(rowID);
        const eventArgs = {
            insertAtIndex: index,
            isPinned: true,
            rowID: rowID,
            row: row
        };
        this.onRowPinning.emit(eventArgs);
        this.endEdit(true);
        const insertIndex = typeof eventArgs.insertAtIndex === 'number' ? eventArgs.insertAtIndex : this._pinnedRecordIDs.length;
        this._pinnedRecordIDs.splice(insertIndex, 0, rowID);
        this._pipeTrigger++;
        if (this.gridAPI.grid) {
            this.notifyChanges();
        }
    }
    /**
     * Unpin the row by its id.
     * @remarks
     * ID is either the primaryKey value or the data record instance.
     * @example
     * ```typescript
     * this.grid.unpinRow(rowID);
     * ```
     * @param rowID The row id - primaryKey value or the data record instance.
     */
    unpinRow(rowID) {
        const index = this._pinnedRecordIDs.indexOf(rowID);
        if (index === -1) {
            return false;
        }
        const row = this.gridAPI.get_row_by_key(rowID);
        const eventArgs = {
            isPinned: false,
            rowID: rowID,
            row: row
        };
        this.onRowPinning.emit(eventArgs);
        this.endEdit(true);
        this._pinnedRecordIDs.splice(index, 1);
        this._pipeTrigger++;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
        return true;
    }
    get pinnedRowHeight() {
        const containerHeight = this.pinContainer ? this.pinContainer.nativeElement.offsetHeight : 0;
        return this.hasPinnedRecords ? containerHeight : 0;
    }
    get totalHeight() {
        return this.calcHeight ? this.calcHeight + this.pinnedRowHeight : this.calcHeight;
    }
    /**
     * Recalculates grid width/height dimensions.
     * @remarks
     * Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * @example
     * ```typescript
     * this.grid.reflow();
     * ```
     */
    reflow() {
        this.calculateGridSizes();
    }
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
     */
    findNext(text, caseSensitive, exactMatch) {
        return this.find(text, 1, caseSensitive, exactMatch);
    }
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * @remarks
     * Returns how many times the grid contains the string.
     * @example
     * ```typescript
     * this.grid.findPrev("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value (defaults to false).
     */
    findPrev(text, caseSensitive, exactMatch) {
        return this.find(text, -1, caseSensitive, exactMatch);
    }
    /**
     * Reapplies the existing search.
     * @remarks
     * Returns how many times the grid contains the last search.
     * @example
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * @param updateActiveInfo
     */
    refreshSearch(updateActiveInfo) {
        if (this.lastSearchInfo.searchText) {
            this.rebuildMatchCache();
            if (updateActiveInfo) {
                const activeInfo = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                this.lastSearchInfo.matchInfoCache.forEach((match, i) => {
                    if (match.column === activeInfo.column &&
                        match.row === activeInfo.row &&
                        match.index === activeInfo.index &&
                        compareMaps(match.metadata, activeInfo.metadata)) {
                        this.lastSearchInfo.activeMatchIndex = i;
                    }
                });
            }
            return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false);
        }
        else {
            return 0;
        }
    }
    /**
     * Removes all the highlights in the cell.
     * @example
     * ```typescript
     * this.grid.clearSearch();
     * ```
     */
    clearSearch() {
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        this.rowList.forEach((row) => {
            if (row.cells) {
                row.cells.forEach((c) => {
                    c.clearHighlight();
                });
            }
        });
    }
    /**
     * Returns if the `IgxGridComponent` has sortable columns.
     * @example
     * ```typescript
     * const sortableGrid = this.grid.hasSortableColumns;
     * ```
     */
    get hasSortableColumns() {
        return this.columnList.some((col) => col.sortable);
    }
    /**
     * Returns if the `IgxGridComponent` has editable columns.
     * @example
     * ```typescript
     * const editableGrid = this.grid.hasEditableColumns;
     * ```
     */
    get hasEditableColumns() {
        return this.columnList.some((col) => col.editable);
    }
    /**
     * Returns if the `IgxGridComponent` has fiterable columns.
     * @example
     * ```typescript
     * const filterableGrid = this.grid.hasFilterableColumns;
     * ```
     */
    get hasFilterableColumns() {
        return this.columnList.some((col) => col.filterable);
    }
    /**
     * Returns if the `IgxGridComponent` has summarized columns.
     * @example
     * ```typescript
     * const summarizedGrid = this.grid.hasSummarizedColumns;
     * ```
     */
    get hasSummarizedColumns() {
        return this.summaryService.hasSummarizedColumns;
    }
    /**
     * @hidden @internal
     */
    get rootSummariesEnabled() {
        return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
    }
    /**
     * @hidden @internal
     */
    get hasVisibleColumns() {
        if (this._hasVisibleColumns === undefined) {
            return this.columnList ? this.columnList.some(c => !c.hidden) : false;
        }
        return this._hasVisibleColumns;
    }
    set hasVisibleColumns(value) {
        this._hasVisibleColumns = value;
    }
    /**
     * Returns if the `IgxGridComponent` has moveable columns.
     * @example
     * ```typescript
     * const movableGrid = this.grid.hasMovableColumns;
     * ```
     */
    get hasMovableColumns() {
        return this.columnList && this.columnList.some((col) => col.movable);
    }
    /**
     * Returns if the `IgxGridComponent` has column groups.
     * @example
     * ```typescript
     * const groupGrid = this.grid.hasColumnGroups;
     * ```
     */
    get hasColumnGroups() {
        return this._columnGroups;
    }
    /**
     * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
     * @example
     * ```typescript
     * const layoutGrid = this.grid.hasColumnLayouts;
     * ```
     */
    get hasColumnLayouts() {
        return !!this.columnList.some(col => col.columnLayout);
    }
    /**
     * Returns an array of the selected `IgxGridCellComponent`s.
     * @example
     * ```typescript
     * const selectedCells = this.grid.selectedCells;
     * ```
     */
    get selectedCells() {
        if (this.dataRowList) {
            return this.dataRowList.map((row) => row.cells.filter((cell) => cell.selected))
                .reduce((a, b) => a.concat(b), []);
        }
        return [];
    }
    /**
     * @hidden @internal
     */
    get multiRowLayoutRowSize() {
        return this._multiRowLayoutRowSize;
    }
    /**
     * @hidden
     */
    get rowBasedHeight() {
        return this.dataLength * this.rowHeight;
    }
    /**
     * @hidden
     */
    get isPercentWidth() {
        return this.width && this.width.indexOf('%') !== -1;
    }
    /**
     * @hidden @internal
     */
    get isPercentHeight() {
        return this._height && this._height.indexOf('%') !== -1;
    }
    /**
     * @hidden
     * Sets columns defaultWidth property
     */
    _derivePossibleWidth() {
        if (!this.columnWidthSetByUser) {
            this._columnWidth = this.width !== null ? this.getPossibleColumnWidth() : MINIMUM_COLUMN_WIDTH + 'px';
        }
        this.columnList.forEach((column) => {
            if (this.hasColumnLayouts && parseInt(this._columnWidth, 10)) {
                const columnWidthCombined = parseInt(this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                column.defaultWidth = columnWidthCombined + 'px';
            }
            else {
                column.defaultWidth = this._columnWidth;
                column.resetCaches();
            }
        });
        this.resetCachedWidths();
    }
    /**
     * @hidden
     */
    get defaultTargetBodyHeight() {
        const allItems = this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     * The rowHeight input is bound to min-height css prop of rows that adds a 1px border in all cases
     */
    get renderedRowHeight() {
        return this.rowHeight + 1;
    }
    /**
     * @hidden
     * @internal
     */
    calcGridHeadRow() {
        if (this.maxLevelHeaderDepth) {
            this._baseFontSize = parseFloat(getComputedStyle(this.document.documentElement).getPropertyValue('font-size'));
            let minSize = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight / this._baseFontSize;
            if (this._allowFiltering && this._filterMode === FilterMode.quickFilter) {
                minSize += (FILTER_ROW_HEIGHT + 1) / this._baseFontSize;
            }
            this.theadRow.nativeElement.style.minHeight = `${minSize}rem`;
        }
    }
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     */
    calculateGridHeight() {
        this.calcGridHeadRow();
        this.summariesHeight = 0;
        if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
            this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
        }
        this.calcHeight = this._calculateGridBodyHeight();
        if (this.pinnedRowHeight && this.calcHeight) {
            this.calcHeight -= this.pinnedRowHeight;
        }
    }
    /**
     * @hidden
     */
    getGroupAreaHeight() {
        return 0;
    }
    /**
     * @hidden
     */
    getToolbarHeight() {
        let toolbarHeight = 0;
        if (this.showToolbar && this.toolbarHtml != null) {
            toolbarHeight = this.toolbarHtml.nativeElement.firstElementChild ?
                this.toolbarHtml.nativeElement.offsetHeight : 0;
        }
        return toolbarHeight;
    }
    /**
     * @hidden
     */
    getPagingHeight() {
        let pagingHeight = 0;
        if (this.paging && this.footer) {
            pagingHeight = this.footer.nativeElement.firstElementChild ?
                this.footer.nativeElement.offsetHeight : 0;
        }
        return pagingHeight;
    }
    /**
     * @hidden
     */
    getFilterCellHeight() {
        const headerGroupNativeEl = (this.headerGroupsList.length !== 0) ?
            this.headerGroupsList[0].element.nativeElement : null;
        const filterCellNativeEl = (headerGroupNativeEl) ?
            headerGroupNativeEl.querySelector('igx-grid-filtering-cell') : null;
        return (filterCellNativeEl) ? filterCellNativeEl.offsetHeight : 0;
    }
    /**
     * @hidden
     */
    _calculateGridBodyHeight() {
        if (!this._height) {
            return null;
        }
        const actualTheadRow = (!this.allowFiltering || (this.allowFiltering && this.filterMode !== FilterMode.quickFilter)) ?
            this.theadRow.nativeElement.offsetHeight - this.getFilterCellHeight() :
            this.theadRow.nativeElement.offsetHeight;
        const footerHeight = this.summariesHeight || this.tfoot.nativeElement.offsetHeight - this.tfoot.nativeElement.clientHeight;
        const toolbarHeight = this.getToolbarHeight();
        const pagingHeight = this.getPagingHeight();
        const groupAreaHeight = this.getGroupAreaHeight();
        const renderedHeight = toolbarHeight + actualTheadRow +
            footerHeight + pagingHeight + groupAreaHeight +
            this.scr.nativeElement.clientHeight;
        let gridHeight = 0;
        if (this.isPercentHeight) {
            const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('height');
            const autoSize = this._shouldAutoSize(renderedHeight);
            if (autoSize || computed.indexOf('%') !== -1) {
                const bodyHeight = this.getDataBasedBodyHeight();
                return bodyHeight > 0 ? bodyHeight : null;
            }
            gridHeight = parseInt(computed, 10);
        }
        else {
            gridHeight = parseInt(this._height, 10);
        }
        const height = Math.abs(gridHeight - renderedHeight);
        if (height === 0 || isNaN(gridHeight)) {
            const bodyHeight = this.defaultTargetBodyHeight;
            return bodyHeight > 0 ? bodyHeight : null;
        }
        return height;
    }
    checkContainerSizeChange() {
        const origHeight = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = 'none';
        const height = this.nativeElement.parentElement.offsetHeight;
        this.nativeElement.style.display = '';
        return origHeight !== height;
    }
    _shouldAutoSize(renderedHeight) {
        this.tbody.nativeElement.style.display = 'none';
        let res = !this.nativeElement.parentElement ||
            this.nativeElement.parentElement.clientHeight === 0 ||
            this.nativeElement.parentElement.clientHeight === renderedHeight;
        if (!isChromium()) {
            // If grid causes the parent container to extend (for example when container is flex)
            // we should always auto-size since the actual size of the container will continuously change as the grid renders elements.
            res = this.checkContainerSizeChange();
        }
        this.tbody.nativeElement.style.display = '';
        return res;
    }
    /**
     * @hidden @internal
     */
    get outerWidth() {
        return this.hasVerticalScroll() ? this.calcWidth + this.scrollWidth : this.calcWidth;
    }
    /**
     * @hidden @internal
     * Gets the visible content height that includes header + tbody + footer.
     */
    getVisibleContentHeight() {
        let height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
        if (this.hasSummarizedColumns) {
            height += this.tfoot.nativeElement.clientHeight;
        }
        return height;
    }
    /**
     * @hidden @internal
     */
    getPossibleColumnWidth(baseWidth = null) {
        let computedWidth;
        if (baseWidth !== null) {
            computedWidth = baseWidth;
        }
        else {
            computedWidth = this.calcWidth ||
                parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
        }
        computedWidth -= this.featureColumnsWidth();
        const visibleChildColumns = this.visibleColumns.filter(c => !c.columnGroup);
        // Column layouts related
        let visibleCols = [];
        const columnBlocks = this.visibleColumns.filter(c => c.columnGroup);
        const colsPerBlock = columnBlocks.map(block => block.getInitialChildColumnSizes(block.children));
        const combinedBlocksSize = colsPerBlock.reduce((acc, item) => acc + item.length, 0);
        colsPerBlock.forEach(blockCols => visibleCols = visibleCols.concat(blockCols));
        //
        const columnsWithSetWidths = this.hasColumnLayouts ?
            visibleCols.filter(c => c.widthSetByUser) :
            visibleChildColumns.filter(c => c.widthSetByUser);
        const columnsToSize = this.hasColumnLayouts ?
            combinedBlocksSize - columnsWithSetWidths.length :
            visibleChildColumns.length - columnsWithSetWidths.length;
        const sumExistingWidths = columnsWithSetWidths
            .reduce((prev, curr) => {
            const colWidth = curr.width;
            const widthValue = parseInt(colWidth, 10);
            const currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                widthValue / 100 * computedWidth :
                widthValue;
            return prev + currWidth;
        }, 0);
        // When all columns are hidden, return 0px width
        if (!sumExistingWidths && !columnsToSize) {
            return '0px';
        }
        const columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
            Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
            Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
        return columnWidth + 'px';
    }
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     */
    calculateGridWidth() {
        let width;
        if (this.isPercentWidth) {
            /* width in %*/
            const computed = this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width');
            width = computed.indexOf('%') === -1 ? parseInt(computed, 10) : null;
        }
        else {
            width = parseInt(this.width, 10);
        }
        if (!width && this.nativeElement) {
            width = this.nativeElement.offsetWidth;
        }
        if (this.width === null || !width) {
            width = this.getColumnWidthSum();
        }
        if (this.hasVerticalScroll() && this.width !== null) {
            width -= this.scrollWidth;
        }
        if ((Number.isFinite(width) || width === null) && width !== this.calcWidth) {
            this.calcWidth = width;
        }
        this._derivePossibleWidth();
    }
    getColumnWidthSum() {
        let colSum = 0;
        const cols = this.hasColumnLayouts ?
            this.visibleColumns.filter(x => x.columnLayout) : this.visibleColumns.filter(x => !x.columnGroup);
        cols.forEach((item) => {
            const isWidthInPercent = item.width && typeof item.width === 'string' && item.width.indexOf('%') !== -1;
            if (isWidthInPercent) {
                item.width = item.calcWidth || MINIMUM_COLUMN_WIDTH + 'px';
            }
            colSum += parseInt((item.width || item.defaultWidth), 10) || MINIMUM_COLUMN_WIDTH;
        });
        if (!colSum) {
            return null;
        }
        this.cdr.detectChanges();
        colSum += this.featureColumnsWidth();
        return colSum;
    }
    /**
     * @hidden @internal
     */
    hasVerticalScroll() {
        if (this._init) {
            return false;
        }
        const isScrollable = this.verticalScrollContainer ? this.verticalScrollContainer.isScrollable() : false;
        return !!(this.calcWidth && this.dataView &&
            this.dataView.length > 0 &&
            isScrollable);
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.data || (this.data.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden @internal
     */
    onPinnedRowsChanged(change) {
        const diff = this.rowListDiffer.diff(change);
        if (diff) {
            this.notifyChanges(true);
        }
    }
    /**
     * @hidden
     */
    onColumnsChanged(change) {
        const diff = this.columnListDiffer.diff(change);
        if (this.autoGenerate && this.columnList.length === 0 && this._autoGeneratedCols.length > 0) {
            // In Ivy if there are nested conditional templates the content children are re-evaluated
            // hence autogenerated columns are cleared and need to be reset.
            this.columnList.reset(this._autoGeneratedCols);
            return;
        }
        if (diff) {
            let added = false;
            let removed = false;
            this.initColumns(this.columnList);
            diff.forEachAddedItem((record) => {
                this.onColumnInit.emit(record.item);
                added = true;
            });
            diff.forEachRemovedItem((record) => {
                const isColumnGroup = record.item instanceof IgxColumnGroupComponent;
                if (!isColumnGroup) {
                    // Clear Grouping
                    this.gridAPI.clear_groupby(record.item.field);
                    // Clear Filtering
                    this.gridAPI.clear_filter(record.item.field);
                    // Close filter row
                    if (this.filteringService.isFilterRowVisible
                        && this.filteringService.filteredColumn
                        && this.filteringService.filteredColumn.field === record.item.field) {
                        this.filteringRow.close();
                    }
                    // Clear Sorting
                    this.gridAPI.clear_sort(record.item.field);
                    // Remove column selection
                    this.selectionService.deselectColumnsWithNoEvent([record.item.field]);
                }
                removed = true;
            });
            this.resetCaches();
            if (added || removed) {
                this.summaryService.clearSummaryCache();
                Promise.resolve().then(() => {
                    // `onColumnsChanged` can be executed midway a current detectChange cycle and markForCheck will be ignored then.
                    // This ensures that we will wait for the current cycle to end so we can trigger a new one and ngDoCheck to fire.
                    this.notifyChanges(true);
                });
            }
        }
    }
    /**
     * @hidden
     */
    calculateGridSizes(recalcFeatureWidth = true) {
        /*
            TODO: (R.K.) This layered lasagne should be refactored
            ASAP. The reason I have to reset the caches so many times is because
            after teach `detectChanges` call they are filled with invalid
            state. Of course all of this happens midway through the grid
            sizing process which of course, uses values from the caches, thus resulting
            in a broken layout.
        */
        this.resetCaches(recalcFeatureWidth);
        this.cdr.detectChanges();
        const hasScroll = this.hasVerticalScroll();
        this.calculateGridWidth();
        this.resetCaches(recalcFeatureWidth);
        this.cdr.detectChanges();
        this.calculateGridHeight();
        if (this.rowEditable) {
            this.repositionRowEditingOverlay(this.rowInEditMode);
        }
        if (this.filteringService.isFilterRowVisible) {
            this.filteringRow.resetChipsArea();
        }
        this.cdr.detectChanges();
        // in case scrollbar has appeared recalc to size correctly.
        if (hasScroll !== this.hasVerticalScroll()) {
            this.calculateGridWidth();
            this.cdr.detectChanges();
        }
        if (this.zone.isStable) {
            this.zone.run(() => {
                this._applyWidthHostBinding();
                this.cdr.detectChanges();
            });
        }
        else {
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                this.zone.run(() => {
                    this._applyWidthHostBinding();
                });
            });
        }
        this.resetCaches(recalcFeatureWidth);
    }
    _applyWidthHostBinding() {
        let width = this._width;
        if (width === null) {
            let currentWidth = this.calcWidth;
            if (this.hasVerticalScroll()) {
                currentWidth += this.scrollWidth;
            }
            width = currentWidth + 'px';
            this.resetCaches();
        }
        this._hostWidth = width;
        this.cdr.markForCheck();
    }
    /**
     * Gets calculated width of the pinned area.
     * @example
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     */
    getPinnedWidth(takeHidden = false) {
        const fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
        let sum = 0;
        for (const col of fc) {
            if (col.level === 0) {
                sum += parseInt(col.calcWidth, 10);
            }
        }
        if (this.pinning.columns === ColumnPinningPosition.Start) {
            sum += this.featureColumnsWidth();
        }
        return sum;
    }
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     */
    getUnpinnedWidth(takeHidden = false) {
        let width = this.isPercentWidth ?
            this.calcWidth :
            parseInt(this.width, 10) || parseInt(this.hostWidth, 10) || this.calcWidth;
        if (this.hasVerticalScroll() && !this.isPercentWidth) {
            width -= this.scrollWidth;
        }
        if (this.pinning.columns === ColumnPinningPosition.End) {
            width -= this.featureColumnsWidth();
        }
        return width - this.getPinnedWidth(takeHidden);
    }
    /**
     * @hidden
     */
    _summaries(fieldName, hasSummary, summaryOperand) {
        const column = this.gridAPI.get_column_by_name(fieldName);
        if (column) {
            column.hasSummary = hasSummary;
            if (summaryOperand) {
                if (this.rootSummariesEnabled) {
                    this.summaryService.retriggerRootPipe++;
                }
                column.summaries = summaryOperand;
            }
        }
    }
    /**
     * @hidden
     */
    _multipleSummaries(expressions, hasSummary) {
        expressions.forEach((element) => {
            this._summaries(element.fieldName, hasSummary, element.customSummary);
        });
    }
    /**
     * @hidden
     */
    _disableMultipleSummaries(expressions) {
        expressions.forEach((column) => {
            const columnName = column && column.fieldName ? column.fieldName : column;
            this._summaries(columnName, false);
        });
    }
    /**
     * @hidden
     */
    resolveDataTypes(rec) {
        if (typeof rec === 'number') {
            return DataType.Number;
        }
        else if (typeof rec === 'boolean') {
            return DataType.Boolean;
        }
        else if (typeof rec === 'object' && rec instanceof Date) {
            return DataType.Date;
        }
        return DataType.String;
    }
    /**
     * @hidden
     */
    autogenerateColumns() {
        const data = this.gridAPI.get_data();
        const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const fields = this.generateDataFields(data);
        const columns = [];
        fields.forEach((field) => {
            const ref = factory.create(this.viewRef.injector);
            ref.instance.field = field;
            ref.instance.dataType = this.resolveDataTypes(data[0][field]);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        this._autoGeneratedCols = columns;
        this.columnList.reset(columns);
        if (data && data.length > 0) {
            this.shouldGenerate = false;
        }
    }
    generateDataFields(data) {
        return Object.keys(data && data.length !== 0 ? data[0] : []);
    }
    /**
     * @hidden
     */
    onlyTopLevel(arr) {
        return arr.filter(c => c.level === 0);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        this._columnGroups = this.columnList.some(col => col.columnGroup);
        if (this.hasColumnLayouts) {
            // Set overall row layout size
            this.columnList.forEach((col) => {
                if (col.columnLayout) {
                    const layoutSize = col.children ?
                        col.children.reduce((acc, val) => Math.max(val.rowStart + val.gridRowSpan - 1, acc), 1) :
                        1;
                    this._multiRowLayoutRowSize = Math.max(layoutSize, this._multiRowLayoutRowSize);
                }
            });
        }
        if (this.hasColumnLayouts && this.hasColumnGroups) {
            // invalid configuration - multi-row and column groups
            // remove column groups
            const columnLayoutColumns = this.columnList.filter((col) => col.columnLayout || col.columnLayoutChild);
            this.columnList.reset(columnLayoutColumns);
        }
        this._maxLevelHeaderDepth = null;
        this._columns = this.columnList.toArray();
        collection.forEach((column) => {
            column.defaultWidth = this.columnWidthSetByUser ? this._columnWidth : column.defaultWidth ? column.defaultWidth : '';
            if (cb) {
                cb(column);
            }
        });
        this.reinitPinStates();
        if (this.hasColumnLayouts) {
            collection.forEach((column) => {
                column.populateVisibleIndexes();
            });
        }
    }
    /**
     * @hidden
     */
    reinitPinStates() {
        this._pinnedColumns = (this.hasColumnGroups) ? this.columnList.filter((c) => c.pinned) :
            this.columnList.filter((c) => c.pinned).sort((a, b) => this._pinnedColumns.indexOf(a) - this._pinnedColumns.indexOf(b));
        this._unpinnedColumns = this.hasColumnGroups ? this.columnList.filter((c) => !c.pinned) :
            this.columnList.filter((c) => !c.pinned)
                .sort((a, b) => this._unpinnedColumns.indexOf(a) - this._unpinnedColumns.indexOf(b));
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return false;
    }
    /**
     * @hidden @internal
     */
    onHeaderSelectorClick(event) {
        if (!this.isMultiRowSelectionEnabled) {
            return;
        }
        this.selectionService.areAllRowSelected() ?
            this.selectionService.clearRowSelection(event) : this.selectionService.selectAllRows(event);
    }
    /**
     * @hidden @internal
     */
    get headSelectorBaseAriaLabel() {
        if (this._filteringExpressionsTree.filteringOperands.length > 0) {
            return this.selectionService.areAllRowSelected() ? 'Deselect all filtered' : 'Select all filtered';
        }
        return this.selectionService.areAllRowSelected() ? 'Deselect all' : 'Select all';
    }
    /**
     * @hidden
     * @internal
     */
    get totalRowsCountAfterFilter() {
        if (this.data) {
            return this.selectionService.allData.length;
        }
        return 0;
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped pinned row data, displayed in the grid.
     * @example
     * ```typescript
     *      const pinnedDataView = this.grid.pinnedDataView;
     * ```
     */
    get pinnedDataView() {
        return this.pinnedRecords ? this.pinnedRecords : [];
    }
    /**
     * Returns currently transformed paged/filtered/sorted/grouped unpinned row data, displayed in the grid.
     * @example
     * ```typescript
     *      const pinnedDataView = this.grid.pinnedDataView;
     * ```
     */
    get unpinnedDataView() {
        return this.unpinnedRecords ? this.unpinnedRecords : this.verticalScrollContainer.igxForOf || [];
    }
    /**
     * Returns the currently transformed paged/filtered/sorted/grouped/pinned/unpinned row data, displayed in the grid.
     * @example
     * ```typescript
     *      const dataView = this.grid.dataView;
     * ```
     */
    get dataView() {
        return this.isRowPinningToTop ?
            [...this.pinnedDataView, ...this.unpinnedDataView] :
            [...this.unpinnedDataView, ...this.pinnedDataView];
    }
    /**
     * Get current selection state.
     * @example
     * Returns an array with selected rows' IDs (primaryKey or rowData)
     * ```typescript
     * const selectedRows = this.grid.selectedRows();
     * ```
     */
    selectedRows() {
        return this.selectionService.getSelectedRows();
    }
    /**
     * Select specified rows by ID.
     * @example
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * @param rowIDs
     * @param clearCurrentSelection if true clears the current selection
     */
    selectRows(rowIDs, clearCurrentSelection) {
        this.selectionService.selectRowsWithNoEvent(rowIDs, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified rows by ID.
     * @example
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * @param rowIDs
     */
    deselectRows(rowIDs) {
        this.selectionService.deselectRowsWithNoEvent(rowIDs);
        this.notifyChanges();
    }
    /**
     * Selects all rows
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will select all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.selectAllRows();
     * this.grid.selectAllRows(false);
     * ```
     * @param onlyFilterData
     */
    selectAllRows(onlyFilterData = true) {
        const data = onlyFilterData && this.filteredData ? this.filteredData : this.gridAPI.get_all_data(true);
        const rowIDs = this.selectionService.getRowIDs(data).filter(rID => !this.gridAPI.row_deleted_transaction(rID));
        this.selectRows(rowIDs);
    }
    /**
     * Deselects all rows
     * @remarks
     * By default if filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * If you set the parameter onlyFilterData to false that will deselect all rows in the grid exept deleted rows.
     * @example
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * @param onlyFilterData
     */
    deselectAllRows(onlyFilterData = true) {
        if (onlyFilterData && this.filteredData && this.filteredData.length > 0) {
            this.deselectRows(this.selectionService.getRowIDs(this.filteredData));
        }
        else {
            this.selectionService.clearAllSelectedRows();
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    clearCellSelection() {
        this.selectionService.clear(true);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    dragScroll(dir) {
        const scrollDelta = 48;
        const horizontal = this.headerContainer.getScroll();
        const vertical = this.verticalScrollContainer.getScroll();
        switch (dir) {
            case DragScrollDirection.LEFT:
                horizontal.scrollLeft -= scrollDelta;
                break;
            case DragScrollDirection.RIGHT:
                horizontal.scrollLeft += scrollDelta;
                break;
            case DragScrollDirection.TOP:
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.BOTTOM:
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.TOPLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.TOPRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            default:
                return;
        }
    }
    /**
     * @hidden @internal
     */
    isDefined(arg) {
        return arg !== undefined && arg !== null;
    }
    /**
     * @hidden @internal
     */
    selectRange(arg) {
        if (!this.isDefined(arg)) {
            this.clearCellSelection();
            return;
        }
        if (arg instanceof Array) {
            arg.forEach(range => this.setSelection(range));
        }
        else {
            this.setSelection(arg);
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    columnToVisibleIndex(field) {
        const visibleColumns = this.visibleColumns;
        if (typeof field === 'number') {
            return field;
        }
        return visibleColumns.find(column => column.field === field).visibleIndex;
    }
    /**
     * @hidden @internal
     */
    setSelection(range) {
        const startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
        const endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
        this.selectionService.pointerState.node = startNode;
        this.selectionService.selectRange(endNode, this.selectionService.pointerState);
        this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
        this.selectionService.initPointerState();
    }
    /**
     * @hidden @internal
     */
    getSelectedRanges() {
        return this.selectionService.ranges;
    }
    extractDataFromSelection(source, formatters = false, headers = false) {
        let columnsArray;
        let record = {};
        const selectedData = [];
        const activeEl = this.selectionService.activeElement;
        const selectionMap = Array.from(this.selectionService.selection)
            .filter((tuple) => tuple[0] < source.length);
        if (this.cellSelection === GridSelectionMode.single && activeEl) {
            selectionMap.push([activeEl.row, new Set().add(activeEl.column)]);
        }
        for (const [row, set] of selectionMap) {
            if (!source[row] || source[row].detailsData !== undefined) {
                continue;
            }
            const temp = Array.from(set);
            for (const each of temp) {
                columnsArray = this.getSelectableColumnsAt(each);
                columnsArray.forEach((col) => {
                    if (col) {
                        const key = headers ? col.header || col.field : col.field;
                        const value = source[row].ghostRecord ? source[row].recordRef[col.field] : source[row][col.field];
                        record[key] = formatters && col.formatter ? col.formatter(value) : value;
                    }
                });
            }
            if (Object.keys(record).length) {
                selectedData.push(record);
            }
            record = {};
        }
        return selectedData;
    }
    getSelectableColumnsAt(index) {
        if (this.hasColumnLayouts) {
            const visibleLayoutColumns = this.visibleColumns
                .filter(col => col.columnLayout)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            const colLayout = visibleLayoutColumns[index];
            return colLayout ? colLayout.children.toArray() : [];
        }
        else {
            const visibleColumns = this.visibleColumns
                .filter(col => !col.columnGroup)
                .sort((a, b) => a.visibleIndex - b.visibleIndex);
            return [visibleColumns[index]];
        }
    }
    /**
     *
     * Returns an array of the current cell selection in the form of `[{ column.field: cell.value }, ...]`.
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedData(formatters = false, headers = false) {
        const source = this.filteredSortedData;
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * Get current selected columns.
     * @example
     * Returns an array with selected columns
     * ```typescript
     * const selectedColumns = this.grid.selectedColumns();
     * ```
     */
    selectedColumns() {
        const fields = this.selectionService.getSelectedColumns();
        return fields.map(field => this.getColumnByName(field)).filter(field => field);
    }
    /**
     * Select specified columns.
     * @example
     * ```typescript
     * this.grid.selectColumns(['ID','Name'], true);
     * ```
     * @param columns
     * @param clearCurrentSelection if true clears the current selection
     */
    selectColumns(columns, clearCurrentSelection) {
        let fieldToSelect = [];
        if (columns.length === 0 || typeof columns[0] === 'string') {
            fieldToSelect = columns;
        }
        else {
            columns.forEach(col => {
                if (col.columnGroup) {
                    const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);
                    fieldToSelect = [...fieldToSelect, ...children];
                }
                else {
                    fieldToSelect.push(col.field);
                }
            });
        }
        this.selectionService.selectColumnsWithNoEvent(fieldToSelect, clearCurrentSelection);
        this.notifyChanges();
    }
    /**
     * Deselect specified columns by filed.
     * @example
     * ```typescript
     * this.grid.deselectColumns(['ID','Name']);
     * ```
     * @param columns
     */
    deselectColumns(columns) {
        let fieldToDeselect = [];
        if (columns.length === 0 || typeof columns[0] === 'string') {
            fieldToDeselect = columns;
        }
        else {
            columns.forEach(col => {
                if (col.columnGroup) {
                    const children = col.allChildren.filter(c => !c.columnGroup).map(c => c.field);
                    fieldToDeselect = [...fieldToDeselect, ...children];
                }
                else {
                    fieldToDeselect.push(col.field);
                }
            });
        }
        this.selectionService.deselectColumnsWithNoEvent(fieldToDeselect);
        this.notifyChanges();
    }
    /**
     * Deselects all columns
     * @example
     * ```typescript
     * this.grid.deselectAllColumns();
     * ```
     */
    deselectAllColumns() {
        this.selectionService.clearAllSelectedColumns();
        this.notifyChanges();
    }
    /**
     * Selects all columns
     * @example
     * ```typescript
     * this.grid.deselectAllColumns();
     * ```
     */
    selectAllColumns() {
        this.selectColumns(this.columnList.filter(c => !c.columnGroup));
    }
    extractDataFromColumnsSelection(source, formatters = false, headers = false) {
        let record = {};
        const selectedData = [];
        const selectedColumns = this.selectedColumns();
        if (selectedColumns.length === 0) {
            return [];
        }
        for (let rowIndex = 0; rowIndex < source.length; rowIndex++) {
            selectedColumns.forEach((col) => {
                const key = headers ? col.header || col.field : col.field;
                record[key] = formatters && col.formatter ? col.formatter(source[rowIndex][col.field])
                    : source[rowIndex][col.field];
            });
            if (Object.keys(record).length) {
                selectedData.push(record);
            }
            record = {};
        }
        return selectedData;
    }
    /**
     *
     * Returns an array of the current columns selection in the form of `[{ column.field: cell.value }, ...]`.
     * @remarks
     * If `formatters` is enabled, the cell value will be formatted by its respective column formatter (if any).
     * If `headers` is enabled, it will use the column header (if any) instead of the column field.
     */
    getSelectedColumnsData(formatters = false, headers = false) {
        const source = this.filteredSortedData ? this.filteredSortedData : this.data;
        return this.extractDataFromColumnsSelection(source, formatters, headers);
    }
    /**
     * @hidden @internal
     */
    copyHandlerIE() {
        if (isIE()) {
            this.copyHandler(null, true);
        }
    }
    /**
     * @hidden
     * @internal
     */
    copyHandler(event, ie11 = false) {
        if (!this.clipboardOptions.enabled || this.crudService.inEditMode) {
            return;
        }
        const data = this.getSelectedData(this.clipboardOptions.copyFormatters, this.clipboardOptions.copyHeaders);
        const ev = { data, cancel: false };
        this.onGridCopy.emit(ev);
        if (ev.cancel) {
            return;
        }
        const transformer = new CharSeparatedValueData(ev.data, this.clipboardOptions.separator);
        let result = transformer.prepareData();
        if (!this.clipboardOptions.copyHeaders) {
            result = result.substring(result.indexOf('\n') + 1);
        }
        if (ie11) {
            window.clipboardData.setData('Text', result);
            return;
        }
        event.preventDefault();
        /* Necessary for the hiearachical case but will probably have to
           change how getSelectedData is propagated in the hiearachical grid
        */
        event.stopPropagation();
        event.clipboardData.setData('text/plain', result);
    }
    /**
     * Navigates to a position in the grid based on provided `rowindex` and `visibleColumnIndex`.
     * @remarks
     * Also can execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * @example
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     */
    navigateTo(rowIndex, visibleColIndex = -1, cb = null) {
        if (rowIndex < 0 || rowIndex > this.dataView.length - 1
            || (visibleColIndex !== -1 && this.columnList.map(col => col.visibleIndex).indexOf(visibleColIndex) === -1)) {
            return;
        }
        if (this.dataView.slice(rowIndex, rowIndex + 1).find(rec => rec.expression || rec.childGridsData)) {
            visibleColIndex = -1;
        }
        // If the target row is pinned no need to scroll as well.
        const shouldScrollVertically = this.navigation.shouldPerformVerticalScroll(rowIndex, visibleColIndex);
        const shouldScrollHorizontally = this.navigation.shouldPerformHorizontalScroll(visibleColIndex, rowIndex);
        if (shouldScrollVertically) {
            this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => {
                if (shouldScrollHorizontally) {
                    this.navigation.performHorizontalScrollToCell(visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));
                }
                else {
                    this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
        }
        else if (shouldScrollHorizontally) {
            this.navigation.performHorizontalScrollToCell(visibleColIndex, () => {
                if (shouldScrollVertically) {
                    this.navigation.performVerticalScrollToCell(rowIndex, visibleColIndex, () => this.executeCallback(rowIndex, visibleColIndex, cb));
                }
                else {
                    this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
        }
        else {
            this.executeCallback(rowIndex, visibleColIndex, cb);
        }
    }
    /**
     * Returns `ICellPosition` which defines the next cell,
     * according to the current position, that match specific criteria.
     * @remarks
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * @example
     * ```typescript
     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
     * ```
     */
    getNextCell(currRowIndex, curVisibleColIndex, callback = null) {
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => a - b) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => a - b);
        const nextCellIndex = colIndexes.find(index => index > curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && nextCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    /**
     * Returns `ICellPosition` which defines the previous cell,
     * according to the current position, that match specific criteria.
     * @remarks
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * @example
     * ```typescript
     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
     * ```
     */
    getPreviousCell(currRowIndex, curVisibleColIndex, callback = null) {
        const columns = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0);
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        const colIndexes = callback ? columns.filter((col) => callback(col)).map(editCol => editCol.visibleIndex).sort((a, b) => b - a) :
            columns.map(editCol => editCol.visibleIndex).sort((a, b) => b - a);
        const prevCellIndex = colIndexes.find(index => index < curVisibleColIndex);
        if (this.dataView.slice(currRowIndex, currRowIndex + 1)
            .find(rec => !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData) && prevCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex, true) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex, true), visibleColumnIndex: colIndexes[0] };
            }
        }
    }
    executeCallback(rowIndex, visibleColIndex = -1, cb = null) {
        if (!cb) {
            return;
        }
        let targetType, target;
        const row = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).find(r => r.index === rowIndex);
        if (!row) {
            return;
        }
        switch (row.nativeElement.tagName.toLowerCase()) {
            case 'igx-grid-groupby-row':
                targetType = GridKeydownTargetType.groupRow;
                target = row;
                break;
            case 'igx-grid-summary-row':
                targetType = GridKeydownTargetType.summaryCell;
                target = visibleColIndex !== -1 ?
                    row.summaryCells.find(c => c.visibleColumnIndex === visibleColIndex) : row.summaryCells.first;
                break;
            case 'igx-child-grid-row':
                targetType = GridKeydownTargetType.hierarchicalRow;
                target = row;
                break;
            default:
                targetType = GridKeydownTargetType.dataCell;
                target = visibleColIndex !== -1 ? row.cells.find(c => c.visibleColumnIndex === visibleColIndex) : row.cells.first;
                break;
        }
        const args = { targetType: targetType, target: target };
        cb(args);
    }
    getNextDataRowIndex(currentRowIndex, previous = false) {
        if (currentRowIndex < 0 || (currentRowIndex === 0 && previous) || (currentRowIndex >= this.dataView.length - 1 && !previous)) {
            return currentRowIndex;
        }
        // find next/prev record that is editable.
        const nextRowIndex = previous ? this.findPrevEditableDataRowIndex(currentRowIndex) :
            this.dataView.findIndex((rec, index) => index > currentRowIndex && this.isEditableDataRecordAtIndex(index));
        return nextRowIndex !== -1 ? nextRowIndex : currentRowIndex;
    }
    /**
     * Returns the previous editable row index or -1 if no such row is found.
     * @param currentIndex The index of the current editable record.
     */
    findPrevEditableDataRowIndex(currentIndex) {
        let i = this.dataView.length;
        while (i--) {
            if (i < currentIndex && this.isEditableDataRecordAtIndex(i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Returns if the record at the specified data view index is a an editable data record.
     * If record is group rec, summary rec, child rec, ghost rec. etc. it is not editable.
     * @param dataViewIndex The index of that record in the data view.
     */
    isEditableDataRecordAtIndex(dataViewIndex) {
        const rec = this.dataView[dataViewIndex];
        return !rec.expression && !rec.summaries && !rec.childGridsData && !rec.detailsData &&
            !this.isGhostRecordAtIndex(dataViewIndex);
    }
    /**
     * Returns if the record at the specified data view index is a ghost.
     * If record is pinned but is not in pinned area then it is a ghost record.
     * @param dataViewIndex The index of that record in the data view.
     */
    isGhostRecordAtIndex(dataViewIndex) {
        const isPinned = this.isRecordPinned(this.dataView[dataViewIndex]);
        const isInPinnedArea = this.isRecordPinnedByViewIndex(dataViewIndex);
        return isPinned && !isInPinnedArea;
    }
    isValidPosition(rowIndex, colIndex) {
        const rows = this.summariesRowList.filter(s => s.index !== 0).concat(this.rowList.toArray()).length;
        const cols = this.columnList.filter(col => !col.columnGroup && col.visibleIndex >= 0 && !col.hidden).length;
        if (rows < 1 || cols < 1) {
            return false;
        }
        if (rowIndex > -1 && rowIndex < this.dataView.length &&
            colIndex > -1 && colIndex <= Math.max(...this.visibleColumns.map(c => c.visibleIndex))) {
            return true;
        }
        return false;
    }
    /**
     * @hidden @internal
     */
    trackColumnChanges(index, col) {
        return col.field + col._calcWidth;
    }
    find(text, increment, caseSensitive, exactMatch, scroll) {
        if (!this.rowList) {
            return 0;
        }
        this.endEdit(false);
        if (!text) {
            this.clearSearch();
            return 0;
        }
        const caseSensitiveResolved = caseSensitive ? true : false;
        const exactMatchResolved = exactMatch ? true : false;
        let rebuildCache = false;
        if (this.lastSearchInfo.searchText !== text ||
            this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
            this.lastSearchInfo.exactMatch !== exactMatchResolved) {
            this.lastSearchInfo = {
                searchText: text,
                activeMatchIndex: 0,
                caseSensitive: caseSensitiveResolved,
                exactMatch: exactMatchResolved,
                matchInfoCache: []
            };
            rebuildCache = true;
        }
        else {
            this.lastSearchInfo.activeMatchIndex += increment;
        }
        if (rebuildCache) {
            this.rowList.forEach((row) => {
                if (row.cells) {
                    row.cells.forEach((c) => {
                        c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                    });
                }
            });
            this.rebuildMatchCache();
        }
        if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
            this.lastSearchInfo.activeMatchIndex = 0;
        }
        else if (this.lastSearchInfo.activeMatchIndex < 0) {
            this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
        }
        if (this.lastSearchInfo.matchInfoCache.length) {
            const matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
            this.lastSearchInfo = Object.assign({}, this.lastSearchInfo);
            if (scroll !== false) {
                this.scrollTo(matchInfo.row, matchInfo.column);
            }
            IgxTextHighlightDirective.setActiveHighlight(this.id, {
                column: matchInfo.column,
                row: matchInfo.row,
                index: matchInfo.index,
                metadata: matchInfo.metadata,
            });
        }
        else {
            IgxTextHighlightDirective.clearActiveHighlight(this.id);
        }
        return this.lastSearchInfo.matchInfoCache.length;
    }
    /**
     * Returns an array containing the filtered sorted data.
     * @example
     * ```typescript
     * const filteredSortedData = this.grid1.filteredSortedData;
     * ```
     */
    get filteredSortedData() {
        return this._filteredSortedData;
    }
    set filteredSortedData(value) {
        this._filteredSortedData = value;
        this.refreshSearch(true);
    }
    /**
     * @hidden
     */
    initPinning() {
        let currentPinnedWidth = 0;
        const pinnedColumns = [];
        const unpinnedColumns = [];
        this.calculateGridWidth();
        this.resetCaches();
        // When a column is a group or is inside a group, pin all related.
        this._pinnedColumns.forEach(col => {
            if (col.parent) {
                col.parent.pinned = true;
            }
            if (col.columnGroup) {
                col.children.forEach(child => child.pinned = true);
            }
        });
        // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
        // We take into account top level columns (top level groups and non groups).
        // If top level is unpinned the pinning handles all children to be unpinned as well.
        for (let i = 0; i < this._columns.length; i++) {
            if (this._columns[i].pinned && !this._columns[i].parent) {
                // Pinned column. Check if with it the unpinned min width is exceeded.
                const colWidth = parseInt(this._columns[i].width, 10);
                currentPinnedWidth += colWidth;
                pinnedColumns.push(this._columns[i]);
            }
            else if (this._columns[i].pinned && this._columns[i].parent) {
                if (this._columns[i].topLevelParent.pinned) {
                    pinnedColumns.push(this._columns[i]);
                }
                else {
                    this._columns[i].pinned = false;
                    unpinnedColumns.push(this._columns[i]);
                }
            }
            else {
                unpinnedColumns.push(this._columns[i]);
            }
        }
        // Assign the applicaple collections.
        this._pinnedColumns = pinnedColumns;
        this._unpinnedColumns = unpinnedColumns;
        this.notifyChanges();
    }
    /**
     * @hidden
     */
    scrollTo(row, column, inCollection = this._filteredSortedUnpinnedData) {
        let delayScrolling = false;
        if (this.paging && typeof (row) !== 'number') {
            const rowIndex = inCollection.indexOf(row);
            const page = Math.floor(rowIndex / this.perPage);
            if (this.page !== page) {
                delayScrolling = true;
                this.page = page;
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(row));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     */
    scrollToHorizontally(column) {
        let columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
        const scrollRow = this.rowList.find(r => r.virtDirRow);
        const virtDir = scrollRow ? scrollRow.virtDirRow : null;
        if (this.isPinningToStart && this.pinnedColumns.length) {
            if (columnIndex >= this.pinnedColumns.length) {
                columnIndex -= this.pinnedColumns.length;
                this.scrollDirective(virtDir, columnIndex);
            }
        }
        else {
            this.scrollDirective(virtDir, columnIndex);
        }
    }
    /**
     * @hidden
     */
    scrollDirective(directive, goal) {
        if (!directive) {
            return;
        }
        directive.scrollTo(goal);
    }
    rebuildMatchCache() {
        this.lastSearchInfo.matchInfoCache = [];
        const caseSensitive = this.lastSearchInfo.caseSensitive;
        const exactMatch = this.lastSearchInfo.exactMatch;
        const searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
        const data = this.filteredSortedData;
        const columnItems = this.visibleColumns.filter((c) => !c.columnGroup).sort((c1, c2) => c1.visibleIndex - c2.visibleIndex);
        const numberPipe = new IgxDecimalPipeComponent(this.locale);
        const datePipe = new IgxDatePipeComponent(this.locale);
        data.forEach((dataRow, rowIndex) => {
            columnItems.forEach((c) => {
                const value = c.formatter ? c.formatter(dataRow[c.field]) :
                    c.dataType === 'number' ? numberPipe.transform(dataRow[c.field], this.locale) :
                        c.dataType === 'date' ? datePipe.transform(dataRow[c.field], this.locale)
                            : dataRow[c.field];
                if (value !== undefined && value !== null && c.searchable) {
                    let searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                    if (exactMatch) {
                        if (searchValue === searchText) {
                            const metadata = new Map();
                            metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: 0,
                                metadata: metadata,
                            });
                        }
                    }
                    else {
                        let occurenceIndex = 0;
                        let searchIndex = searchValue.indexOf(searchText);
                        while (searchIndex !== -1) {
                            const metadata = new Map();
                            metadata.set('pinned', this.isRecordPinnedByIndex(rowIndex));
                            this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: occurenceIndex++,
                                metadata: metadata,
                            });
                            searchValue = searchValue.substring(searchIndex + searchText.length);
                            searchIndex = searchValue.indexOf(searchText);
                        }
                    }
                }
            });
        });
    }
    /**
     * @hidden
     */
    isExpandedGroup(_group) {
        return undefined;
    }
    changeRowEditingOverlayStateOnScroll(row) {
        if (!this.rowEditable || !this.rowEditingOverlay || this.rowEditingOverlay.collapsed) {
            return;
        }
        if (!row) {
            this.toggleRowEditingOverlay(false);
        }
        else {
            this.repositionRowEditingOverlay(row);
        }
    }
    /**
     * Should be called when data and/or isLoading input changes so that the overlay can be
     * hidden/shown based on the current value of shouldOverlayLoading
     */
    evaluateLoadingState() {
        if (this.shouldOverlayLoading) {
            // a new overlay should be shown
            const overlaySettings = {
                outlet: this.loadingOutlet,
                closeOnOutsideClick: false,
                positionStrategy: new ContainerPositionStrategy()
            };
            if (!this._loadingId) {
                this._loadingId = this.overlayService.attach(this.loadingOverlay, overlaySettings);
                this.overlayService.show(this._loadingId, overlaySettings);
            }
        }
        else {
            if (this._loadingId) {
                this.overlayService.hide(this._loadingId);
                this._loadingId = null;
            }
        }
    }
    /**
     * @hidden @internal
     */
    openRowOverlay(id) {
        this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
        this.rowEditingOverlay.open(this.rowEditSettings);
        this.rowEditPositioningStrategy.isTopInitialPosition = this.rowEditPositioningStrategy.isTop;
        this.rowEditingOverlay.element.addEventListener('wheel', this.rowEditingWheelHandler);
    }
    /**
     * @hidden @internal
     */
    closeRowEditingOverlay() {
        this.rowEditingOverlay.element.removeEventListener('wheel', this.rowEditingWheelHandler);
        this.rowEditPositioningStrategy.isTopInitialPosition = null;
        this.rowEditingOverlay.close();
        this.rowEditingOverlay.element.parentElement.style.display = '';
    }
    /**
     * @hidden @internal
     */
    toggleRowEditingOverlay(show) {
        const rowStyle = this.rowEditingOverlay.element.style;
        if (show) {
            rowStyle.display = 'block';
        }
        else {
            rowStyle.display = 'none';
        }
    }
    /**
     * @hidden @internal
     */
    repositionRowEditingOverlay(row) {
        if (row && !this.rowEditingOverlay.collapsed) {
            const rowStyle = this.rowEditingOverlay.element.parentElement.style;
            if (row) {
                rowStyle.display = '';
                this.configureRowEditingOverlay(row.rowID);
                this.rowEditingOverlay.reposition();
            }
            else {
                rowStyle.display = 'none';
            }
        }
    }
    configureRowEditingOverlay(rowID, useOuter = false) {
        this.rowEditSettings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
        this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
        const pinned = this._pinnedRecordIDs.indexOf(rowID) !== -1;
        const targetRow = !pinned ? this.gridAPI.get_row_by_key(rowID) : this.pinnedRows.find(x => x.rowID === rowID);
        if (!targetRow) {
            return;
        }
        this.rowEditPositioningStrategy.settings.target = targetRow.element.nativeElement;
        this.toggleRowEditingOverlay(true);
    }
    /**
     * @hidden @internal
     */
    get rowChangesCount() {
        if (!this.crudService.row) {
            return 0;
        }
        const rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
        return rowChanges ? Object.keys(rowChanges).length : 0;
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
    }
    /**
     * @hidden @internal
     */
    endRowTransaction(commit, row) {
        row.newData = this.transactions.getAggregatedValue(row.id, true);
        let args = row.createEditEventArgs();
        if (!commit) {
            this.onRowEditCancel.emit(args);
            this.transactions.endPending(false);
        }
        else {
            args = this.gridAPI.update_row(row, row.newData);
        }
        if (args.cancel) {
            this.transactions.startPending();
            return;
        }
        this.crudService.endRowEdit();
        this.closeRowEditingOverlay();
    }
    /**
     * @hidden @internal
     */
    gridOutletKeyboardHandler(event) {
        // TODO: This should be removed after grid keyboard refactoring
        // call stopPropagation for keydown event for the outlet not to propagate event to the grid
        event.stopPropagation();
    }
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     * @remarks
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     * @example
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param commit
     */
    endEdit(commit = true, event) {
        const row = this.crudService.row;
        const cell = this.crudService.cell;
        // TODO: Merge the crudService with wht BaseAPI service
        if (!row && !cell) {
            return;
        }
        commit ? this.gridAPI.submit_value() : this.gridAPI.escape_editMode();
        if (!this.rowEditable || this.rowEditingOverlay && this.rowEditingOverlay.collapsed || !row) {
            return;
        }
        this.endRowTransaction(commit, row);
        const activeCell = this.selectionService.activeElement;
        if (event && activeCell) {
            const rowIndex = activeCell.row;
            const visibleColIndex = activeCell.layout ? activeCell.layout.columnVisibleIndex : activeCell.column;
            this.navigateTo(rowIndex, visibleColIndex, (c) => {
                if (c.targetType === GridKeydownTargetType.dataCell && c.target) {
                    c.target.activate();
                }
            });
        }
    }
    /**
     * @hidden
     * @internal
     */
    endRowEdit(commit = true, event) {
        this.endEdit(commit, event);
        const activeCell = this.navigation.activeNode;
        if (activeCell && activeCell.row !== -1) {
            this.tbody.nativeElement.focus();
        }
    }
    /**
     * @hidden @internal
     */
    get dataWithAddedInTransactionRows() {
        const result = cloneArray(this.gridAPI.get_all_data());
        if (this.transactions.enabled) {
            result.push(...this.transactions.getAggregatedChanges(true)
                .filter(t => t.type === TransactionType.ADD)
                .map(t => t.newValue));
        }
        return result;
    }
    /**
     * @hidden @internal
     */
    get dataLength() {
        return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
    }
    /**
     * @hidden @internal
     */
    hasHorizontalScroll() {
        return this.totalWidth - this.unpinnedWidth > 0;
    }
    _restoreVirtState(row) {
        // check virtualization state of data record added from cache
        // in case state is no longer valid - update it.
        const rowForOf = row.virtDirRow;
        const gridScrLeft = rowForOf.getScroll().scrollLeft;
        const left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
        const actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
        if (gridScrLeft !== actualScrollLeft) {
            rowForOf.onHScroll(gridScrLeft);
            rowForOf.cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    getExportExcel() {
        return this._exportExcel;
    }
    /**
     * @hidden
     */
    getExportCsv() {
        return this._exportCsv;
    }
    /**
     * @hidden @internal
     */
    get shouldOverlayLoading() {
        return this.isLoading && this.data && this.data.length > 0;
    }
    /**
     * @hidden @internal
     */
    isSummaryRow(rowData) {
        return rowData.summaries && (rowData.summaries instanceof Map);
    }
    /**
     * @hidden @internal
     */
    get isMultiRowSelectionEnabled() {
        return this.rowSelection === GridSelectionMode.multiple;
    }
    /**
     * @hidden @internal
     */
    get isRowSelectable() {
        return this.rowSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden @internal
     */
    get isCellSelectable() {
        return this.cellSelection !== GridSelectionMode.none;
    }
    /**
     * @hidden @internal
     */
    cachedViewLoaded(args) {
        if (this.hasHorizontalScroll()) {
            const tmplId = args.context.templateID;
            const index = args.context.index;
            args.view.detectChanges();
            this.zone.onStable.pipe(first$1()).subscribe(() => {
                const row = tmplId === 'dataRow' ? this.getRowByIndex(index) : null;
                const summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.find((sr) => sr.dataRowIndex === index) : null;
                if (row && row instanceof IgxRowDirective) {
                    this._restoreVirtState(row);
                }
                else if (summaryRow) {
                    this._restoreVirtState(summaryRow);
                }
            });
        }
    }
    /**
     * Opens the advanced filtering dialog.
     */
    openAdvancedFilteringDialog() {
        if (!this._advancedFilteringOverlayId) {
            this._advancedFilteringOverlaySettings.positionStrategy.settings.target =
                this.rootGrid ? this.rootGrid.nativeElement : this.nativeElement;
            this._advancedFilteringOverlaySettings.outlet = this.outletDirective;
            this._advancedFilteringOverlayId = this.overlayService.attach(IgxAdvancedFilteringDialogComponent, this._advancedFilteringOverlaySettings, {
                injector: this.viewRef.injector,
                componentFactoryResolver: this.resolver
            });
            this.overlayService.show(this._advancedFilteringOverlayId, this._advancedFilteringOverlaySettings);
        }
    }
    /**
     * Closes the advanced filtering dialog.
     * @param applyChanges indicates whether the changes should be applied
     */
    closeAdvancedFilteringDialog(applyChanges) {
        if (this._advancedFilteringOverlayId) {
            const advancedFilteringOverlay = this.overlayService.getOverlayById(this._advancedFilteringOverlayId);
            const advancedFilteringDialog = advancedFilteringOverlay.componentRef.instance;
            if (applyChanges) {
                advancedFilteringDialog.applyChanges();
            }
            advancedFilteringDialog.closeDialog();
        }
    }
};
IgxGridBaseDirective.ɵfac = function IgxGridBaseDirective_Factory(t) { return new (t || IgxGridBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridTransaction), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(IgxGridNavigationService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxGridSummaryService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxGridBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridBaseDirective, selectors: [["", "igxGridBaseComponent", ""]], contentQueries: function IgxGridBaseDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowExpandedIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowCollapsedIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHeaderExpandIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHeaderCollapseIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStyleSortingTemplateDirective, true, IgxExcelStyleSortingTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStyleMovingTemplateDirective, true, IgxExcelStyleMovingTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStyleHidingTemplateDirective, true, IgxExcelStyleHidingTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStyleSelectingTemplateDirective, true, IgxExcelStyleSelectingTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExcelStylePinningTemplateDirective, true, IgxExcelStylePinningTemplateDirective);
        ɵngcc0.ɵɵstaticContentQuery(dirIndex, IgxExcelStyleLoadingValuesTemplateDirective, true, IgxExcelStyleLoadingValuesTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditTextDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditActionsDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, true, IgxColumnComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridToolbarCustomContentDirective, false, IgxGridToolbarCustomContentDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxHeadSelectorDirective, false, IgxHeadSelectorDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowSelectorDirective, false, IgxRowSelectorDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowDragGhostDirective, false, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDragIndicatorIconDirective, false, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowEditTabStopDirective, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowExpandedIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowCollapsedIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerExpandIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerCollapseIndicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleSortingTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleMovingTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleHidingTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleSelectingTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStylePinningTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.excelStyleLoadingValuesTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditCustom = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditText = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditActions = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.columnList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbarCustomContentTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headSelectorsTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowSelectorsTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragGhostCustomTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconTemplates = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditTabsCUSTOM = _t);
    } }, viewQuery: function IgxGridBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c117, true, IgxGridToolbarComponent);
        ɵngcc0.ɵɵviewQuery(_c117, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c118, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c119, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxGridColumnResizerComponent, true);
        ɵngcc0.ɵɵstaticViewQuery(_c120, true);
        ɵngcc0.ɵɵstaticViewQuery(_c121, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c122, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c123, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c124, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c6, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c125, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c126, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c127, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c128, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c129, true, IgxGridForOfDirective);
        ɵngcc0.ɵɵviewQuery(_c130, true);
        ɵngcc0.ɵɵviewQuery(_c131, true);
        ɵngcc0.ɵɵviewQuery(_c132, true);
        ɵngcc0.ɵɵviewQuery(_c133, true, IgxGridFilteringRowComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c134, true);
        ɵngcc0.ɵɵstaticViewQuery(_c135, true);
        ɵngcc0.ɵɵviewQuery(_c136, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c137, true);
        ɵngcc0.ɵɵstaticViewQuery(_c138, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c139, true, IgxOverlayOutletDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c140, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c141, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxTemplateOutletDirective, true, IgxTemplateOutletDirective);
        ɵngcc0.ɵɵviewQuery(IgxGridHeaderGroupComponent, true, IgxGridHeaderGroupComponent);
        ɵngcc0.ɵɵviewQuery(_c142, true);
        ɵngcc0.ɵɵviewQuery(_c143, true);
        ɵngcc0.ɵɵviewQuery(_c144, true, IgxSummaryRowComponent);
        ɵngcc0.ɵɵviewQuery(IgxRowDirective, true, IgxRowDirective);
        ɵngcc0.ɵɵviewQuery(IgxRowEditTabStopDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toolbarHtml = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resizeLine = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingOutlet = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyFilteredGridTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyGridDefaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.loadingGridDefaultTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.parentVirtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.verticalScrollContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.verticalScroll = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scr = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerSelectorContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerDragContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerGroupContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filteringRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.theadRow = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tbody = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.pinContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tfoot = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._outletDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditingOutletDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultRowEditTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditingOverlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tmpOutlets = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerGroups = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._rowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._pinnedRowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._summaryRowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._dataRowList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowEditTabsDEFAULT = _t);
    } }, hostVars: 7, hostBindings: function IgxGridBaseDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("role", ctx.hostRole)("class", ctx.hostClass);
        ɵngcc0.ɵɵstyleProp("height", ctx.height)("width", ctx.hostWidth);
    } }, inputs: { autoGenerate: "autoGenerate", class: "class", evenRowCSS: "evenRowCSS", oddRowCSS: "oddRowCSS", columnHidingTitle: "columnHidingTitle", columnPinningTitle: "columnPinningTitle", clipboardOptions: "clipboardOptions", resourceStrings: "resourceStrings", filteringLogic: "filteringLogic", filteringExpressionsTree: "filteringExpressionsTree", advancedFilteringExpressionsTree: "advancedFilteringExpressionsTree", locale: "locale", paging: "paging", page: "page", perPage: "perPage", columnHiding: "columnHiding", hideRowSelectors: "hideRowSelectors", rowDraggable: "rowDraggable", rowEditable: "rowEditable", height: "height", width: "width", rowHeight: "rowHeight", columnWidth: "columnWidth", emptyGridMessage: "emptyGridMessage", isLoading: "isLoading", emptyFilteredGridMessage: "emptyFilteredGridMessage", pinning: "pinning", columnPinning: "columnPinning", allowFiltering: "allowFiltering", allowAdvancedFiltering: "allowAdvancedFiltering", filterMode: "filterMode", summaryPosition: "summaryPosition", summaryCalculationMode: "summaryCalculationMode", filterStrategy: "filterStrategy", sortStrategy: "sortStrategy", sortingExpressions: "sortingExpressions", hiddenColumnsText: "hiddenColumnsText", pinnedColumnsText: "pinnedColumnsText", showToolbar: "showToolbar", toolbarTitle: "toolbarTitle", exportExcel: "exportExcel", exportCsv: "exportCsv", exportText: "exportText", exportExcelText: "exportExcelText", exportCsvText: "exportCsvText", cellSelection: "cellSelection", rowSelection: "rowSelection", columnSelection: "columnSelection", expansionStates: "expansionStates", emptyGridTemplate: "emptyGridTemplate", loadingGridTemplate: "loadingGridTemplate", paginationTemplate: "paginationTemplate", primaryKey: "primaryKey", uniqueColumnValuesStrategy: "uniqueColumnValuesStrategy" }, outputs: { filteringExpressionsTreeChange: "filteringExpressionsTreeChange", advancedFilteringExpressionsTreeChange: "advancedFilteringExpressionsTreeChange", pageChange: "pageChange", perPageChange: "perPageChange", onCellClick: "onCellClick", onSelection: "onSelection", onRowSelectionChange: "onRowSelectionChange", onColumnSelectionChange: "onColumnSelectionChange", onColumnPinning: "onColumnPinning", onCellEditCancel: "onCellEditCancel", onCellEditEnter: "onCellEditEnter", onCellEdit: "onCellEdit", onRowEditEnter: "onRowEditEnter", onRowEdit: "onRowEdit", onRowEditCancel: "onRowEditCancel", onColumnInit: "onColumnInit", onSortingDone: "onSortingDone", onFilteringDone: "onFilteringDone", onPagingDone: "onPagingDone", onRowAdded: "onRowAdded", onRowDeleted: "onRowDeleted", onDataPreLoad: "onDataPreLoad", onColumnResized: "onColumnResized", onContextMenu: "onContextMenu", onDoubleClick: "onDoubleClick", onColumnVisibilityChanged: "onColumnVisibilityChanged", onColumnMovingStart: "onColumnMovingStart", onColumnMoving: "onColumnMoving", onColumnMovingEnd: "onColumnMovingEnd", onGridKeydown: "onGridKeydown", onRowDragStart: "onRowDragStart", onRowDragEnd: "onRowDragEnd", onGridCopy: "onGridCopy", expansionStatesChange: "expansionStatesChange", onRowToggle: "onRowToggle", onRowPinning: "onRowPinning", sortingExpressionsChange: "sortingExpressionsChange", onToolbarExporting: "onToolbarExporting", onRangeSelection: "onRangeSelection" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxGridBaseDirective.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    ViewChild('defaultExpandedTemplate', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "defaultExpandedTemplate", void 0);
__decorate([
    ViewChild('defaultCollapsedTemplate', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "defaultCollapsedTemplate", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "resourceStrings", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "autoGenerate", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "emptyGridTemplate", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "loadingGridTemplate", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "filteringLogic", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "filteringExpressionsTree", null);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "filteringExpressionsTreeChange", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTreeChange", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "advancedFilteringExpressionsTree", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "locale", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "paging", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "page", null);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "pageChange", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "perPage", null);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "perPageChange", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "paginationTemplate", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "columnHiding", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "hideRowSelectors", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "rowDraggable", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "rowEditable", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "class", void 0);
__decorate([
    WatchChanges(),
    HostBinding('style.height'),
    Input()
], IgxGridBaseDirective.prototype, "height", null);
__decorate([
    HostBinding('style.width')
], IgxGridBaseDirective.prototype, "hostWidth", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "width", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "evenRowCSS", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "oddRowCSS", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "rowHeight", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "columnWidth", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "primaryKey", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "emptyGridMessage", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "isLoading", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "emptyFilteredGridMessage", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "columnHidingTitle", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "pinning", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "columnPinning", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "columnPinningTitle", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "allowFiltering", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "allowAdvancedFiltering", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "filterMode", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "summaryPosition", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "summaryCalculationMode", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "filterStrategy", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "sortStrategy", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "uniqueColumnValuesStrategy", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onCellClick", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onSelection", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowSelectionChange", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnSelectionChange", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnPinning", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onCellEditCancel", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onCellEditEnter", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onCellEdit", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowEditEnter", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowEdit", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowEditCancel", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnInit", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onSortingDone", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onFilteringDone", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onPagingDone", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowAdded", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowDeleted", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onDataPreLoad", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnResized", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onContextMenu", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onDoubleClick", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnVisibilityChanged", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnMovingStart", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnMoving", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onColumnMovingEnd", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onGridKeydown", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowDragStart", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowDragEnd", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onGridCopy", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "expansionStatesChange", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowToggle", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRowPinning", void 0);
__decorate([
    ViewChild(IgxGridColumnResizerComponent)
], IgxGridBaseDirective.prototype, "resizeLine", void 0);
__decorate([
    ViewChild('loadingOverlay', { static: true })
], IgxGridBaseDirective.prototype, "loadingOverlay", void 0);
__decorate([
    ViewChild('igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true })
], IgxGridBaseDirective.prototype, "loadingOutlet", void 0);
__decorate([
    ContentChildren(IgxColumnComponent, { read: IgxColumnComponent, descendants: true })
], IgxGridBaseDirective.prototype, "columnList", void 0);
__decorate([
    ContentChild(IgxExcelStyleSortingTemplateDirective, { read: IgxExcelStyleSortingTemplateDirective })
], IgxGridBaseDirective.prototype, "excelStyleSortingTemplateDirective", void 0);
__decorate([
    ContentChild(IgxExcelStyleMovingTemplateDirective, { read: IgxExcelStyleMovingTemplateDirective })
], IgxGridBaseDirective.prototype, "excelStyleMovingTemplateDirective", void 0);
__decorate([
    ContentChild(IgxExcelStyleHidingTemplateDirective, { read: IgxExcelStyleHidingTemplateDirective })
], IgxGridBaseDirective.prototype, "excelStyleHidingTemplateDirective", void 0);
__decorate([
    ContentChild(IgxExcelStyleSelectingTemplateDirective, { read: IgxExcelStyleSelectingTemplateDirective })
], IgxGridBaseDirective.prototype, "excelStyleSelectingTemplateDirective", void 0);
__decorate([
    ContentChild(IgxExcelStylePinningTemplateDirective, { read: IgxExcelStylePinningTemplateDirective })
], IgxGridBaseDirective.prototype, "excelStylePinningTemplateDirective", void 0);
__decorate([
    ContentChild(IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true })
], IgxGridBaseDirective.prototype, "excelStyleLoadingValuesTemplateDirective", void 0);
__decorate([
    ViewChildren(IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent })
], IgxGridBaseDirective.prototype, "headerGroups", void 0);
__decorate([
    ViewChildren('row')
], IgxGridBaseDirective.prototype, "_rowList", void 0);
__decorate([
    ViewChildren('pinnedRow')
], IgxGridBaseDirective.prototype, "_pinnedRowList", void 0);
__decorate([
    ViewChildren('summaryRow', { read: IgxSummaryRowComponent })
], IgxGridBaseDirective.prototype, "_summaryRowList", void 0);
__decorate([
    ViewChildren(IgxRowDirective, { read: IgxRowDirective })
], IgxGridBaseDirective.prototype, "_dataRowList", void 0);
__decorate([
    ViewChild('emptyFilteredGrid', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "emptyFilteredGridTemplate", void 0);
__decorate([
    ViewChild('defaultEmptyGrid', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "emptyGridDefaultTemplate", void 0);
__decorate([
    ViewChild('defaultLoadingGrid', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "loadingGridDefaultTemplate", void 0);
__decorate([
    ViewChild('scrollContainer', { read: IgxGridForOfDirective, static: true })
], IgxGridBaseDirective.prototype, "parentVirtDir", void 0);
__decorate([
    ContentChildren(IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false })
], IgxGridBaseDirective.prototype, "toolbarCustomContentTemplates", void 0);
__decorate([
    ContentChildren(IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false })
], IgxGridBaseDirective.prototype, "headSelectorsTemplates", void 0);
__decorate([
    ContentChildren(IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false })
], IgxGridBaseDirective.prototype, "rowSelectorsTemplates", void 0);
__decorate([
    ContentChildren(IgxRowDragGhostDirective, { read: TemplateRef, descendants: false })
], IgxGridBaseDirective.prototype, "dragGhostCustomTemplates", void 0);
__decorate([
    ViewChild('verticalScrollContainer', { read: IgxGridForOfDirective, static: true })
], IgxGridBaseDirective.prototype, "verticalScrollContainer", void 0);
__decorate([
    ViewChild('verticalScrollHolder', { read: IgxGridForOfDirective, static: true })
], IgxGridBaseDirective.prototype, "verticalScroll", void 0);
__decorate([
    ViewChild('scr', { read: ElementRef, static: true })
], IgxGridBaseDirective.prototype, "scr", void 0);
__decorate([
    ViewChild('footer', { read: ElementRef })
], IgxGridBaseDirective.prototype, "footer", void 0);
__decorate([
    ViewChild('hContainer', { read: IgxGridForOfDirective, static: true })
], IgxGridBaseDirective.prototype, "headerContainer", void 0);
__decorate([
    ViewChild('headerSelectorContainer')
], IgxGridBaseDirective.prototype, "headerSelectorContainer", void 0);
__decorate([
    ViewChild('headerDragContainer')
], IgxGridBaseDirective.prototype, "headerDragContainer", void 0);
__decorate([
    ViewChild('headerGroupContainer')
], IgxGridBaseDirective.prototype, "headerGroupContainer", void 0);
__decorate([
    ViewChild('filteringRow', { read: IgxGridFilteringRowComponent })
], IgxGridBaseDirective.prototype, "filteringRow", void 0);
__decorate([
    ViewChild('theadRow', { static: true })
], IgxGridBaseDirective.prototype, "theadRow", void 0);
__decorate([
    ViewChild('tbody', { static: true })
], IgxGridBaseDirective.prototype, "tbody", void 0);
__decorate([
    ViewChild('pinContainer', { read: ElementRef })
], IgxGridBaseDirective.prototype, "pinContainer", void 0);
__decorate([
    ViewChild('tfoot', { static: true })
], IgxGridBaseDirective.prototype, "tfoot", void 0);
__decorate([
    ViewChild('igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true })
], IgxGridBaseDirective.prototype, "_outletDirective", void 0);
__decorate([
    ViewChild('igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true })
], IgxGridBaseDirective.prototype, "rowEditingOutletDirective", void 0);
__decorate([
    ViewChildren(IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective })
], IgxGridBaseDirective.prototype, "tmpOutlets", void 0);
__decorate([
    ViewChild('dragIndicatorIconBase', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "dragIndicatorIconBase", void 0);
__decorate([
    ViewChild('defaultRowEditTemplate', { read: TemplateRef, static: true })
], IgxGridBaseDirective.prototype, "defaultRowEditTemplate", void 0);
__decorate([
    ContentChild(IgxRowEditTemplateDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "rowEditCustom", void 0);
__decorate([
    ContentChild(IgxRowEditTextDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "rowEditText", void 0);
__decorate([
    ContentChild(IgxRowEditActionsDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "rowEditActions", void 0);
__decorate([
    ContentChild(IgxRowExpandedIndicatorDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "rowExpandedIndicatorTemplate", void 0);
__decorate([
    ContentChild(IgxRowCollapsedIndicatorDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "rowCollapsedIndicatorTemplate", void 0);
__decorate([
    ContentChild(IgxHeaderExpandIndicatorDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "headerExpandIndicatorTemplate", void 0);
__decorate([
    ContentChild(IgxHeaderCollapseIndicatorDirective, { read: TemplateRef })
], IgxGridBaseDirective.prototype, "headerCollapseIndicatorTemplate", void 0);
__decorate([
    ContentChildren(IgxDragIndicatorIconDirective, { read: TemplateRef, descendants: false })
], IgxGridBaseDirective.prototype, "dragIndicatorIconTemplates", void 0);
__decorate([
    ViewChildren(IgxRowEditTabStopDirective)
], IgxGridBaseDirective.prototype, "rowEditTabsDEFAULT", void 0);
__decorate([
    ContentChildren(IgxRowEditTabStopDirective)
], IgxGridBaseDirective.prototype, "rowEditTabsCUSTOM", void 0);
__decorate([
    ViewChild(IgxToggleDirective)
], IgxGridBaseDirective.prototype, "rowEditingOverlay", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxGridBaseDirective.prototype, "tabindex", void 0);
__decorate([
    HostBinding('attr.class')
], IgxGridBaseDirective.prototype, "hostClass", null);
__decorate([
    HostBinding('attr.role')
], IgxGridBaseDirective.prototype, "hostRole", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "sortingExpressions", null);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "sortingExpressionsChange", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "hiddenColumnsText", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "pinnedColumnsText", null);
__decorate([
    ViewChild('toolbar', { read: IgxGridToolbarComponent })
], IgxGridBaseDirective.prototype, "toolbar", void 0);
__decorate([
    ViewChild('toolbar', { read: ElementRef })
], IgxGridBaseDirective.prototype, "toolbarHtml", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "showToolbar", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "toolbarTitle", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "exportExcel", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "exportCsv", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "exportText", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "exportExcelText", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "exportCsvText", null);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "clipboardOptions", void 0);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "cellSelection", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "rowSelection", null);
__decorate([
    WatchChanges(),
    Input()
], IgxGridBaseDirective.prototype, "columnSelection", null);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onToolbarExporting", void 0);
__decorate([
    Output()
], IgxGridBaseDirective.prototype, "onRangeSelection", void 0);
__decorate([
    Input()
], IgxGridBaseDirective.prototype, "expansionStates", null);
IgxGridBaseDirective = __decorate([ __param(4, Inject(IgxGridTransaction)),
    __param(7, Inject(DOCUMENT)),
    __param(14, Inject(IgxOverlayService)),
    __param(16, Optional()), __param(16, Inject(DisplayDensityToken))
], IgxGridBaseDirective);

let IgxGridFooterComponent = class IgxGridFooterComponent {
};
IgxGridFooterComponent.ɵfac = function IgxGridFooterComponent_Factory(t) { return new (t || IgxGridFooterComponent)(); };
IgxGridFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridFooterComponent, selectors: [["igx-grid-footer"]], ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxGridFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });

/**
 * The `<igx-select-item>` is a container intended for row items in
 * a `<igx-select>` container.
 */
let IgxSelectGroupComponent = class IgxSelectGroupComponent extends IgxDropDownGroupComponent {
};
IgxSelectGroupComponent.ɵfac = function IgxSelectGroupComponent_Factory(t) { return ɵIgxSelectGroupComponent_BaseFactory(t || IgxSelectGroupComponent); };
IgxSelectGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSelectGroupComponent, selectors: [["igx-select-item-group"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c146, decls: 3, vars: 2, consts: [[3, "id"]], template: function IgxSelectGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c145);
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵpropertyInterpolate("id", ctx.labelId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.label);
    } }, encapsulation: 2 });

/** @hidden @internal */
let IgxSelectItemNavigationDirective = class IgxSelectItemNavigationDirective extends IgxDropDownItemNavigationDirective {
    constructor() {
        super(null);
        // tslint:disable:member-ordering
        this.inputStream = '';
        this.clearStream$ = Subscription.EMPTY;
    }
    /** Captures keydown events and calls the appropriate handlers on the target component */
    handleKeyDown(event) {
        if (!event || event.shiftKey) {
            return;
        }
        const key = event.key.toLowerCase();
        if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
            this.target.toggle();
            return;
        }
        if (this.target.collapsed) {
            switch (key) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'enter':
                    event.preventDefault();
                    this.target.open();
                    return;
                case 'arrowdown':
                case 'down':
                    this.target.navigateNext();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                case 'arrowup':
                case 'up':
                    this.target.navigatePrev();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                default:
                    break;
            }
        }
        super.handleKeyDown(event);
    }
    /** Handle continuous letter typing navigation */
    captureKey(event) {
        // relying only on key, available on all major browsers:
        // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
        if (!event || !event.key || event.key.length > 1) {
            // ignore longer keys ('Alt', 'ArrowDown', etc)
            return;
        }
        this.clearStream$.unsubscribe();
        this.clearStream$ = timer(500).subscribe(() => {
            this.inputStream = '';
        });
        this.inputStream += event.key;
        const focusedItem = this.target.focusedItem;
        // select the item
        if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
            return;
        }
        this.activateItemByText(this.inputStream);
    }
    activateItemByText(text) {
        const items = this.target.items;
        const activeItemIndex = items.indexOf(this.target.focusedItem) || 0;
        // ^ this is focused OR selected if the dd is closed
        let nextItem = items.slice(activeItemIndex + 1).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
        if (!nextItem) {
            nextItem = items.slice(0, activeItemIndex).find(x => !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())));
        }
        if (!nextItem) {
            return;
        }
        if (this.target.collapsed) {
            this.target.selectItem(nextItem);
        }
        this.target.navigateItem(items.indexOf(nextItem));
    }
    ngOnDestroy() {
        this.clearStream$.unsubscribe();
    }
};
IgxSelectItemNavigationDirective.ɵfac = function IgxSelectItemNavigationDirective_Factory(t) { return new (t || IgxSelectItemNavigationDirective)(); };
IgxSelectItemNavigationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSelectItemNavigationDirective, selectors: [["", "igxSelectItemNavigation", ""]], hostBindings: function IgxSelectItemNavigationDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup", function IgxSelectItemNavigationDirective_keyup_HostBindingHandler($event) { return ctx.captureKey($event); });
    } }, inputs: { target: ["igxSelectItemNavigation", "target"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input('igxSelectItemNavigation')
], IgxSelectItemNavigationDirective.prototype, "target", void 0);
__decorate([
    HostListener('keyup', ['$event'])
], IgxSelectItemNavigationDirective.prototype, "captureKey", null);

/** @hidden */
let IgxSelectModule = class IgxSelectModule {
};
IgxSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSelectModule });
IgxSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSelectModule_Factory(t) { return new (t || IgxSelectModule)(); }, providers: [], imports: [[
            CommonModule,
            FormsModule,
            IgxButtonModule,
            IgxDropDownModule,
            IgxIconModule,
            IgxInputGroupModule,
            IgxRippleModule,
            IgxToggleModule,
            ReactiveFormsModule
        ]] });

let IgxPaginatorComponent = class IgxPaginatorComponent extends DisplayDensityBase {
    constructor(_displayDensityOptions) {
        super(_displayDensityOptions);
        this._displayDensityOptions = _displayDensityOptions;
        this._resourceStrings = CurrentResourceStrings.PaginatorResStrings;
        this._page = 0;
        this.defaultSelectValues = [5, 10, 15, 25, 50, 100, 500];
        this._perPage = 15;
        /**
         * An @Input property that sets if the pager in the paginator should be enabled.
         * ```html
         * <igx-paginator [pagerEnabled]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.pagerEnabled = true;
        /**
         * An @Input property that sets if the pager in the paginator should be hidden.
         * ```html
         * <igx-paginator [pagerHidden]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.pagerHidden = false;
        /**
         * An @Input property that sets if the dropdown in the paginator should be enabled.
         * ```html
         * <igx-paginator [dropdownEnabled]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.dropdownEnabled = true;
        /**
         * An @Input property that sets if the dropdown in the paginator should be hidden.
         * ```html
         * <igx-paginator [dropdownHidden]="true"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.dropdownHidden = false;
        /**
         * @deprecated Use 'resourceStrings' instead.
         * An @Input property, sets number of label of the select.
         * The default is 'Items per page' localized string.
         * ```html
         * <igx-paginator label="My custom label"></igx-paginator>
         * ```
         * @memberof IgxPaginatorComponent
         */
        this.selectLabel = CurrentResourceStrings.PaginatorResStrings.igx_paginator_label;
        /**
         * @deprecated Use 'resourceStrings' instead.
         * An @Input property, sets a preposition between the current page and total pages.
         * The default is 'of' localized string.
         * @memberof IgxPaginatorComponent
         */
        this.prepositionPage = CurrentResourceStrings.PaginatorResStrings.igx_paginator_pager_text;
        /**
         * Emitted when `perPage` property value of the paginator is changed.
         * @example
         * ```html
         * <igx-paginator (perPageChange)="onPerPageChange($event)"></igx-paginator>
         * ```
         * ```typescript
         * public onPerPageChange(perPage: number) {
         *   this.perPage = perPage;
         * }
         * ```
         */
        this.perPageChange = new EventEmitter();
        /**
         * Emitted after the current page is changed.
         * @example
         * ```html
         * <igx-paginator (pageChange)="onPageChange($event)"></igx-paginator>
         * ```
         * ```typescript
         * public onPageChange(page: number) {
         *   this.currentPage = page;
         * }
         * ```
         */
        this.pageChange = new EventEmitter();
    }
    /**
     * Sets the class of the IgxPaginatorComponent based
     * on the provided displayDensity.
     */
    get classCosy() {
        return this.displayDensity === DisplayDensity.cosy;
    }
    get classCompact() {
        return this.displayDensity === DisplayDensity.compact;
    }
    get classComfortable() {
        return this.displayDensity === DisplayDensity.comfortable;
    }
    /**
     * An @Input property, sets current page of the `IgxPaginatorComponent`.
     * The default is 0.
     * ```typescript
     * let page = this.paginator.page;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get page() {
        return this._page;
    }
    set page(value) {
        this._page = value;
        this.pageChange.emit(this._page);
    }
    /**
     * An @Input property, sets number of visible items per page in the `IgxPaginatorComponent`.
     * The default is 15.
     * ```typescript
     * let itemsPerPage = this.paginator.perPage;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get perPage() {
        return this._perPage;
    }
    set perPage(value) {
        this._perPage = Number(value);
        this.perPageChange.emit(this._perPage);
        this._selectOptions = this.sortUniqueOptions(this.defaultSelectValues, this._perPage);
        this.totalPages = Math.ceil(this.totalRecords / this._perPage);
        if (this.totalPages !== 0 && this.page >= this.totalPages) {
            this.page = this.totalPages - 1;
        }
    }
    /**
     * An @Input property that sets the total records.
     * ```typescript
     * let totalRecords = this.paginator.totalRecords;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get totalRecords() {
        return this._totalRecords;
    }
    set totalRecords(value) {
        this._totalRecords = value;
        this.totalPages = Math.ceil(this.totalRecords / this.perPage);
    }
    /**
     * An @Input property that sets custom options in the select of the paginator
     * ```typescript
     * let options = this.paginator.selectOptions;
     * ```
     * @memberof IgxPaginatorComponent
     */
    get selectOptions() {
        return this._selectOptions;
    }
    set selectOptions(value) {
        this._selectOptions = this.sortUniqueOptions(value, this._perPage);
        this.defaultSelectValues = [...value];
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * Returns if the current page is the last page.
     * ```typescript
     * const lastPage = this.paginator.isLastPage;
     * ```
     */
    get isLastPage() {
        return this.page + 1 >= this.totalPages;
    }
    /**
     * Returns if the current page is the first page.
     * ```typescript
     * const lastPage = this.paginator.isFirstPage;
     * ```
     */
    get isFirstPage() {
        return this.page === 0;
    }
    /**
     * Returns if the first pager buttons should be disabled
     */
    get isFirstPageDisabled() {
        return this.isFirstPage || !this.pagerEnabled;
    }
    /**
     * Returns if the last pager buttons should be disabled
     */
    get isLastPageDisabled() {
        return this.isLastPage || !this.pagerEnabled;
    }
    sortUniqueOptions(values, newOption) {
        return Array.from(new Set([...values, newOption])).sort((a, b) => a - b);
    }
    /**
     * Sets DisplayDensity for the <select> inside the paginator
     * @hidden
     */
    paginatorSelectDisplayDensity() {
        if (this.displayDensity === DisplayDensity.comfortable) {
            return DisplayDensity.cosy;
        }
        return DisplayDensity.compact;
    }
    /**
     * Goes to the next page of the `IgxPaginatorComponent`, if the paginator is not already at the last page.
     * ```typescript
     * this.paginator.nextPage();
     * ```
     * @memberof IgxPaginatorComponent
     */
    nextPage() {
        if (!this.isLastPage) {
            this.page += 1;
        }
    }
    /**
     * Goes to the previous page of the `IgxPaginatorComponent`, if the paginator is not already at the first page.
     * ```typescript
     * this.paginator.previousPage();
     * ```
     * @memberof IgxPaginatorComponent
     */
    previousPage() {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    }
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.paginator.paginate(1);
     * ```
     * @param val
     * @memberof IgxPaginatorComponent
     */
    paginate(val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    }
};
IgxPaginatorComponent.ɵfac = function IgxPaginatorComponent_Factory(t) { return new (t || IgxPaginatorComponent)(ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxPaginatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxPaginatorComponent, selectors: [["igx-paginator"]], hostVars: 6, hostBindings: function IgxPaginatorComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-paginator--cosy", ctx.classCosy)("igx-paginator--compact", ctx.classCompact)("igx-paginator", ctx.classComfortable);
    } }, inputs: { pagerEnabled: "pagerEnabled", pagerHidden: "pagerHidden", dropdownEnabled: "dropdownEnabled", dropdownHidden: "dropdownHidden", selectLabel: "selectLabel", prepositionPage: "prepositionPage", page: "page", perPage: "perPage", totalRecords: "totalRecords", selectOptions: "selectOptions", resourceStrings: "resourceStrings" }, outputs: { perPageChange: "perPageChange", pageChange: "pageChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 28, vars: 24, consts: [[1, "igx-paginator__select", 3, "hidden"], [1, "igx-paginator__label"], [1, "igx-paginator__select-input"], ["type", "border", 3, "ngModel", "displayDensity", "disabled", "ngModelChange"], ["igxLabel", "", 3, "hidden"], [3, "value", 4, "ngFor", "ngForOf"], ["role", "navigation", 1, "igx-paginator__pager", 3, "hidden"], ["igxButton", "icon", "igxRipple", "", "igxRippleCentered", "true", 3, "title", "disabled", "click"], ["fontSet", "material"], ["aria-current", "page", 1, "igx-paginator__pager-text"], ["igxRipple", "", "igxRippleCentered", "true", "igxButton", "icon", 3, "title", "disabled", "click"], [3, "value"]], template: function IgxPaginatorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "label", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "igx-select", 3);
        ɵngcc0.ɵɵlistener("ngModelChange", function IgxPaginatorComponent_Template_igx_select_ngModelChange_4_listener($event) { return ctx.perPage = $event; });
        ɵngcc0.ɵɵelementStart(5, "label", 4);
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, IgxPaginatorComponent_igx_select_item_7_Template, 2, 2, "igx-select-item", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 6);
        ɵngcc0.ɵɵelementStart(9, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_9_listener() { return ctx.paginate(0); });
        ɵngcc0.ɵɵelementStart(10, "igx-icon", 8);
        ɵngcc0.ɵɵtext(11, "first_page");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_12_listener() { return ctx.previousPage(); });
        ɵngcc0.ɵɵelementStart(13, "igx-icon", 8);
        ɵngcc0.ɵɵtext(14, "chevron_left");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(15, "div", 9);
        ɵngcc0.ɵɵelementStart(16, "span");
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(18, "span");
        ɵngcc0.ɵɵtext(19);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "span");
        ɵngcc0.ɵɵtext(21);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(22, "button", 10);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_22_listener() { return ctx.nextPage(); });
        ɵngcc0.ɵɵelementStart(23, "igx-icon", 8);
        ɵngcc0.ɵɵtext(24, "chevron_right");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(25, "button", 7);
        ɵngcc0.ɵɵlistener("click", function IgxPaginatorComponent_Template_button_click_25_listener() { return ctx.paginate(ctx.totalPages - 1); });
        ɵngcc0.ɵɵelementStart(26, "igx-icon", 8);
        ɵngcc0.ɵɵtext(27, "last_page");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("hidden", ctx.dropdownHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.resourceStrings.igx_paginator_label);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngModel", ctx.perPage)("displayDensity", ctx.paginatorSelectDisplayDensity())("disabled", !ctx.dropdownEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", true);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.resourceStrings.igx_paginator_label);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.selectOptions);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.pagerHidden);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_first_page_button_text)("disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_previous_page_button_text)("disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isFirstPageDisabled);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.page + 1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1("\u00A0", ctx.resourceStrings.igx_paginator_pager_text, "\u00A0");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.totalPages);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_next_page_button_text)("disabled", ctx.isLastPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isLastPageDisabled);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("title", ctx.resourceStrings.igx_paginator_last_page_button_text)("disabled", ctx.isLastPageDisabled);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.isLastPageDisabled);
    } }, directives: [IgxSelectComponent, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxLabelDirective, ɵngcc2.NgForOf, IgxButtonDirective,
        IgxRippleDirective,
        IgxIconComponent,
        IgxSelectItemComponent], encapsulation: 2 });
IgxPaginatorComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    HostBinding('class.igx-paginator--cosy')
], IgxPaginatorComponent.prototype, "classCosy", null);
__decorate([
    HostBinding('class.igx-paginator--compact')
], IgxPaginatorComponent.prototype, "classCompact", null);
__decorate([
    HostBinding('class.igx-paginator')
], IgxPaginatorComponent.prototype, "classComfortable", null);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "page", null);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "perPage", null);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "totalRecords", null);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "selectOptions", null);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "pagerEnabled", void 0);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "pagerHidden", void 0);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "dropdownEnabled", void 0);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "dropdownHidden", void 0);
__decorate([
    Input()
], IgxPaginatorComponent.prototype, "resourceStrings", null);
__decorate([
    DeprecateProperty(`'selectLabel' property is deprecated. Use 'resourceStrings' instead.`),
    Input()
], IgxPaginatorComponent.prototype, "selectLabel", void 0);
__decorate([
    DeprecateProperty(`'prepositionPage' property is deprecated. Use 'resourceStrings' instead.`),
    Input()
], IgxPaginatorComponent.prototype, "prepositionPage", void 0);
__decorate([
    Output()
], IgxPaginatorComponent.prototype, "perPageChange", void 0);
__decorate([
    Output()
], IgxPaginatorComponent.prototype, "pageChange", void 0);
IgxPaginatorComponent = __decorate([ __param(0, Optional()), __param(0, Inject(DisplayDensityToken))
], IgxPaginatorComponent);
let IgxPaginatorModule = class IgxPaginatorModule {
};
IgxPaginatorModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxPaginatorModule });
IgxPaginatorModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxPaginatorModule_Factory(t) { return new (t || IgxPaginatorModule)(); }, imports: [[CommonModule, IgxSelectModule, FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]] });

let IgxGridPipesModule = class IgxGridPipesModule {
};
IgxGridPipesModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridPipesModule });
IgxGridPipesModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridPipesModule_Factory(t) { return new (t || IgxGridPipesModule)(); }, imports: [[
            CommonModule
        ]] });

/**
 * @hidden
 */
let IgxExcelStyleColumnMovingComponent = class IgxExcelStyleColumnMovingComponent {
    constructor() { }
    get visibleColumns() {
        return this.grid.visibleColumns.filter(col => !(col instanceof IgxColumnGroupComponent));
    }
    get canNotMoveLeft() {
        return this.column.visibleIndex === 0 ||
            (this.grid.unpinnedColumns.indexOf(this.column) === 0 && this.column.disablePinning) ||
            (this.grid.unpinnedColumns.indexOf(this.column) === 0 && !this.isColumnPinnable) ||
            (this.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
    }
    get canNotMoveRight() {
        return this.column.visibleIndex === this.visibleColumns.length - 1 ||
            (this.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
    }
    onMoveButtonClicked(moveDirection) {
        let targetColumn;
        if (this.column.pinned) {
            if (this.column.isLastPinned && moveDirection === 1 && this.grid.isPinningToStart) {
                targetColumn = this.grid.unpinnedColumns[0];
                moveDirection = 0;
            }
            else if (this.column.isFirstPinned && moveDirection === 0 && !this.grid.isPinningToStart) {
                targetColumn = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1];
                moveDirection = 1;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.grid.pinnedColumns);
            }
        }
        else if (this.grid.unpinnedColumns.indexOf(this.column) === 0 && moveDirection === 0 &&
            this.grid.isPinningToStart) {
            targetColumn = this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1];
            if (targetColumn.parent) {
                targetColumn = targetColumn.topLevelParent;
            }
            moveDirection = 1;
        }
        else if (this.grid.unpinnedColumns.indexOf(this.column) === this.grid.unpinnedColumns.length - 1 &&
            moveDirection === 1 && !this.grid.isPinningToStart) {
            targetColumn = this.grid.pinnedColumns[0];
            moveDirection = 0;
        }
        else {
            targetColumn = this.findColumn(moveDirection, this.grid.unpinnedColumns);
        }
        this.grid.moveColumn(this.column, targetColumn, moveDirection);
    }
    findColumn(moveDirection, columns) {
        let index = columns.indexOf(this.column);
        if (moveDirection === 0) {
            while (index > 0) {
                index--;
                if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                    return columns[index];
                }
            }
        }
        else {
            while (index < columns.length - 1) {
                index++;
                if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                    return columns[index];
                }
            }
        }
    }
};
IgxExcelStyleColumnMovingComponent.ɵfac = function IgxExcelStyleColumnMovingComponent_Factory(t) { return new (t || IgxExcelStyleColumnMovingComponent)(); };
IgxExcelStyleColumnMovingComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExcelStyleColumnMovingComponent, selectors: [["igx-excel-style-column-moving"]], inputs: { column: "column", grid: "grid", displayDensity: "displayDensity", isColumnPinnable: "isColumnPinnable" }, decls: 13, vars: 7, consts: [[1, "igx-excel-filter__move-buttons"], ["igxButton", "", 3, "displayDensity", "disabled", "click"]], template: function IgxExcelStyleColumnMovingComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "header");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "section", 0);
        ɵngcc0.ɵɵelementStart(3, "button", 1);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleColumnMovingComponent_Template_button_click_3_listener() { return ctx.onMoveButtonClicked(0); });
        ɵngcc0.ɵɵelementStart(4, "igx-icon");
        ɵngcc0.ɵɵtext(5, "arrow_back");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span");
        ɵngcc0.ɵɵtext(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "button", 1);
        ɵngcc0.ɵɵlistener("click", function IgxExcelStyleColumnMovingComponent_Template_button_click_8_listener() { return ctx.onMoveButtonClicked(1); });
        ɵngcc0.ɵɵelementStart(9, "span");
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(11, "igx-icon");
        ɵngcc0.ɵɵtext(12, "arrow_forwards");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.grid.resourceStrings.igx_grid_excel_filter_moving_header, "\n");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("disabled", ctx.canNotMoveLeft);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayDensity === "compact" ? ctx.grid.resourceStrings.igx_grid_excel_filter_moving_left_short : ctx.grid.resourceStrings.igx_grid_excel_filter_moving_left, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("disabled", ctx.canNotMoveRight);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.displayDensity === "compact" ? ctx.grid.resourceStrings.igx_grid_excel_filter_moving_right_short : ctx.grid.resourceStrings.igx_grid_excel_filter_moving_right, " ");
    } }, directives: [IgxButtonDirective,
        IgxIconComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], IgxExcelStyleColumnMovingComponent.prototype, "column", void 0);
__decorate([
    Input()
], IgxExcelStyleColumnMovingComponent.prototype, "grid", void 0);
__decorate([
    Input()
], IgxExcelStyleColumnMovingComponent.prototype, "displayDensity", void 0);
__decorate([
    Input()
], IgxExcelStyleColumnMovingComponent.prototype, "isColumnPinnable", void 0);

/**
 * @hidden
 */
let IgxExcelStyleSearchFilterPipe = class IgxExcelStyleSearchFilterPipe {
    transform(items, searchText) {
        if (!items || !items.length) {
            return [];
        }
        if (!searchText) {
            return items;
        }
        searchText = searchText.toLowerCase();
        const result = items.filter((it, i) => (i === 0 && it.isSpecial) ||
            (it.label !== null && it.label !== undefined) &&
                !it.isBlanks &&
                it.label.toString().toLowerCase().indexOf(searchText) > -1);
        // If 'result' contains the 'Select All' item and at least one more - we use it, otherwise we use an empty array.
        return result.length > 1 ? result : [];
    }
};
IgxExcelStyleSearchFilterPipe.ɵfac = function IgxExcelStyleSearchFilterPipe_Factory(t) { return new (t || IgxExcelStyleSearchFilterPipe)(); };
IgxExcelStyleSearchFilterPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "excelStyleSearchFilter", type: IgxExcelStyleSearchFilterPipe, pure: true });

let IgxProcessBarTextTemplateDirective = class IgxProcessBarTextTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxProcessBarTextTemplateDirective.ɵfac = function IgxProcessBarTextTemplateDirective_Factory(t) { return new (t || IgxProcessBarTextTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxProcessBarTextTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxProcessBarTextTemplateDirective, selectors: [["", "igxProcessBarText", ""]] });
IgxProcessBarTextTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxProgressBarGradientDirective = class IgxProgressBarGradientDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxProgressBarGradientDirective.ɵfac = function IgxProgressBarGradientDirective_Factory(t) { return new (t || IgxProgressBarGradientDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxProgressBarGradientDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxProgressBarGradientDirective, selectors: [["", "igxProgressBarGradient", ""]] });
IgxProgressBarGradientDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Injection token is used to inject the document into Directionality
 * which factory could be faked for testing purposes.
 *
 * We can't provide and mock the DOCUMENT token from platform-browser because configureTestingModule
 * allows override of the default providers, directive, pipes, modules of the test injector
 * which causes errors.
 *
 * @hidden
 */
const DIR_DOCUMENT = new InjectionToken('dir-doc', {
    providedIn: 'root',
    factory: DIR_DOCUMENT_FACTORY
});
/**
 * @hidden
 */
function DIR_DOCUMENT_FACTORY() {
    return inject(DOCUMENT);
}
/**
 * @hidden
 *
 * Bidirectional service that extracts the value of the direction attribute on the body or html elements.
 *
 * The dir attribute over the body element takes precedence.
 */
let IgxDirectionality = class IgxDirectionality {
    constructor(document) {
        this._document = document;
        const bodyDir = this._document.body ? this._document.body.dir : null;
        const htmlDir = this._document.documentElement ? this._document.documentElement.dir : null;
        const extractedDir = bodyDir || htmlDir;
        this._dir = (extractedDir === 'ltr' || extractedDir === 'rtl') ? extractedDir : 'ltr';
    }
    get value() {
        return this._dir;
    }
    get document() {
        return this._document;
    }
    get rtl() {
        return this._dir === 'rtl';
    }
};
IgxDirectionality.ɵfac = function IgxDirectionality_Factory(t) { return new (t || IgxDirectionality)(ɵngcc0.ɵɵinject(DIR_DOCUMENT)); };
IgxDirectionality.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DIR_DOCUMENT,] }] }
];
IgxDirectionality.ɵprov = ɵɵdefineInjectable({ factory: function IgxDirectionality_Factory() { return new IgxDirectionality(ɵɵinject(DIR_DOCUMENT)); }, token: IgxDirectionality, providedIn: "root" });
IgxDirectionality = __decorate([ __param(0, Inject(DIR_DOCUMENT))
], IgxDirectionality);

const ONE_PERCENT = 0.01;
const MIN_VALUE = 0;
var IgxTextAlign;
(function (IgxTextAlign) {
    IgxTextAlign["START"] = "start";
    IgxTextAlign["CENTER"] = "center";
    IgxTextAlign["END"] = "end";
})(IgxTextAlign || (IgxTextAlign = {}));
var IgxProgressType;
(function (IgxProgressType) {
    IgxProgressType["ERROR"] = "error";
    IgxProgressType["INFO"] = "info";
    IgxProgressType["WARNING"] = "warning";
    IgxProgressType["SUCCESS"] = "success";
})(IgxProgressType || (IgxProgressType = {}));
/**
 * @hidden
 */
class BaseProgress {
    constructor() {
        this.requestAnimationId = undefined;
        this._initValue = 0;
        this._contentInit = false;
        this._valueInPercent = MIN_VALUE;
        this._max = 100;
        this._value = MIN_VALUE;
        this._newVal = MIN_VALUE;
        this._animate = true;
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *     alert("Progress made!");
         * }
         *  //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * <igx-linear-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-linear-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
    }
    /**
     * Returns the value which update the progress indicator of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public stepValue(event) {
     *     let step = this.progressBar.step;
     *     alert(step);
     * }
     * ```
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Animating the progress. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [max]="200" [value]="50"></igx-linear-bar>
     * <igx-circular-bar [animate]="false" [max]="200" [value]="50"></igx-circular-bar>
     * ```
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `progress bar` has animation true/false.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public animationStatus(event) {
     *     let animationStatus = this.progressBar.animate;
     *     alert(animationStatus);
     * }
     * ```
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [max]="200" [value]="0"></igx-linear-bar>
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `progress bar`.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent | IgxCircularBarComponent;
     * public maxValue(event) {
     *     let max = this.progressBar.max;
     *     alert(max);
     * }
     * ```
     */
    get max() {
        return this._max;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *     public setValue(event){
     *     this.progressBar.valueInPercent = 56;
     * }
     * ```
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *     let percentValue = this.progressBar.valueInPercent;
     *     alert(percentValue);
     * }
     * ```
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    triggerProgressTransition(oldVal, newVal) {
        if (oldVal === newVal) {
            return;
        }
        const changedValues = {
            currentValue: newVal,
            previousValue: oldVal
        };
        const stepDirection = this.directionFlow(oldVal, newVal);
        if (this._animate) {
            this.runAnimation(newVal, stepDirection);
        }
        else {
            this.updateProgressDirectly(newVal);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        this._value = valueInRange(this._value, this._max) + step;
        const passedValue = toPercent(val, this._max);
        const progressValue = toPercent(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
    /**
     * @hidden
     */
    directionFlow(currentValue, prevValue) {
        return currentValue < prevValue ? this.step : -this.step;
    }
    /**
     * @hidden
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @param step
     */
    updateProgress(val) {
        this._value = valueInRange(val, this._max);
        this.valueInPercent = toPercent(this._value, this._max);
    }
}
BaseProgress.ɵfac = function BaseProgress_Factory(t) { return new (t || BaseProgress)(); };
BaseProgress.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseProgress, hostVars: 1, hostBindings: function BaseProgress_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max);
    } }, inputs: { step: "step", animate: "animate", max: "max" }, outputs: { onProgressChanged: "onProgressChanged" } });
__decorate([
    Output()
], BaseProgress.prototype, "onProgressChanged", void 0);
__decorate([
    Input()
], BaseProgress.prototype, "step", null);
__decorate([
    Input()
], BaseProgress.prototype, "animate", null);
__decorate([
    HostBinding('attr.aria-valuemax'),
    Input()
], BaseProgress.prototype, "max", null);
let NEXT_LINEAR_ID = 0;
let NEXT_CIRCULAR_ID = 0;
let NEXT_GRADIENT_ID = 0;
let IgxLinearProgressBarComponent = class IgxLinearProgressBarComponent extends BaseProgress {
    constructor() {
        super();
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * An @Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *     this.positionCenter = IgxTextAlign.CENTER;
         * }
         *  //...
         * ```
         *  ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         *  <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         *  <igx-linear-bar type="error" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `error`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="error"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    /**
     * @hidden
     */
    get error() {
        return this.type === IgxProgressType.ERROR;
    }
    /**
     * @hidden
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
};
IgxLinearProgressBarComponent.ɵfac = function IgxLinearProgressBarComponent_Factory(t) { return new (t || IgxLinearProgressBarComponent)(); };
IgxLinearProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxLinearProgressBarComponent, selectors: [["igx-linear-bar"]], hostVars: 18, hostBindings: function IgxLinearProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-valuemin", ctx.valueMin)("role", ctx.role)("id", ctx.id)("aria-valuenow", ctx.value);
        ɵngcc0.ɵɵclassProp("igx-linear-bar", ctx.cssClass)("igx-linear-bar--striped", ctx.striped)("igx-linear-bar--indeterminate", ctx.indeterminate)("igx-linear-bar--danger", ctx.error)("igx-linear-bar--info", ctx.info)("igx-linear-bar--warning", ctx.warning)("igx-linear-bar--success", ctx.success);
    } }, inputs: { striped: "striped", indeterminate: "indeterminate", role: "role", id: "id", textAlign: "textAlign", textVisibility: "textVisibility", textTop: "textTop", type: "type", value: "value", text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 10, consts: [[1, "igx-linear-bar__base"], [1, "igx-linear-bar__indicator"], [1, "igx-linear-bar__value", 3, "ngClass"]], template: function IgxLinearProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.valueInPercent, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction5(4, _c147, ctx.textAlign === "start", ctx.textAlign === "center", ctx.textAlign === "end", ctx.textTop, !ctx.textVisibility));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.text ? ctx.text : ctx.valueInPercent + "%", "\n");
    } }, directives: [ɵngcc2.NgClass], encapsulation: 2 });
__decorate([
    HostBinding('attr.aria-valuemin')
], IgxLinearProgressBarComponent.prototype, "valueMin", void 0);
__decorate([
    HostBinding('class.igx-linear-bar')
], IgxLinearProgressBarComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-linear-bar--striped'),
    Input()
], IgxLinearProgressBarComponent.prototype, "striped", void 0);
__decorate([
    HostBinding('class.igx-linear-bar--indeterminate'),
    Input()
], IgxLinearProgressBarComponent.prototype, "indeterminate", void 0);
__decorate([
    HostBinding('attr.role'),
    Input()
], IgxLinearProgressBarComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxLinearProgressBarComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxLinearProgressBarComponent.prototype, "textAlign", void 0);
__decorate([
    Input()
], IgxLinearProgressBarComponent.prototype, "textVisibility", void 0);
__decorate([
    Input()
], IgxLinearProgressBarComponent.prototype, "textTop", void 0);
__decorate([
    Input()
], IgxLinearProgressBarComponent.prototype, "text", void 0);
__decorate([
    Input()
], IgxLinearProgressBarComponent.prototype, "type", void 0);
__decorate([
    HostBinding('attr.aria-valuenow'),
    Input()
], IgxLinearProgressBarComponent.prototype, "value", null);
__decorate([
    HostBinding('class.igx-linear-bar--danger')
], IgxLinearProgressBarComponent.prototype, "error", null);
__decorate([
    HostBinding('class.igx-linear-bar--info')
], IgxLinearProgressBarComponent.prototype, "info", null);
__decorate([
    HostBinding('class.igx-linear-bar--warning')
], IgxLinearProgressBarComponent.prototype, "warning", null);
__decorate([
    HostBinding('class.igx-linear-bar--success')
], IgxLinearProgressBarComponent.prototype, "success", null);
let IgxCircularProgressBarComponent = class IgxCircularProgressBarComponent extends BaseProgress {
    constructor(renderer, _directionality) {
        super();
        this.renderer = renderer;
        this._directionality = _directionality;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        /** @hidden */
        this.cssClass = 'igx-circular-bar';
        /**
         * An @Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * @hidden
         */
        this.gradientId = `igx-circular-gradient-${NEXT_GRADIENT_ID++}`;
        /**
         * An @Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
    }
    /**
     * @hidden
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     *  @ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *     let value = this.progressBar.value;
     *     alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     */
    set value(val) {
        const valInRange = valueInRange(val, this.max);
        if (isNaN(valInRange) || this._value === val || this.indeterminate) {
            return;
        }
        if (this._contentInit) {
            this.triggerProgressTransition(this._value, valInRange);
        }
        else {
            this._initValue = valInRange;
        }
    }
    ngAfterContentInit() {
        this.triggerProgressTransition(MIN_VALUE, this._initValue);
        this._contentInit = true;
    }
    ngAfterViewInit() {
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke', `url(#${this.gradientId})`);
    }
    /**
     * @hidden
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        const FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    getProgress(percentage) {
        return this._directionality.rtl ?
            this._circumference + (percentage * this._circumference / 100) :
            this._circumference - (percentage * this._circumference / 100);
    }
};
IgxCircularProgressBarComponent.ɵfac = function IgxCircularProgressBarComponent_Factory(t) { return new (t || IgxCircularProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(IgxDirectionality)); };
IgxCircularProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCircularProgressBarComponent, selectors: [["igx-circular-bar"]], contentQueries: function IgxCircularProgressBarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxProcessBarTextTemplateDirective, true, IgxProcessBarTextTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxProgressBarGradientDirective, true, IgxProgressBarGradientDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.textTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gradientTemplate = _t.first);
    } }, viewQuery: function IgxCircularProgressBarComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c148, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._svgCircle = _t.first);
    } }, hostVars: 5, hostBindings: function IgxCircularProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-circular-bar", ctx.cssClass)("igx-circular-bar--indeterminate", ctx.indeterminate);
    } }, inputs: { id: "id", indeterminate: "indeterminate", textVisibility: "textVisibility", value: "value", text: "text" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 12, vars: 7, consts: [["xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "version", "1.1", "viewBox", "0 0 100 100", "preserveAspectRatio", "xMidYMid meet", "role", "progressbar", "aria-valuemin", "0"], ["svg", ""], ["cx", "50", "cy", "50", "r", "46", 1, "igx-circular-bar__inner"], ["cx", "50", "cy", "50", "r", "46", 1, "igx-circular-bar__outer"], ["circle", ""], ["text-anchor", "middle", "x", "50", "y", "60", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultTextTemplate", ""], ["defaultGradientTemplate", ""], ["text-anchor", "middle", "x", "50", "y", "60"], [1, "igx-circular-bar__text"], ["gradientTransform", "rotate(90)", 3, "id"], ["offset", "0%", 1, "igx-circular-bar__gradient-start"], ["offset", "100%", 1, "igx-circular-bar__gradient-end"]], template: function IgxCircularProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "svg", 0, 1);
        ɵngcc0.ɵɵelement(2, "circle", 2);
        ɵngcc0.ɵɵelement(3, "circle", 3, 4);
        ɵngcc0.ɵɵtemplate(5, IgxCircularProgressBarComponent__svg_text_5_Template, 2, 2, "text", 5);
        ɵngcc0.ɵɵelementStart(6, "defs");
        ɵngcc0.ɵɵtemplate(7, IgxCircularProgressBarComponent__svg_ng_container_7_Template, 1, 0, "ng-container", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, IgxCircularProgressBarComponent__svg_ng_template_8_Template, 2, 1, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxCircularProgressBarComponent__svg_ng_template_10_Template, 3, 1, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r744 = ɵngcc0.ɵɵreference(11);
        ɵngcc0.ɵɵattribute("aria-valuemax", ctx.max)("aria-valuenow", ctx.value);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.textVisibility);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.gradientTemplate ? ctx.gradientTemplate.template : _r744)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(5, _c13, ctx.gradientId));
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: IgxDirectionality }
];
__decorate([
    HostBinding('class.igx-circular-bar')
], IgxCircularProgressBarComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxCircularProgressBarComponent.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-circular-bar--indeterminate'),
    Input()
], IgxCircularProgressBarComponent.prototype, "indeterminate", void 0);
__decorate([
    Input()
], IgxCircularProgressBarComponent.prototype, "textVisibility", void 0);
__decorate([
    Input()
], IgxCircularProgressBarComponent.prototype, "text", void 0);
__decorate([
    ContentChild(IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective })
], IgxCircularProgressBarComponent.prototype, "textTemplate", void 0);
__decorate([
    ContentChild(IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective })
], IgxCircularProgressBarComponent.prototype, "gradientTemplate", void 0);
__decorate([
    Input()
], IgxCircularProgressBarComponent.prototype, "value", null);
__decorate([
    ViewChild('circle', { static: true })
], IgxCircularProgressBarComponent.prototype, "_svgCircle", void 0);
function valueInRange(value, max, min = 0) {
    return Math.max(Math.min(value, max), min);
}
function toPercent(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
let IgxProgressBarModule = class IgxProgressBarModule {
};
IgxProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxProgressBarModule });
IgxProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxProgressBarModule_Factory(t) { return new (t || IgxProgressBarModule)(); }, imports: [[CommonModule]] });

/**
 * @hidden
 */
let IgxGridExcelStyleFilteringModule = class IgxGridExcelStyleFilteringModule {
};
IgxGridExcelStyleFilteringModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridExcelStyleFilteringModule });
IgxGridExcelStyleFilteringModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridExcelStyleFilteringModule_Factory(t) { return new (t || IgxGridExcelStyleFilteringModule)(); }, providers: [
        IgxSelectionAPIService
    ], imports: [[
            CommonModule,
            FormsModule,
            IgxGridPipesModule,
            IgxButtonModule,
            IgxButtonGroupModule,
            IgxDatePickerModule,
            IgxIconModule,
            IgxRippleModule,
            IgxInputGroupModule,
            IgxDropDownModule,
            IgxForOfModule,
            IgxCheckboxModule,
            IgxFilterModule,
            IgxToggleModule,
            IgxListModule,
            IgxProgressBarModule
        ]] });

let IgxGridSelectionModule = class IgxGridSelectionModule {
};
IgxGridSelectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridSelectionModule });
IgxGridSelectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridSelectionModule_Factory(t) { return new (t || IgxGridSelectionModule)(); } });

/**
 * @hidden
 * @internal
 */
let IgxResizeHandleDirective = class IgxResizeHandleDirective {
    constructor(zone, element, colResizingService) {
        this.zone = zone;
        this.element = element;
        this.colResizingService = colResizingService;
        /**
         * @hidden
         */
        this._dblClick = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this.DEBOUNCE_TIME = 200;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (!this.column.columnGroup && this.column.resizable) {
            this.zone.runOutsideAngular(() => {
                fromEvent(this.element.nativeElement, 'mousedown').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe((event) => {
                    if (this._dblClick) {
                        this._dblClick = false;
                        return;
                    }
                    if (event.button === 0) {
                        this._onResizeAreaMouseDown(event);
                        this.column.grid.resizeLine.resizer.onMousedown(event);
                    }
                });
            });
            fromEvent(this.element.nativeElement, 'mouseup').pipe(debounceTime(this.DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe(() => {
                this.colResizingService.isColumnResizing = false;
                this.colResizingService.showResizer = false;
                this.column.grid.cdr.detectChanges();
            });
        }
    }
    /**
     * @hidden
     */
    onMouseOver() {
        this.colResizingService.resizeCursor = 'col-resize';
    }
    /**
     * @hidden
     */
    onDoubleClick() {
        this._dblClick = true;
        this.colResizingService.column = this.column;
        this.colResizingService.autosizeColumnOnDblClick();
    }
    /**
     * @hidden
     */
    _onResizeAreaMouseDown(event) {
        this.colResizingService.column = this.column;
        this.colResizingService.isColumnResizing = true;
        this.colResizingService.startResizePos = event.clientX;
        this.colResizingService.showResizer = true;
        this.column.grid.cdr.detectChanges();
    }
};
IgxResizeHandleDirective.ɵfac = function IgxResizeHandleDirective_Factory(t) { return new (t || IgxResizeHandleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService)); };
IgxResizeHandleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxResizeHandleDirective, selectors: [["", "igxResizeHandle", ""]], hostBindings: function IgxResizeHandleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseover", function IgxResizeHandleDirective_mouseover_HostBindingHandler() { return ctx.onMouseOver(); })("dblclick", function IgxResizeHandleDirective_dblclick_HostBindingHandler() { return ctx.onDoubleClick(); });
    } }, inputs: { column: ["igxResizeHandle", "column"] } });
IgxResizeHandleDirective.ctorParameters = () => [
    { type: NgZone },
    { type: ElementRef },
    { type: IgxColumnResizingService }
];
__decorate([
    Input('igxResizeHandle')
], IgxResizeHandleDirective.prototype, "column", void 0);
__decorate([
    HostListener('mouseover')
], IgxResizeHandleDirective.prototype, "onMouseOver", null);
__decorate([
    HostListener('dblclick')
], IgxResizeHandleDirective.prototype, "onDoubleClick", null);

let IgxGridResizingModule = class IgxGridResizingModule {
};
IgxGridResizingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridResizingModule });
IgxGridResizingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridResizingModule_Factory(t) { return new (t || IgxGridResizingModule)(); }, providers: [
        IgxColumnResizingService
    ], imports: [[
            CommonModule
        ]] });

let IgxColumnMovingDropDirective = class IgxColumnMovingDropDirective extends IgxDropDirective {
    constructor(elementRef, renderer, zone, cms) {
        super(elementRef, renderer, zone);
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        this.cms = cms;
        this._dropIndicator = null;
        this._lastDropIndicator = null;
        this._dragLeave = new Subject();
        this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
    }
    set data(val) {
        if (val instanceof IgxColumnComponent) {
            this._column = val;
        }
        if (val instanceof IgxGridForOfDirective) {
            this._hVirtDir = val;
        }
    }
    get column() {
        return this._column;
    }
    get isDropTarget() {
        return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable &&
            ((!this._column.pinned && this.cms.column.disablePinning) || !this.cms.column.disablePinning);
    }
    get horizontalScroll() {
        if (this._hVirtDir) {
            return this._hVirtDir;
        }
    }
    ngOnDestroy() {
        this._dragLeave.next(true);
        this._dragLeave.complete();
    }
    onDragOver(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (this._lastDropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            const clientRect = this.elementRef.nativeElement.getBoundingClientRect();
            const pos = clientRect.left + clientRect.width / 2;
            const parent = this.elementRef.nativeElement.parentElement;
            if (event.detail.pageX < pos) {
                this._dropPos = DropPosition.BeforeDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.firstElementChild;
            }
            else {
                this._dropPos = DropPosition.AfterDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent.lastElementChild;
            }
            if (this.cms.icon.innerText !== 'block') {
                this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
            }
        }
    }
    onDragEnter(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            this.cms.icon.innerText = 'block';
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                this.cms.icon.innerText = 'swap_horiz';
            }
            this.cms.icon.innerText = 'lock';
        }
        else {
            this.cms.icon.innerText = 'block';
        }
        if (this.horizontalScroll) {
            this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
            interval(100).pipe(takeUntil(this._dragLeave)).subscribe(() => {
                event.target.id === 'right' ? this.horizontalScroll.scrollPosition += 15 :
                    this.horizontalScroll.scrollPosition -= 15;
            });
        }
    }
    onDragLeave(event) {
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        this.cms.icon.innerText = 'block';
        if (this._dropIndicator) {
            this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
    }
    onDragDrop(event) {
        event.preventDefault();
        const drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
            return;
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
        if (this.isDropTarget) {
            const args = {
                source: this.cms.column,
                target: this.column
            };
            this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        }
    }
};
IgxColumnMovingDropDirective.ɵfac = function IgxColumnMovingDropDirective_Factory(t) { return new (t || IgxColumnMovingDropDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxColumnMovingService)); };
IgxColumnMovingDropDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxColumnMovingDropDirective, selectors: [["", "igxColumnMovingDrop", ""]], inputs: { data: ["igxColumnMovingDrop", "data"] }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxColumnMovingDropDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: IgxColumnMovingService }
];
__decorate([
    Input('igxColumnMovingDrop')
], IgxColumnMovingDropDirective.prototype, "data", null);

let IgxColumnMovingModule = class IgxColumnMovingModule {
};
IgxColumnMovingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnMovingModule });
IgxColumnMovingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnMovingModule_Factory(t) { return new (t || IgxColumnMovingModule)(); } });

let NEXT_ID$h = 0;
/**
 * Determines the igxBadge type
 */
var IgxBadgeType;
(function (IgxBadgeType) {
    IgxBadgeType["PRIMARY"] = "primary";
    IgxBadgeType["INFO"] = "info";
    IgxBadgeType["SUCCESS"] = "success";
    IgxBadgeType["WARNING"] = "warning";
    IgxBadgeType["ERROR"] = "error";
})(IgxBadgeType || (IgxBadgeType = {}));
/**
 * Badge provides visual notifications used to decorate avatars, menus, etc.
 *
 * @igxModule IgxBadgeModule
 *
 * @igxTheme igx-badge-theme
 *
 * @igxKeywords badge, icon, notification
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * @example
 * ```html
 * <igx-avatar>
 *   <igx-badge icon="check" type="success"></igx-badge>
 * </igx-avatar>
 */
let IgxBadgeComponent = class IgxBadgeComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the badge.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-badge-0"`.
         *
         * @example
         * ```html
         * <igx-badge id="igx-badge-2"></igx-badge>
         * ```
         */
        this.id = `igx-badge-${NEXT_ID$h++}`;
        /**
         * Sets/gets the type of the badge.
         *
         * @remarks
         * Allowed values are `primary`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         *
         * @example
         * ```html
         * <igx-badge type="success"></igx-badge>
         * ```
         */
        this.type = IgxBadgeType.PRIMARY;
        /**
         * Sets/gets the value to be displayed inside the badge.
         *
         * @remarks
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the content of the badge will be empty.
         *
         * @example
         * ```html
         * <igx-badge value="11"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * Sets/gets the role attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.role = 'status';
         * ```
         */
        this.role = 'status';
        /**
         * Sets/gets the the css class to use on the badge.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.cssClass = 'my-badge-class';
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * Sets/gets the aria-label attribute value.
         *
         * @example
         * ```typescript
         * @ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         *
         * badge.label = 'badge';
         * ```
         */
        this.label = 'badge';
    }
    /**
     * Defines a human-readable, accessor, author-localized description for
     * the `type` and the `icon` or `value` of the element.
     * @hidden
     * @internal
     */
    get roleDescription() {
        let message;
        // tslint:disable-next-line:prefer-conditional-expression
        if (this.icon) {
            message = this.type + ' type badge with icon type ' + this.icon;
        }
        else if (this.value) {
            message = this.type + ' badge type with value ' + this.value;
        }
        else {
            message = this.type + ' badge type without value';
        }
        return message;
    }
    /**
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @hidden
     * @internal
     */
    setClasses() {
        let classes = {};
        switch (IgxBadgeType[this.type.toUpperCase()]) {
            case IgxBadgeType.INFO:
                classes = {
                    [`${this.cssClass}__circle--info`]: true
                };
                break;
            case IgxBadgeType.SUCCESS:
                classes = {
                    [`${this.cssClass}__circle--success`]: true
                };
                break;
            case IgxBadgeType.WARNING:
                classes = {
                    [`${this.cssClass}__circle--warning`]: true
                };
                break;
            case IgxBadgeType.ERROR:
                classes = {
                    [`${this.cssClass}__circle--error`]: true
                };
                break;
            default:
                classes = {
                    [`${this.cssClass}__circle--default`]: true
                };
        }
        return classes;
    }
};
IgxBadgeComponent.ɵfac = function IgxBadgeComponent_Factory(t) { return new (t || IgxBadgeComponent)(); };
IgxBadgeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxBadgeComponent, selectors: [["igx-badge"]], hostVars: 5, hostBindings: function IgxBadgeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-label", ctx.label);
        ɵngcc0.ɵɵclassProp("igx-badge", ctx.cssClass);
    } }, inputs: { id: "id", type: "type", value: "value", icon: "icon" }, decls: 3, vars: 4, consts: [[1, "igx-badge__circle", 3, "ngClass"], ["class", "igx-badge__circle-value", 4, "ngIf"], ["fontSet", "material", 4, "ngIf"], [1, "igx-badge__circle-value"], ["fontSet", "material"]], template: function IgxBadgeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxBadgeComponent_span_1_Template, 2, 1, "span", 1);
        ɵngcc0.ɵɵtemplate(2, IgxBadgeComponent_igx_icon_2_Template, 2, 1, "igx-icon", 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ctx.setClasses());
        ɵngcc0.ɵɵattribute("aria-roledescription", ctx.roleDescription);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxBadgeComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxBadgeComponent.prototype, "icon", void 0);
__decorate([
    HostBinding('attr.role')
], IgxBadgeComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-badge')
], IgxBadgeComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxBadgeComponent.prototype, "label", void 0);
/**
 * @hidden
 */
let IgxBadgeModule = class IgxBadgeModule {
};
IgxBadgeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxBadgeModule });
IgxBadgeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxBadgeModule_Factory(t) { return new (t || IgxBadgeModule)(); }, imports: [[CommonModule, IgxIconModule]] });

let IgxGridAPIService = class IgxGridAPIService extends GridBaseAPIService {
    groupBy(expression) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState, groupingState], expression);
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    groupBy_multiple(expressions) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        for (const each of expressions) {
            this.prepare_sorting_expression([sortingState, groupingState], each);
        }
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    }
    clear_groupby(name) {
        const groupingState = cloneArray(this.grid.groupingExpressions);
        const sortingState = cloneArray(this.grid.sortingExpressions);
        if (name) {
            const names = typeof name === 'string' ? [name] : name;
            const groupedCols = groupingState.filter((state) => names.indexOf(state.fieldName) < 0);
            const newSortingExpr = sortingState.filter((state) => names.indexOf(state.fieldName) < 0);
            this.grid.groupingExpressions = groupedCols;
            this.grid.sortingExpressions = newSortingExpr;
            names.forEach((colName) => {
                const grExprIndex = groupingState.findIndex((exp) => exp.fieldName === colName);
                const grpExpandState = this.grid.groupingExpansionState;
                /* remove expansion states related to the cleared group
                   and all with deeper hierarchy than the cleared group */
                const newExpandState = grpExpandState.filter((val) => {
                    return val.hierarchy && val.hierarchy.length <= grExprIndex;
                });
                /* Do not set the new instance produced by filter
                    when there are no differences between expansion states */
                if (newExpandState.length !== grpExpandState.length) {
                    this.grid.groupingExpansionState = newExpandState;
                }
            });
        }
        else {
            // clear all
            this.grid.groupingExpressions = [];
            this.grid.groupingExpansionState = [];
            for (const grExpr of groupingState) {
                const sortExprIndex = sortingState.findIndex((exp) => exp.fieldName === grExpr.fieldName);
                if (sortExprIndex > -1) {
                    sortingState.splice(sortExprIndex, 1);
                }
            }
            this.grid.sortingExpressions = sortingState;
        }
    }
    groupBy_get_expanded_for_group(groupRow) {
        const grState = this.grid.groupingExpansionState;
        const hierarchy = DataUtil.getHierarchy(groupRow);
        return grState.find((state) => DataUtil.isHierarchyMatch(state.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy));
    }
    groupBy_is_row_in_group(groupRow, rowID) {
        const grid = this.grid;
        let rowInGroup = false;
        groupRow.records.forEach(row => {
            if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                rowInGroup = true;
            }
        });
        return rowInGroup;
    }
    groupBy_toggle_group(groupRow) {
        const grid = this.grid;
        if (grid.crudService.isInEditMode) {
            grid.endEdit(true);
        }
        const expansionState = grid.groupingExpansionState;
        const state = this.groupBy_get_expanded_for_group(groupRow);
        if (state) {
            state.expanded = !state.expanded;
        }
        else {
            expansionState.push({
                expanded: !grid.groupsExpanded,
                hierarchy: DataUtil.getHierarchy(groupRow)
            });
        }
        this.grid.groupingExpansionState = [...expansionState];
        if (grid.rowEditable) {
            grid.repositionRowEditingOverlay(grid.rowInEditMode);
        }
    }
    groupBy_fully_expand_group(groupRow) {
        const state = this.groupBy_get_expanded_for_group(groupRow);
        const expanded = state ? state.expanded : this.grid.groupsExpanded;
        if (!expanded) {
            this.groupBy_toggle_group(groupRow);
        }
        if (groupRow.groupParent) {
            this.groupBy_fully_expand_group(groupRow.groupParent);
        }
    }
    remove_grouping_expression(fieldName) {
        const groupingExpressions = this.grid.groupingExpressions;
        const index = groupingExpressions.findIndex((expr) => expr.fieldName === fieldName);
        if (index !== -1) {
            groupingExpressions.splice(index, 1);
        }
    }
    arrange_sorting_expressions() {
        const groupingState = this.grid.groupingExpressions;
        this.grid.sortingExpressions.sort((a, b) => {
            const groupExprA = groupingState.find((expr) => expr.fieldName === a.fieldName);
            const groupExprB = groupingState.find((expr) => expr.fieldName === b.fieldName);
            if (groupExprA && groupExprB) {
                return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
            }
            else if (groupExprA) {
                return -1;
            }
            else if (groupExprB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    get_groupBy_record_id(gRow) {
        let recordId = '{ ';
        const hierrarchy = DataUtil.getHierarchy(gRow);
        for (let i = 0; i < hierrarchy.length; i++) {
            const groupByKey = hierrarchy[i];
            recordId += `'${groupByKey.fieldName}': '${groupByKey.value}'`;
            if (i < hierrarchy.length - 1) {
                recordId += ', ';
            }
        }
        recordId += ' }';
        return recordId;
    }
};
IgxGridAPIService.ɵfac = function IgxGridAPIService_Factory(t) { return ɵIgxGridAPIService_BaseFactory(t || IgxGridAPIService); };
IgxGridAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridAPIService, factory: IgxGridAPIService.ɵfac });

let IgxGridGroupByRowComponent = class IgxGridGroupByRowComponent {
    constructor(gridAPI, gridSelection, element, cdr) {
        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */
        this.isFocused = false;
    }
    /**
     * Returns whether the row is focused.
     * ```
     * let gridRowFocused = this.grid1.rowList.first.focused;
     * ```
     */
    get focused() {
        return this.isActive();
    }
    /**
     * Returns whether the group row is expanded.
     * ```typescript
     * const groupRowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded() {
        return this.grid.isExpandedGroup(this.groupRow);
    }
    /**
     * @hidden
     */
    get describedBy() {
        const grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
        return this.gridID + '_' + grRowExpr;
    }
    get dataRowIndex() {
        return this.index;
    }
    /**
     * Returns a reference to the underlying HTML element.
     * ```typescript
     * const groupRowElement = this.nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    get attrCellID() {
        return `${this.gridID}_${this.index}`;
    }
    /**
     * Returns the style classes applied to the group rows.
     * ```typescript
     * const groupCssStyles = this.grid1.rowList.first.styleClasses;
     * ```
     */
    get styleClasses() {
        return `${this.defaultCssClass} ` + `${this.paddingIndentationCssClass}-` + this.groupRow.level +
            (this.isActive() ? ` ${this.defaultCssClass}--active` : '');
    }
    isActive() {
        return this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row === this.index : false;
    }
    activate() {
        this.grid.navigation.activeNode ? this.grid.navigation.activeNode.row = this.index :
            this.grid.navigation.activeNode = { row: this.index };
    }
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle() {
        this.grid.toggleGroup(this.groupRow);
    }
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultGroupByExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultGroupByCollapsedTemplate;
        }
    }
    get selectionNode() {
        return {
            row: this.index,
            column: this.gridSelection.activeElement ? this.gridSelection.activeElement.column : 0
        };
    }
    /**
     * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
     * ```typescript
     * this.grid1.rowList.first.grid;
     * ```
     */
    get grid() {
        return this.gridAPI.grid;
    }
    /**
     * @hidden
     */
    get dataType() {
        const column = this.grid.getColumnByName(this.groupRow.expression.fieldName);
        return (column && column.dataType) || DataType.String;
    }
};
IgxGridGroupByRowComponent.ɵfac = function IgxGridGroupByRowComponent_Factory(t) { return new (t || IgxGridGroupByRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxGridGroupByRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridGroupByRowComponent, selectors: [["igx-grid-groupby-row"]], viewQuery: function IgxGridGroupByRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c149, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c150, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c151, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultGroupByExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultGroupByCollapsedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupContent = _t.first);
    } }, hostVars: 6, hostBindings: function IgxGridGroupByRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerdown", function IgxGridGroupByRowComponent_pointerdown_HostBindingHandler() { return ctx.activate(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded)("aria-describedby", ctx.describedBy)("data-rowIndex", ctx.dataRowIndex)("id", ctx.attrCellID);
        ɵngcc0.ɵɵclassMap(ctx.styleClasses);
    } }, inputs: { isFocused: "isFocused", index: "index", gridID: "gridID", groupRow: "groupRow" }, decls: 13, vars: 8, consts: [["defaultGroupRow", ""], [1, "igx-grid__grouping-indicator", 3, "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-grid__group-content"], ["groupContent", ""], ["defaultGroupByExpandedTemplate", ""], ["defaultGroupByCollapsedTemplate", ""], ["defaultGroupByTemplate", ""], ["fontSet", "material"], [1, "igx-group-label"], ["fontSet", "material", 1, "igx-group-label__icon"], [1, "igx-group-label__column-name"], [4, "ngIf", "ngIfElse"], ["default", ""], [1, "igx-group-label__count-badge", 3, "value"], [1, "igx-group-label__text"], [4, "ngIf"]], template: function IgxGridGroupByRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainerStart(0, null, 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵlistener("click", function IgxGridGroupByRowComponent_Template_div_click_2_listener() { return ctx.toggle(); });
        ɵngcc0.ɵɵtemplate(3, IgxGridGroupByRowComponent_ng_container_3_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3, 4);
        ɵngcc0.ɵɵtemplate(6, IgxGridGroupByRowComponent_ng_container_6_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, IgxGridGroupByRowComponent_ng_template_7_Template, 2, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxGridGroupByRowComponent_ng_template_9_Template, 2, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxGridGroupByRowComponent_ng_template_11_Template, 9, 4, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementContainerEnd();
    } if (rf & 2) {
        const _r757 = ɵngcc0.ɵɵreference(12);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(4, _c13, ctx));
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.grid.groupRowTemplate ? ctx.grid.groupRowTemplate : _r757)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(6, _c13, ctx.groupRow));
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxIconComponent, ɵngcc2.NgIf, IgxBadgeComponent], pipes: [ɵngcc2.DecimalPipe, ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
IgxGridGroupByRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    ViewChild('defaultGroupByExpandedTemplate', { read: TemplateRef, static: true })
], IgxGridGroupByRowComponent.prototype, "defaultGroupByExpandedTemplate", void 0);
__decorate([
    ViewChild('defaultGroupByCollapsedTemplate', { read: TemplateRef, static: true })
], IgxGridGroupByRowComponent.prototype, "defaultGroupByCollapsedTemplate", void 0);
__decorate([
    Input()
], IgxGridGroupByRowComponent.prototype, "isFocused", void 0);
__decorate([
    Input()
], IgxGridGroupByRowComponent.prototype, "index", void 0);
__decorate([
    Input()
], IgxGridGroupByRowComponent.prototype, "gridID", void 0);
__decorate([
    Input()
], IgxGridGroupByRowComponent.prototype, "groupRow", void 0);
__decorate([
    ViewChild('groupContent', { static: true })
], IgxGridGroupByRowComponent.prototype, "groupContent", void 0);
__decorate([
    HostBinding('attr.aria-expanded')
], IgxGridGroupByRowComponent.prototype, "expanded", null);
__decorate([
    HostBinding('attr.aria-describedby')
], IgxGridGroupByRowComponent.prototype, "describedBy", null);
__decorate([
    HostBinding('attr.data-rowIndex')
], IgxGridGroupByRowComponent.prototype, "dataRowIndex", null);
__decorate([
    HostBinding('attr.id')
], IgxGridGroupByRowComponent.prototype, "attrCellID", null);
__decorate([
    HostBinding('class')
], IgxGridGroupByRowComponent.prototype, "styleClasses", null);
__decorate([
    HostListener('pointerdown')
], IgxGridGroupByRowComponent.prototype, "activate", null);

/** @hidden */
let IgxGridMRLNavigationService = class IgxGridMRLNavigationService extends IgxGridNavigationService {
    getNextPosition(rowIndex, colIndex, key, shift, ctrl, event) {
        if (!this.activeNode.layout) {
            this.activeNode.layout = this.layout(this.activeNode.column || 0);
        }
        switch (key) {
            case 'tab':
            case ' ':
            case 'spacebar':
            case 'space':
            case 'escape':
            case 'esc':
            case 'enter':
            case 'f2':
                super.getNextPosition(rowIndex, colIndex, key, shift, ctrl, event);
                break;
            case 'end':
                rowIndex = ctrl ? this.findLastDataRowIndex() : this.activeNode.row;
                colIndex = ctrl ? this.lastColIndexPerMRLBlock(this.lastIndexPerRow) : this.lastIndexPerRow;
                break;
            case 'home':
                rowIndex = ctrl ? this.findFirstDataRowIndex() : this.activeNode.row;
                colIndex = ctrl ? 0 : this.firstIndexPerRow;
                break;
            case 'arrowleft':
            case 'left':
                colIndex = ctrl ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
                break;
            case 'arrowright':
            case 'right':
                colIndex = ctrl ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
                break;
            case 'arrowup':
            case 'up':
                const prevPos = this.getNextVerticalPosition(true);
                colIndex = ctrl ? this.activeNode.column : prevPos.column;
                rowIndex = ctrl ? this.findFirstDataRowIndex() : prevPos.row;
                break;
            case 'arrowdown':
            case 'down':
                const nextPos = this.getNextVerticalPosition();
                colIndex = ctrl ? this.activeNode.column : nextPos.column;
                rowIndex = ctrl ? this.findLastDataRowIndex() : nextPos.row;
                break;
            default:
                return;
        }
        const nextLayout = this.layout(colIndex);
        const newLayout = key.includes('up') || key.includes('down') ? { rowStart: nextLayout.rowStart } : { colStart: nextLayout.colStart };
        Object.assign(this.activeNode.layout, newLayout, { rowEnd: nextLayout.rowEnd });
        if (ctrl && (key === 'home' || key === 'end')) {
            this.activeNode.layout = nextLayout;
        }
        return { rowIndex, colIndex };
    }
    isValidPosition(rowIndex, colIndex) {
        if (rowIndex < 0 || colIndex < 0 || this.grid.dataView.length - 1 < rowIndex ||
            Math.max(...this.grid.visibleColumns.map(col => col.visibleIndex)) < colIndex ||
            (this.activeNode.column !== colIndex && !this.isDataRow(rowIndex, true))) {
            return false;
        }
        return true;
    }
    shouldPerformVerticalScroll(targetRowIndex, visibleColIndex) {
        if (!super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex)) {
            return false;
        }
        if (!this.isDataRow(targetRowIndex)) {
            return super.shouldPerformVerticalScroll(targetRowIndex, visibleColIndex);
        }
        const targetRow = super.getRowElementByIndex(targetRowIndex);
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const scrollPos = this.getVerticalScrollPositions(targetRowIndex, visibleColIndex);
        return (!targetRow || targetRow.offsetTop + scrollPos.topOffset < Math.abs(this.containerTopOffset)
            || containerHeight && containerHeight < scrollPos.rowBottom - Math.ceil(this.scrollTop));
    }
    isColumnFullyVisible(visibleColIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
        if (this.isParentColumnFullyVisible(targetCol === null || targetCol === void 0 ? void 0 : targetCol.parent) || super.isColumnPinned(visibleColIndex, this.forOfDir())) {
            return true;
        }
        const scrollPos = this.getChildColumnScrollPositions(visibleColIndex);
        const colWidth = scrollPos.rightScroll - scrollPos.leftScroll;
        if (this.displayContainerWidth < colWidth && this.displayContainerScrollLeft === scrollPos.leftScroll) {
            return true;
        }
        return this.displayContainerWidth >= scrollPos.rightScroll - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= scrollPos.leftScroll;
    }
    isParentColumnFullyVisible(parent) {
        if (!this.forOfDir().getScroll().clientWidth || (parent === null || parent === void 0 ? void 0 : parent.pinned)) {
            return true;
        }
        const index = this.forOfDir().igxForOf.indexOf(parent);
        return this.displayContainerWidth >= this.forOfDir().getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft &&
            this.displayContainerScrollLeft <= this.forOfDir().getColumnScrollLeft(index);
    }
    getChildColumnScrollPositions(visibleColIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleColIndex);
        const parentVIndex = this.forOfDir().igxForOf.indexOf(targetCol.parent);
        let leftScroll = this.forOfDir().getColumnScrollLeft(parentVIndex);
        let rightScroll = this.forOfDir().getColumnScrollLeft(parentVIndex + 1);
        targetCol.parent.children.forEach((c) => {
            if (c.rowStart >= targetCol.rowStart && c.visibleIndex < targetCol.visibleIndex) {
                leftScroll += parseInt(c.width, 10);
            }
            if (c.rowStart <= targetCol.rowStart && c.visibleIndex > targetCol.visibleIndex) {
                rightScroll -= parseInt(c.width, 10);
            }
        });
        return { leftScroll, rightScroll: rightScroll };
    }
    getVerticalScrollPositions(rowIndex, visibleIndex) {
        const targetCol = this.grid.getColumnByVisibleIndex(visibleIndex);
        const rowSpan = targetCol.rowEnd && targetCol.rowEnd - targetCol.rowStart ? targetCol.rowEnd - targetCol.rowStart : 1;
        const topOffset = this.grid.defaultRowHeight * (targetCol.rowStart - 1);
        const rowTop = this.grid.verticalScrollContainer.sizesCache[rowIndex] + topOffset;
        return { topOffset, rowTop, rowBottom: rowTop + (this.grid.defaultRowHeight * rowSpan) };
    }
    performHorizontalScrollToCell(visibleColumnIndex, cb) {
        if (!this.shouldPerformHorizontalScroll(visibleColumnIndex)) {
            return;
        }
        const scrollPos = this.getChildColumnScrollPositions(visibleColumnIndex);
        const startScroll = scrollPos.rightScroll - this.displayContainerScrollLeft;
        const nextScroll = !(this.displayContainerScrollLeft <= scrollPos.leftScroll) && this.displayContainerWidth >= startScroll ?
            scrollPos.leftScroll : scrollPos.rightScroll - this.displayContainerWidth;
        this.forOfDir().getScroll().scrollLeft = nextScroll;
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first$1())
            .subscribe(() => {
            if (cb) {
                cb();
            }
        });
    }
    performVerticalScrollToCell(rowIndex, visibleColIndex, cb) {
        var _a;
        const children = (_a = this.parentByChildIndex(visibleColIndex || 0)) === null || _a === void 0 ? void 0 : _a.children;
        if (!super.isDataRow(rowIndex) || (children && children.length < 2)) {
            return super.performVerticalScrollToCell(rowIndex, visibleColIndex, cb);
        }
        const containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        const pos = this.getVerticalScrollPositions(rowIndex, visibleColIndex);
        const row = super.getRowElementByIndex(rowIndex);
        if ((this.scrollTop > pos.rowTop) && (!row || row.offsetTop + pos.topOffset < Math.abs(this.containerTopOffset))) {
            pos.topOffset === 0 ? this.grid.verticalScrollContainer.scrollTo(rowIndex) :
                this.grid.verticalScrollContainer.scrollPosition = pos.rowTop;
        }
        else {
            this.grid.verticalScrollContainer.addScrollTop(Math.abs(pos.rowBottom - this.scrollTop - containerHeight));
        }
        this.grid.verticalScrollContainer.onChunkLoad
            .pipe(first$1()).subscribe(() => {
            if (cb) {
                cb();
            }
        });
    }
    getNextHorizontalCellPosition(previous = false) {
        const parent = this.parentByChildIndex(this.activeNode.column);
        if (!this.hasNextHorizontalPosition(previous, parent)) {
            return { row: this.activeNode.row, column: this.activeNode.column };
        }
        const columns = previous ? parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart)
            .sort((a, b) => b.visibleIndex - a.visibleIndex) : parent.children.filter(c => c.rowStart <= this.activeNode.layout.rowStart);
        let column = columns.find((col) => previous ?
            col.visibleIndex < this.activeNode.column && this.rowEnd(col) > this.activeNode.layout.rowStart :
            col.visibleIndex > this.activeNode.column && col.colStart > this.activeNode.layout.colStart);
        if (!column || (previous && this.activeNode.layout.colStart === 1)) {
            const index = previous ? parent.visibleIndex - 1 : parent.visibleIndex + 1;
            const children = this.grid.columnList.find(cols => cols.columnLayout && cols.visibleIndex === index).children;
            column = previous ? children.toArray().reverse().find(child => child.rowStart <= this.activeNode.layout.rowStart) :
                children.find(child => this.rowEnd(child) > this.activeNode.layout.rowStart && child.colStart === 1);
        }
        return { row: this.activeNode.row, column: column.visibleIndex };
    }
    getNextVerticalPosition(previous = false) {
        this.activeNode.column = this.activeNode.column || 0;
        if (!this.hasNextVerticalPosition(previous)) {
            return { row: this.activeNode.row, column: this.activeNode.column };
        }
        const currentRowStart = this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
        const nextBlock = !this.isDataRow(this.activeNode.row) ||
            (previous ? currentRowStart === 1 : currentRowStart === this.lastRowStartPerBlock());
        const nextRI = previous ? this.activeNode.row - 1 : this.activeNode.row + 1;
        if (nextBlock && !this.isDataRow(nextRI)) {
            return { row: nextRI, column: this.activeNode.column };
        }
        const children = this.parentByChildIndex(this.activeNode.column).children;
        const col = previous ? this.getPreviousRowIndex(children, nextBlock) : this.getNextRowIndex(children, nextBlock);
        return { row: nextBlock ? nextRI : this.activeNode.row, column: col.visibleIndex };
    }
    getNextRowIndex(children, next) {
        const rowStart = next ? 1 : this.rowEnd(this.grid.getColumnByVisibleIndex(this.activeNode.column));
        const col = children.filter(c => c.rowStart === rowStart);
        return col.find(co => co.colStart === this.activeNode.layout.colStart) ||
            col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);
    }
    getPreviousRowIndex(children, prev) {
        const end = prev ? Math.max(...children.map(c => this.rowEnd(c))) :
            this.grid.getColumnByVisibleIndex(this.activeNode.column).rowStart;
        const col = children.filter(c => this.rowEnd(c) === end);
        return col.find(co => co.colStart === this.activeNode.layout.colStart) ||
            col.sort((a, b) => b.visibleIndex - a.visibleIndex).find(co => co.colStart <= this.activeNode.layout.colStart);
    }
    headerNavigation(event) {
        const key = event.key.toLowerCase();
        if (!HEADER_KEYS.has(key)) {
            return;
        }
        event.preventDefault();
        if (!this.activeNode.layout) {
            this.activeNode.layout = this.layout(this.activeNode.column || 0);
        }
        const alt = event.altKey;
        const ctrl = event.ctrlKey;
        this.performHeaderKeyCombination(this.grid.getColumnByVisibleIndex(this.activeNode.column), key, event.shiftKey, ctrl, alt, event);
        if (!ctrl && !alt && (key.includes('down') || key.includes('up'))) {
            const children = this.parentByChildIndex(this.activeNode.column).children;
            const col = key.includes('down') ? this.getNextRowIndex(children, false) : this.getPreviousRowIndex(children, false);
            if (!col) {
                return;
            }
            this.activeNode.column = col.visibleIndex;
            const newLayout = this.layout(this.activeNode.column);
            Object.assign(this.activeNode.layout, { rowStart: newLayout.rowStart, rowEnd: newLayout.rowEnd });
            return;
        }
        this.horizontalNav(event, key, -1);
    }
    horizontalNav(event, key, rowIndex) {
        const ctrl = event.ctrlKey;
        if (!HORIZONTAL_NAV_KEYS.has(key) || event.altKey) {
            return;
        }
        this.activeNode.row = rowIndex;
        if ((key.includes('left') || key === 'home') && this.activeNode.column > 0) {
            this.activeNode.column = ctrl || key === 'home' ? this.firstIndexPerRow : this.getNextHorizontalCellPosition(true).column;
        }
        if ((key.includes('right') || key === 'end') && this.activeNode.column !== this.lastIndexPerRow) {
            this.activeNode.column = ctrl || key === 'end' ? this.lastIndexPerRow : this.getNextHorizontalCellPosition().column;
        }
        const newLayout = this.layout(this.activeNode.column);
        Object.assign(this.activeNode.layout, { colStart: newLayout.colStart, rowEnd: newLayout.rowEnd });
        this.performHorizontalScrollToCell(this.activeNode.column);
    }
    get lastIndexPerRow() {
        const children = this.grid.visibleColumns.find(c => c.visibleIndex === this.lastLayoutIndex && c.columnLayout)
            .children.toArray().reverse();
        const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) ||
            children.find(co => co.rowStart <= this.activeNode.layout.rowStart);
        return column.visibleIndex;
    }
    get firstIndexPerRow() {
        const children = this.grid.visibleColumns.find(c => c.visibleIndex === 0 && c.columnLayout).children;
        const column = children.find(co => co.rowStart === this.activeNode.layout.rowStart) ||
            children.find(co => co.rowStart <= this.activeNode.layout.rowStart);
        return column.visibleIndex;
    }
    get lastLayoutIndex() {
        return Math.max(...this.grid.visibleColumns.filter(c => c.columnLayout).map(col => col.visibleIndex));
    }
    get scrollTop() {
        return Math.abs(this.grid.verticalScrollContainer.getScroll().scrollTop);
    }
    lastColIndexPerMRLBlock(visibleIndex = this.activeNode.column) {
        return this.parentByChildIndex(visibleIndex).children.last.visibleIndex;
    }
    lastRowStartPerBlock(visibleIndex = this.activeNode.column) {
        return Math.max(...this.parentByChildIndex(visibleIndex).children.map(c => c.rowStart));
    }
    rowEnd(column) {
        return column.rowEnd && column.rowEnd - column.rowStart ? column.rowStart + column.rowEnd - column.rowStart : column.rowStart + 1;
    }
    /**
     * @hidden
     * @internal
     */
    layout(visibleIndex) {
        const column = this.grid.getColumnByVisibleIndex(visibleIndex);
        return { colStart: column.colStart, rowStart: column.rowStart,
            colEnd: column.colEnd, rowEnd: column.rowEnd, columnVisibleIndex: column.visibleIndex };
    }
    parentByChildIndex(visibleIndex) {
        var _a;
        return (_a = this.grid.getColumnByVisibleIndex(visibleIndex)) === null || _a === void 0 ? void 0 : _a.parent;
    }
    hasNextHorizontalPosition(previous = false, parent) {
        if (previous && parent.visibleIndex === 0 && this.activeNode.layout.colStart === 1 ||
            !previous && parent.visibleIndex === this.lastLayoutIndex && this.activeNode.column === this.lastIndexPerRow) {
            return false;
        }
        return true;
    }
    hasNextVerticalPosition(prev = false) {
        if ((prev && this.activeNode.row === 0 && (!this.isDataRow(this.activeNode.row) || this.activeNode.layout.rowStart === 1)) ||
            (!prev && this.activeNode.row >= this.grid.dataView.length - 1 && this.activeNode.column === this.lastColIndexPerMRLBlock())) {
            return false;
        }
        return true;
    }
};
IgxGridMRLNavigationService.ɵfac = function IgxGridMRLNavigationService_Factory(t) { return ɵIgxGridMRLNavigationService_BaseFactory(t || IgxGridMRLNavigationService); };
IgxGridMRLNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxGridMRLNavigationService, factory: IgxGridMRLNavigationService.ɵfac });

var IgxGridComponent_1;
let NEXT_ID$i = 0;
/**
 * Grid provides a way to present and manipulate tabular data.
 * @igxModule IgxGridModule
 * @igxGroup Grids & Lists
 * @igxKeywords grid, table
 * @igxTheme igx-grid-theme
 * @remarks
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 * @example
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
let IgxGridComponent = IgxGridComponent_1 = class IgxGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        this._id = `igx-grid-${NEXT_ID$i++}`;
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._filteredData = null;
        this.childDetailTemplates = new Map();
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.groupingExpansionStateChange = new EventEmitter();
        /**
         * Gets/Sets whether created groups are rendered expanded or collapsed.
         * @remarks
         * The default rendered state is expanded.
         * @example
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.groupsExpanded = true;
        /**
         * Gets the hierarchical representation of the group by records.
         * @example
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         */
        this.groupsRecords = [];
        /**
         * Emitted when columns are grouped/ungrouped.
         * @remarks
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * @example
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         */
        this.onGroupingDone = new EventEmitter();
        /**
         * @hidden @internal
         */
        this.detailTemplate = null;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * Gets/Sets the array of data that populates the `IgxGridComponent`.
     * @example
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Gets/Sets an array of objects containing the filtered data.
     * @example
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * this.grid.filteredData = [...];
     * ```
     */
    get filteredData() {
        return this._filteredData;
    }
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Gets/Sets the total number of records in the data source.
     * @remarks
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * @example
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * this.grid1.totalItemCount = 55;
     * ```
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * Gets/Sets the group by state.
     * @example
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * this.grid.groupingExpressions = [...];
     * ```
     * @remarks
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    set groupingExpressions(value) {
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        const oldExpressions = this.groupingExpressions;
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();
            this._gridAPI.arrange_sorting_expressions();
            this.notifyChanges();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            const groupedCols = [];
            const ungroupedCols = [];
            const groupedColsArr = newExpressions.filter((obj) => {
                return !oldExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            const ungroupedColsArr = oldExpressions.filter((obj) => {
                return !newExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Gets/Sets a list of expansion states for group rows.
     * @remarks
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * Supports two-way data binding.
     * @example
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * Gets/Sets whether the grouped columns should be hidden.
     * @remarks
     * The default value is "false"
     * @example
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * Gets/Sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * @remarks
     * The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * @example
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * Gets the list of group rows.
     * @example
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     */
    get groupsRowList() {
        const res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        const rList = this._groupsRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        }).sort((item1, item2) => item1.index - item2.index);
        res.reset(rList);
        return res;
    }
    /**
     * @hidden @internal
     */
    getDetailsContext(rowData, index) {
        return {
            $implicit: rowData,
            index: index
        };
    }
    /**
     * @hidden @internal
     */
    trackChanges(index, rec) {
        if (rec.detailsData !== undefined) {
            return rec.detailsData;
        }
        return rec;
    }
    /**
     * @hidden @internal
     */
    detailsViewFocused(container, rowIndex) {
        this.navigation.activeNode ? this.navigation.activeNode.row = rowIndex :
            this.navigation.activeNode = { row: rowIndex };
    }
    /**
     * @hidden @internal
     */
    get hasDetails() {
        return !!this.gridDetailsTemplate;
    }
    /**
     * @hidden @internal
     */
    getRowTemplate(rowData) {
        if (this.isGroupByRecord(rowData)) {
            return this.defaultGroupTemplate;
        }
        else if (this.isSummaryRow(rowData)) {
            return this.summaryTemplate;
        }
        else if (this.hasDetails && this.isDetailRecord(rowData)) {
            return this.detailTemplateContainer;
        }
        else {
            return this.recordTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    isDetailRecord(record) {
        return record.detailsData !== undefined;
    }
    /**
     * @hidden @internal
     */
    isDetailActive(rowIndex) {
        return this.navigation.activeNode ? this.navigation.activeNode.row === rowIndex : false;
    }
    /**
     * @hidden @internal
     */
    get groupAreaHostClass() {
        return this.getComponentDensityClass('igx-drop-area');
    }
    /**
     * Gets/Sets the template reference for the group row.
     * @example
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * this.grid.groupRowTemplate = myRowTemplate;
     * ```
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Gets/Sets the template reference of the `IgxGridComponent`'s group area.
     * @example
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * @remarks
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * @example
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     *     { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     *     { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     *     { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.endEdit(true);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears grouping for particular column, array of columns or all columns.
     * @remarks
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * @example
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     * @param name Name of column or array of column names to be ungrouped.
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.notifyChanges(true);
    }
    preventHeaderScroll(args) {
        if (args.target.scrollLeft !== 0) {
            this.navigation.forOfDir().getScroll().scrollLeft = args.target.scrollLeft;
            args.target.scrollLeft = 0;
        }
    }
    /**
     * Returns if a group is expanded or not.
     * @param group The group record.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     */
    isExpandedGroup(group) {
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     * @param groupRow The group record to toggle.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     * @param groupRow The group record to fully expand.
     * @example
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     * @example
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     * @example
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    _setGroupColsVisibility(value) {
        if (this.columnList.length > 0 && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    /**
     * Gets if the grid's group by drop area is visible.
     * @example
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden @internal
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden @internal
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    }
    /**
     * @hidden @internal
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden @internal
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isDetailRecord(rowData)) {
            const cachedData = this.childDetailTemplates.get(rowData.detailsData);
            const rowID = this.primaryKey ? rowData.detailsData[this.primaryKey] : this.data.indexOf(rowData.detailsData);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData.detailsData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData),
                    templateID: 'detailRow-' + rowID
                };
            }
            else {
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData.detailsData,
                    templateID: 'detailRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData)
        };
    }
    /**
     * @hidden @internal
     */
    viewCreatedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            this.childDetailTemplates.set(args.context.$implicit, args);
        }
    }
    /**
     * @hidden @internal
     */
    viewMovedHandler(args) {
        if (args.context.templateID.indexOf('detailRow') !== -1) {
            // view was moved, update owner in cache
            const key = args.context.$implicit;
            const cachedData = this.childDetailTemplates.get(key);
            cachedData.owner = args.owner;
        }
    }
    /**
     * @hidden @internal
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden @internal
     */
    chipsOrderChanged(event) {
        const newGrouping = [];
        for (let i = 0; i < event.chipsArray.length; i++) {
            const expr = this.groupingExpressions.filter((item) => {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipClicked(event) {
        const sortingExpr = this.sortingExpressions;
        const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.notifyChanges();
    }
    /**
     * @hidden @internal
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            const sortingExpr = this.sortingExpressions;
            const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        }
    }
    /**
     * @hidden @internal
     */
    get defaultTargetBodyHeight() {
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden @internal
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    }
    /**
     * @hidden @internal
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            const rowIndex = this.groupingResult.indexOf(row);
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden @internal
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getGroupByChipTitle(expression) {
        const column = this.getColumnByName(expression.fieldName);
        return (column && column.header) || expression.fieldName;
    }
    /**
     * @hidden @internal
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden @internal
     */
    getColumnGroupable(fieldName) {
        const column = this.getColumnByName(fieldName);
        return column && column.groupable;
    }
    /**
     * @hidden @internal
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isDetailRecord(rowData)) {
                const cachedData = this.childDetailTemplates.get(rowData.detailsData);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.endEdit(true);
            this.summaryService.updateSummaryCache(args);
            this._headerFeaturesWidth = NaN;
        });
    }
    /**
     * @hidden @internal
     */
    ngDoCheck() {
        if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length) {
            const source = [];
            const process = (record) => {
                if (record.expression || record.summaries) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
        }
    }
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
};
IgxGridComponent.ɵfac = function IgxGridComponent_Factory(t) { return ɵIgxGridComponent_BaseFactory(t || IgxGridComponent); };
IgxGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridComponent, selectors: [["igx-grid"]], contentQueries: function IgxGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridDetailTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGroupByRowTemplateDirective, true, IgxGroupByRowTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxGridDetailTemplateDirective, true, IgxGridDetailTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.detailTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.gridDetailsTemplate = _t.first);
    } }, viewQuery: function IgxGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c152, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(_c153, true);
        ɵngcc0.ɵɵstaticViewQuery(_c154, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c155, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c156, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c157, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxGridGroupByRowComponent, true, IgxGridGroupByRowComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultDropAreaTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groupArea = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.detailTemplateContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultGroupTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.summaryTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._groupsRowList = _t);
    } }, hostVars: 1, hostBindings: function IgxGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { groupsExpanded: "groupsExpanded", id: "id", data: "data", groupingExpressions: "groupingExpressions", groupingExpansionState: "groupingExpansionState", hideGroupedColumns: "hideGroupedColumns", dropAreaMessage: "dropAreaMessage", dropAreaTemplate: "dropAreaTemplate" }, outputs: { groupingExpressionsChange: "groupingExpressionsChange", groupingExpansionStateChange: "groupingExpansionStateChange", onGroupingDone: "onGroupingDone" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxGridNavigationService,
            IgxGridSummaryService,
            IgxGridSelectionService,
            IgxGridCRUDService,
            { provide: GridBaseAPIService, useClass: IgxGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxGridComponent_1) },
            IgxFilteringService,
            IgxColumnResizingService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService,
            IgxRowIslandAPIService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c173, decls: 108, vars: 176, consts: [["role", "toolbar", 3, "max-width", "flex-basis", "gridID", "displayDensity", 4, "ngIf"], ["class", "igx-grid__grouparea", 3, "flex-basis", 4, "ngIf"], [1, "igx-grid__thead"], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__thead-wrapper", 3, "focus", "keydown", "scroll"], ["theadRow", ""], ["role", "row", 1, "igx-grid__tr"], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], ["id", "left", "class", "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["hContainer", ""], [3, "width", "column", 4, "ngIf"], ["id", "right", "class", "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop", 4, "ngIf"], [1, "igx-grid__thead-thumb", 3, "hidden"], ["igxGridBody", "", 1, "igx-grid__tbody", 3, "keydown.control.c", "copy"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tbody-content", 3, "igxGridDragSelect", "keydown", "focus", "onDragStop", "scroll", "onDragScroll"], ["tbody", ""], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", 4, "ngIf"], [4, "ngTemplateOutlet"], ["pinnedRecordsTemplate", ""], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForItemSize", "igxForTrackBy", "onChunkPreload"], ["verticalScrollContainer", ""], ["record_template", ""], ["pinned_record_template", ""], ["group_template", ""], ["summary_template", ""], ["detail_template_container", ""], ["igxOverlayOutlet", "", 1, "igx-grid__row-editing-outlet"], ["igxRowEditingOverlayOutlet", ""], ["loadingOverlay", ""], [3, "indeterminate", 4, "ngIf"], [1, "igx-grid__tbody-scrollbar", 3, "hidden"], [1, "igx-grid__tbody-scrollbar-start"], [1, "igx-grid__tbody-scrollbar-main"], ["igxGridFor", "", 3, "igxGridForOf"], ["verticalScrollHolder", ""], [1, "igx-grid__tbody-scrollbar-end"], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__tfoot", 3, "focus", "keydown"], ["tfoot", ""], ["role", "row", "class", "igx-grid__summaries", 3, "width", "height", "gridID", "summaries", "index", 4, "ngIf"], [1, "igx-grid__tfoot-thumb", 3, "hidden"], [1, "igx-grid__scroll", 3, "hidden"], ["scr", ""], [1, "igx-grid__scroll-start"], [1, "igx-grid__scroll-main"], ["scrollContainer", ""], [1, "igx-grid__scroll-end", 3, "hidden"], [1, "igx-grid__footer"], ["footer", ""], ["defaultPaginator", ""], ["emptyFilteredGrid", ""], ["defaultEmptyGrid", ""], ["defaultLoadingGrid", ""], ["defaultDropArea", ""], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["igxToggle", "", 4, "ngIf"], ["defaultRowEditText", ""], ["defaultRowEditActions", ""], ["defaultRowEditTemplate", ""], ["dragIndicatorIconBase", ""], ["igxHeadSelector", ""], ["headSelectorBaseTemplate", ""], ["igxOverlayOutlet", "", 1, "igx-grid__loading-outlet"], ["igxLoadingOverlayOutlet", ""], ["igxOverlayOutlet", "", 1, "igx-grid__outlet", 3, "keydown"], ["igxFilteringOverlayOutlet", ""], ["role", "toolbar", 3, "gridID", "displayDensity"], ["toolbar", ""], [1, "igx-grid__grouparea"], ["groupArea", ""], [3, "onReorder", "onMoveEnd"], [4, "ngFor", "ngForOf"], ["igxGroupAreaDrop", ""], [3, "id", "removable", "draggable", "displayDensity", "disabled", "onKeyDown", "onRemove", "onClick"], ["igxSuffix", ""], [1, "igx-grid__grouparea-connector"], ["id", "left", 1, "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop"], ["id", "left", 1, "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop"], [3, "ngClass", "click"], ["headerGroupContainer", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-grid__drag-indicator", 3, "ngClass"], ["headerDragContainer", ""], [2, "visibility", "hidden"], [1, "igx-grid__cbx-selection", 3, "ngClass", "click"], ["headerSelectorContainer", ""], ["headSelector", ""], ["ngFor", "", 3, "ngForOf"], [3, "column", "gridID"], [3, "column"], ["filteringRow", ""], ["id", "right", 1, "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop"], ["class", "igx-grid__tr--pinned", 3, "ngClass", "width", 4, "ngIf"], [1, "igx-grid__tr--pinned", 3, "ngClass"], ["pinContainer", ""], [3, "igxTemplateOutlet", "igxTemplateOutletContext", "onCachedViewLoaded", "onViewCreated", "onViewMoved"], [3, "gridID", "index", "rowData", "disabled"], ["row", ""], [3, "gridID", "index", "rowData"], ["row", "", "pinnedRow", ""], [3, "gridID", "index", "groupRow"], [1, "igx-grid__summaries--body", 3, "gridID", "summaries", "index"], ["summaryRow", ""], ["detail", "true", 2, "overflow", "auto", "width", "100%", 3, "id", "ngClass", "pointerdown"], ["detailsContainer", ""], [1, "igx-grid__hierarchical-indent", 2, "display", "flex"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "indeterminate"], ["role", "row", 1, "igx-grid__summaries", 3, "gridID", "summaries", "index"], [3, "displayDensity", "page", "totalRecords", "perPage", "pageChange", "perPageChange"], [1, "igx-grid__tbody-message"], [1, "igx-grid__loading"], ["fontSet", "material", 1, "igx-drop-area__icon"], [1, "igx-drop-area__text"], ["role", "button", 1, "igx-grid__group-expand-btn", 3, "ngClass"], ["igxToggle", ""], [3, "className"], ["igxButton", "", "igxRowEditTabStop", "", 3, "click"], [1, "igx-banner__message"], [1, "igx-banner__text"], [1, "igx-banner__actions"], [1, "igx-banner__row"], ["fontSet", "material"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "ngStyle", "indeterminate", "aria-label"], ["headerCheckbox", ""]], template: function IgxGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c169);
        ɵngcc0.ɵɵtemplate(0, IgxGridComponent_igx_grid_toolbar_0_Template, 2, 6, "igx-grid-toolbar", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridComponent_div_1_Template, 6, 9, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3, 4);
        ɵngcc0.ɵɵlistener("focus", function IgxGridComponent_Template_div_focus_3_listener() { return ctx.navigation.focusFirstCell(); })("keydown", function IgxGridComponent_Template_div_keydown_3_listener($event) { return ctx.navigation.headerNavigation($event); })("scroll", function IgxGridComponent_Template_div_scroll_3_listener($event) { return ctx.preventHeaderScroll($event); });
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵtemplate(6, IgxGridComponent_span_6_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(7, IgxGridComponent_span_7_Template, 1, 4, "span", 7);
        ɵngcc0.ɵɵtemplate(8, IgxGridComponent_ng_container_8_Template, 4, 10, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(9, IgxGridComponent_ng_container_9_Template, 5, 4, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(10, IgxGridComponent_ng_container_10_Template, 4, 10, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(11, IgxGridComponent_ng_container_11_Template, 3, 3, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(12, IgxGridComponent_ng_template_12_Template, 1, 6, "ng-template", 9, 10, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(14, "igxTopLevel");
        ɵngcc0.ɵɵtemplate(15, IgxGridComponent_ng_container_15_Template, 3, 3, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(16, IgxGridComponent_igx_grid_filtering_row_16_Template, 2, 3, "igx-grid-filtering-row", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(17, IgxGridComponent_span_17_Template, 1, 2, "span", 12);
        ɵngcc0.ɵɵelement(18, "div", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(19, "div", 14);
        ɵngcc0.ɵɵlistener("keydown.control.c", function IgxGridComponent_Template_div_keydown_control_c_19_listener() { return ctx.copyHandlerIE(); })("copy", function IgxGridComponent_Template_div_copy_19_listener($event) { return ctx.copyHandler($event); });
        ɵngcc0.ɵɵelementStart(20, "div", 15, 16);
        ɵngcc0.ɵɵlistener("keydown", function IgxGridComponent_Template_div_keydown_20_listener($event) { return ctx.navigation.handleNavigation($event); })("focus", function IgxGridComponent_Template_div_focus_20_listener($event) { return ctx.navigation.focusTbody($event); })("onDragStop", function IgxGridComponent_Template_div_onDragStop_20_listener($event) { return ctx.selectionService.dragMode = $event; })("scroll", function IgxGridComponent_Template_div_scroll_20_listener($event) { return ctx.preventContainerScroll($event); })("onDragScroll", function IgxGridComponent_Template_div_onDragScroll_20_listener($event) { return ctx.dragScroll($event); });
        ɵngcc0.ɵɵtemplate(22, IgxGridComponent_span_22_Template, 1, 2, "span", 17);
        ɵngcc0.ɵɵtemplate(23, IgxGridComponent_span_23_Template, 1, 4, "span", 7);
        ɵngcc0.ɵɵtemplate(24, IgxGridComponent_ng_container_24_Template, 1, 0, "ng-container", 18);
        ɵngcc0.ɵɵtemplate(25, IgxGridComponent_ng_template_25_Template, 6, 43, "ng-template", null, 19, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(27, IgxGridComponent_ng_template_27_Template, 1, 2, "ng-template", 20, 21, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(29, "gridRowPinning");
        ɵngcc0.ɵɵpipe(30, "gridDetails");
        ɵngcc0.ɵɵpipe(31, "gridSummary");
        ɵngcc0.ɵɵpipe(32, "gridPaging");
        ɵngcc0.ɵɵpipe(33, "gridGroupBy");
        ɵngcc0.ɵɵpipe(34, "gridSort");
        ɵngcc0.ɵɵpipe(35, "gridFiltering");
        ɵngcc0.ɵɵpipe(36, "visibleColumns");
        ɵngcc0.ɵɵpipe(37, "gridTransaction");
        ɵngcc0.ɵɵlistener("onChunkPreload", function IgxGridComponent_Template_ng_template_onChunkPreload_27_listener($event) { return ctx.dataLoading($event); });
        ɵngcc0.ɵɵtemplate(38, IgxGridComponent_ng_container_38_Template, 1, 0, "ng-container", 18);
        ɵngcc0.ɵɵtemplate(39, IgxGridComponent_ng_template_39_Template, 2, 4, "ng-template", null, 22, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(41, IgxGridComponent_ng_template_41_Template, 3, 3, "ng-template", null, 23, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(43, IgxGridComponent_ng_template_43_Template, 2, 3, "ng-template", null, 24, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(45, IgxGridComponent_ng_template_45_Template, 2, 3, "ng-template", null, 25, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(47, IgxGridComponent_ng_template_47_Template, 5, 9, "ng-template", null, 26, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(49, IgxGridComponent_ng_container_49_Template, 1, 0, "ng-container", 18);
        ɵngcc0.ɵɵelement(50, "div", 27, 28);
        ɵngcc0.ɵɵelement(52, "igc-trial-watermark");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(53, "div", null, 29);
        ɵngcc0.ɵɵtemplate(55, IgxGridComponent_igx_circular_bar_55_Template, 1, 1, "igx-circular-bar", 30);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(56, IgxGridComponent_span_56_Template, 1, 2, "span", 12);
        ɵngcc0.ɵɵelementStart(57, "div", 31);
        ɵngcc0.ɵɵelement(58, "div", 32);
        ɵngcc0.ɵɵelementStart(59, "div", 33);
        ɵngcc0.ɵɵtemplate(60, IgxGridComponent_ng_template_60_Template, 0, 0, "ng-template", 34, 35, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(62, "div", 36);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(63, "div", 37, 38);
        ɵngcc0.ɵɵlistener("focus", function IgxGridComponent_Template_div_focus_63_listener() { return ctx.navigation.focusFirstCell(false); })("keydown", function IgxGridComponent_Template_div_keydown_63_listener($event) { return ctx.navigation.summaryNav($event); });
        ɵngcc0.ɵɵtemplate(65, IgxGridComponent_igx_grid_summary_row_65_Template, 3, 10, "igx-grid-summary-row", 39);
        ɵngcc0.ɵɵelement(66, "div", 40);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(67, "div", 41, 42);
        ɵngcc0.ɵɵelement(69, "div", 43);
        ɵngcc0.ɵɵelementStart(70, "div", 44);
        ɵngcc0.ɵɵtemplate(71, IgxGridComponent_ng_template_71_Template, 0, 0, "ng-template", 34, 45, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(73, "div", 46);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(74, "div", 47, 48);
        ɵngcc0.ɵɵprojection(76);
        ɵngcc0.ɵɵtemplate(77, IgxGridComponent_ng_container_77_Template, 2, 4, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(78, IgxGridComponent_ng_template_78_Template, 1, 4, "ng-template", null, 49, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(80, IgxGridComponent_ng_template_80_Template, 2, 1, "ng-template", null, 50, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(82, IgxGridComponent_ng_template_82_Template, 2, 1, "ng-template", null, 51, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(84, IgxGridComponent_ng_template_84_Template, 2, 1, "ng-template", null, 52, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(86, IgxGridComponent_ng_template_86_Template, 4, 1, "ng-template", null, 53, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(88, IgxGridComponent_ng_template_88_Template, 2, 3, "ng-template", null, 54, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(90, IgxGridComponent_ng_template_90_Template, 2, 3, "ng-template", null, 55, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(92, IgxGridComponent_div_92_Template, 3, 6, "div", 56);
        ɵngcc0.ɵɵtemplate(93, IgxGridComponent_ng_template_93_Template, 1, 1, "ng-template", null, 57, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(95, IgxGridComponent_ng_template_95_Template, 4, 0, "ng-template", null, 58, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(97, IgxGridComponent_ng_template_97_Template, 6, 8, "ng-template", null, 59, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(99, IgxGridComponent_ng_template_99_Template, 2, 0, "ng-template", null, 60, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(101, IgxGridComponent_ng_template_101_Template, 3, 8, "ng-template", 61, 62, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(103, IgxGridComponent_igx_grid_column_resizer_103_Template, 1, 0, "igx-grid-column-resizer", 8);
        ɵngcc0.ɵɵelement(104, "div", 63, 64);
        ɵngcc0.ɵɵelementStart(106, "div", 65, 66);
        ɵngcc0.ɵɵlistener("keydown", function IgxGridComponent_Template_div_keydown_106_listener($event) { return ctx.gridOutletKeyboardHandler($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r782 = ɵngcc0.ɵɵreference(26);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToolbar);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.groupingExpressions.length > 0 || ctx.hasGroupableColumns);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵclassProp("igx-grid__tr--mrl", ctx.hasColumnLayouts);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.groupingExpressions.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(14, 83, ctx.unpinnedColumns))("igxForScrollOrientation", "horizontal")("igxForScrollContainer", ctx.parentVirtDir)("igxForContainerSize", ctx.unpinnedWidth)("igxForTrackBy", ctx.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteringService.isFilterRowVisible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px")("width", ctx.calcWidth || null, "px");
        ɵngcc0.ɵɵproperty("igxGridDragSelect", ctx.selectionService.dragMode);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r782 : null);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind4(29, 85, ɵngcc0.ɵɵpipeBind4(30, 90, ɵngcc0.ɵɵpipeBindV(31, 95, ɵngcc0.ɵɵpureFunction7(166, _c170, ɵngcc0.ɵɵpipeBindV(32, 103, ɵngcc0.ɵɵpureFunction5(160, _c171, ɵngcc0.ɵɵpipeBindV(33, 109, ɵngcc0.ɵɵpureFunction7(152, _c170, ɵngcc0.ɵɵpipeBindV(34, 117, ɵngcc0.ɵɵpureFunction5(146, _c171, ɵngcc0.ɵɵpipeBindV(35, 123, ɵngcc0.ɵɵpureFunction7(138, _c170, ɵngcc0.ɵɵpipeBind2(36, 131, ɵngcc0.ɵɵpipeBind3(37, 134, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.groupingExpressions, ctx.groupingExpansionState, ctx.groupsExpanded, ctx.id, ctx.groupsRecords, ctx.pipeTrigger)), ctx.page, ctx.perPage, ctx.id, ctx.pipeTrigger)), ctx.hasSummarizedColumns, ctx.summaryCalculationMode, ctx.summaryPosition, ctx.id, ctx.pipeTrigger, ctx.summaryPipeTrigger)), ctx.hasDetails, ctx.expansionStates, ctx.pipeTrigger), ctx.id, false, ctx.pipeTrigger))("igxForScrollOrientation", "vertical")("igxForScrollContainer", ctx.verticalScroll)("igxForContainerSize", ctx.calcHeight)("igxForItemSize", ctx.hasColumnLayouts ? ctx.rowHeight * ctx.multiRowLayoutRowSize + 1 : ctx.renderedRowHeight)("igxForTrackBy", ctx.trackChanges);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r782 : null);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldOverlayLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(174, _c172));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px")("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.isHorizontalScrollHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px")("min-width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.unpinnedWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(175, _c172));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("float", "right")("width", ctx.pinnedWidth, "px")("min-width", ctx.pinnedWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.pinnedWidth === 0 || ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.paging && ctx.totalRecords);
        ɵngcc0.ɵɵadvance(15);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowEditable);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.colResizingService.showResizer);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxGridForOfDirective,
        IgxGridBodyDirective,
        IgxGridDragSelectDirective, ɵngcc2.NgTemplateOutlet, IgxOverlayOutletDirective,
        IgxHeadSelectorDirective,
        IgxGridToolbarComponent,
        IgxChipsAreaComponent, ɵngcc2.NgForOf, IgxGroupAreaDropDirective,
        IgxChipComponent,
        IgxIconComponent,
        IgxSuffixDirective,
        IgxColumnMovingDropDirective, ɵngcc2.NgClass, IgxGridHeaderGroupComponent,
        IgxGridFilteringRowComponent,
        IgxTemplateOutletDirective,
        IgxGridRowComponent,
        IgxGridGroupByRowComponent,
        IgxSummaryRowComponent,
        IgxCircularProgressBarComponent,
        IgxPaginatorComponent,
        IgxToggleDirective,
        IgxButtonDirective,
        IgxRowEditTabStopDirective,
        IgxCheckboxComponent, ɵngcc2.NgStyle, IgxGridColumnResizerComponent]; }, pipes: function () { return [IgxGridTopLevelColumns,
        IgxGridRowPinningPipe,
        IgxGridDetailsPipe,
        IgxGridSummaryPipe,
        IgxGridPagingPipe,
        IgxGridGroupingPipe,
        IgxGridSortingPipe,
        IgxGridFilteringPipe,
        IgxHasVisibleColumnsPipe,
        IgxGridTransactionPipe,
        IgxSummaryDataPipe]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxGridComponent.prototype, "id", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "data", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "groupingExpressions", null);
__decorate([
    Output()
], IgxGridComponent.prototype, "groupingExpressionsChange", void 0);
__decorate([
    Input()
], IgxGridComponent.prototype, "groupingExpansionState", null);
__decorate([
    Output()
], IgxGridComponent.prototype, "groupingExpansionStateChange", void 0);
__decorate([
    Input()
], IgxGridComponent.prototype, "groupsExpanded", void 0);
__decorate([
    Input()
], IgxGridComponent.prototype, "hideGroupedColumns", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "dropAreaMessage", null);
__decorate([
    Input()
], IgxGridComponent.prototype, "dropAreaTemplate", void 0);
__decorate([
    Output()
], IgxGridComponent.prototype, "onGroupingDone", void 0);
__decorate([
    ContentChild(IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective })
], IgxGridComponent.prototype, "groupTemplate", void 0);
__decorate([
    ContentChild(IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false })
], IgxGridComponent.prototype, "gridDetailsTemplate", void 0);
__decorate([
    ViewChildren(IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent })
], IgxGridComponent.prototype, "_groupsRowList", void 0);
__decorate([
    ViewChild('defaultDropArea', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "defaultDropAreaTemplate", void 0);
__decorate([
    ViewChild('groupArea')
], IgxGridComponent.prototype, "groupArea", void 0);
__decorate([
    ViewChild('record_template', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "recordTemplate", void 0);
__decorate([
    ViewChild('detail_template_container', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "detailTemplateContainer", void 0);
__decorate([
    ContentChild(IgxGridDetailTemplateDirective, { read: TemplateRef, static: false })
], IgxGridComponent.prototype, "detailTemplate", void 0);
__decorate([
    ViewChild('group_template', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "defaultGroupTemplate", void 0);
__decorate([
    ViewChild('summary_template', { read: TemplateRef, static: true })
], IgxGridComponent.prototype, "summaryTemplate", void 0);

const COLUMNS = 'columns';
const FILTERING = 'filtering';
const ADVANCED_FILTERING = 'advancedFiltering';
const SORTING = 'sorting';
const GROUPBY = 'groupBy';
const PAGING = 'paging';
const ROW_SELECTION = 'rowSelection';
const ROW_PINNING = 'rowPinning';
const PINNING_CONFIG = 'pinningConfig';
const CELL_SELECTION = 'cellSelection';
const COLUMN_SELECTION = 'columnSelection';
let IgxGridStateDirective = class IgxGridStateDirective {
    /**
     * @hidden
     */
    constructor(grid, resolver, viewRef) {
        this.grid = grid;
        this.resolver = resolver;
        this.viewRef = viewRef;
        this._options = {
            columns: true,
            filtering: true,
            advancedFiltering: true,
            sorting: true,
            groupBy: true,
            paging: true,
            cellSelection: true,
            rowSelection: true,
            columnSelection: true,
            rowPinning: true
        };
    }
    /**
     *  An object with options determining if a certain feature state should be saved.
     *
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * public options = {selection: false, advancedFiltering: false};
     * ```
     */
    get options() {
        return this._options;
    }
    set options(value) {
        Object.assign(this._options, value);
    }
    /**
     * Gets the state of a feature or states of all grid features, unless a certain feature is disabled through the `options` property.
     * @param `serialize` determines whether the returned object will be serialized to JSON string. Default value is false.
     * @param `feature` string or array of strings determining the features which state to retrieve. If skipped, returns all.
     * @returns Returns the serialized to JSON string IGridState object, or the non-serialized IGridState object.
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * let state =  this.state.getState();
     * ```
     */
    getState(serialize = true, feature) {
        let state;
        if (feature) {
            state = {};
            if (Array.isArray(feature)) {
                feature.forEach(f => {
                    state = Object.assign(state, this.getGridFeature(f));
                });
            }
            else {
                state = this.getGridFeature(feature);
            }
        }
        else {
            state = this.getAllGridFeatures();
        }
        if (serialize) {
            state = JSON.stringify(state, this.stringifyCallback);
            return state;
        }
        else {
            return state;
        }
    }
    /**
     * Restores grid features' state based on the IGridState object passed as an argument.
     * @param IGridState object to restore state from.
     * @returns
     * ```html
     * <igx-grid [igxGridState]="options"></igx-grid>
     * ```
     * ```typescript
     * @ViewChild(IgxGridStateDirective, { static: true }) public state;
     * this.state.setState(gridState);
     * ```
     */
    setState(state) {
        if (typeof state === 'string') {
            state = JSON.parse(state);
        }
        this.state = state;
        this.restoreGridState();
        this.grid.cdr.detectChanges();
    }
    /**
     * The method that calls corresponding methods to restore feature from this.state object.
     */
    restoreGridState() {
        for (const key of Object.keys(this.state)) {
            if (this.state[key]) {
                this.restoreFeature(key, this.state[key]);
            }
        }
    }
    /**
     * Restores the state of a feature.
     */
    restoreFeature(feature, state) {
        switch (feature) {
            case COLUMNS: {
                this.restoreColumns(state);
                break;
            }
            case FILTERING: {
                this.restoreFiltering(state);
                break;
            }
            case ADVANCED_FILTERING: {
                this.restoreAdvancedFiltering(state);
                break;
            }
            case SORTING: {
                this.restoreSorting(state);
                break;
            }
            case GROUPBY: {
                this.restoreGroupBy(state);
                break;
            }
            case PAGING: {
                this.restorePaging(state);
                break;
            }
            case ROW_SELECTION: {
                this.restoreRowSelection(state);
                break;
            }
            case ROW_PINNING: {
                this.restoreRowPinning(state);
                break;
            }
            case PINNING_CONFIG: {
                this.restorePinningConfig(state);
                break;
            }
            case CELL_SELECTION: {
                this.restoreCellSelection(state);
                break;
            }
            case COLUMN_SELECTION: {
                this.restoreColumnSelection(state);
                break;
            }
        }
    }
    /**
     * Returns an object containing all grid features state.
     */
    getAllGridFeatures() {
        let gridState = {};
        for (const key of Object.keys(this.options)) {
            if (this.options[key]) {
                const feature = this.getGridFeature(key);
                gridState = Object.assign(gridState, feature);
            }
        }
        gridState = Object.assign({}, gridState);
        return gridState;
    }
    /**
     * Restores an object containing the state for a grid feature.
     * `serialize` param determines whether the returned object will be serialized to a JSON string. Default value is false.,
     */
    getGridFeature(feature) {
        const state = {};
        switch (feature) {
            case COLUMNS: {
                Object.assign(state, this.getColumns());
                break;
            }
            case FILTERING: {
                Object.assign(state, this.getFiltering());
                break;
            }
            case ADVANCED_FILTERING: {
                Object.assign(state, this.getAdvancedFiltering());
                break;
            }
            case SORTING: {
                Object.assign(state, this.getSorting());
                break;
            }
            case GROUPBY: {
                Object.assign(state, this.getGroupBy());
                break;
            }
            case PAGING: {
                Object.assign(state, this.getPaging());
                break;
            }
            case ROW_SELECTION: {
                Object.assign(state, this.getRowSelection());
                break;
            }
            case ROW_PINNING: {
                Object.assign(state, this.getRowPinning());
                break;
            }
            case PINNING_CONFIG: {
                Object.assign(state, this.getPinningConfig());
                break;
            }
            case CELL_SELECTION: {
                Object.assign(state, this.getCellSelection());
                break;
            }
            case COLUMN_SELECTION: {
                Object.assign(state, this.getColumnSelection());
                break;
            }
        }
        return state;
    }
    /**
     * Helper method that creates a new array with the current grid columns.
     */
    getColumns() {
        const gridColumns = this.grid.columns.sort(this.sortByVisibleIndex).map((c) => {
            return {
                pinned: c.pinned,
                sortable: c.sortable,
                filterable: c.filterable,
                editable: c.editable,
                sortingIgnoreCase: c.sortingIgnoreCase,
                filteringIgnoreCase: c.filteringIgnoreCase,
                headerClasses: c.headerClasses,
                headerGroupClasses: c.headerGroupClasses,
                maxWidth: c.maxWidth,
                groupable: c.groupable,
                movable: c.movable,
                hidden: c.hidden,
                dataType: c.dataType,
                hasSummary: c.hasSummary,
                field: c.field,
                width: c.width,
                header: c.header,
                resizable: c.resizable,
                searchable: c.searchable
            };
        });
        return { columns: gridColumns };
    }
    getFiltering() {
        const filteringState = this.grid.filteringExpressionsTree;
        return { filtering: filteringState };
    }
    getAdvancedFiltering() {
        const advancedFiltering = this.grid.advancedFilteringExpressionsTree;
        return { advancedFiltering: advancedFiltering };
    }
    getPaging() {
        const pagingState = this.grid.pagingState;
        return { paging: pagingState };
    }
    getSorting() {
        const sortingState = this.grid.sortingExpressions;
        sortingState.forEach(s => {
            delete s.strategy;
        });
        return { sorting: sortingState };
    }
    getGroupBy() {
        const groupingExpressions = this.grid.groupingExpressions;
        groupingExpressions.forEach(expr => {
            delete expr.strategy;
        });
        const expansionState = this.grid.groupingExpansionState;
        const groupsExpanded = this.grid.groupsExpanded;
        return { groupBy: { expressions: groupingExpressions, expansion: expansionState, defaultExpanded: groupsExpanded } };
    }
    getRowSelection() {
        const selection = this.grid.selectedRows();
        return { rowSelection: selection };
    }
    getRowPinning() {
        const pinned = this.grid.pinnedRows.map(x => x.rowID);
        return { rowPinning: pinned };
    }
    getPinningConfig() {
        return { pinningConfig: this.grid.pinning };
    }
    getColumnSelection() {
        const selection = this.grid.selectedColumns().map(c => c.field);
        return { columnSelection: selection };
    }
    getCellSelection() {
        const selection = this.grid.getSelectedRanges().map(range => {
            return { rowStart: range.rowStart, rowEnd: range.rowEnd, columnStart: range.columnStart, columnEnd: range.columnEnd };
        });
        return { cellSelection: selection };
    }
    /**
     * Restores the grid columns by modifying the `columnList` collection of the grid.
     */
    restoreColumns(columnsState) {
        const newColumns = [];
        const factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
        columnsState.forEach((colState) => {
            const ref = factory.create(this.viewRef.injector);
            Object.assign(ref.instance, colState);
            ref.changeDetectorRef.detectChanges();
            newColumns.push(ref.instance);
        });
        this.grid.columnList.reset(newColumns);
        this.grid.columnList.notifyOnChanges();
    }
    sortByVisibleIndex(colA, colB) {
        const a = colA.visibleIndex, b = colB.visibleIndex;
        return a > b ? 1 : a < b ? -1 : 0;
    }
    /**
     * Restores the grid filtering state, i.e. sets the `filteringExpressionsTree` property value.
     */
    restoreFiltering(state) {
        const filterTree = this.createExpressionsTreeFromObject(state);
        this.grid.filteringExpressionsTree = filterTree;
    }
    /**
     * Restores the grid advanced filtering state, i.e. sets the `advancedFilteringExpressionsTree` property value.
     */
    restoreAdvancedFiltering(state) {
        const advFilterTree = this.createExpressionsTreeFromObject(state);
        this.grid.advancedFilteringExpressionsTree = advFilterTree;
    }
    /**
     * Restores the grid sorting state, i.e. sets the `sortingExpressions` property value.
     */
    restoreSorting(state) {
        this.grid.sortingExpressions = state;
    }
    /**
     * Restores the grid grouping state, i.e. sets the `groupbyExpressions` property value.
     */
    restoreGroupBy(state) {
        this.grid.groupingExpressions = state.expressions;
        if (this.grid.groupsExpanded !== state.defaultExpanded) {
            this.grid.toggleAllGroupRows();
        }
        else {
            this.grid.groupingExpansionState = state.expansion;
        }
    }
    /**
     * Restores the grid paging state, i.e. sets the `perPage` property value and paginate to index.
     */
    restorePaging(state) {
        if (this.grid.perPage !== state.recordsPerPage) {
            this.grid.perPage = state.recordsPerPage;
            this.grid.cdr.detectChanges();
        }
        this.grid.page = state.index;
    }
    restoreRowSelection(state) {
        this.grid.selectRows(state);
    }
    restoreRowPinning(state) {
        // clear current state.
        this.grid.pinnedRows.forEach(row => row.unpin());
        state.forEach(rowID => this.grid.pinRow(rowID));
    }
    restorePinningConfig(state) {
        this.grid.pinning = state;
    }
    restoreColumnSelection(state) {
        this.grid.selectColumns(state);
    }
    restoreCellSelection(state) {
        state.forEach(r => {
            const range = { rowStart: r.rowStart, rowEnd: r.rowEnd, columnStart: r.columnStart, columnEnd: r.columnEnd };
            this.grid.selectRange(range);
        });
    }
    /**
     * This method builds a FilteringExpressionsTree from a provided object.
     */
    createExpressionsTreeFromObject(exprTreeObject) {
        if (!exprTreeObject || !exprTreeObject.filteringOperands) {
            return null;
        }
        const expressionsTree = new FilteringExpressionsTree(exprTreeObject.operator, exprTreeObject.fieldName);
        for (const item of exprTreeObject.filteringOperands) {
            // Check if item is an expressions tree or a single expression.
            if (item.filteringOperands) {
                const subTree = this.createExpressionsTreeFromObject(item);
                expressionsTree.filteringOperands.push(subTree);
            }
            else {
                const expr = item;
                let dataType;
                if (this.grid.columnList.length > 0) {
                    dataType = this.grid.columnList.find(c => c.field === expr.fieldName).dataType;
                }
                else {
                    dataType = this.state[COLUMNS].find(c => c.field === expr.fieldName).dataType;
                }
                // when ESF, values are stored in Set.
                // First those values are converted to an array before returning string in the stringifyCallback
                // now we need to convert those back to Set
                if (Array.isArray(expr.searchVal)) {
                    expr.searchVal = new Set(expr.searchVal);
                }
                else {
                    expr.searchVal = (dataType === 'date') ? new Date(Date.parse(expr.searchVal)) : expr.searchVal;
                }
                expr.condition = this.generateFilteringCondition(dataType, expr.condition.name);
                expressionsTree.filteringOperands.push(expr);
            }
        }
        return expressionsTree;
    }
    /**
     * Returns the filtering logic function for a given dataType and condition (contains, greaterThan, etc.)
     */
    generateFilteringCondition(dataType, name) {
        let filters;
        switch (dataType) {
            case DataType.Boolean:
                filters = IgxBooleanFilteringOperand.instance();
                break;
            case DataType.Number:
                filters = IgxNumberFilteringOperand.instance();
                break;
            case DataType.Date:
                filters = IgxDateFilteringOperand.instance();
                break;
            case DataType.String:
            default:
                filters = IgxStringFilteringOperand.instance();
                break;
        }
        return filters.condition(name);
    }
    stringifyCallback(key, val) {
        if (key === 'searchVal' && val instanceof Set) {
            return Array.from(val);
        }
        return val;
    }
};
IgxGridStateDirective.ɵfac = function IgxGridStateDirective_Factory(t) { return new (t || IgxGridStateDirective)(ɵngcc0.ɵɵdirectiveInject(IgxGridComponent, 9), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
IgxGridStateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridStateDirective, selectors: [["", "igxGridState", ""]], inputs: { options: ["igxGridState", "options"] } });
IgxGridStateDirective.ctorParameters = () => [
    { type: IgxGridComponent, decorators: [{ type: Host }, { type: Optional }] },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
__decorate([
    Input('igxGridState')
], IgxGridStateDirective.prototype, "options", null);
IgxGridStateDirective = __decorate([ __param(0, Host()), __param(0, Optional())
], IgxGridStateDirective);
/**
 * @hidden
 */
let IgxGridStateModule = class IgxGridStateModule {
};
IgxGridStateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridStateModule });
IgxGridStateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridStateModule_Factory(t) { return new (t || IgxGridStateModule)(); } });

let IgxGridSharedModules = class IgxGridSharedModules {
};
IgxGridSharedModules.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridSharedModules });
IgxGridSharedModules.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridSharedModules_Factory(t) { return new (t || IgxGridSharedModules)(); }, imports: [[
            CommonModule,
            FormsModule,
            IgxButtonModule,
            IgxDatePickerModule,
            IgxIconModule,
            IgxRippleModule,
            IgxInputGroupModule,
            IgxFocusModule,
            IgxToggleModule,
            IgxForOfModule,
            IgxTemplateOutletModule,
            IgxTextHighlightModule,
            IgxTextSelectionModule,
            IgxCheckboxModule,
            IgxBadgeModule,
            IgxChipsModule,
            IgxDragDropModule,
            IgxDropDownModule,
            IgxButtonGroupModule,
            IgxProgressBarModule,
            IgxSelectModule,
            IgxGridStateModule
        ],
        CommonModule,
        FormsModule,
        IgxButtonModule,
        IgxDatePickerModule,
        IgxIconModule,
        IgxRippleModule,
        IgxInputGroupModule,
        IgxFocusModule,
        IgxToggleModule,
        IgxForOfModule,
        IgxTemplateOutletModule,
        IgxTextHighlightModule,
        IgxGridStateModule,
        IgxTextSelectionModule,
        IgxCheckboxModule,
        IgxBadgeModule,
        IgxChipsModule,
        IgxDragDropModule,
        IgxDropDownModule,
        IgxButtonGroupModule,
        IgxProgressBarModule,
        IgxSelectModule] });

let IgxSummaryDataPipe = class IgxSummaryDataPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(id, trigger = 0) {
        const summaryService = this.gridAPI.grid.summaryService;
        return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
    }
};
IgxSummaryDataPipe.ɵfac = function IgxSummaryDataPipe_Factory(t) { return new (t || IgxSummaryDataPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxSummaryDataPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "igxGridSummaryDataPipe", type: IgxSummaryDataPipe, pure: true });
IgxSummaryDataPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

let IgxGridSummaryModule = class IgxGridSummaryModule {
};
IgxGridSummaryModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridSummaryModule });
IgxGridSummaryModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridSummaryModule_Factory(t) { return new (t || IgxGridSummaryModule)(); }, imports: [[
            IgxGridPipesModule,
            IgxGridSharedModules
        ]] });

let IgxColumnHidingModule = class IgxColumnHidingModule {
};
IgxColumnHidingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnHidingModule });
IgxColumnHidingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnHidingModule_Factory(t) { return new (t || IgxColumnHidingModule)(); }, imports: [[
            IgxGridSharedModules
        ]] });

let IgxColumnPinningModule = class IgxColumnPinningModule {
};
IgxColumnPinningModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxColumnPinningModule });
IgxColumnPinningModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxColumnPinningModule_Factory(t) { return new (t || IgxColumnPinningModule)(); }, imports: [[
            IgxGridSharedModules
        ]] });

let IgxGridToolbarModule = class IgxGridToolbarModule {
};
IgxGridToolbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridToolbarModule });
IgxGridToolbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridToolbarModule_Factory(t) { return new (t || IgxGridToolbarModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxColumnHidingModule,
            IgxColumnPinningModule
        ]] });

var IgxColumnLayoutComponent_1;
let IgxColumnLayoutComponent = IgxColumnLayoutComponent_1 = class IgxColumnLayoutComponent extends IgxColumnGroupComponent {
    constructor() {
        super(...arguments);
        this.childrenVisibleIndexes = [];
    }
    /**
     * Gets the width of the column layout.
     * ```typescript
     * let columnGroupWidth = this.columnGroup.width;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get width() {
        const width = this.getFilledChildColumnSizes(this.children).reduce((acc, val) => acc + parseInt(val, 10), 0);
        return width;
    }
    set width(val) { }
    get columnLayout() {
        return true;
    }
    /**
     * @hidden
     */
    getCalcWidth() {
        let borderWidth = 0;
        if (this.headerGroup && this.headerGroup.hasLastPinnedChildColumn) {
            const headerStyles = this.grid.document.defaultView.getComputedStyle(this.headerGroup.element.nativeElement.children[0]);
            borderWidth = parseInt(headerStyles.borderRightWidth, 10);
        }
        return super.getCalcWidth() + borderWidth;
    }
    /**
     * Gets the column visible index.
     * If the column is not visible, returns `-1`.
     * ```typescript
     * let visibleColumnIndex =  this.column.visibleIndex;
     * ```
     * @memberof IgxColumnComponent
     */
    get visibleIndex() {
        if (!isNaN(this._vIndex)) {
            return this._vIndex;
        }
        const unpinnedColumns = this.grid.unpinnedColumns.filter(c => c.columnLayout && !c.hidden);
        const pinnedColumns = this.grid.pinnedColumns.filter(c => c.columnLayout && !c.hidden);
        let vIndex = -1;
        if (!this.pinned) {
            const indexInCollection = unpinnedColumns.indexOf(this);
            vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
        }
        else {
            vIndex = pinnedColumns.indexOf(this);
        }
        this._vIndex = vIndex;
        return vIndex;
    }
    /*
     * Gets whether the column layout is hidden.
     * ```typescript
     * let isHidden = this.columnGroup.hidden;
     * ```
     * @memberof IgxColumnGroupComponent
     */
    get hidden() {
        return this._hidden;
    }
    /**
     * Sets the column layout hidden property.
     * ```typescript
     * <igx-column-layout [hidden] = "true"></igx-column->
     * ```
     * @memberof IgxColumnGroupComponent
     */
    set hidden(value) {
        this._hidden = value;
        this.children.forEach(child => child.hidden = value);
        if (this.grid && this.grid.columns && this.grid.columns.length > 0) {
            // reset indexes in case columns are hidden/shown runtime
            this.grid.columns.filter(x => x.columnGroup).forEach(x => x.populateVisibleIndexes());
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (!this.hidden) {
            this.hidden = this.allChildren.some(x => x.hidden);
        }
        else {
            this.children.forEach(child => child.hidden = this.hidden);
        }
        this.children.forEach(child => {
            child.movable = false;
        });
    }
    /*
     * Gets whether the group contains the last pinned child column of the column layout.
     * ```typescript
     * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
     * ```
     * @memberof IgxColumnLayoutComponent
     */
    get hasLastPinnedChildColumn() {
        return this.children.some(child => child.isLastPinned);
    }
    /*
     * Gets whether the group contains the first pinned child column of the column layout.
     * ```typescript
     * let hasFirstPinnedChildColumn = this.columnLayout.hasFirstPinnedChildColumn;
     * ```
     * @memberof IgxColumnLayoutComponent
     */
    get hasFirstPinnedChildColumn() {
        return this.children.some(child => child.isFirstPinned);
    }
    /**
     * @hidden
     */
    populateVisibleIndexes() {
        this.childrenVisibleIndexes = [];
        const grid = this.gridAPI.grid;
        const columns = grid && grid.pinnedColumns && grid.unpinnedColumns ? grid.pinnedColumns.concat(grid.unpinnedColumns) : [];
        const orderedCols = columns
            .filter(x => !x.columnGroup && !x.hidden)
            .sort((a, b) => a.rowStart - b.rowStart || columns.indexOf(a.parent) - columns.indexOf(b.parent) || a.colStart - b.colStart);
        this.children.forEach(child => {
            const rs = child.rowStart || 1;
            let vIndex = 0;
            // filter out all cols with larger rowStart
            const cols = orderedCols.filter(c => !c.columnGroup && (c.rowStart || 1) <= rs);
            vIndex = cols.indexOf(child);
            this.childrenVisibleIndexes.push({ column: child, index: vIndex });
        });
    }
};
IgxColumnLayoutComponent.ɵfac = function IgxColumnLayoutComponent_Factory(t) { return ɵIgxColumnLayoutComponent_BaseFactory(t || IgxColumnLayoutComponent); };
IgxColumnLayoutComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxColumnLayoutComponent, selectors: [["igx-column-layout"]], inputs: { hidden: "hidden" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnLayoutComponent_1) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IgxColumnLayoutComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input()
], IgxColumnLayoutComponent.prototype, "hidden", null);

let IgxGridColumnModule = class IgxGridColumnModule {
};
IgxGridColumnModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridColumnModule });
IgxGridColumnModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridColumnModule_Factory(t) { return new (t || IgxGridColumnModule)(); } });

let IgxGridFilteringModule = class IgxGridFilteringModule {
};
IgxGridFilteringModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridFilteringModule });
IgxGridFilteringModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridFilteringModule_Factory(t) { return new (t || IgxGridFilteringModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxGridPipesModule
        ]] });

let IgxGridHeadersModule = class IgxGridHeadersModule {
};
IgxGridHeadersModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridHeadersModule });
IgxGridHeadersModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridHeadersModule_Factory(t) { return new (t || IgxGridHeadersModule)(); }, imports: [[
            IgxGridSharedModules,
            IgxGridFilteringModule,
            IgxColumnMovingModule,
            IgxGridResizingModule
        ]] });

/**
 * @hidden
 */
let IgxGridCommonModule = class IgxGridCommonModule {
};
IgxGridCommonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridCommonModule });
IgxGridCommonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridCommonModule_Factory(t) { return new (t || IgxGridCommonModule)(); }, providers: [
        { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
    ], imports: [[
            IgxGridColumnModule,
            IgxGridHeadersModule,
            IgxColumnMovingModule,
            IgxGridResizingModule,
            IgxColumnPinningModule,
            IgxGridSelectionModule,
            IgxGridSummaryModule,
            IgxGridToolbarModule,
            IgxColumnHidingModule,
            IgxGridPipesModule,
            IgxGridFilteringModule,
            IgxGridExcelStyleFilteringModule,
            IgxRowDragModule,
            IgxPaginatorModule,
            IgxGridSharedModules
        ],
        IgxColumnHidingModule,
        IgxColumnPinningModule,
        IgxGridColumnModule,
        IgxGridHeadersModule,
        IgxGridPipesModule,
        IgxGridFilteringModule,
        IgxGridExcelStyleFilteringModule,
        IgxRowDragModule,
        IgxPaginatorModule,
        IgxGridResizingModule,
        IgxColumnMovingModule,
        IgxGridSelectionModule,
        IgxGridSummaryModule,
        IgxGridToolbarModule,
        IgxGridSharedModules] });

let IgxGridActionsBaseDirective = class IgxGridActionsBaseDirective {
    constructor(strip) {
        this.strip = strip;
    }
    /**
     * Getter to be used in template
     * @hidden
     * @internal
     */
    get isRowContext() {
        return this.isRow(this.strip.context);
    }
    /**
     * Check if the param is a row from a grid
     * @hidden
     * @internal
     * @param context
     */
    isRow(context) {
        return context && context instanceof IgxRowDirective;
    }
};
IgxGridActionsBaseDirective.ɵfac = function IgxGridActionsBaseDirective_Factory(t) { return new (t || IgxGridActionsBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxActionStripComponent)); };
IgxGridActionsBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxGridActionsBaseDirective, selectors: [["", "igxGridActionsBase", ""]] });
IgxGridActionsBaseDirective.ctorParameters = () => [
    { type: IgxActionStripComponent, decorators: [{ type: Inject, args: [IgxActionStripComponent,] }] }
];
IgxGridActionsBaseDirective = __decorate([ __param(0, Inject(IgxActionStripComponent))
], IgxGridActionsBaseDirective);

var IgxGridEditingActionsComponent_1;
let IgxGridEditingActionsComponent = IgxGridEditingActionsComponent_1 = class IgxGridEditingActionsComponent extends IgxGridActionsBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Host `class.igx-action-strip` binding.
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-action-strip__editing-actions';
        this.isMessageShown = false;
    }
    /**
     * Enter row or cell edit mode depending the grid rowEditable option
     * @example
     * ```typescript
     * this.gridEditingActions.startEdit();
     * ```
     */
    startEdit(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const firstEditable = row.cells.filter(cell => cell.editable)[0];
        const grid = row.grid;
        if (!grid.hasEditableColumns) {
            this.isMessageShown = showMessage('The grid should be editable in order to use IgxGridEditingActionsComponent', this.isMessageShown);
            return;
        }
        // be sure row is in view
        if (grid.rowList.filter(r => r === row).length !== 0) {
            grid.crudService.begin(firstEditable);
        }
        this.strip.hide();
    }
    /**
     * Delete a row according to the context
     * @example
     * ```typescript
     * this.gridEditingActions.deleteRow();
     * ```
     */
    deleteRow(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        grid.deleteRow(context.rowID);
        this.strip.hide();
    }
    /**
     * Getter if the row is disabled
     * @hidden
     * @internal
     */
    get disabled() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        return this.strip.context.disabled;
    }
};
IgxGridEditingActionsComponent.ɵfac = function IgxGridEditingActionsComponent_Factory(t) { return ɵIgxGridEditingActionsComponent_BaseFactory(t || IgxGridEditingActionsComponent); };
IgxGridEditingActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridEditingActionsComponent, selectors: [["igx-grid-editing-actions"]], hostVars: 2, hostBindings: function IgxGridEditingActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-action-strip__editing-actions", ctx.cssClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridEditingActionsComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["igxButton", "icon", "igxRipple", "", 3, "disabled", "click"], ["igxButton", "icon", "igxRipple", "", 1, "igx-action-strip__delete", 3, "disabled", "click"]], template: function IgxGridEditingActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridEditingActionsComponent_ng_container_0_Template, 7, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRowContext);
    } }, directives: [ɵngcc2.NgIf, IgxButtonDirective,
        IgxRippleDirective,
        IgxIconComponent], encapsulation: 2 });
__decorate([
    HostBinding('class.igx-action-strip__editing-actions')
], IgxGridEditingActionsComponent.prototype, "cssClass", void 0);

var IgxGridPinningActionsComponent_1;
let IgxGridPinningActionsComponent = IgxGridPinningActionsComponent_1 = class IgxGridPinningActionsComponent extends IgxGridActionsBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * Host `class.igx-action-strip` binding.
         * @hidden
         * @internal
         */
        this.cssClass = 'igx-action-strip__pining-actions';
        this.iconsRendered = false;
    }
    /**
     * Getter to know if the row is pinned
     * @hidden
     * @internal
     */
    get pinned() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        if (context && !this.iconsRendered) {
            this.renderIcons();
            this.iconsRendered = true;
        }
        return context && context.pinned;
    }
    /**
     * Getter to know if the row is in pinned and ghost
     * @hidden
     * @internal
     */
    get inPinnedArea() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        return this.pinned && !context.disabled;
    }
    /**
     * Getter to know if the row pinning is set to top or bottom
     * @hidden
     * @internal
     */
    get pinnedTop() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        return this.strip.context.grid.isRowPinningToTop;
    }
    /**
     * Pin the row according to the context.
     * @example
     * ```typescript
     * this.gridPinningActions.pin();
     * ```
     */
    pin(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const grid = row.grid;
        grid.pinRow(row.rowID);
        this.strip.hide();
    }
    /**
     * Unpin the row according to the context.
     * @example
     * ```typescript
     * this.gridPinningActions.unpin();
     * ```
     */
    unpin(event) {
        if (event) {
            event.stopPropagation();
        }
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const row = this.strip.context;
        const grid = row.grid;
        grid.unpinRow(row.rowID);
        this.strip.hide();
    }
    scrollToRow(event) {
        if (event) {
            event.stopPropagation();
        }
        const context = this.strip.context;
        const grid = context.grid;
        grid.scrollTo(context.rowData, 0);
        this.strip.hide();
    }
    renderIcons() {
        if (!this.isRow(this.strip.context)) {
            return;
        }
        const context = this.strip.context;
        const grid = context.grid;
        if (grid) {
            grid.filteringService.registerSVGIcons();
        }
    }
};
IgxGridPinningActionsComponent.ɵfac = function IgxGridPinningActionsComponent_Factory(t) { return ɵIgxGridPinningActionsComponent_BaseFactory(t || IgxGridPinningActionsComponent); };
IgxGridPinningActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridPinningActionsComponent, selectors: [["igx-grid-pinning-actions"]], hostVars: 2, hostBindings: function IgxGridPinningActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-action-strip__pining-actions", ctx.cssClass);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridPinningActionsComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 1, consts: [[4, "ngIf"], ["igxRipple", "", "igxButton", "icon", 3, "click", 4, "ngIf"], ["igxRipple", "", "igxButton", "icon", 3, "click"], ["fontSet", "filtering-icons", "name", "jump_down"], ["fontSet", "filtering-icons", "name", "jump_up"], ["fontSet", "filtering-icons", "name", "pin"], ["fontSet", "filtering-icons", "name", "unpin"]], template: function IgxGridPinningActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridPinningActionsComponent_ng_container_0_Template, 5, 4, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRowContext);
    } }, directives: [ɵngcc2.NgIf, IgxRippleDirective,
        IgxButtonDirective,
        IgxIconComponent], encapsulation: 2 });
__decorate([
    HostBinding('class.igx-action-strip__pining-actions')
], IgxGridPinningActionsComponent.prototype, "cssClass", void 0);

/**
 * @hidden
 */
let IgxActionStripModule = class IgxActionStripModule {
};
IgxActionStripModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxActionStripModule });
IgxActionStripModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxActionStripModule_Factory(t) { return new (t || IgxActionStripModule)(); }, imports: [[CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]] });

/** @hidden */
const IGX_EXPANSION_PANEL_COMPONENT = new InjectionToken('IgxExpansionPanelToken');

let IgxExpansionPanelBodyComponent = class IgxExpansionPanelBodyComponent {
    constructor(panel, element, cdr) {
        this.panel = panel;
        this.element = element;
        this.cdr = cdr;
        this._labelledBy = '';
        this._label = '';
        /**
         * @hidden
         */
        this.cssClass = `igx-expansion-panel__body`;
        /**
         * Gets/sets the `role` attribute of the panel body
         * Default is 'region';
         * Get
         * ```typescript
         *  const currentRole = this.panel.body.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.body.role = 'content';
         * ```
         * ```html
         *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
         * ```
         */
        this.role = 'region';
    }
    /**
     * Gets the `aria-label` attribute of the panel body
     * Defaults to the panel id with '-region' in the end;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.label;
     * ```
     */
    get label() {
        return this._label || this.panel.id + '-region';
    }
    /**
     * Sets the `aria-label` attribute of the panel body
     * ```typescript
     *  this.panel.body.label = 'my-custom-label';
     * ```
     * ```html
     *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
     * ```
     */
    set label(val) {
        this._label = val;
    }
    /**
     * Gets the `aria-labelledby` attribute of the panel body
     * Defaults to the panel header id;
     * Get
     * ```typescript
     *  const currentLabel = this.panel.body.labelledBy;
     * ```
     */
    get labelledBy() {
        return this._labelledBy;
    }
    /**
     * Sets the `aria-labelledby` attribute of the panel body
     * ```typescript
     *  this.panel.body.labelledBy = 'my-custom-id';
     * ```
     * ```html
     *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
     * ```
     */
    set labelledBy(val) {
        this._labelledBy = val;
    }
};
IgxExpansionPanelBodyComponent.ɵfac = function IgxExpansionPanelBodyComponent_Factory(t) { return new (t || IgxExpansionPanelBodyComponent)(ɵngcc0.ɵɵdirectiveInject(IGX_EXPANSION_PANEL_COMPONENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxExpansionPanelBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExpansionPanelBodyComponent, selectors: [["igx-expansion-panel-body"]], hostVars: 5, hostBindings: function IgxExpansionPanelBodyComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-label", ctx.label)("aria-labelledby", ctx.labelledBy);
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__body", ctx.cssClass);
    } }, inputs: { role: "role", label: "label", labelledBy: "labelledBy" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxExpansionPanelBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxExpansionPanelBodyComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    HostBinding('class.igx-expansion-panel__body')
], IgxExpansionPanelBodyComponent.prototype, "cssClass", void 0);
__decorate([
    Input(),
    HostBinding('attr.aria-label')
], IgxExpansionPanelBodyComponent.prototype, "label", null);
__decorate([
    Input(),
    HostBinding('attr.aria-labelledby')
], IgxExpansionPanelBodyComponent.prototype, "labelledBy", null);
__decorate([
    Input(),
    HostBinding('attr.role')
], IgxExpansionPanelBodyComponent.prototype, "role", void 0);
IgxExpansionPanelBodyComponent = __decorate([ __param(0, Inject(IGX_EXPANSION_PANEL_COMPONENT))
], IgxExpansionPanelBodyComponent);

/**
 * @hidden
 */
let IgxExpansionPanelTitleDirective = class IgxExpansionPanelTitleDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-title`;
    }
};
IgxExpansionPanelTitleDirective.ɵfac = function IgxExpansionPanelTitleDirective_Factory(t) { return new (t || IgxExpansionPanelTitleDirective)(); };
IgxExpansionPanelTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExpansionPanelTitleDirective, selectors: [["igx-expansion-panel-title"]], hostVars: 2, hostBindings: function IgxExpansionPanelTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__header-title", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-expansion-panel__header-title')
], IgxExpansionPanelTitleDirective.prototype, "cssClass", void 0);
/**
 * @hidden
 */
let IgxExpansionPanelDescriptionDirective = class IgxExpansionPanelDescriptionDirective {
    constructor() {
        this.cssClass = `igx-expansion-panel__header-description`;
    }
};
IgxExpansionPanelDescriptionDirective.ɵfac = function IgxExpansionPanelDescriptionDirective_Factory(t) { return new (t || IgxExpansionPanelDescriptionDirective)(); };
IgxExpansionPanelDescriptionDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExpansionPanelDescriptionDirective, selectors: [["igx-expansion-panel-description"]], hostVars: 2, hostBindings: function IgxExpansionPanelDescriptionDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__header-description", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-expansion-panel__header-description')
], IgxExpansionPanelDescriptionDirective.prototype, "cssClass", void 0);
/**
 * @hidden
 */
let IgxExpansionPanelIconDirective = class IgxExpansionPanelIconDirective {
};
IgxExpansionPanelIconDirective.ɵfac = function IgxExpansionPanelIconDirective_Factory(t) { return new (t || IgxExpansionPanelIconDirective)(); };
IgxExpansionPanelIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxExpansionPanelIconDirective, selectors: [["igx-expansion-panel-icon"]] });

/**
 * @hidden
 */
var ICON_POSITION;
(function (ICON_POSITION) {
    ICON_POSITION["LEFT"] = "left";
    ICON_POSITION["NONE"] = "none";
    ICON_POSITION["RIGHT"] = "right";
})(ICON_POSITION || (ICON_POSITION = {}));
let IgxExpansionPanelHeaderComponent = class IgxExpansionPanelHeaderComponent {
    constructor(panel, cdr, elementRef) {
        this.panel = panel;
        this.cdr = cdr;
        this.elementRef = elementRef;
        // properties section
        this._iconTemplate = false;
        /**
         * Sets/gets the `id` of the expansion panel header.
         * ```typescript
         * let panelHeaderId =  this.panel.header.id;
         * ```
         * @memberof IgxExpansionPanelComponent
         */
        this.id = '';
        /**
         * Gets/sets the `aria-level` attribute of the header
         * Get
         * ```typescript
         *  const currentAriaLevel = this.panel.header.lv;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.lv = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
         * ```
         */
        this.lv = '3';
        /**
         * Gets/sets the `role` attribute of the header
         * Get
         * ```typescript
         *  const currentRole = this.panel.header.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.role = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
         * ```
         */
        this.role = 'heading';
        /**
         * Gets/sets the position of the expansion-panel-header expand/collapse icon
         * Accepts `left`, `right` or `none`
         * ```typescript
         *  const currentIconPosition = this.panel.header.iconPosition;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.iconPosition = 'left';
         * ```
         * ```html
         *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
         * ```
         */
        this.iconPosition = ICON_POSITION.LEFT;
        /**
         * Emitted whenever a user interacts with the header host
         * ```typescript
         *  handleInteraction(event: IExpansionPanelEventArgs) {
         *  ...
         * }
         * ```
         * ```html
         *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
         *      ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.onInteraction = new EventEmitter();
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel__header';
        /**
         * Gets/sets the whether the header is disabled
         * When disabled, the header will not handle user events and will stop their propagation
         *
         * ```typescript
         *  const isDisabled = this.panel.header.disabled;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.disabled = true;
         * ```
         * ```html
         *  <igx-expansion-panel-header [disabled]="true">
         *     ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.disabled = false;
        this.id = `${this.panel.id}-header`;
    }
    /**
     * @hidden
     */
    set iconTemplate(val) {
        this._iconTemplate = val;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        return this._iconTemplate;
    }
    /**
     * @hidden
     */
    get controls() {
        return this.panel.id;
    }
    /**
     * @hidden
     */
    get isExpanded() {
        return !this.panel.collapsed;
    }
    /**
     * @hidden
     */
    onAction(evt) {
        if (this.disabled) {
            evt.stopPropagation();
            return;
        }
        this.onInteraction.emit({ event: evt, panel: this.panel });
        this.panel.toggle(evt);
        evt.preventDefault();
    }
    /** @hidden @internal */
    openPanel(event) {
        if (event.altKey) {
            this.panel.expand(event);
            this.onInteraction.emit({ event: event, panel: this.panel });
        }
    }
    /** @hidden @internal */
    closePanel(event) {
        if (event.altKey) {
            this.panel.collapse(event);
            this.onInteraction.emit({ event: event, panel: this.panel });
        }
    }
    /**
     * @hidden
     */
    get iconPositionClass() {
        switch (this.iconPosition) {
            case (ICON_POSITION.LEFT):
                return `igx-expansion-panel__header-icon--start`;
            case (ICON_POSITION.RIGHT):
                return `igx-expansion-panel__header-icon--end`;
            case (ICON_POSITION.NONE):
                return `igx-expansion-panel__header-icon--none`;
            default:
                return '';
        }
    }
};
IgxExpansionPanelHeaderComponent.ɵfac = function IgxExpansionPanelHeaderComponent_Factory(t) { return new (t || IgxExpansionPanelHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(IGX_EXPANSION_PANEL_COMPONENT, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxExpansionPanelHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExpansionPanelHeaderComponent, selectors: [["igx-expansion-panel-header"]], contentQueries: function IgxExpansionPanelHeaderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelIconDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
    } }, hostVars: 8, hostBindings: function IgxExpansionPanelHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.Enter", function IgxExpansionPanelHeaderComponent_keydown_Enter_HostBindingHandler($event) { return ctx.onAction($event); })("keydown.Space", function IgxExpansionPanelHeaderComponent_keydown_Space_HostBindingHandler($event) { return ctx.onAction($event); })("keydown.Spacebar", function IgxExpansionPanelHeaderComponent_keydown_Spacebar_HostBindingHandler($event) { return ctx.onAction($event); })("click", function IgxExpansionPanelHeaderComponent_click_HostBindingHandler($event) { return ctx.onAction($event); })("keydown.Alt.ArrowDown", function IgxExpansionPanelHeaderComponent_keydown_Alt_ArrowDown_HostBindingHandler($event) { return ctx.openPanel($event); })("keydown.Alt.ArrowUp", function IgxExpansionPanelHeaderComponent_keydown_Alt_ArrowUp_HostBindingHandler($event) { return ctx.closePanel($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-level", ctx.lv)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-expansion-panel__header", ctx.cssClass)("igx-expansion-panel--disabled", ctx.disabled)("igx-expansion-panel__header--expanded", ctx.isExpanded);
    } }, inputs: { lv: "lv", role: "role", iconPosition: "iconPosition", disabled: "disabled" }, outputs: { onInteraction: "onInteraction" }, ngContentSelectors: _c175, decls: 8, vars: 8, consts: [["tabindex", "0", "role", "button", 1, "igx-expansion-panel__header-inner"], [1, "igx-expansion-panel__title-wrapper"], [4, "ngIf"], ["fontSet", "material", 4, "ngIf"], ["fontSet", "material"]], template: function IgxExpansionPanelHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c174);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 2);
        ɵngcc0.ɵɵelementStart(5, "div");
        ɵngcc0.ɵɵtemplate(6, IgxExpansionPanelHeaderComponent_6_Template, 1, 0, undefined, 2);
        ɵngcc0.ɵɵtemplate(7, IgxExpansionPanelHeaderComponent_igx_icon_7_Template, 2, 1, "igx-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("aria-disabled", ctx.disabled)("aria-expanded", ctx.isExpanded)("aria-controls", ctx.controls);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵclassMap(ctx.iconPositionClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.iconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.iconTemplate);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent], encapsulation: 2 });
IgxExpansionPanelHeaderComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Host }, { type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
__decorate([
    ContentChild(IgxExpansionPanelIconDirective)
], IgxExpansionPanelHeaderComponent.prototype, "iconTemplate", null);
__decorate([
    HostBinding('attr.aria-level'),
    Input()
], IgxExpansionPanelHeaderComponent.prototype, "lv", void 0);
__decorate([
    HostBinding('attr.role'),
    Input()
], IgxExpansionPanelHeaderComponent.prototype, "role", void 0);
__decorate([
    Input()
], IgxExpansionPanelHeaderComponent.prototype, "iconPosition", void 0);
__decorate([
    Output()
], IgxExpansionPanelHeaderComponent.prototype, "onInteraction", void 0);
__decorate([
    HostBinding('class.igx-expansion-panel__header')
], IgxExpansionPanelHeaderComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-expansion-panel__header--expanded')
], IgxExpansionPanelHeaderComponent.prototype, "isExpanded", null);
__decorate([
    Input(),
    HostBinding('class.igx-expansion-panel--disabled')
], IgxExpansionPanelHeaderComponent.prototype, "disabled", void 0);
__decorate([
    HostListener('keydown.Enter', ['$event']),
    HostListener('keydown.Space', ['$event']),
    HostListener('keydown.Spacebar', ['$event']),
    HostListener('click', ['$event'])
], IgxExpansionPanelHeaderComponent.prototype, "onAction", null);
__decorate([
    HostListener('keydown.Alt.ArrowDown', ['$event'])
], IgxExpansionPanelHeaderComponent.prototype, "openPanel", null);
__decorate([
    HostListener('keydown.Alt.ArrowUp', ['$event'])
], IgxExpansionPanelHeaderComponent.prototype, "closePanel", null);
IgxExpansionPanelHeaderComponent = __decorate([ __param(0, Host()), __param(0, Inject(IGX_EXPANSION_PANEL_COMPONENT))
], IgxExpansionPanelHeaderComponent);

var IgxExpansionPanelComponent_1;
let NEXT_ID$j = 0;
let IgxExpansionPanelComponent = IgxExpansionPanelComponent_1 = class IgxExpansionPanelComponent {
    constructor(cdr, builder) {
        this.cdr = cdr;
        this.builder = builder;
        this._collapsed = true;
        /**
         * Sets/gets the animation settings of the expansion panel component
         * Open and Close animation should be passed
         *
         * Get
         * ```typescript
         *  const currentAnimations = this.panel.animationSettings;
         * ```
         * Set
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  this.panel.animationsSettings = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```
         * or via template
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  myCustomAnimationObject = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```html
         *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
         *  ...
         *  </igx-expansion-panel>
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /**
         * Sets/gets the `id` of the expansion panel component.
         * If not set, `id` will have value `"igx-expansion-panel-0"`;
         * ```html
         * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
         * ```
         * ```typescript
         * let panelId =  this.panel.id;
         * ```
         * @memberof IgxExpansionPanelComponent
         */
        this.id = `igx-expansion-panel-${NEXT_ID$j++}`;
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel';
        /**
         * @hidden
         */
        this.collapsedChange = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes collapsing
         * ```typescript
         *  handleCollapsed(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onCollapsed = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes expanding
         * ```typescript
         *  handleExpanded(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onExpanded = new EventEmitter();
    }
    /**
     * Gets/sets whether the component is collapsed (its content is hidden)
     * Get
     * ```typescript
     *  const myPanelState: boolean = this.panel.collapsed;
     * ```
     * Set
     * ```html
     *  this.panel.collapsed = true;
     * ```
     *
     * Two-way data binding:
     * ```html
     * <igx-expansion-panel [(collapsed)]="model.isCollapsed"></igx-expansion-panel>
     * ```
     */
    get collapsed() {
        return this._collapsed;
    }
    set collapsed(value) {
        this._collapsed = value;
        this.collapsedChange.emit(this._collapsed);
    }
    /**
     * @hidden
     */
    get headerId() {
        return this.header ? `${this.id}-header` : '';
    }
    /** @hidden */
    ngAfterContentInit() {
        if (this.body && this.header) {
            // schedule at end of turn:
            Promise.resolve().then(() => {
                this.body.labelledBy = this.body.labelledBy || this.headerId;
                this.body.label = this.body.label || this.id + '-region';
            });
        }
    }
    playOpenAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        const animation = useAnimation(this.animationSettings.openAnimation);
        const animationBuilder = this.builder.build(animation);
        const openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        openAnimationPlayer.onDone(() => {
            cb();
            openAnimationPlayer.reset();
        });
        openAnimationPlayer.play();
    }
    playCloseAnimation(cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        const animation = useAnimation(this.animationSettings.closeAnimation);
        const animationBuilder = this.builder.build(animation);
        const closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        closeAnimationPlayer.onDone(() => {
            cb();
            closeAnimationPlayer.reset();
        });
        closeAnimationPlayer.play();
    }
    /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     */
    collapse(evt) {
        if (this.collapsed) { // If expansion panel is already collapsed, do nothing
            return;
        }
        this.playCloseAnimation(() => {
            this.onCollapsed.emit({ event: evt, panel: this });
            this.collapsed = true;
        });
    }
    /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     */
    expand(evt) {
        if (!this.collapsed) { // If the panel is already opened, do nothing
            return;
        }
        this.collapsed = false;
        this.cdr.detectChanges();
        this.playOpenAnimation(() => {
            this.onExpanded.emit({ event: evt, panel: this });
        });
    }
    /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     */
    toggle(evt) {
        if (this.collapsed) {
            this.open(evt);
        }
        else {
            this.close(evt);
        }
    }
    open(evt) {
        this.expand(evt);
    }
    close(evt) {
        this.collapse(evt);
    }
};
IgxExpansionPanelComponent.ɵfac = function IgxExpansionPanelComponent_Factory(t) { return new (t || IgxExpansionPanelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder)); };
IgxExpansionPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxExpansionPanelComponent, selectors: [["igx-expansion-panel"]], contentQueries: function IgxExpansionPanelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelBodyComponent, true, IgxExpansionPanelBodyComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxExpansionPanelHeaderComponent, true, IgxExpansionPanelHeaderComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.body = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.header = _t.first);
    } }, hostVars: 3, hostBindings: function IgxExpansionPanelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-expansion-panel", ctx.cssClass);
    } }, inputs: { animationSettings: "animationSettings", id: "id", collapsed: "collapsed" }, outputs: { collapsedChange: "collapsedChange", onCollapsed: "onCollapsed", onExpanded: "onExpanded" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent_1 }])], ngContentSelectors: _c177, decls: 2, vars: 1, consts: [[4, "ngIf"]], template: function IgxExpansionPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c176);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxExpansionPanelComponent_1_Template, 1, 0, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
IgxExpansionPanelComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: AnimationBuilder }
];
__decorate([
    Input()
], IgxExpansionPanelComponent.prototype, "animationSettings", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxExpansionPanelComponent.prototype, "id", void 0);
__decorate([
    HostBinding('class.igx-expansion-panel')
], IgxExpansionPanelComponent.prototype, "cssClass", void 0);
__decorate([
    Input()
], IgxExpansionPanelComponent.prototype, "collapsed", null);
__decorate([
    Output()
], IgxExpansionPanelComponent.prototype, "collapsedChange", void 0);
__decorate([
    Output()
], IgxExpansionPanelComponent.prototype, "onCollapsed", void 0);
__decorate([
    Output()
], IgxExpansionPanelComponent.prototype, "onExpanded", void 0);
__decorate([
    ContentChild(IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent })
], IgxExpansionPanelComponent.prototype, "body", void 0);
__decorate([
    ContentChild(IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent })
], IgxExpansionPanelComponent.prototype, "header", void 0);

/**
 * @hidden
 */
let IgxExpansionPanelModule = class IgxExpansionPanelModule {
};
IgxExpansionPanelModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxExpansionPanelModule });
IgxExpansionPanelModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxExpansionPanelModule_Factory(t) { return new (t || IgxExpansionPanelModule)(); }, imports: [[
            CommonModule,
            IgxRippleModule,
            IgxIconModule,
            IgxButtonModule,
            IgxAvatarModule
        ]] });

// tslint:disable:directive-selector
let IgxBannerActionsDirective = class IgxBannerActionsDirective {
};
IgxBannerActionsDirective.ɵfac = function IgxBannerActionsDirective_Factory(t) { return new (t || IgxBannerActionsDirective)(); };
IgxBannerActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxBannerActionsDirective, selectors: [["igx-banner-actions"]] });

/**
 * **Ignite UI for Angular Banner** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
 *
 * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
 *
 * Usage:
 *
 * ```html
 * <igx-banner #banner>
 *   Our privacy settings have changed.
 *  <igx-banner-actions>
 *      <button igxButton="raised">Read More</button>
 *      <button igxButton="raised">Accept and Continue</button>
 *  </igx-banner-actions>
 * </igx-banner>
 * ```
 */
let IgxBannerComponent = class IgxBannerComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Fires after the banner shows up
         * ```typescript
         * public handleOpened(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Fires before the banner shows up
         * ```typescript
         * public handleOpening(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Fires after the banner hides
         * ```typescript
         * public handleClosed(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Fires before the banner hides
         * ```typescript
         * public handleClosing(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
         * ```
         */
        this.onClosing = new EventEmitter();
    }
    /** @hidden */
    get useDefaultTemplate() {
        return !this._bannerActionTemplate;
    }
    /**
     * Get the animation settings used by the banner open/close methods
     * ```typescript
     * let currentAnimations: AnimationSettings = banner.animationSettings
     * ```
     */
    get animationSettings() {
        return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
    }
    /**
     * Set the animation settings used by the banner open/close methods
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
     * ```
     */
    set animationSettings(settings) {
        this._animationSettings = settings;
    }
    /**
     * Gets whether banner is collapsed
     *
     * ```typescript
     * const isCollapsed: boolean = banner.collapsed;
     * ```
     */
    get collapsed() {
        return this._expansionPanel.collapsed;
    }
    /**
     * Returns the native element of the banner component
     * ```typescript
     *  const myBannerElement: HTMLElement = banner.element;
     * ```
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get displayStyle() {
        return this.collapsed ? '' : 'block';
    }
    /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     */
    open(event) {
        this._bannerEvent = { banner: this, event };
        const openingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onOpening.emit(openingArgs);
        if (openingArgs.cancel) {
            return;
        }
        this._expansionPanel.open(event);
    }
    /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     */
    close(event) {
        this._bannerEvent = { banner: this, event };
        const closingArgs = {
            banner: this,
            event,
            cancel: false
        };
        this.onClosing.emit(closingArgs);
        if (closingArgs.cancel) {
            return;
        }
        this._expansionPanel.close(event);
    }
    /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     */
    toggle(event) {
        if (this.collapsed) {
            this.open(event);
        }
        else {
            this.close(event);
        }
    }
    /** @hidden */
    onExpansionPanelOpen() {
        this.onOpened.emit(this._bannerEvent);
    }
    /** @hidden */
    onExpansionPanelClose() {
        this.onClosed.emit(this._bannerEvent);
    }
};
IgxBannerComponent.ɵfac = function IgxBannerComponent_Factory(t) { return new (t || IgxBannerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxBannerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxBannerComponent, selectors: [["igx-banner"]], contentQueries: function IgxBannerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxBannerActionsDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxIconComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._bannerActionTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.bannerIcon = _t.first);
    } }, viewQuery: function IgxBannerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c178, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._expansionPanel = _t.first);
    } }, hostVars: 2, hostBindings: function IgxBannerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("display", ctx.displayStyle);
    } }, inputs: { animationSettings: "animationSettings" }, outputs: { onOpened: "onOpened", onOpening: "onOpening", onClosed: "onClosed", onClosing: "onClosing" }, ngContentSelectors: _c180, decls: 12, vars: 6, consts: [["aria-live", "polite", 3, "animationSettings", "collapsed", "onCollapsed", "onExpanded"], ["expansionPanel", ""], [1, "igx-banner"], [1, "igx-banner__message"], ["class", "igx-banner__illustration", 4, "ngIf"], [1, "igx-banner__text"], [1, "igx-banner__actions"], [1, "igx-banner__row"], [4, "ngIf"], [1, "igx-banner__illustration"], ["igxButton", "flat", "igxRipple", "", 3, "click"]], template: function IgxBannerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c179);
        ɵngcc0.ɵɵelementStart(0, "igx-expansion-panel", 0, 1);
        ɵngcc0.ɵɵlistener("onCollapsed", function IgxBannerComponent_Template_igx_expansion_panel_onCollapsed_0_listener() { return ctx.onExpansionPanelClose(); })("onExpanded", function IgxBannerComponent_Template_igx_expansion_panel_onExpanded_0_listener() { return ctx.onExpansionPanelOpen(); });
        ɵngcc0.ɵɵelementStart(2, "igx-expansion-panel-body");
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵtemplate(5, IgxBannerComponent_div_5_Template, 2, 0, "div", 4);
        ɵngcc0.ɵɵelementStart(6, "span", 5);
        ɵngcc0.ɵɵprojection(7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "div", 6);
        ɵngcc0.ɵɵelementStart(9, "div", 7);
        ɵngcc0.ɵɵtemplate(10, IgxBannerComponent_ng_container_10_Template, 3, 0, "ng-container", 8);
        ɵngcc0.ɵɵtemplate(11, IgxBannerComponent_ng_container_11_Template, 2, 0, "ng-container", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("animationSettings", ctx.animationSettings)("collapsed", ctx.collapsed);
        ɵngcc0.ɵɵattribute("aria-hidden", ctx.collapsed);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.bannerIcon);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.useDefaultTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.useDefaultTemplate);
    } }, directives: [IgxExpansionPanelComponent,
        IgxExpansionPanelBodyComponent, ɵngcc2.NgIf, IgxButtonDirective,
        IgxRippleDirective], encapsulation: 2 });
IgxBannerComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    ViewChild('expansionPanel', { static: true })
], IgxBannerComponent.prototype, "_expansionPanel", void 0);
__decorate([
    ContentChild(IgxBannerActionsDirective)
], IgxBannerComponent.prototype, "_bannerActionTemplate", void 0);
__decorate([
    ContentChild(IgxIconComponent)
], IgxBannerComponent.prototype, "bannerIcon", void 0);
__decorate([
    Output()
], IgxBannerComponent.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxBannerComponent.prototype, "onOpening", void 0);
__decorate([
    Output()
], IgxBannerComponent.prototype, "onClosed", void 0);
__decorate([
    Output()
], IgxBannerComponent.prototype, "onClosing", void 0);
__decorate([
    Input()
], IgxBannerComponent.prototype, "animationSettings", null);
__decorate([
    HostBinding('style.display')
], IgxBannerComponent.prototype, "displayStyle", null);
/**
 * @hidden
 */
let IgxBannerModule = class IgxBannerModule {
};
IgxBannerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxBannerModule });
IgxBannerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxBannerModule_Factory(t) { return new (t || IgxBannerModule)(); }, imports: [[CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]] });

let NEXT_ID$k = 0;
/**
 * IgxCardMedia is container for the card media section.
 * Use it to wrap images and videos.
 */
let IgxCardMediaDirective = class IgxCardMediaDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card__media';
        /**
         * An @Input property that sets the `width` and `min-width` style property
         * of the media container. If not provided it will be set to `auto`.
         *
         * @example
         * ```html
         * <igx-card-media width="300px"></igx-card-media>
         * ```
         */
        this.width = 'auto';
        /**
         * An @Input property that sets the `height` style property of the media container.
         * If not provided it will be set to `auto`.
         *
         * @example
         * ```html
         * <igx-card-media height="50%"></igx-card-media>
         * ```
         */
        this.height = 'auto';
        /**
         * An @Input property that sets the `role` attribute of the media container.
         */
        this.role = 'img';
    }
};
IgxCardMediaDirective.ɵfac = function IgxCardMediaDirective_Factory(t) { return new (t || IgxCardMediaDirective)(); };
IgxCardMediaDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardMediaDirective, selectors: [["igx-card-media"]], hostVars: 9, hostBindings: function IgxCardMediaDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵstyleProp("width", ctx.width)("min-width", ctx.width)("height", ctx.height);
        ɵngcc0.ɵɵclassProp("igx-card__media", ctx.cssClass);
    } }, inputs: { width: "width", height: "height", role: "role" } });
__decorate([
    HostBinding('class.igx-card__media')
], IgxCardMediaDirective.prototype, "cssClass", void 0);
__decorate([
    HostBinding('style.width'),
    HostBinding('style.min-width'),
    Input()
], IgxCardMediaDirective.prototype, "width", void 0);
__decorate([
    HostBinding('style.height'),
    Input()
], IgxCardMediaDirective.prototype, "height", void 0);
__decorate([
    HostBinding('attr.role'),
    Input()
], IgxCardMediaDirective.prototype, "role", void 0);
/**
 * IgxCardHeader is container for the card header
 */
let IgxCardHeaderComponent = class IgxCardHeaderComponent {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-header';
        /**
         * An @Input property that sets the layout style of the header.
         * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
         *
         * @example
         * ```html
         * <igx-card-header [vertical]="true"></igx-card-header>
         * ```
         */
        this.vertical = false;
        /**
         * An @Input property that sets the value of the `role` attribute of the card header.
         * By default the value is set to `header`.
         *
         * @example
         * ```html
         * <igx-card-header role="header"></igx-card-header>
         * ```
         */
        this.role = 'header';
    }
};
IgxCardHeaderComponent.ɵfac = function IgxCardHeaderComponent_Factory(t) { return new (t || IgxCardHeaderComponent)(); };
IgxCardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCardHeaderComponent, selectors: [["igx-card-header"]], hostVars: 5, hostBindings: function IgxCardHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-card-header", ctx.cssClass)("igx-card-header--vertical", ctx.vertical);
    } }, inputs: { vertical: "vertical" }, ngContentSelectors: _c182, decls: 5, vars: 0, consts: [[1, "igx-card-header__thumbnail"], [1, "igx-card-header__titles"]], template: function IgxCardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c181);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 2);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('class.igx-card-header')
], IgxCardHeaderComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-card-header--vertical'),
    Input()
], IgxCardHeaderComponent.prototype, "vertical", void 0);
__decorate([
    HostBinding('attr.role')
], IgxCardHeaderComponent.prototype, "role", void 0);
/**
 * IgxCardThumbnail is container for the card thumbnail section.
 * Use it to wrap anything you want to be used as a thumbnail.
 */
let IgxCardThumbnailDirective = class IgxCardThumbnailDirective {
};
IgxCardThumbnailDirective.ɵfac = function IgxCardThumbnailDirective_Factory(t) { return new (t || IgxCardThumbnailDirective)(); };
IgxCardThumbnailDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardThumbnailDirective, selectors: [["", "igxCardThumbnail", ""]] });
/**
 * igxCardHeaderTitle is used to denote the header title in a card.
 * Use it to tag text nodes.
 */
let IgxCardHeaderTitleDirective = class IgxCardHeaderTitleDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card__header__title';
    }
};
IgxCardHeaderTitleDirective.ɵfac = function IgxCardHeaderTitleDirective_Factory(t) { return new (t || IgxCardHeaderTitleDirective)(); };
IgxCardHeaderTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardHeaderTitleDirective, selectors: [["", "igxCardHeaderTitle", ""]], hostVars: 2, hostBindings: function IgxCardHeaderTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-header__title", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-card-header__title')
], IgxCardHeaderTitleDirective.prototype, "cssClass", void 0);
/**
 * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
 * Use it to tag text nodes.
 */
let IgxCardHeaderSubtitleDirective = class IgxCardHeaderSubtitleDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-header__subtitle';
    }
};
IgxCardHeaderSubtitleDirective.ɵfac = function IgxCardHeaderSubtitleDirective_Factory(t) { return new (t || IgxCardHeaderSubtitleDirective)(); };
IgxCardHeaderSubtitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardHeaderSubtitleDirective, selectors: [["", "igxCardHeaderSubtitle", ""]], hostVars: 2, hostBindings: function IgxCardHeaderSubtitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-header__subtitle", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-card-header__subtitle')
], IgxCardHeaderSubtitleDirective.prototype, "cssClass", void 0);
/**
 * IgxCardContent is container for the card content.
 */
let IgxCardContentDirective = class IgxCardContentDirective {
    constructor() {
        /** @hidden @internal */
        this.cssClass = 'igx-card-content';
    }
};
IgxCardContentDirective.ɵfac = function IgxCardContentDirective_Factory(t) { return new (t || IgxCardContentDirective)(); };
IgxCardContentDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardContentDirective, selectors: [["igx-card-content"]], hostVars: 2, hostBindings: function IgxCardContentDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-content", ctx.cssClass);
    } } });
__decorate([
    HostBinding('class.igx-card-content')
], IgxCardContentDirective.prototype, "cssClass", void 0);
/**
 * IgxCardFooter is container for the card footer
 */
let IgxCardFooterDirective = class IgxCardFooterDirective {
    constructor() {
        /**
         * An @Input property that sets the value of the `role` attribute of the card footer.
         * By default the value is set to `footer`.
         *
         * @example
         * ```html
         * <igx-card-footer role="footer"></igx-card-footer>
         * ```
         */
        this.role = 'footer';
    }
};
IgxCardFooterDirective.ɵfac = function IgxCardFooterDirective_Factory(t) { return new (t || IgxCardFooterDirective)(); };
IgxCardFooterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCardFooterDirective, selectors: [["igx-card-footer"]], hostVars: 1, hostBindings: function IgxCardFooterDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { role: "role" } });
__decorate([
    HostBinding('attr.role'),
    Input()
], IgxCardFooterDirective.prototype, "role", void 0);
/**
 * Card provides a way to display organized content in appealing way.
 *
 * @igxModule IgxCardModule
 *
 * @igxTheme igx-card-theme, igx-icon-theme, igx-button-theme
 *
 * @igxKeywords card, button, avatar, icon
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI Card serves as a container that allows custom content to be organized in an appealing way. There are
 * five sections in a card that you can use to organize your content. These are header, media, content, actions, and footer.
 *
 * @example
 * ```html
 * <igx-card>
 *   <igx-card-header>
 *     <h3 igxCardHeaderTitle>{{title}}</h3>
 *     <h5 igxCardHeaderSubtitle>{{subtitle}}</h5>
 *   </igx-card-header>
 *   <igx-card-actions>
 *       <button igxButton igxRipple>Share</button>
 *       <button igxButton igxRipple>Play Album</button>
 *   </igx-card-actions>
 * </igx-card>
 * ```
 */
var IgxCardType;
(function (IgxCardType) {
    IgxCardType["ELEVATED"] = "elevated";
    IgxCardType["OUTLINED"] = "outlined";
})(IgxCardType || (IgxCardType = {}));
let IgxCardComponent = class IgxCardComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the card.
         * If not set, `id` will have value `"igx-card-0"`;
         *
         * @example
         * ```html
         * <igx-card id = "my-first-card"></igx-card>
         * ```
         * ```typescript
         * let cardId =  this.card.id;
         * ```
         */
        this.id = `igx-card-${NEXT_ID$k++}`;
        /**
         * An @Input property that sets the value of the `role` attribute of the card.
         * By default the value is set to `group`.
         *
         * @example
         * ```html
         * <igx-card role="group"></igx-card>
         * ```
         */
        this.role = 'group';
        /**
         * An @Input property that sets the value of the `type` attribute of the card.
         * By default the value is set to `default`. You can make the card use the
         * outlined style by setting the value to `outlined`.
         *
         * @example
         * ```html
         * <igx-card type="outlined"></igx-card>
         * ```
         */
        this.type = IgxCardType.ELEVATED;
        /**
         * An @Input property that sets the value of the `horizontal` attribute of the card.
         * Setting this to `true` will make the different card sections align horizontally,
         * essentially flipping the card to the side.
         *
         * @example
         * ```html
         * <igx-card [horizontal]="true"></igx-card>
         * ```
         */
        this.horizontal = false;
    }
    /**
     * A getter which will return true if the card type is `outlined`.
     */
    get isOutlinedCard() {
        return this.type === IgxCardType.OUTLINED;
    }
};
IgxCardComponent.ɵfac = function IgxCardComponent_Factory(t) { return new (t || IgxCardComponent)(); };
IgxCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCardComponent, selectors: [["igx-card"]], hostVars: 8, hostBindings: function IgxCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-card", ctx.type)("igx-card--horizontal", ctx.horizontal)("igx-card--outlined", ctx.isOutlinedCard);
    } }, inputs: { id: "id", role: "role", type: "type", horizontal: "horizontal" }, ngContentSelectors: _c2, decls: 5, vars: 0, consts: [["select", "igx-card-media"], ["select", "igx-card-header"], ["select", "igx-card-content"], ["select", "igx-card-actions"]], template: function IgxCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementContainer(1, 1);
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainer(4, 3);
    } }, encapsulation: 2 });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxCardComponent.prototype, "id", void 0);
__decorate([
    HostBinding('attr.role'),
    Input()
], IgxCardComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-card'),
    Input()
], IgxCardComponent.prototype, "type", void 0);
__decorate([
    HostBinding('class.igx-card--outlined')
], IgxCardComponent.prototype, "isOutlinedCard", null);
__decorate([
    HostBinding('class.igx-card--horizontal'),
    Input()
], IgxCardComponent.prototype, "horizontal", void 0);
var IgxCardActionsLayout;
(function (IgxCardActionsLayout) {
    IgxCardActionsLayout["START"] = "start";
    IgxCardActionsLayout["JUSTIFY"] = "justify";
})(IgxCardActionsLayout || (IgxCardActionsLayout = {}));
/**
 * IgxCardActions is container for the card actions.
 */
let IgxCardActionsComponent = class IgxCardActionsComponent {
    constructor(card) {
        this.card = card;
        this.isVerticalSet = false;
        /**
         * An @Input property that sets the layout style of the actions.
         * By default icons and icon buttons, as well as regular buttons
         * are split into two containers, which are then positioned on both ends
         * of the card-actions area.
         * You can justify the elements in those groups so they are positioned equally
         * from one another taking up all the space available along the card actions axis.
         *
         * @example
         * ```html
         * <igx-card-actions layout="justify"></igx-card-actions>
         * ```
         */
        this.layout = IgxCardActionsLayout.START;
        /**
         * An @Input property that sets order of the buttons the actions area.
         * By default all icons/icon buttons are placed at the end of the action
         * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
         * placed in the actions area.
         * If you want to reverse their positions so that icons appear first, use the `reverse`
         * attribute.
         *
         * @example
         * ```html
         * <igx-card-actions [reverse]="true"></igx-card-actions>
         * ```
         */
        this.reverse = false;
    }
    /**
     * A getter that returns `true` when the layout has been
     * set to `justify`.
     */
    get isJustifyLayout() {
        return this.layout === IgxCardActionsLayout.JUSTIFY;
    }
    ngOnChanges(changes) {
        for (const prop in changes) {
            if (prop === 'vertical') {
                this.isVerticalSet = true;
            }
        }
    }
    ngOnInit() {
        this.vertical = !this.isVerticalSet && this.card.horizontal;
    }
};
IgxCardActionsComponent.ɵfac = function IgxCardActionsComponent_Factory(t) { return new (t || IgxCardActionsComponent)(ɵngcc0.ɵɵdirectiveInject(IgxCardComponent, 8)); };
IgxCardActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCardActionsComponent, selectors: [["igx-card-actions"]], hostVars: 8, hostBindings: function IgxCardActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-card-actions", ctx.layout)("igx-card-actions--reverse", ctx.reverse)("igx-card-actions--justify", ctx.isJustifyLayout)("igx-card-actions--vertical", ctx.vertical);
    } }, inputs: { layout: "layout", reverse: "reverse", vertical: "vertical" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c184, decls: 6, vars: 0, consts: [[1, "igx-card-actions__icons"], [1, "igx-card-actions__buttons"], ["buttons", ""]], template: function IgxCardActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c183);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(5, 2);
    } }, encapsulation: 2 });
IgxCardActionsComponent.ctorParameters = () => [
    { type: IgxCardComponent, decorators: [{ type: Optional }, { type: Inject, args: [IgxCardComponent,] }] }
];
__decorate([
    HostBinding('class.igx-card-actions'),
    Input()
], IgxCardActionsComponent.prototype, "layout", void 0);
__decorate([
    HostBinding('class.igx-card-actions--vertical'),
    Input()
], IgxCardActionsComponent.prototype, "vertical", void 0);
__decorate([
    HostBinding('class.igx-card-actions--justify')
], IgxCardActionsComponent.prototype, "isJustifyLayout", null);
__decorate([
    HostBinding('class.igx-card-actions--reverse'),
    Input()
], IgxCardActionsComponent.prototype, "reverse", void 0);
IgxCardActionsComponent = __decorate([ __param(0, Optional()), __param(0, Inject(IgxCardComponent))
], IgxCardActionsComponent);
/**
 * @hidden
 */
let IgxCardModule = class IgxCardModule {
};
IgxCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCardModule });
IgxCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCardModule_Factory(t) { return new (t || IgxCardModule)(); }, imports: [[CommonModule, IgxButtonModule]] });

let IgxCarouselIndicatorDirective = class IgxCarouselIndicatorDirective {
};
IgxCarouselIndicatorDirective.ɵfac = function IgxCarouselIndicatorDirective_Factory(t) { return new (t || IgxCarouselIndicatorDirective)(); };
IgxCarouselIndicatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCarouselIndicatorDirective, selectors: [["", "igxCarouselIndicator", ""]] });
let IgxCarouselNextButtonDirective = class IgxCarouselNextButtonDirective {
};
IgxCarouselNextButtonDirective.ɵfac = function IgxCarouselNextButtonDirective_Factory(t) { return new (t || IgxCarouselNextButtonDirective)(); };
IgxCarouselNextButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCarouselNextButtonDirective, selectors: [["", "igxCarouselNextButton", ""]] });
let IgxCarouselPrevButtonDirective = class IgxCarouselPrevButtonDirective {
};
IgxCarouselPrevButtonDirective.ɵfac = function IgxCarouselPrevButtonDirective_Factory(t) { return new (t || IgxCarouselPrevButtonDirective)(); };
IgxCarouselPrevButtonDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxCarouselPrevButtonDirective, selectors: [["", "igxCarouselPrevButton", ""]] });

var Direction$1;
(function (Direction) {
    Direction[Direction["NONE"] = 0] = "NONE";
    Direction[Direction["NEXT"] = 1] = "NEXT";
    Direction[Direction["PREV"] = 2] = "PREV";
})(Direction$1 || (Direction$1 = {}));
/**
 * A slide component that usually holds an image and/or a caption text.
 * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
 *
 * ```
 * <igx-slide [input bindings] >
 *    <ng-content></ng-content>
 * </igx-slide>
 * ```
 *
 * @export
 */
let IgxSlideComponent = class IgxSlideComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._active = false;
        this._destroy$ = new Subject();
        /**
         * Returns the class of the slide component.
         * ```typescript
         * let class =  this.slide.cssClass;
         * ```
         * @memberof IgxSlideComponent
         */
        this.cssClass = 'igx-slide';
        this.previous = false;
        /**
         * @hidden
         */
        this.activeChange = new EventEmitter();
    }
    /**
     * Returns the `tabIndex` of the slide component.
     * ```typescript
     * let tabIndex =  this.carousel.tabIndex;
     * ```
     * @memberof IgxSlideComponent
     */
    get tabIndex() {
        return this.active ? 0 : null;
    }
    /**
     * Returns the `aria-selected` of the slide.
     *
     * ```typescript
     * let slide = this.slide.ariaSelected;
     * ```
     *
     */
    get ariaSelected() {
        return this.active;
    }
    /**
     * Returns the `aria-live` of the slide.
     *
     * ```typescript
     * let slide = this.slide.ariaLive;
     * ```
     *
     */
    get ariaLive() {
        return this.active ? 'polite' : null;
    }
    /**
     * Gets/sets the `active` state of the slide.
     * ```html
     * <igx-carousel>
     *  <igx-slide [active] ="false"></igx-slide>
     * <igx-carousel>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-carousel>
     *  <igx-slide [(active)] ="model.isActive"></igx-slide>
     * <igx-carousel>
     * ```
     * @memberof IgxSlideComponent
     */
    get active() {
        return this._active;
    }
    set active(value) {
        this._active = !!value;
        this.activeChange.emit(this._active);
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.slide.nativeElement;
     * ```
     * @memberof IgxSlideComponent
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get isDestroyed() {
        return this._destroy$;
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
};
IgxSlideComponent.ɵfac = function IgxSlideComponent_Factory(t) { return new (t || IgxSlideComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSlideComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSlideComponent, selectors: [["igx-slide"]], hostVars: 8, hostBindings: function IgxSlideComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabIndex)("aria-selected", ctx.ariaLive);
        ɵngcc0.ɵɵclassProp("igx-slide", ctx.cssClass)("igx-slide--previous", ctx.previous)("igx-slide--current", ctx.active);
    } }, inputs: { previous: "previous", active: "active", index: "index", direction: "direction" }, outputs: { activeChange: "activeChange" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxSlideComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxSlideComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], IgxSlideComponent.prototype, "index", void 0);
__decorate([
    Input()
], IgxSlideComponent.prototype, "direction", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxSlideComponent.prototype, "tabIndex", null);
__decorate([
    HostBinding('attr.aria-selected')
], IgxSlideComponent.prototype, "ariaSelected", null);
__decorate([
    HostBinding('attr.aria-selected')
], IgxSlideComponent.prototype, "ariaLive", null);
__decorate([
    HostBinding('class.igx-slide')
], IgxSlideComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-slide--current'),
    Input()
], IgxSlideComponent.prototype, "active", null);
__decorate([
    HostBinding('class.igx-slide--previous'),
    Input()
], IgxSlideComponent.prototype, "previous", void 0);
__decorate([
    Output()
], IgxSlideComponent.prototype, "activeChange", void 0);

let NEXT_ID$l = 0;
var CarouselIndicatorsOrientation;
(function (CarouselIndicatorsOrientation) {
    CarouselIndicatorsOrientation["bottom"] = "bottom";
    CarouselIndicatorsOrientation["top"] = "top";
})(CarouselIndicatorsOrientation || (CarouselIndicatorsOrientation = {}));
var CarouselAnimationType;
(function (CarouselAnimationType) {
    CarouselAnimationType["none"] = "none";
    CarouselAnimationType["slide"] = "slide";
    CarouselAnimationType["fade"] = "fade";
})(CarouselAnimationType || (CarouselAnimationType = {}));
let CarouselHammerConfig = class CarouselHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_HORIZONTAL }
        };
    }
};
CarouselHammerConfig.ɵfac = function CarouselHammerConfig_Factory(t) { return ɵCarouselHammerConfig_BaseFactory(t || CarouselHammerConfig); };
CarouselHammerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CarouselHammerConfig, factory: CarouselHammerConfig.ɵfac });
/**
 * **Ignite UI for Angular Carousel** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
 *
 * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
 * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
 * It can be used as a separate fullscreen element or inside another component.
 *
 * Example:
 * ```html
 * <igx-carousel>
 *   <igx-slide>
 *     <h3>First Slide Header</h3>
 *     <p>First slide Content</p>
 *   <igx-slide>
 *   <igx-slide>
 *     <h3>Second Slide Header</h3>
 *     <p>Second Slide Content</p>
 * </igx-carousel>
 * ```
 */
let IgxCarouselComponent = class IgxCarouselComponent {
    constructor(element, iterableDiffers, builder, platformUtil) {
        this.element = element;
        this.iterableDiffers = iterableDiffers;
        this.builder = builder;
        this.platformUtil = platformUtil;
        /**
         * Returns the `role` attribute of the carousel.
         * ```typescript
         * let carouselRole =  this.carousel.role;
         * ```
         * @memberof IgxCarouselComponent
         */
        this.role = 'region';
        /**
         * Sets the `id` of the carousel.
         * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
         * ```html
         * <igx-carousel id="my-first-carousel"></igx-carousel>
         * ```
         * @memberof IgxCarouselComponent
         */
        this.id = `igx-carousel-${NEXT_ID$l++}`;
        /**
         * Returns the `aria-label` of the carousel.
         *
         * ```typescript
         * let carousel = this.carousel.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'carousel';
        /**
         * Returns the class of the carousel component.
         * ```typescript
         * let class =  this.carousel.cssClass;
         * ```
         * @memberof IgxCarouselComponent
         */
        this.cssClass = 'igx-carousel';
        /**
         * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
         * Default value is `true`.
         * ```html
         * <igx-carousel [loop]="false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.loop = true;
        /**
         * Sets whether the carousel will `pause` the slide transitions on user interactions.
         * Default value is `true`.
         * ```html
         *  <igx-carousel [pause]="false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.pause = true;
        /**
         * Controls whether the carousel should render the left/right `navigation` buttons.
         * Default value is `true`.
         * ```html
         * <igx-carousel [navigation] = "false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.navigation = true;
        /**
         * Controls whether the carousel should support keyboard navigation.
         * Default value is `true`.
         * ```html
         * <igx-carousel [keyboardSupport] = "false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.keyboardSupport = true;
        /**
         * Controls whether the carousel should support gestures.
         * Default value is `true`.
         * ```html
         * <igx-carousel [gesturesSupport] = "false"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.gesturesSupport = true;
        /**
         * Controls the maximum indexes that can be shown.
         * Default value is `5`.
         * ```html
         * <igx-carousel [maximumIndicatorsCount] = "10"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.maximumIndicatorsCount = 5;
        /**
         * Gets/sets the display mode of carousel indicators. It can be top or bottom.
         * Default value is `bottom`.
         * ```html
         * <igx-carousel indicatorsOrientation='top'>
         * <igx-carousel>
         * ```
         * @memberOf IgxSlideComponent
         */
        this.indicatorsOrientation = CarouselIndicatorsOrientation.bottom;
        /**
         * Gets/sets the animation type of carousel.
         * Default value is `slide`.
         * ```html
         * <igx-carousel animationType='none'>
         * <igx-carousel>
         * ```
         * @memberOf IgxSlideComponent
         */
        this.animationType = CarouselAnimationType.slide;
        /**
         * The custom template, if any, that should be used when rendering carousel indicators
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.indicatorTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselIndicator let-slide>
         *         <igx-icon *ngIf="slide.active"  fontSet="material">brightness_7</igx-icon>
         *         <igx-icon *ngIf="!slide.active"  fontSet="material">brightness_5</igx-icon>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.indicatorTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering carousel next button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselNextButton let-disabled>
         *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
         *                <igx-icon fontSet="material">add</igx-icon>
         *           </button>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.nextButtonTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering carousel previous button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.carousel.nextButtonTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-carousel #carousel>
         *      ...
         *      <ng-template igxCarouselPrevButton let-disabled>
         *            <button igxButton="fab" igxRipple="white" [disabled]="disabled">
         *                <igx-icon fontSet="material">remove</igx-icon>
         *           </button>
         *      </ng-template>
         *  </igx-carousel>
         * ```
         */
        this.prevButtonTemplate = null;
        /**
         * An event that is emitted after a slide transition has happened.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onSlideChanged = new EventEmitter();
        /**
         * An event that is emitted after a slide has been added to the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onSlideAdded = new EventEmitter();
        /**
         * An event that is emitted after a slide has been removed from the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onSlideRemoved = new EventEmitter();
        /**
         * An event that is emitted after the carousel has been paused.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onCarouselPaused = new EventEmitter();
        /**
         * An event that is emitted after the carousel has resumed transitioning between `slides`.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
         * ```
         * @memberOf IgxCarouselComponent
         */
        this.onCarouselPlaying = new EventEmitter();
        this._resourceStrings = CurrentResourceStrings.CarouselResStrings;
        this.destroy$ = new Subject();
        this.differ = null;
        this.animationDuration = 320;
        this.animationPosition = 0;
        this.newDuration = 0;
        this.differ = this.iterableDiffers.find([]).create(null);
    }
    /**
     * Returns the `tabIndex` of the carousel component.
     * ```typescript
     * let tabIndex =  this.carousel.tabIndex;
     * ```
     * @memberof IgxCarouselComponent
     */
    get tabIndex() {
        return 0;
    }
    /**
     * Gets the `touch-action` style of the `list item`.
     * ```typescript
     * let touchAction = this.listItem.touchAction;
     * ```
     */
    get touchAction() {
        return this.gesturesSupport ? 'pan-y' : 'auto';
    }
    /**
     * Returns the time `interval` in milliseconds before the slide changes.
     * ```typescript
     * let timeInterval = this.carousel.interval;
     * ```
     * @memberof IgxCarouselComponent
     */
    get interval() {
        return this._interval;
    }
    /**
     * Sets the time `interval` in milliseconds before the slide changes.
     * If not set, the carousel will not change `slides` automatically.
     * ```html
     * <igx-carousel [interval] = "1000"></igx-carousel>
     * ```
     * @memberof IgxCarouselComponent
     */
    set interval(value) {
        this._interval = +value;
        this.restartInterval();
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /** @hidden */
    ngAfterContentInit() {
        this.slides.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe((change) => { this.initSlides(change); });
        this.initSlides(this.slides);
    }
    /** @hidden */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.destroyed = true;
        if (this.lastInterval) {
            clearInterval(this.lastInterval);
        }
    }
    unsubscriber(slide) {
        return merge(this.destroy$, slide.isDestroyed);
    }
    onSlideActivated(slide) {
        if (slide.active && slide !== this.currentSlide) {
            if (slide.direction === Direction$1.NONE) {
                const newIndex = slide.index;
                slide.direction = newIndex > this.current ? Direction$1.NEXT : Direction$1.PREV;
            }
            if (this.currentSlide) {
                if (this.previousSlide && this.previousSlide.previous) {
                    this.previousSlide.previous = false;
                }
                this.currentSlide.direction = slide.direction;
                this.currentSlide.active = false;
                this.previousSlide = this.currentSlide;
                this.currentSlide = slide;
                if (this.animationType !== CarouselAnimationType.none) {
                    if (this.animationStarted(this.leaveAnimationPlayer) || this.animationStarted(this.enterAnimationPlayer)) {
                        requestAnimationFrame(() => {
                            this.resetAnimations();
                            this.playAnimations();
                        });
                    }
                    else {
                        this.playAnimations();
                    }
                }
            }
            else {
                this.currentSlide = slide;
            }
            this.onSlideChanged.emit({ carousel: this, slide });
            this.restartInterval();
        }
    }
    playAnimations() {
        this.playLeaveAnimation();
        this.playEnterAnimation();
    }
    finishAnimations() {
        if (this.animationStarted(this.leaveAnimationPlayer)) {
            this.leaveAnimationPlayer.finish();
        }
        if (this.animationStarted(this.enterAnimationPlayer)) {
            this.enterAnimationPlayer.finish();
        }
    }
    resetAnimations() {
        if (this.animationStarted(this.leaveAnimationPlayer)) {
            this.leaveAnimationPlayer.reset();
        }
        if (this.animationStarted(this.enterAnimationPlayer)) {
            this.enterAnimationPlayer.reset();
        }
    }
    animationStarted(animation) {
        return animation && animation.hasStarted();
    }
    getAnimation() {
        let duration;
        if (this.newDuration) {
            duration = this.animationPosition ? this.animationPosition * this.newDuration : this.newDuration;
        }
        else {
            duration = this.animationPosition ? this.animationPosition * this.animationDuration : this.animationDuration;
        }
        switch (this.animationType) {
            case CarouselAnimationType.slide:
                const trans = this.animationPosition ? this.animationPosition * 100 : 100;
                return {
                    enterAnimation: useAnimation(slideInLeft, {
                        params: {
                            delay: '0s',
                            duration: `${duration}ms`,
                            endOpacity: 1,
                            startOpacity: 1,
                            fromPosition: `translateX(${this.currentSlide.direction === 1 ? trans : -trans}%)`,
                            toPosition: 'translateX(0%)'
                        }
                    }),
                    leaveAnimation: useAnimation(slideInLeft, {
                        params: {
                            delay: '0s',
                            duration: `${duration}ms`,
                            endOpacity: 1,
                            startOpacity: 1,
                            fromPosition: `translateX(0%)`,
                            toPosition: `translateX(${this.currentSlide.direction === 1 ? -trans : trans}%)`,
                        }
                    })
                };
            case CarouselAnimationType.fade:
                return {
                    enterAnimation: useAnimation(fadeIn, { params: { duration: `${duration}ms`, startOpacity: `${this.animationPosition}` } }),
                    leaveAnimation: null
                };
        }
        return {
            enterAnimation: null,
            leaveAnimation: null
        };
    }
    playEnterAnimation() {
        const animation = this.getAnimation().enterAnimation;
        if (!animation) {
            return;
        }
        const animationBuilder = this.builder.build(animation);
        this.enterAnimationPlayer = animationBuilder.create(this.currentSlide.nativeElement);
        this.enterAnimationPlayer.onDone(() => {
            if (this.enterAnimationPlayer) {
                this.enterAnimationPlayer.reset();
                this.enterAnimationPlayer = null;
            }
            this.animationPosition = 0;
            this.newDuration = 0;
            this.previousSlide.previous = false;
        });
        this.previousSlide.previous = true;
        this.enterAnimationPlayer.play();
    }
    playLeaveAnimation() {
        const animation = this.getAnimation().leaveAnimation;
        if (!animation) {
            return;
        }
        const animationBuilder = this.builder.build(animation);
        this.leaveAnimationPlayer = animationBuilder.create(this.previousSlide.nativeElement);
        this.leaveAnimationPlayer.onDone(() => {
            if (this.leaveAnimationPlayer) {
                this.leaveAnimationPlayer.reset();
                this.leaveAnimationPlayer = null;
            }
            this.animationPosition = 0;
            this.newDuration = 0;
        });
        this.leaveAnimationPlayer.play();
    }
    initSlides(change) {
        const diff = this.differ.diff(change.toArray());
        if (diff) {
            this.slides.reduce((any, c, ind) => c.index = ind, 0); // reset slides indexes
            diff.forEachAddedItem((record) => {
                const slide = record.item;
                this.onSlideAdded.emit({ carousel: this, slide });
                if (slide.active) {
                    this.currentSlide = slide;
                }
                slide.activeChange.pipe(takeUntil(this.unsubscriber(slide))).subscribe(() => this.onSlideActivated(slide));
            });
            diff.forEachRemovedItem((record) => {
                const slide = record.item;
                this.onSlideRemoved.emit({ carousel: this, slide });
                if (slide.active) {
                    slide.active = false;
                    this.currentSlide = this.get(slide.index < this.total ? slide.index : this.total - 1);
                }
            });
            this.updateSlidesSelection();
        }
    }
    updateSlidesSelection() {
        requestAnimationFrame(() => {
            if (this.currentSlide) {
                this.currentSlide.active = true;
                const activeSlides = this.slides.filter(slide => slide.active && slide.index !== this.currentSlide.index);
                activeSlides.forEach(slide => { slide.active = false; });
            }
            else if (this.total) {
                this.slides.first.active = true;
            }
            this.play();
        });
    }
    /** @hidden */
    get getIndicatorTemplate() {
        if (this.indicatorTemplate) {
            return this.indicatorTemplate;
        }
        return this.defaultIndicator;
    }
    /** @hidden */
    get getNextButtonTemplate() {
        if (this.nextButtonTemplate) {
            return this.nextButtonTemplate;
        }
        return this.defaultNextButton;
    }
    /** @hidden */
    get getPrevButtonTemplate() {
        if (this.prevButtonTemplate) {
            return this.prevButtonTemplate;
        }
        return this.defaultPrevButton;
    }
    /** @hidden */
    setAriaLabel(slide) {
        return `Item ${slide.index + 1} of ${this.total}`;
    }
    /** @hidden */
    get indicatorsOrientationClass() {
        return `igx-carousel-indicators--${this.indicatorsOrientation}`;
    }
    /** @hidden */
    get showIndicators() {
        return this.total <= this.maximumIndicatorsCount && this.total > 0;
    }
    /** @hidden */
    get showIndicatorsLabel() {
        return this.total > this.maximumIndicatorsCount;
    }
    /** @hidden */
    get getCarouselLabel() {
        return `${this.current + 1} ${this.resourceStrings.igx_carousel_of} ${this.total}`;
    }
    /**
     * Returns the total number of `slides` in the carousel.
     * ```typescript
     * let slideCount =  this.carousel.total;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get total() {
        return this.slides.length;
    }
    /**
     * The index of the slide being currently shown.
     * ```typescript
     * let currentSlideNumber =  this.carousel.current;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get current() {
        return !this.currentSlide ? 0 : this.currentSlide.index;
    }
    getNextIndex() {
        return (this.current + 1) % this.total;
    }
    getPrevIndex() {
        return this.current - 1 < 0 ? this.total - 1 : this.current - 1;
    }
    /**
     * Returns a boolean indicating if the carousel is playing.
     * ```typescript
     * let isPlaying =  this.carousel.isPlaying;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get isPlaying() {
        return this.playing;
    }
    /**
     * Returns а boolean indicating if the carousel is destroyed.
     * ```typescript
     * let isDestroyed =  this.carousel.isDestroyed;
     * ```
     * @memberOf IgxCarouselComponent
     */
    get isDestroyed() {
        return this.destroyed;
    }
    /**
     * Returns a reference to the carousel element in the DOM.
     * ```typescript
     * let nativeElement =  this.carousel.nativeElement;
     * ```
     * @memberof IgxCarouselComponent
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     * @memberOf IgxCarouselComponent
     */
    get(index) {
        return this.slides.find((slide) => slide.index === index);
    }
    /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     * @memberOf IgxCarouselComponent
     */
    add(slide) {
        const newSlides = this.slides.toArray();
        newSlides.push(slide);
        this.slides.reset(newSlides);
        this.slides.notifyOnChanges();
    }
    /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     * @memberOf IgxCarouselComponent
     */
    remove(slide) {
        if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
            const newSlides = this.slides.toArray();
            newSlides.splice(slide.index, 1);
            this.slides.reset(newSlides);
            this.slides.notifyOnChanges();
        }
    }
    /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     * @memberOf IgxCarouselComponent
     */
    select(slide, direction = Direction$1.NONE) {
        if (slide && slide !== this.currentSlide) {
            slide.direction = direction;
            slide.active = true;
        }
    }
    /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     * @memberOf IgxCarouselComponent
     */
    next() {
        const index = this.getNextIndex();
        if (index === 0 && !this.loop) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.NEXT);
    }
    /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     * @memberOf IgxCarouselComponent
     */
    prev() {
        const index = this.getPrevIndex();
        if (!this.loop && index === this.total - 1) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction$1.PREV);
    }
    /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     * @memberOf IgxCarouselComponent
     */
    play() {
        if (!this.playing) {
            this.playing = true;
            this.onCarouselPlaying.emit(this);
            this.restartInterval();
            this.stoppedByInteraction = false;
        }
    }
    /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     * @memberOf IgxCarouselComponent
     */
    stop() {
        if (this.pause) {
            this.playing = false;
            this.onCarouselPaused.emit(this);
            this.resetInterval();
        }
    }
    resetInterval() {
        if (this.lastInterval) {
            clearInterval(this.lastInterval);
            this.lastInterval = null;
        }
    }
    restartInterval() {
        this.resetInterval();
        if (!isNaN(this.interval) && this.interval > 0 && this.platformUtil.isBrowser) {
            this.lastInterval = setInterval(() => {
                const tick = +this.interval;
                if (this.playing && this.total && !isNaN(tick) && tick > 0) {
                    this.next();
                }
                else {
                    this.stop();
                }
            }, this.interval);
        }
    }
    /** @hidden */
    get nextButtonDisabled() {
        return !this.loop && this.current === (this.total - 1);
    }
    /** @hidden */
    get prevButtonDisabled() {
        return !this.loop && this.current === 0;
    }
    /** @hidden */
    onKeydownArrowRight(event) {
        if (this.keyboardSupport) {
            event.preventDefault();
            this.next();
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onKeydownArrowLeft(event) {
        if (this.keyboardSupport) {
            event.preventDefault();
            this.prev();
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onTap(event) {
        // play pause only when tap on slide
        if (event.target && event.target.classList.contains('igx-slide')) {
            if (this.isPlaying) {
                if (this.pause) {
                    this.stoppedByInteraction = true;
                }
                this.stop();
            }
            else if (this.stoppedByInteraction) {
                this.play();
            }
        }
    }
    /** @hidden */
    onKeydownHome(event) {
        if (this.keyboardSupport && this.slides.length > 0) {
            event.preventDefault();
            this.slides.first.active = true;
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onKeydownEnd(event) {
        if (this.keyboardSupport && this.slides.length > 0) {
            event.preventDefault();
            this.slides.last.active = true;
            requestAnimationFrame(() => this.nativeElement.focus());
        }
    }
    /** @hidden */
    onMouseEnter() {
        if (this.pause && this.isPlaying) {
            this.stoppedByInteraction = true;
        }
        this.stop();
    }
    /** @hidden */
    onMouseLeave() {
        if (this.stoppedByInteraction) {
            this.play();
        }
    }
    /** @hidden */
    onPanLeft(event) {
        this.pan(event);
    }
    /** @hidden */
    onPanRight(event) {
        this.pan(event);
    }
    resetSlideStyles(slide) {
        slide.nativeElement.style.transform = '';
        slide.nativeElement.style.opacity = '';
    }
    pan(event) {
        const slideWidth = this.currentSlide.nativeElement.offsetWidth;
        const panOffset = (slideWidth / 1000);
        const deltaX = event.deltaX;
        const index = deltaX < 0 ? this.getNextIndex() : this.getPrevIndex();
        const offset = deltaX < 0 ? slideWidth + deltaX : -slideWidth + deltaX;
        if (!this.gesturesSupport || event.isFinal || Math.abs(deltaX) + panOffset >= slideWidth) {
            return;
        }
        if (!this.loop && ((this.current === 0 && deltaX > 0) || (this.current === this.total - 1 && deltaX < 0))) {
            this.incomingSlide = null;
            return;
        }
        event.preventDefault();
        if (this.isPlaying) {
            this.stoppedByInteraction = true;
            this.stop();
        }
        if (this.previousSlide && this.previousSlide.previous) {
            this.previousSlide.previous = false;
        }
        this.finishAnimations();
        if (this.incomingSlide) {
            if (index !== this.incomingSlide.index) {
                this.resetSlideStyles(this.incomingSlide);
                this.incomingSlide.previous = false;
                this.incomingSlide = this.get(index);
            }
        }
        else {
            this.incomingSlide = this.get(index);
        }
        this.incomingSlide.previous = true;
        if (this.animationType === CarouselAnimationType.fade) {
            this.currentSlide.nativeElement.style.opacity = `${Math.abs(offset) / slideWidth}`;
        }
        else {
            this.currentSlide.nativeElement.style.transform = `translateX(${deltaX}px)`;
            this.incomingSlide.nativeElement.style.transform = `translateX(${offset}px)`;
        }
    }
    /**
     * @hidden
     */
    onPanEnd(event) {
        if (!this.gesturesSupport) {
            return;
        }
        event.preventDefault();
        const slideWidth = this.currentSlide.nativeElement.offsetWidth;
        const panOffset = (slideWidth / 1000);
        const deltaX = Math.abs(event.deltaX) + panOffset < slideWidth ? Math.abs(event.deltaX) : slideWidth - panOffset;
        const velocity = Math.abs(event.velocity);
        this.resetSlideStyles(this.currentSlide);
        if (this.incomingSlide) {
            this.resetSlideStyles(this.incomingSlide);
            if (slideWidth / 2 < deltaX || velocity > 1) {
                this.incomingSlide.direction = event.deltaX < 0 ? Direction$1.NEXT : Direction$1.PREV;
                this.incomingSlide.previous = false;
                this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                    deltaX / slideWidth : (slideWidth - deltaX) / slideWidth;
                if (velocity > 1) {
                    this.newDuration = this.animationDuration / velocity;
                }
                this.incomingSlide.active = true;
            }
            else {
                this.currentSlide.direction = event.deltaX > 0 ? Direction$1.NEXT : Direction$1.PREV;
                this.previousSlide = this.incomingSlide;
                this.previousSlide.previous = true;
                this.animationPosition = this.animationType === CarouselAnimationType.fade ?
                    Math.abs((slideWidth - deltaX) / slideWidth) : deltaX / slideWidth;
                this.playAnimations();
            }
        }
        if (this.stoppedByInteraction) {
            this.play();
        }
    }
};
IgxCarouselComponent.ɵfac = function IgxCarouselComponent_Factory(t) { return new (t || IgxCarouselComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.AnimationBuilder), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxCarouselComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxCarouselComponent, selectors: [["igx-carousel"]], contentQueries: function IgxCarouselComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCarouselIndicatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCarouselNextButtonDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxCarouselPrevButtonDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSlideComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nextButtonTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.prevButtonTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.slides = _t);
    } }, viewQuery: function IgxCarouselComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c185, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c186, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c187, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultNextButton = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultPrevButton = _t.first);
    } }, hostVars: 8, hostBindings: function IgxCarouselComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.arrowright", function IgxCarouselComponent_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrowRight($event); })("keydown.arrowleft", function IgxCarouselComponent_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrowLeft($event); })("tap", function IgxCarouselComponent_tap_HostBindingHandler($event) { return ctx.onTap($event); })("keydown.home", function IgxCarouselComponent_keydown_home_HostBindingHandler($event) { return ctx.onKeydownHome($event); })("keydown.end", function IgxCarouselComponent_keydown_end_HostBindingHandler($event) { return ctx.onKeydownEnd($event); })("mouseenter", function IgxCarouselComponent_mouseenter_HostBindingHandler() { return ctx.onMouseEnter(); })("mouseleave", function IgxCarouselComponent_mouseleave_HostBindingHandler() { return ctx.onMouseLeave(); })("panleft", function IgxCarouselComponent_panleft_HostBindingHandler($event) { return ctx.onPanLeft($event); })("panright", function IgxCarouselComponent_panright_HostBindingHandler($event) { return ctx.onPanRight($event); })("panend", function IgxCarouselComponent_panend_HostBindingHandler($event) { return ctx.onPanEnd($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("id", ctx.id)("aria-label", ctx.ariaLabel)("tabindex", ctx.tabIndex);
        ɵngcc0.ɵɵstyleProp("touch-action", ctx.touchAction);
        ɵngcc0.ɵɵclassProp("igx-carousel", ctx.cssClass);
    } }, inputs: { id: "id", loop: "loop", pause: "pause", navigation: "navigation", keyboardSupport: "keyboardSupport", gesturesSupport: "gesturesSupport", maximumIndicatorsCount: "maximumIndicatorsCount", indicatorsOrientation: "indicatorsOrientation", animationType: "animationType", interval: "interval", resourceStrings: "resourceStrings" }, outputs: { onSlideChanged: "onSlideChanged", onSlideAdded: "onSlideAdded", onSlideRemoved: "onSlideRemoved", onCarouselPaused: "onCarouselPaused", onCarouselPlaying: "onCarouselPlaying" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: CarouselHammerConfig
            }
        ])], ngContentSelectors: _c2, decls: 12, vars: 4, consts: [["defaultIndicator", ""], ["defaultNextButton", ""], ["defaultPrevButton", ""], [3, "ngClass", 4, "ngIf"], ["role", "list", 1, "igx-carousel__inner"], ["role", "button", "tabindex", "0", "class", "igx-carousel__arrow--prev", 3, "click", 4, "ngIf"], ["role", "button", "tabindex", "0", "class", "igx-carousel__arrow--next", 3, "click", 4, "ngIf"], [1, "igx-nav-dot"], [1, "igx-nav-arrow"], ["fontSet", "material"], [3, "ngClass"], ["class", "igx-carousel-indicators__indicator", 3, "click", 4, "ngFor", "ngForOf"], [1, "igx-carousel-indicators__indicator", 3, "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-carousel__label"], ["role", "button", "tabindex", "0", 1, "igx-carousel__arrow--prev", 3, "click"], ["role", "button", "tabindex", "0", 1, "igx-carousel__arrow--next", 3, "click"]], template: function IgxCarouselComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxCarouselComponent_ng_template_0_Template, 1, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxCarouselComponent_ng_template_2_Template, 3, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxCarouselComponent_ng_template_4_Template, 3, 2, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxCarouselComponent_div_6_Template, 2, 2, "div", 3);
        ɵngcc0.ɵɵtemplate(7, IgxCarouselComponent_div_7_Template, 3, 2, "div", 3);
        ɵngcc0.ɵɵelementStart(8, "div", 4);
        ɵngcc0.ɵɵprojection(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxCarouselComponent_div_10_Template, 2, 4, "div", 5);
        ɵngcc0.ɵɵtemplate(11, IgxCarouselComponent_div_11_Template, 2, 4, "div", 6);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showIndicators);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showIndicatorsLabel);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigation && ctx.slides.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.navigation && ctx.slides.length);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent, ɵngcc2.NgClass, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet], styles: ["[_nghost-%COMP%] {\n        display: block;\n        outline-style: none;\n    }"] });
IgxCarouselComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers },
    { type: AnimationBuilder },
    { type: PlatformUtil }
];
__decorate([
    HostBinding('attr.role')
], IgxCarouselComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxCarouselComponent.prototype, "id", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxCarouselComponent.prototype, "ariaLabel", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxCarouselComponent.prototype, "tabIndex", null);
__decorate([
    HostBinding('class.igx-carousel')
], IgxCarouselComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('style.touch-action')
], IgxCarouselComponent.prototype, "touchAction", null);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "loop", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "pause", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "interval", null);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "navigation", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "keyboardSupport", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "gesturesSupport", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "maximumIndicatorsCount", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "indicatorsOrientation", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "animationType", void 0);
__decorate([
    Input()
], IgxCarouselComponent.prototype, "resourceStrings", null);
__decorate([
    ViewChild('defaultIndicator', { read: TemplateRef, static: true })
], IgxCarouselComponent.prototype, "defaultIndicator", void 0);
__decorate([
    ViewChild('defaultNextButton', { read: TemplateRef, static: true })
], IgxCarouselComponent.prototype, "defaultNextButton", void 0);
__decorate([
    ViewChild('defaultPrevButton', { read: TemplateRef, static: true })
], IgxCarouselComponent.prototype, "defaultPrevButton", void 0);
__decorate([
    ContentChild(IgxCarouselIndicatorDirective, { read: TemplateRef, static: false })
], IgxCarouselComponent.prototype, "indicatorTemplate", void 0);
__decorate([
    ContentChild(IgxCarouselNextButtonDirective, { read: TemplateRef, static: false })
], IgxCarouselComponent.prototype, "nextButtonTemplate", void 0);
__decorate([
    ContentChild(IgxCarouselPrevButtonDirective, { read: TemplateRef, static: false })
], IgxCarouselComponent.prototype, "prevButtonTemplate", void 0);
__decorate([
    ContentChildren(IgxSlideComponent)
], IgxCarouselComponent.prototype, "slides", void 0);
__decorate([
    Output()
], IgxCarouselComponent.prototype, "onSlideChanged", void 0);
__decorate([
    Output()
], IgxCarouselComponent.prototype, "onSlideAdded", void 0);
__decorate([
    Output()
], IgxCarouselComponent.prototype, "onSlideRemoved", void 0);
__decorate([
    Output()
], IgxCarouselComponent.prototype, "onCarouselPaused", void 0);
__decorate([
    Output()
], IgxCarouselComponent.prototype, "onCarouselPlaying", void 0);
__decorate([
    HostListener('keydown.arrowright', ['$event'])
], IgxCarouselComponent.prototype, "onKeydownArrowRight", null);
__decorate([
    HostListener('keydown.arrowleft', ['$event'])
], IgxCarouselComponent.prototype, "onKeydownArrowLeft", null);
__decorate([
    HostListener('tap', ['$event'])
], IgxCarouselComponent.prototype, "onTap", null);
__decorate([
    HostListener('keydown.home', ['$event'])
], IgxCarouselComponent.prototype, "onKeydownHome", null);
__decorate([
    HostListener('keydown.end', ['$event'])
], IgxCarouselComponent.prototype, "onKeydownEnd", null);
__decorate([
    HostListener('mouseenter')
], IgxCarouselComponent.prototype, "onMouseEnter", null);
__decorate([
    HostListener('mouseleave')
], IgxCarouselComponent.prototype, "onMouseLeave", null);
__decorate([
    HostListener('panleft', ['$event'])
], IgxCarouselComponent.prototype, "onPanLeft", null);
__decorate([
    HostListener('panright', ['$event'])
], IgxCarouselComponent.prototype, "onPanRight", null);
__decorate([
    HostListener('panend', ['$event'])
], IgxCarouselComponent.prototype, "onPanEnd", null);
/**
 * @hidden
 */
let IgxCarouselModule = class IgxCarouselModule {
};
IgxCarouselModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxCarouselModule });
IgxCarouselModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxCarouselModule_Factory(t) { return new (t || IgxCarouselModule)(); }, imports: [[CommonModule, IgxIconModule]] });

/**
 * @hidden
 */
let IgxComboHeaderDirective = class IgxComboHeaderDirective {
};
IgxComboHeaderDirective.ɵfac = function IgxComboHeaderDirective_Factory(t) { return new (t || IgxComboHeaderDirective)(); };
IgxComboHeaderDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboHeaderDirective, selectors: [["", "igxComboHeader", ""]] });
/**
 * @hidden
 */
let IgxComboFooterDirective = class IgxComboFooterDirective {
};
IgxComboFooterDirective.ɵfac = function IgxComboFooterDirective_Factory(t) { return new (t || IgxComboFooterDirective)(); };
IgxComboFooterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboFooterDirective, selectors: [["", "igxComboFooter", ""]] });
/**
 * @hidden
 */
let IgxComboItemDirective = class IgxComboItemDirective {
};
IgxComboItemDirective.ɵfac = function IgxComboItemDirective_Factory(t) { return new (t || IgxComboItemDirective)(); };
IgxComboItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboItemDirective, selectors: [["", "igxComboItem", ""]] });
/**
 * @hidden
 */
let IgxComboEmptyDirective = class IgxComboEmptyDirective {
};
IgxComboEmptyDirective.ɵfac = function IgxComboEmptyDirective_Factory(t) { return new (t || IgxComboEmptyDirective)(); };
IgxComboEmptyDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboEmptyDirective, selectors: [["", "igxComboEmpty", ""]] });
/**
 * @hidden
 */
let IgxComboHeaderItemDirective = class IgxComboHeaderItemDirective {
};
IgxComboHeaderItemDirective.ɵfac = function IgxComboHeaderItemDirective_Factory(t) { return new (t || IgxComboHeaderItemDirective)(); };
IgxComboHeaderItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboHeaderItemDirective, selectors: [["", "igxComboHeaderItem", ""]] });
/**
 * @hidden
 */
let IgxComboAddItemDirective = class IgxComboAddItemDirective {
};
IgxComboAddItemDirective.ɵfac = function IgxComboAddItemDirective_Factory(t) { return new (t || IgxComboAddItemDirective)(); };
IgxComboAddItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboAddItemDirective, selectors: [["", "igxComboAddItem", ""]] });
/**
 * @hidden
 */
let IgxComboToggleIconDirective = class IgxComboToggleIconDirective {
};
IgxComboToggleIconDirective.ɵfac = function IgxComboToggleIconDirective_Factory(t) { return new (t || IgxComboToggleIconDirective)(); };
IgxComboToggleIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboToggleIconDirective, selectors: [["", "igxComboToggleIcon", ""]] });
/**
 * @hidden
 */
let IgxComboClearIconDirective = class IgxComboClearIconDirective {
};
IgxComboClearIconDirective.ɵfac = function IgxComboClearIconDirective_Factory(t) { return new (t || IgxComboClearIconDirective)(); };
IgxComboClearIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxComboClearIconDirective, selectors: [["", "igxComboClearIcon", ""]] });

/**
 * @hidden
 */
let IgxComboAPIService = class IgxComboAPIService {
    constructor() {
        this.disableTransitions = false;
    }
    register(combo) {
        this.combo = combo;
    }
    clear() {
        this.combo = null;
    }
    get valueKey() {
        return this.combo.valueKey !== null && this.combo.valueKey !== undefined ? this.combo.valueKey : null;
    }
    get item_focusable() {
        return false;
    }
    get isRemote() {
        return this.combo.isRemote;
    }
    add_custom_item() {
        if (!this.combo) {
            return;
        }
        this.combo.addItemToCollection();
    }
    get comboID() {
        return this.combo.id;
    }
    set_selected_item(itemID, event) {
        const selected = this.combo.isItemSelected(itemID);
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (!selected) {
            this.combo.selectItems([itemID], false, event);
        }
        else {
            this.combo.deselectItems([itemID], event);
        }
    }
    is_item_selected(itemID) {
        return this.combo.isItemSelected(itemID);
    }
};
IgxComboAPIService.ɵfac = function IgxComboAPIService_Factory(t) { return new (t || IgxComboAPIService)(); };
IgxComboAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxComboAPIService, factory: IgxComboAPIService.ɵfac });

/** @hidden */
let IgxComboItemComponent = class IgxComboItemComponent extends IgxDropDownItemComponent {
    constructor(comboAPI, dropDown, elementRef, selection) {
        super(dropDown, elementRef, null, selection);
        this.comboAPI = comboAPI;
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.selection = selection;
        /**
         * Gets the height of a list item
         * @hidden
         */
        this.itemHeight = '';
    }
    /**
     * @hidden
     */
    get itemID() {
        const valueKey = this.comboAPI.valueKey;
        return valueKey !== null ? this.value[valueKey] : this.value;
    }
    /**
     * @hidden
     */
    get comboID() {
        return this.comboAPI.comboID;
    }
    /**
     * @hidden
     * @internal
     */
    get disableTransitions() {
        return this.comboAPI.disableTransitions;
    }
    /**
     * @hidden
     */
    get selected() {
        return this.comboAPI.is_item_selected(this.itemID);
    }
    set selected(value) {
        if (this.isHeader) {
            return;
        }
        this._selected = value;
    }
    /**
     * @hidden
     */
    isVisible(direction) {
        const rect = this.element.nativeElement.getBoundingClientRect();
        const parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
        if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
        }
        return rect.y >= parentDiv.y;
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        if (!this.isSelectable) {
            return;
        }
        this.dropDown.navigateItem(this.index);
        this.comboAPI.set_selected_item(this.itemID, event);
    }
    /**
     * @hidden
     * @internal
     * The event that is prevented is the click on the checkbox label element.
     * That is the only visible element that a user can interact with.
     * The click propagates to the host and the preventDefault is to stop it from
     * switching focus to the input it's base on.
     * The toggle happens in an internal handler in the drop-down on the next task queue cycle.
     */
    disableCheck(event) {
        event.preventDefault();
    }
    ngDoCheck() {
    }
};
IgxComboItemComponent.ɵfac = function IgxComboItemComponent_Factory(t) { return new (t || IgxComboItemComponent)(ɵngcc0.ɵɵdirectiveInject(IgxComboAPIService), ɵngcc0.ɵɵdirectiveInject(IGX_DROPDOWN_BASE), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService)); };
IgxComboItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboItemComponent, selectors: [["igx-combo-item"]], hostVars: 2, hostBindings: function IgxComboItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.itemHeight, "px");
    } }, inputs: { itemHeight: "itemHeight" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 2, vars: 1, consts: [[4, "ngIf"], ["disableRipple", "true", 1, "igx-combo__checkbox", 3, "checked", "disableTransitions", "tabindex", "click"]], template: function IgxComboItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxComboItemComponent_ng_container_0_Template, 2, 3, "ng-container", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.isHeader);
    } }, directives: [ɵngcc2.NgIf, IgxCheckboxComponent], encapsulation: 2 });
IgxComboItemComponent.ctorParameters = () => [
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
    { type: ElementRef },
    { type: IgxSelectionAPIService, decorators: [{ type: Inject, args: [IgxSelectionAPIService,] }] }
];
__decorate([
    Input(),
    HostBinding('style.height.px')
], IgxComboItemComponent.prototype, "itemHeight", void 0);
IgxComboItemComponent = __decorate([ __param(1, Inject(IGX_DROPDOWN_BASE)),
    __param(3, Inject(IgxSelectionAPIService))
], IgxComboItemComponent);

const IGX_COMBO_COMPONENT = new InjectionToken('IgxComboComponentToken');

var IgxComboAddItemComponent_1;
/**
 * @hidden
 */
let IgxComboAddItemComponent = IgxComboAddItemComponent_1 = class IgxComboAddItemComponent extends IgxComboItemComponent {
    get selected() {
        return false;
    }
    set selected(value) {
    }
    /**
     * @inheritdoc
     */
    clicked(event) {
        this.comboAPI.disableTransitions = false;
        this.comboAPI.add_custom_item();
    }
};
IgxComboAddItemComponent.ɵfac = function IgxComboAddItemComponent_Factory(t) { return ɵIgxComboAddItemComponent_BaseFactory(t || IgxComboAddItemComponent); };
IgxComboAddItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboAddItemComponent, selectors: [["igx-combo-add-item"]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxComboAddItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });

var IgxComboDropDownComponent_1;
/** @hidden */
let IgxComboDropDownComponent = IgxComboDropDownComponent_1 = class IgxComboDropDownComponent extends IgxDropDownComponent {
    constructor(elementRef, cdr, selection, combo, comboAPI, _displayDensityOptions) {
        super(elementRef, cdr, selection, _displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.combo = combo;
        this.comboAPI = comboAPI;
        this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         * @internal
         */
        this.children = null;
        this.scrollHandler = () => {
            this.comboAPI.disableTransitions = true;
        };
    }
    /** @hidden @internal */
    get scrollContainer() {
        return this.virtDir.dc.location.nativeElement;
    }
    get isScrolledToLast() {
        const scrollTop = this.virtDir.scrollPosition;
        const scrollHeight = this.virtDir.getScroll().scrollHeight;
        return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
    }
    get lastVisibleIndex() {
        return this.combo.totalItemCount ?
            Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
            this.items.length - 1;
    }
    /**
     * @hidden @internal
     */
    onFocus() {
        this.focusedItem = this._focusedItem || this.items[0];
    }
    /**
     * @hidden @internal
     */
    onBlur(evt) {
        this.focusedItem = null;
    }
    /**
     * @hidden @internal
     */
    onToggleOpened() {
        this.onOpened.emit();
    }
    /**
     * @hidden
     */
    navigateFirst() {
        this.navigateItem(this.virtDir.igxForOf.findIndex(e => !e.isHeader));
    }
    /**
     * @hidden
     */
    navigatePrev() {
        if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
            this.combo.focusSearchInput(false);
        }
        else {
            super.navigatePrev();
        }
    }
    /**
     * @hidden
     */
    navigateNext() {
        const lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
        if (this._focusedItem && this._focusedItem.index === lastIndex) {
            this.focusAddItemButton();
        }
        else {
            super.navigateNext();
        }
    }
    /**
     * @hidden @internal
     */
    selectItem(item) {
        if (item === null || item === undefined) {
            return;
        }
        this.comboAPI.set_selected_item(item.itemID);
        this._focusedItem = item;
    }
    focusAddItemButton() {
        if (this.combo.isAddButtonVisible()) {
            this.focusedItem = this.items[this.items.length - 1];
        }
    }
    scrollToHiddenItem(newItem) { }
    get sortedChildren() {
        if (this.children !== undefined) {
            return this.children.toArray()
                .sort((a, b) => {
                return a.index - b.index;
            });
        }
        return null;
    }
    /**
     * Get all non-header items
     *
     * ```typescript
     * let myDropDownItems = this.dropdown.items;
     * ```
     */
    get items() {
        const items = [];
        if (this.children !== undefined) {
            const sortedChildren = this.sortedChildren;
            for (const child of sortedChildren) {
                if (!child.isHeader) {
                    items.push(child);
                }
            }
        }
        return items;
    }
    /**
     * @hidden @internal
     */
    updateScrollPosition() {
        this.virtDir.getScroll().scrollTop = this._scrollPosition;
    }
    /**
     * @hidden @internal
     */
    onItemActionKey(key) {
        switch (key) {
            case DropDownActionKey.ENTER:
                this.handleEnter();
                break;
            case DropDownActionKey.SPACE:
                this.handleSpace();
                break;
            case DropDownActionKey.ESCAPE:
                this.close();
        }
    }
    handleEnter() {
        if (this.isAddItemFocused()) {
            this.combo.addItemToCollection();
        }
        else {
            this.close();
        }
    }
    handleSpace() {
        if (this.isAddItemFocused()) {
            return;
        }
        else {
            this.selectItem(this.focusedItem);
        }
    }
    isAddItemFocused() {
        return this.focusedItem instanceof IgxComboAddItemComponent;
    }
    ngAfterViewInit() {
        this.virtDir.getScroll().addEventListener('scroll', this.scrollHandler);
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.virtDir.getScroll().removeEventListener('scroll', this.scrollHandler);
        this.destroy$.next(true);
        this.destroy$.complete();
    }
};
IgxComboDropDownComponent.ɵfac = function IgxComboDropDownComponent_Factory(t) { return new (t || IgxComboDropDownComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(IGX_COMBO_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxComboAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxComboDropDownComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboDropDownComponent, selectors: [["igx-combo-drop-down"]], contentQueries: function IgxComboDropDownComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 4, vars: 8, consts: [["igxToggle", "", 1, "igx-drop-down__list", 3, "onOpening", "onOpened", "onAppended", "onClosing", "onClosed"], ["role", "listbox", 1, "igx-drop-down__list-scroll"], ["scrollContainer", ""], [4, "ngIf"]], template: function IgxComboDropDownComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("onOpening", function IgxComboDropDownComponent_Template_div_onOpening_0_listener($event) { return ctx.onToggleOpening($event); })("onOpened", function IgxComboDropDownComponent_Template_div_onOpened_0_listener() { return ctx.onToggleOpened(); })("onAppended", function IgxComboDropDownComponent_Template_div_onAppended_0_listener() { return ctx.onToggleContentAppended(); })("onClosing", function IgxComboDropDownComponent_Template_div_onClosing_0_listener($event) { return ctx.onToggleClosing($event); })("onClosed", function IgxComboDropDownComponent_Template_div_onClosed_0_listener() { return ctx.onToggleClosed(); });
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, IgxComboDropDownComponent_ng_container_3_Template, 2, 0, "ng-container", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.width);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.height)("max-height", ctx.maxHeight);
        ɵngcc0.ɵɵattribute("id", ctx.listId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.collapsed);
    } }, directives: [IgxToggleDirective, ɵngcc2.NgIf], encapsulation: 2 });
IgxComboDropDownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] },
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    ContentChildren(IgxComboItemComponent, { descendants: true })
], IgxComboDropDownComponent.prototype, "children", void 0);
IgxComboDropDownComponent = IgxComboDropDownComponent_1 = __decorate([ __param(3, Inject(IGX_COMBO_COMPONENT)),
    __param(5, Optional()), __param(5, Inject(DisplayDensityToken))
], IgxComboDropDownComponent);

/**
 * @hidden
 */
let IgxComboFilteringPipe = class IgxComboFilteringPipe {
    transform(collection, searchValue, displayKey, shouldFilter) {
        if (!collection) {
            return [];
        }
        if (!searchValue || !shouldFilter) {
            return collection;
        }
        else {
            const searchTerm = searchValue.toLowerCase().trim();
            if (displayKey != null) {
                return collection.filter(e => e[displayKey].toLowerCase().includes(searchTerm));
            }
            else {
                return collection.filter(e => e.toLowerCase().includes(searchTerm));
            }
        }
    }
};
IgxComboFilteringPipe.ɵfac = function IgxComboFilteringPipe_Factory(t) { return new (t || IgxComboFilteringPipe)(); };
IgxComboFilteringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "comboFiltering", type: IgxComboFilteringPipe, pure: true });
/**
 * @hidden
 */
let IgxComboGroupingPipe = class IgxComboGroupingPipe {
    constructor(combo) {
        this.combo = combo;
    }
    transform(collection, groupKey, valueKey) {
        this.combo.filteredData = collection;
        if ((!groupKey && groupKey !== 0) || !collection.length) {
            return collection;
        }
        const sorted = DataUtil.sort(cloneArray(collection), [{
                fieldName: groupKey,
                dir: SortingDirection.Asc,
                ignoreCase: true,
                strategy: DefaultSortingStrategy.instance()
            }]);
        const data = cloneArray(sorted);
        let inserts = 0;
        let currentHeader = null;
        for (let i = 0; i < sorted.length; i++) {
            let insertFlag = 0;
            if (currentHeader !== sorted[i][groupKey]) {
                currentHeader = sorted[i][groupKey];
                insertFlag = 1;
            }
            if (insertFlag) {
                data.splice(i + inserts, 0, {
                    [valueKey]: currentHeader,
                    [groupKey]: currentHeader,
                    isHeader: true
                });
                inserts++;
            }
        }
        return data;
    }
};
IgxComboGroupingPipe.ɵfac = function IgxComboGroupingPipe_Factory(t) { return new (t || IgxComboGroupingPipe)(ɵngcc0.ɵɵdirectiveInject(IGX_COMBO_COMPONENT)); };
IgxComboGroupingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "comboGrouping", type: IgxComboGroupingPipe, pure: true });
IgxComboGroupingPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] }
];
IgxComboGroupingPipe = __decorate([ __param(0, Inject(IGX_COMBO_COMPONENT))
], IgxComboGroupingPipe);

var IgxComboComponent_1;
/**
 * @hidden
 */
var DataTypes;
(function (DataTypes) {
    DataTypes["EMPTY"] = "empty";
    DataTypes["PRIMITIVE"] = "primitive";
    DataTypes["COMPLEX"] = "complex";
    DataTypes["PRIMARYKEY"] = "valueKey";
})(DataTypes || (DataTypes = {}));
/**
 * @hidden
 */
const ItemHeights = {
    'comfortable': 40,
    'cosy': 32,
    'compact': 28,
};
/**
 * @hidden
 * The default number of items that should be in the combo's
 * drop-down list if no `[itemsMaxHeight]` is specified
 */
const itemsInContainer = 10;
var IgxComboState;
(function (IgxComboState) {
    /**
     * Combo with initial state.
     */
    IgxComboState[IgxComboState["INITIAL"] = 0] = "INITIAL";
    /**
     * Combo with valid state.
     */
    IgxComboState[IgxComboState["VALID"] = 1] = "VALID";
    /**
     * Combo with invalid state.
     */
    IgxComboState[IgxComboState["INVALID"] = 2] = "INVALID";
})(IgxComboState || (IgxComboState = {}));
/**
 * When called with sets A & B, returns A - B (as array);
 * @hidden
 */
function diffInSets(set1, set2) {
    const results = [];
    set1.forEach(entry => {
        if (!set2.has(entry)) {
            results.push(entry);
        }
    });
    return results;
}
let NEXT_ID$m = 0;
const noop$6 = () => { };
const ɵ0$7 = noop$6;
let IgxComboComponent = IgxComboComponent_1 = class IgxComboComponent extends DisplayDensityBase {
    constructor(elementRef, cdr, selection, comboAPI, _displayDensityOptions, _injector) {
        super(_displayDensityOptions);
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.selection = selection;
        this.comboAPI = comboAPI;
        this._displayDensityOptions = _displayDensityOptions;
        this._injector = _injector;
        /**
         * @hidden @internal
         */
        this.customValueFlag = true;
        /**
         * @hidden @internal
         */
        this.defaultFallbackGroup = 'Other';
        this.stringFilters = IgxStringFilteringOperand;
        this.booleanFilters = IgxBooleanFilteringOperand;
        this._groupKey = '';
        this._prevInputValue = '';
        this._dataType = '';
        this.ngControl = null;
        this.destroy$ = new Subject();
        this._data = [];
        this._filteredData = [];
        this._itemHeight = null;
        this._itemsMaxHeight = null;
        this._remoteSelection = {};
        this._onChangeCallback = noop$6;
        this._onTouchedCallback = noop$6;
        this._overlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludePositionTarget: true
        };
        this._value = '';
        this._valid = IgxComboState.INITIAL;
        /**
         * Set custom overlay settings that control how the combo's list of items is displayed.
         * Set:
         * ```html
         * <igx-combo [overlaySettings] = "customOverlaySettings"></igx-combo>
         * ```
         *
         * ```typescript
         *  const customSettings = { positionStrategy: { settings: { target: myTarget } } };
         *  combo.overlaySettings = customSettings;
         * ```
         * Get any custom overlay settings used by the combo:
         * ```typescript
         *  const comboOverlaySettings: OverlaySettings = myCombo.overlaySettings;
         * ```
         */
        this.overlaySettings = null;
        /**
         * @hidden @internal
         */
        this.searchInput = null;
        /**
         * The custom template, if any, that should be used when rendering ITEMS in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.itemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboItem>
         *          <div class="custom-item" let-item let-key="valueKey">
         *              <div class="custom-item__name">{{ item[key] }}</div>
         *              <div class="custom-item__cost">{{ item.cost }}</div>
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.itemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeader>
         *          <div class="combo__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboFooter>
         *          <div class="combo__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.footerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
         *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.headerItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.addItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboAddItem>
         *          <button class="combo__add-button">
         *              Click to add item
         *          </button>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.addItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.emptyTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboEmpty>
         *          <div class="combo--empty">
         *              There are no items to display
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.emptyTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo CLEAR button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.clearIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboClearIcon>
         *          <igx-icon>clear</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        this.clearIconTemplate = null;
        this.dropdownContainer = null;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
         * ```
         */
        this.onSelectionChange = new EventEmitter();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-combo onOpening='handleOpening($event)'></igx-combo>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-combo (onOpened)='handleOpened()'></igx-combo>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosed)='handleClosed()'></igx-combo>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when an item is being added to the data collection
         *
         * ```html
         * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
         * ```
         */
        this.onAddition = new EventEmitter();
        /**
         * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
         *
         * ```html
         * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
         * ```
         */
        this.onSearchInput = new EventEmitter();
        /**
         * Emitted when new chunk of data is loaded from the virtualization
         *
         * ```html
         * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
         * ```
         */
        this.onDataPreLoad = new EventEmitter();
        /**
         * Gets/gets combo id.
         *
         * ```typescript
         * // get
         * let id = this.combo.id;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [id]='combo1'></igx-combo>
         * ```
         */
        this.id = `igx-combo-${NEXT_ID$m++}`;
        /**
         * @hidden @internal
         */
        this.cssClass = 'igx-combo'; // Independent of display density, at the time being
        /**
         * @hidden @internal
         */
        this.role = 'combobox';
        /**
         * Controls whether custom values can be added to the collection
         *
         * ```typescript
         * // get
         * let comboAllowsCustomValues = this.combo.allowCustomValues;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [allowCustomValues]='true'></igx-combo>
         * ```
         */
        this.allowCustomValues = false;
        /**
         * @hidden @internal
         */
        this.filteringLogic = FilteringLogic.Or;
        /**
         * Defines the placeholder value for the combo dropdown search field
         *
         * ```typescript
         * // get
         * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
         * ```
         */
        this.searchPlaceholder = 'Enter a Search Term';
        /**
         * Combo value data source property.
         *
         * ```typescript
         * // get
         * let myComboValueKey = this.combo.valueKey;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [valueKey]='myKey'></igx-combo>
         * ```
         */
        this.valueKey = null;
        /**
         * An @Input property that enabled/disables filtering in the list. The default is `true`.
         * ```html
         * <igx-combo [filterable]="false">
         * ```
         */
        this.filterable = true;
        /**
         * An @Input property that enabled/disables combo. The default is `false`.
         * ```html
         * <igx-combo [disabled]="'true'">
         * ```
         */
        this.disabled = false;
        /**
         * An @Input property that sets how the combo will be styled.
         * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
         * ```html
         * <igx-combo [type]="'line'">
         * ```
         */
        this.type = 'box';
        /**
         * An @Input property that controls whether the combo's search box
         * should be focused after the `onOpened` event is called
         * When `false`, the combo's list item container will be focused instead
         */
        this.autoFocusSearch = true;
        /**
         * @hidden @internal
         */
        this.searchValue = '';
        this.onStatusChanged = () => {
            if ((this.ngControl.control.touched || this.ngControl.control.dirty) &&
                (this.ngControl.control.validator || this.ngControl.control.asyncValidator)) {
                this.valid = this.ngControl.valid ? IgxComboState.VALID : IgxComboState.INVALID;
            }
            this.manageRequiredAsterisk();
        };
        this.comboAPI.register(this);
    }
    /**
     * @hidden @internal
     */
    get displaySearchInput() {
        return this.filterable || this.allowCustomValues;
    }
    /**
     * @hidden @internal
     */
    get ariaExpanded() {
        return !this.dropdown.collapsed;
    }
    /**
     * @hidden @internal
     */
    get hasPopUp() {
        return 'listbox';
    }
    /**
     * @hidden @internal
     */
    get ariaOwns() {
        return this.dropdown.id;
    }
    /**
     * Configures the drop down list height
     *
     * ```typescript
     * // get
     * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemsMaxHeight]='320'></igx-combo>
     * ```
     */
    get itemsMaxHeight() {
        if (this._itemsMaxHeight === null || this._itemsMaxHeight === undefined) {
            return this.itemHeight * itemsInContainer;
        }
        return this._itemsMaxHeight;
    }
    set itemsMaxHeight(val) {
        this._itemsMaxHeight = val;
    }
    /**
     * Configures the drop down list item height
     *
     * ```typescript
     * // get
     * let myComboItemHeight = this.combo.itemHeight;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [itemHeight]='32'></igx-combo>
     * ```
     */
    get itemHeight() {
        if (this._itemHeight === null || this._itemHeight === undefined) {
            return ItemHeights[this.displayDensity];
        }
        return this._itemHeight;
    }
    set itemHeight(val) {
        this._itemHeight = val;
    }
    /**
     * @hidden @internal
     */
    get inputEmpty() {
        return !this.value && !this.placeholder;
    }
    /**
     * Combo data source.
     *
     * ```html
     * <!--set-->
     * <igx-combo [data]='items'></igx-combo>
     * ```
     */
    get data() {
        return this._data;
    }
    set data(val) {
        this._data = (val) ? val : [];
    }
    set displayKey(val) {
        this._displayKey = val;
    }
    /**
     * Combo text data source property.
     *
     * ```typescript
     * // get
     * let myComboDisplayKey = this.combo.displayKey;
     *
     * // set
     * this.combo.displayKey = 'val';
     *
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-combo [displayKey]='myDisplayKey'></igx-combo>
     * ```
     */
    get displayKey() {
        return this._displayKey ? this._displayKey : this.valueKey;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```html
     * <!--set-->
     * <igx-combo [groupKey]='newGroupKey'></igx-combo>
     * ```
     */
    set groupKey(val) {
        this._groupKey = val;
    }
    /**
     * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
     *
     * ```typescript
     * // get
     * let currentGroupKey = this.combo.groupKey;
     * ```
     */
    get groupKey() {
        return this._groupKey;
    }
    /**
     * Gets if control is valid, when used in a form
     *
     * ```typescript
     * // get
     * let valid = this.combo.valid;
     * ```
     */
    get valid() {
        return this._valid;
    }
    /**
     * Sets if control is valid, when used in a form
     *
     * ```typescript
     * // set
     * this.combo.valid = IgxComboState.INVALID;
     * ```
     */
    set valid(valid) {
        this._valid = valid;
        this.comboInput.valid = IgxInputState[IgxComboState[valid]];
    }
    /**
     * @hidden @internal
     */
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.open();
    }
    /**
     * @hidden @internal
     */
    onInputClick(event) {
        event.stopPropagation();
        event.preventDefault();
        this.toggle();
    }
    /**
     * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
     *
     * ```typescript
     * // get
     * let state = this.combo.virtualizationState;
     * ```
     */
    get virtualizationState() {
        return this.virtDir.state;
    }
    /**
     * Sets the current state of the virtualized data.
     *
     * ```typescript
     * // set
     * this.combo.virtualizationState(state);
     * ```
     */
    set virtualizationState(state) {
        this.virtDir.state = state;
    }
    /**
     * Gets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // get
     * let count = this.combo.totalItemCount;
     * ```
     */
    get totalItemCount() {
        return this.virtDir.totalItemCount;
    }
    /**
     * Sets total count of the virtual data items, when using remote service.
     *
     * ```typescript
     * // set
     * this.combo.totalItemCount(remoteService.count);
     * ```
     */
    set totalItemCount(count) {
        this.virtDir.totalItemCount = count;
    }
    /**
     * The text displayed in the combo input
     *
     * ```typescript
     * // get
     * let comboValue = this.combo.value;
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * @hidden @internal
     */
    get filteredData() {
        return this.filterable ? this._filteredData : this.data;
    }
    /**
     * @hidden @internal
     */
    set filteredData(val) {
        this._filteredData = this.groupKey ? (val || []).filter((e) => e.isHeader !== true) : val;
        this.checkMatch();
    }
    /**
     * @hidden @internal
     */
    handleKeyUp(event) {
        if (event.key === 'ArrowDown' || event.key === 'Down') {
            this.dropdown.focusedItem = this.dropdown.items[0];
            this.dropdownContainer.nativeElement.focus();
        }
        else if (event.key === 'Escape' || event.key === 'Esc') {
            this.toggle();
        }
    }
    /**
     * @hidden @internal
     */
    handleKeyDown(event) {
        if (event.key === 'ArrowUp' || event.key === 'Up') {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    }
    checkMatch() {
        const displayKey = this.displayKey;
        const matchFn = (e) => {
            const value = displayKey ? e[displayKey] : e;
            return value.toString().toLowerCase() === this.searchValue.trim().toLowerCase();
        };
        const itemMatch = this.filteredData.some(matchFn);
        this.customValueFlag = this.allowCustomValues && !itemMatch;
    }
    /**
     * @hidden @internal
     */
    handleInputChange(event) {
        if (event !== undefined) {
            this.onSearchInput.emit(event);
        }
        this.checkMatch();
    }
    /**
     * @hidden @internal
     */
    get dataType() {
        if (this.displayKey) {
            return DataTypes.COMPLEX;
        }
        return DataTypes.PRIMITIVE;
    }
    /**
     * @hidden @internal
     */
    get isRemote() {
        return this.totalItemCount > 0 &&
            this.valueKey &&
            this.dataType === DataTypes.COMPLEX;
    }
    /** Contains key-value pairs of the selected valueKeys and their resp. displayKeys */
    registerRemoteEntries(ids, add = true) {
        if (add) {
            const selection = this.getValueDisplayPairs(ids);
            for (const entry of selection) {
                this._remoteSelection[entry[this.valueKey]] = entry[this.displayKey];
            }
        }
        else {
            for (const entry of ids) {
                delete this._remoteSelection[entry];
            }
        }
    }
    /**
     * For `id: any[]` returns a mapped `{ [combo.valueKey]: any, [combo.displayKey]: any }[]`
     */
    getValueDisplayPairs(ids) {
        return this.data.filter(entry => ids.indexOf(entry[this.valueKey]) > -1).map(e => {
            return {
                [this.valueKey]: e[this.valueKey],
                [this.displayKey]: e[this.displayKey]
            };
        });
    }
    /**
     * Returns if the specified itemID is selected
     * @hidden
     * @internal
     */
    isItemSelected(item) {
        return this.selection.is_item_selected(this.id, item);
    }
    /**
     * Triggers change detection on the combo view
     */
    triggerCheck() {
        this.cdr.detectChanges();
    }
    /**
     * @hidden @internal
     */
    isAddButtonVisible() {
        // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
        return this.searchValue !== '' && this.customValueFlag;
    }
    /**
     * @hidden @internal
     */
    handleSelectAll(evt) {
        if (evt.checked) {
            this.selectAllItems();
        }
        else {
            this.deselectAllItems();
        }
    }
    /**
     * @hidden @internal
     */
    addItemToCollection() {
        if (!this.searchValue) {
            return;
        }
        const newValue = this.searchValue.trim();
        const addedItem = this.displayKey ? {
            [this.valueKey]: newValue,
            [this.displayKey]: newValue
        } : newValue;
        if (this.groupKey) {
            Object.assign(addedItem, { [this.groupKey]: this.defaultFallbackGroup });
        }
        const oldCollection = this.data;
        const newCollection = [...this.data];
        newCollection.push(addedItem);
        const args = {
            oldCollection, addedItem, newCollection
        };
        this.onAddition.emit(args);
        this.data.push(addedItem);
        // If you mutate the array, no pipe is invoked and the display isn't updated;
        // if you replace the array, the pipe executes and the display is updated.
        this.data = cloneArray(this.data);
        this.selectItems(this.comboAPI.valueKey !== null ? [addedItem[this.valueKey]] : [addedItem], false);
        this.customValueFlag = false;
        this.searchInput.nativeElement.focus();
        this.dropdown.focusedItem = null;
        this.virtDir.scrollTo(0);
    }
    /**
     * @hidden @internal
     */
    focusSearchInput(opening) {
        if (this.displaySearchInput && this.searchInput) {
            this.searchInput.nativeElement.focus();
        }
        else {
            if (opening) {
                this.dropdownContainer.nativeElement.focus();
            }
            else {
                this.comboInput.nativeElement.focus();
                this.toggle();
            }
        }
    }
    manageRequiredAsterisk() {
        if (this.ngControl && this.ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this.ngControl.control.validator({});
            this.inputGroup.isRequired = error && error.required;
        }
    }
    /**
     * @hidden @internal
     */
    onBlur() {
        if (this.collapsed) {
            this._onTouchedCallback();
            if (this.ngControl && !this.ngControl.valid) {
                this.valid = IgxComboState.INVALID;
            }
            else {
                this.valid = IgxComboState.INITIAL;
            }
        }
    }
    /** @hidden @internal */
    onFocus() {
        if (this.collapsed) {
            this._onTouchedCallback();
        }
    }
    /**
     * @hidden @internal
     */
    ngOnInit() {
        this.ngControl = this._injector.get(NgControl, null);
        this._overlaySettings.positionStrategy.settings.target = this.elementRef.nativeElement;
        this.selection.set(this.id, new Set());
    }
    /**
     * @hidden @internal
     */
    ngAfterViewInit() {
        this.filteredData = [...this.data];
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged);
            this.manageRequiredAsterisk();
            this.cdr.detectChanges();
        }
        this.virtDir.onChunkPreload.pipe(takeUntil(this.destroy$)).subscribe((e) => {
            this.onDataPreLoad.emit(e);
        });
    }
    /**
     * @hidden @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.comboAPI.clear();
        this.selection.clear(this.id);
    }
    /**
     * @hidden @internal
     */
    writeValue(value) {
        this.selectItems(value, true);
        this.cdr.markForCheck();
    }
    /**
     * @hidden @internal
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden @internal
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden @internal
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @hidden
     */
    getEditElement() {
        return this.comboInput.nativeElement;
    }
    /**
     * @hidden @internal
     */
    get template() {
        this._dataType = this.dataType;
        if (this.itemTemplate) {
            return this.itemTemplate;
        }
        if (this._dataType === DataTypes.COMPLEX) {
            return this.complexTemplate;
        }
        return this.primitiveTemplate;
    }
    /**
     * @hidden @internal
     */
    get context() {
        return {
            $implicit: this
        };
    }
    /**
     * @hidden @internal
     */
    handleClearItems(event) {
        this.deselectAllItems(true, event);
        if (this.collapsed) {
            this.getEditElement().focus();
        }
        else {
            this.focusSearchInput(true);
        }
        event.stopPropagation();
    }
    /**
     * A method that opens/closes the combo.
     *
     * ```html
     * <button (click)="combo.toggle()">Toggle Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    toggle() {
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.toggle(overlaySettings);
    }
    /**
     * A method that opens the combo.
     *
     * ```html
     * <button (click)="combo.open()">Open Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    open() {
        const overlaySettings = Object.assign({}, this._overlaySettings, this.overlaySettings);
        this.dropdown.open(overlaySettings);
    }
    /**
     * A method that closes the combo.
     *
     * ```html
     * <button (click)="combo.close()">Close Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     */
    close() {
        this.dropdown.close();
    }
    /**
     * Gets drop down state.
     *
     * ```typescript
     * let state = this.combo.collapsed;
     * ```
     */
    get collapsed() {
        return this.dropdown.collapsed;
    }
    /**
     * Get current selection state
     * @returns Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    selectedItems() {
        const items = Array.from(this.selection.get(this.id));
        return items;
    }
    /**
     * Select defined items
     * @param newItems new items to be selected
     * @param clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     */
    selectItems(newItems, clearCurrentSelection, event) {
        if (newItems) {
            const newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Deselect defined items
     * @param items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     */
    deselectItems(items, event) {
        if (items) {
            const newSelection = this.selection.delete_items(this.id, items);
            this.setSelection(newSelection, event);
        }
    }
    /**
     * Select all (filtered) items
     * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     */
    selectAllItems(ignoreFilter, event) {
        const allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData, this.valueKey);
        const newSelection = this.selection.add_items(this.id, allVisible);
        this.setSelection(newSelection, event);
    }
    /**
     * Deselect all (filtered) items
     * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     */
    deselectAllItems(ignoreFilter, event) {
        let newSelection = this.selection.get_empty();
        if (this.filteredData.length !== this.data.length && !ignoreFilter) {
            newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData, this.valueKey));
        }
        this.setSelection(newSelection, event);
    }
    /**
     * Selects/Deselects a single item
     * @param itemID the itemID of the specific item
     * @param select If the item should be selected (true) or deselected (false)
     *
     * Without specified valueKey;
     * ```typescript
     * this.combo.valueKey = null;
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem(items[0], true);
     * ```
     * With specified valueKey;
     * ```typescript
     * this.combo.valueKey = 'field';
     * const items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * ```
     */
    setSelectedItem(itemID, select = true, event) {
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (select) {
            this.selectItems([itemID], false, event);
        }
        else {
            this.deselectItems([itemID], event);
        }
    }
    setSelection(newSelection, event) {
        const removed = diffInSets(this.selection.get(this.id), newSelection);
        const added = diffInSets(newSelection, this.selection.get(this.id));
        const newSelectionAsArray = Array.from(newSelection);
        const oldSelectionAsArray = Array.from(this.selection.get(this.id) || []);
        const displayText = this.createDisplayText(newSelectionAsArray, oldSelectionAsArray);
        const args = {
            newSelection: newSelectionAsArray,
            oldSelection: oldSelectionAsArray,
            added,
            removed,
            event,
            displayText,
            cancel: false
        };
        this.onSelectionChange.emit(args);
        if (!args.cancel) {
            this.selection.select_items(this.id, args.newSelection, true);
            if (displayText !== args.displayText) {
                this._value = args.displayText;
            }
            else {
                this._value = this.createDisplayText(args.newSelection, args.oldSelection);
            }
            this._onChangeCallback(args.newSelection);
        }
    }
    /** Returns a string that should be populated in the combo's text box */
    concatDisplayText(selection) {
        const value = this.displayKey !== null && this.displayKey !== undefined ?
            this.convertKeysToItems(selection).map(entry => entry[this.displayKey]).join(', ') :
            selection.join(', ');
        return value;
    }
    /**
     * Constructs the combo display value
     * If remote, caches the key displayText
     * If not, just combine the object.displayKeys
     */
    createDisplayText(newSelection, oldSelection) {
        let value = '';
        if (this.isRemote) {
            if (newSelection.length) {
                const removedItems = oldSelection.filter(e => newSelection.indexOf(e) < 0);
                const addedItems = newSelection.filter(e => oldSelection.indexOf(e) < 0);
                this.registerRemoteEntries(addedItems);
                this.registerRemoteEntries(removedItems, false);
                value = Object.keys(this._remoteSelection).map(e => this._remoteSelection[e]).join(', ');
            }
            else {
                // If new selection is empty, clear all items
                this.registerRemoteEntries(oldSelection, false);
            }
        }
        else {
            value = this.concatDisplayText(newSelection);
        }
        return value;
    }
    /** if there is a valueKey - map the keys to data items, else - just return the keys */
    convertKeysToItems(keys) {
        if (this.comboAPI.valueKey === null) {
            return keys;
        }
        // map keys vs. filter data to retain the order of the selected items
        return keys.map(key => this.data.find(entry => entry[this.valueKey] === key)).filter(e => e !== undefined);
    }
    /**
     * Event handlers
     * @hidden
     * @internal
     */
    handleOpening(event) {
        this.onOpening.emit(event);
        if (event.cancel) {
            return;
        }
    }
    /**
     * @hidden @internal
     */
    handleOpened() {
        this.triggerCheck();
        // Disabling focus of the search input should happen only when drop down opens.
        // During keyboard navigation input should receive focus, even the autoFocusSearch is disabled.
        // That is why in such cases focusing of the dropdownContainer happens outside focusSearchInput method.
        if (this.autoFocusSearch) {
            this.focusSearchInput(true);
        }
        else {
            this.dropdownContainer.nativeElement.focus();
        }
        this.onOpened.emit();
    }
    /**
     * @hidden @internal
     */
    handleClosing(event) {
        this.onClosing.emit(event);
        if (event.cancel) {
            return;
        }
        this.searchValue = '';
        this.comboInput.nativeElement.focus();
    }
    /**
     * @hidden @internal
     */
    handleClosed() {
        this.onClosed.emit();
    }
};
IgxComboComponent.ɵfac = function IgxComboComponent_Factory(t) { return new (t || IgxComboComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(IgxSelectionAPIService), ɵngcc0.ɵɵdirectiveInject(IgxComboAPIService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector, 8)); };
IgxComboComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxComboComponent, selectors: [["igx-combo"]], contentQueries: function IgxComboComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboItemDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboHeaderDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboFooterDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboHeaderItemDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboAddItemDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboEmptyDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboToggleIconDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxComboClearIconDirective, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerItemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.addItemTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.emptyTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleIconTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clearIconTemplate = _t.first);
    } }, viewQuery: function IgxComboComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c188, true);
        ɵngcc0.ɵɵstaticViewQuery(_c189, true);
        ɵngcc0.ɵɵstaticViewQuery(IgxForOfDirective, true, IgxForOfDirective);
        ɵngcc0.ɵɵstaticViewQuery(_c98, true, IgxInputGroupComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c190, true, IgxInputDirective);
        ɵngcc0.ɵɵstaticViewQuery(IgxComboDropDownComponent, true, IgxComboDropDownComponent);
        ɵngcc0.ɵɵstaticViewQuery(_c191, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c192, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(IgxForOfDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtDir = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.comboInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdown = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.primitiveTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.complexTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.virtualScrollContainer = _t.first);
    } }, hostVars: 10, hostBindings: function IgxComboComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.ArrowDown", function IgxComboComponent_keydown_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); })("keydown.Alt.ArrowDown", function IgxComboComponent_keydown_Alt_ArrowDown_HostBindingHandler($event) { return ctx.onArrowDown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("role", ctx.role)("aria-expanded", ctx.ariaExpanded)("aria-haspopup", ctx.hasPopUp)("aria-owns", ctx.ariaOwns)("aria-labelledby", ctx.ariaLabelledBy);
        ɵngcc0.ɵɵstyleProp("width", ctx.width);
        ɵngcc0.ɵɵclassProp("igx-combo", ctx.cssClass);
    } }, inputs: { overlaySettings: "overlaySettings", id: "id", allowCustomValues: "allowCustomValues", searchPlaceholder: "searchPlaceholder", valueKey: "valueKey", filterable: "filterable", disabled: "disabled", type: "type", autoFocusSearch: "autoFocusSearch", itemsMaxHeight: "itemsMaxHeight", itemHeight: "itemHeight", data: "data", displayKey: "displayKey", groupKey: "groupKey", width: "width", itemsWidth: "itemsWidth", placeholder: "placeholder", ariaLabelledBy: "ariaLabelledBy" }, outputs: { onSelectionChange: "onSelectionChange", onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed", onAddition: "onAddition", onSearchInput: "onSearchInput", onDataPreLoad: "onDataPreLoad" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxComboAPIService,
            { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent_1 },
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxComboComponent_1, multi: true }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c196, decls: 37, vars: 34, consts: [[3, "displayDensity", "type", "click"], ["inputGroup", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["ngProjectAs", "igx-prefix", 5, ["igx-prefix"]], ["ngProjectAs", "igx-hint, [igxHint]", 5, ["igx-hint"]], ["igxInput", "", "name", "comboInput", "type", "text", "readonly", "", 3, "value", "disabled", "blur", "focus"], ["comboInput", ""], ["ngProjectAs", "igx-suffix", 5, ["igx-suffix"]], ["aria-label", "Clear Selection", "class", "igx-combo__clear-button", 3, "click", 4, "ngIf"], ["igxButton", "icon", "igxRipple", "", 1, "igx-combo__toggle-button"], [4, "ngIf"], ["fontSet", "material", 4, "ngIf"], [1, "igx-combo__drop-down", 3, "displayDensity", "width", "onOpening", "onClosing", "onOpened", "onClosed"], ["igxComboDropDown", ""], ["class", "igx-combo__search", 3, "displayDensity", 4, "ngIf"], [4, "ngTemplateOutlet"], ["role", "listbox", 1, "igx-combo__content", 3, "igxDropDownItemNavigation", "tabindex", "focus"], ["dropdownItemContainer", ""], ["role", "option", 3, "itemHeight", "value", "isHeader", "index", 4, "igxFor", "igxForOf", "igxForContainerSize", "igxForScrollOrientation", "igxForItemSize"], ["class", "igx-combo__add", 4, "ngIf"], ["complex", ""], ["primitive", ""], ["empty", ""], ["addItemDefault", ""], ["headerItemBase", ""], ["aria-label", "Clear Selection", 1, "igx-combo__clear-button", 3, "click"], ["fontSet", "material"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "igx-combo__search", 3, "displayDensity"], ["igxInput", "", "name", "searchInput", "autocomplete", "off", "type", "text", "aria-autocomplete", "both", 1, "igx-combo-input", 3, "ngModel", "ngModelChange", "keyup", "keydown", "focus"], ["searchInput", ""], ["role", "option", 3, "itemHeight", "value", "isHeader", "index"], ["listItem", ""], [1, "igx-combo__add"], ["class", "igx-combo__empty", 4, "ngIf"], ["class", "igx-combo__add-item", "role", "button", "aria-label", "Add Item", 3, "itemHeight", "tabindex", "index", 4, "ngIf"], [1, "igx-combo__empty"], ["role", "button", "aria-label", "Add Item", 1, "igx-combo__add-item", 3, "itemHeight", "tabindex", "index"], ["igxButton", "flat", "igxRipple", ""]], template: function IgxComboComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c195);
        ɵngcc0.ɵɵelementStart(0, "igx-input-group", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxComboComponent_Template_igx_input_group_click_0_listener($event) { return ctx.onInputClick($event); });
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainerStart(4, 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementContainerStart(6, 4);
        ɵngcc0.ɵɵprojection(7, 2);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementStart(8, "input", 5, 6);
        ɵngcc0.ɵɵlistener("blur", function IgxComboComponent_Template_input_blur_8_listener() { return ctx.onBlur(); })("focus", function IgxComboComponent_Template_input_focus_8_listener() { return ctx.onFocus(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementContainerStart(10, 7);
        ɵngcc0.ɵɵprojection(11, 3);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵtemplate(12, IgxComboComponent_igx_suffix_12_Template, 3, 2, "igx-suffix", 8);
        ɵngcc0.ɵɵelementStart(13, "igx-suffix", 9);
        ɵngcc0.ɵɵtemplate(14, IgxComboComponent_ng_container_14_Template, 2, 4, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(15, IgxComboComponent_igx_icon_15_Template, 2, 1, "igx-icon", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(16, "igx-combo-drop-down", 12, 13);
        ɵngcc0.ɵɵlistener("onOpening", function IgxComboComponent_Template_igx_combo_drop_down_onOpening_16_listener($event) { return ctx.handleOpening($event); })("onClosing", function IgxComboComponent_Template_igx_combo_drop_down_onClosing_16_listener($event) { return ctx.handleClosing($event); })("onOpened", function IgxComboComponent_Template_igx_combo_drop_down_onOpened_16_listener() { return ctx.handleOpened(); })("onClosed", function IgxComboComponent_Template_igx_combo_drop_down_onClosed_16_listener() { return ctx.handleClosed(); });
        ɵngcc0.ɵɵtemplate(18, IgxComboComponent_igx_input_group_18_Template, 3, 5, "igx-input-group", 14);
        ɵngcc0.ɵɵtemplate(19, IgxComboComponent_ng_container_19_Template, 1, 0, "ng-container", 15);
        ɵngcc0.ɵɵelementStart(20, "div", 16, 17);
        ɵngcc0.ɵɵlistener("focus", function IgxComboComponent_Template_div_focus_20_listener() { return ctx.dropdown.onFocus(); });
        ɵngcc0.ɵɵtemplate(22, IgxComboComponent_igx_combo_item_22_Template, 3, 6, "igx-combo-item", 18);
        ɵngcc0.ɵɵpipe(23, "comboGrouping");
        ɵngcc0.ɵɵpipe(24, "comboFiltering");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(25, IgxComboComponent_div_25_Template, 3, 2, "div", 19);
        ɵngcc0.ɵɵtemplate(26, IgxComboComponent_ng_container_26_Template, 1, 0, "ng-container", 15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(27, IgxComboComponent_ng_template_27_Template, 1, 1, "ng-template", null, 20, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(29, IgxComboComponent_ng_template_29_Template, 1, 1, "ng-template", null, 21, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(31, IgxComboComponent_ng_template_31_Template, 2, 0, "ng-template", null, 22, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(33, IgxComboComponent_ng_template_33_Template, 2, 0, "ng-template", null, 23, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(35, IgxComboComponent_ng_template_35_Template, 1, 1, "ng-template", null, 24, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("type", ctx.type);
        ɵngcc0.ɵɵadvance(8);
        ɵngcc0.ɵɵproperty("value", ctx.value)("disabled", ctx.disabled);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.value.length);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.toggleIconTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("displayDensity", ctx.displayDensity)("width", ctx.itemsWidth || "100%");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.displaySearchInput);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.headerTemplate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("overflow", "hidden")("max-height", ctx.itemsMaxHeight, "px");
        ɵngcc0.ɵɵproperty("igxDropDownItemNavigation", ctx.dropdown)("tabindex", ctx.dropdown.collapsed ? 0 - 1 : 0);
        ɵngcc0.ɵɵattribute("id", ctx.dropdown.id);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("igxForOf", ɵngcc0.ɵɵpipeBind3(23, 25, ɵngcc0.ɵɵpipeBind4(24, 29, ctx.data, ctx.searchValue, ctx.displayKey, ctx.filterable), ctx.groupKey, ctx.valueKey))("igxForContainerSize", ctx.itemsMaxHeight)("igxForScrollOrientation", "vertical")("igxForItemSize", ctx.itemHeight);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteredData.length === 0 || ctx.isAddButtonVisible());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.footerTemplate);
    } }, directives: [IgxInputGroupComponent,
        IgxInputDirective, ɵngcc2.NgIf, IgxSuffixDirective,
        IgxButtonDirective,
        IgxRippleDirective,
        IgxComboDropDownComponent, ɵngcc2.NgTemplateOutlet, IgxDropDownItemNavigationDirective,
        IgxForOfDirective,
        IgxIconComponent, ɵngcc3.DefaultValueAccessor, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxComboItemComponent,
        IgxComboAddItemComponent], pipes: [IgxComboGroupingPipe,
        IgxComboFilteringPipe], encapsulation: 2 });
IgxComboComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: IgxSelectionAPIService },
    { type: IgxComboAPIService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: Injector, decorators: [{ type: Optional }] }
];
__decorate([
    ViewChild(IgxForOfDirective, { read: IgxForOfDirective, static: true })
], IgxComboComponent.prototype, "virtDir", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "overlaySettings", void 0);
__decorate([
    ViewChild('inputGroup', { read: IgxInputGroupComponent, static: true })
], IgxComboComponent.prototype, "inputGroup", void 0);
__decorate([
    ViewChild('comboInput', { read: IgxInputDirective, static: true })
], IgxComboComponent.prototype, "comboInput", void 0);
__decorate([
    ViewChild(IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true })
], IgxComboComponent.prototype, "dropdown", void 0);
__decorate([
    ViewChild('searchInput')
], IgxComboComponent.prototype, "searchInput", void 0);
__decorate([
    ContentChild(IgxComboItemDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "itemTemplate", void 0);
__decorate([
    ContentChild(IgxComboHeaderDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "headerTemplate", void 0);
__decorate([
    ContentChild(IgxComboFooterDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "footerTemplate", void 0);
__decorate([
    ContentChild(IgxComboHeaderItemDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "headerItemTemplate", void 0);
__decorate([
    ContentChild(IgxComboAddItemDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "addItemTemplate", void 0);
__decorate([
    ContentChild(IgxComboEmptyDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "emptyTemplate", void 0);
__decorate([
    ContentChild(IgxComboToggleIconDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "toggleIconTemplate", void 0);
__decorate([
    ContentChild(IgxComboClearIconDirective, { read: TemplateRef })
], IgxComboComponent.prototype, "clearIconTemplate", void 0);
__decorate([
    ViewChild('primitive', { read: TemplateRef, static: true })
], IgxComboComponent.prototype, "primitiveTemplate", void 0);
__decorate([
    ViewChild('complex', { read: TemplateRef, static: true })
], IgxComboComponent.prototype, "complexTemplate", void 0);
__decorate([
    ViewChild(IgxForOfDirective, { static: true })
], IgxComboComponent.prototype, "virtualScrollContainer", void 0);
__decorate([
    ViewChild('dropdownItemContainer', { static: true })
], IgxComboComponent.prototype, "dropdownContainer", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onSelectionChange", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onOpening", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onClosing", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onClosed", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onAddition", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onSearchInput", void 0);
__decorate([
    Output()
], IgxComboComponent.prototype, "onDataPreLoad", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxComboComponent.prototype, "id", void 0);
__decorate([
    HostBinding('style.width'),
    Input()
], IgxComboComponent.prototype, "width", void 0);
__decorate([
    HostBinding('class.igx-combo')
], IgxComboComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding(`attr.role`)
], IgxComboComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.aria-expanded')
], IgxComboComponent.prototype, "ariaExpanded", null);
__decorate([
    HostBinding('attr.aria-haspopup')
], IgxComboComponent.prototype, "hasPopUp", null);
__decorate([
    HostBinding('attr.aria-owns')
], IgxComboComponent.prototype, "ariaOwns", null);
__decorate([
    Input()
], IgxComboComponent.prototype, "allowCustomValues", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "itemsMaxHeight", null);
__decorate([
    Input()
], IgxComboComponent.prototype, "itemsWidth", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "itemHeight", null);
__decorate([
    Input()
], IgxComboComponent.prototype, "placeholder", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "searchPlaceholder", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "data", null);
__decorate([
    Input()
], IgxComboComponent.prototype, "valueKey", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "displayKey", null);
__decorate([
    Input()
], IgxComboComponent.prototype, "groupKey", null);
__decorate([
    Input()
], IgxComboComponent.prototype, "filterable", void 0);
__decorate([
    Input(),
    HostBinding('attr.aria-labelledby')
], IgxComboComponent.prototype, "ariaLabelledBy", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxComboComponent.prototype, "autoFocusSearch", void 0);
__decorate([
    HostListener('keydown.ArrowDown', ['$event']),
    HostListener('keydown.Alt.ArrowDown', ['$event'])
], IgxComboComponent.prototype, "onArrowDown", null);
IgxComboComponent = IgxComboComponent_1 = __decorate([ __param(4, Optional()), __param(4, Inject(DisplayDensityToken)),
    __param(5, Optional())
], IgxComboComponent);
/**
 * @hidden
 */
let IgxComboModule = class IgxComboModule {
};
IgxComboModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxComboModule });
IgxComboModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxComboModule_Factory(t) { return new (t || IgxComboModule)(); }, imports: [[IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
            IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]] });

/**
 * @hidden
 */
let IgxDialogTitleDirective = class IgxDialogTitleDirective {
    constructor() {
        this.defaultStyle = true;
    }
};
IgxDialogTitleDirective.ɵfac = function IgxDialogTitleDirective_Factory(t) { return new (t || IgxDialogTitleDirective)(); };
IgxDialogTitleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDialogTitleDirective, selectors: [["igx-dialog-title"], ["", "igxDialogTitle", ""]], hostVars: 2, hostBindings: function IgxDialogTitleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-dialog__window-title", ctx.defaultStyle);
    } } });
__decorate([
    HostBinding('class.igx-dialog__window-title')
], IgxDialogTitleDirective.prototype, "defaultStyle", void 0);
/**
 * @hidden
 */
let IgxDialogActionsDirective = class IgxDialogActionsDirective {
    constructor() {
        this.defaultClass = true;
    }
};
IgxDialogActionsDirective.ɵfac = function IgxDialogActionsDirective_Factory(t) { return new (t || IgxDialogActionsDirective)(); };
IgxDialogActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDialogActionsDirective, selectors: [["igx-dialog-actions"], ["", "igxDialogActions", ""]], hostVars: 2, hostBindings: function IgxDialogActionsDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-dialog__window-actions", ctx.defaultClass);
    } } });
__decorate([
    HostBinding('class.igx-dialog__window-actions')
], IgxDialogActionsDirective.prototype, "defaultClass", void 0);

var IgxDialogComponent_1;
let DIALOG_ID = 0;
/**
 * **Ignite UI for Angular Dialog Window** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
 *
 * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
 * more complicated visuals such as a user sign-in form.  It also provides a right and left button
 * which can be used for custom actions.
 *
 * Example:
 * ```html
 * <button (click)="form.open()">Show Dialog</button>
 * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
 *   <div>
 *     <input type="text" igxInput/>
 *     <label igxLabel>Username</label>
 *   </div>
 *   <div>
 *     <input type="password" igxInput/>
 *     <label igxLabel>Password</label>
 *   </div>
 * </igx-dialog>
 * ```
 */
let IgxDialogComponent = IgxDialogComponent_1 = class IgxDialogComponent {
    constructor(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification"
         *  leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()">
         * </igx-dialog>
         * ```
         */
        this.id = `igx-dialog-${DIALOG_ID++}`;
        /**
         * An @Input property controlling the `title` of the dialog.
         * ```html
         * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.title = '';
        /**
         *  An @Input property controlling the `message` of the dialog.
         * ```html
         * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.message = '';
        /**
         * An @Input property to set the `label` of the left button of the dialog.
         * ```html
         * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonLabel = '';
        /**
         * An @Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonType = 'flat';
        /**
         * An @Input property to set the left button color. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonColor = '';
        /**
         * An @Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonBackgroundColor = '';
        /**
         * An @Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
         * The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonRipple = '';
        /**
         * An @Input property to set the `label` of the right button of the dialog.
         * ```html
         * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonLabel = '';
        /**
         * An @Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonType = 'flat';
        /**
         * An @Input property to set the right button `color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonColor = '';
        /**
         * An @Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonBackgroundColor = '';
        /**
         * An @Input property to set the right button `ripple`.
         * ```html
         * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonRipple = '';
        /**
         * An event that is emitted when the dialog is opened.
         * ```html
         * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onOpen = new EventEmitter();
        /**
         * An event that is emitted when the dialog is closed.
         * ```html
         * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onClose = new EventEmitter();
        /**
         * An event that is emitted when the left button is clicked.
         * ```html
         * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
         * </igx-dialog>
         * ```
         */
        this.onLeftButtonSelect = new EventEmitter();
        /**
         * An event that is emitted when the right button is clicked.
         * ```html
         * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
         * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
         * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
         * </igx-dialog>
         * ```
         */
        this.onRightButtonSelect = new EventEmitter();
        this._positionSettings = {
            openAnimation: useAnimation(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
            closeAnimation: useAnimation(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
        };
        this._closeOnOutsideSelect = false;
        this._isModal = true;
        this.destroy$ = new Subject();
        /**
         * The default `tabindex` attribute for the component
         *
         * @hidden
         */
        this.tabindex = -1;
        this._titleId = IgxDialogComponent_1.NEXT_ID++ + '_title';
        this._overlayDefaultSettings = {
            positionStrategy: new GlobalPositionStrategy(this._positionSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: this.isModal,
            closeOnOutsideClick: this.closeOnOutsideSelect
        };
    }
    get isModal() {
        return this._isModal;
    }
    set isModal(val) {
        this._overlayDefaultSettings.modal = val;
        this._isModal = val;
    }
    /**
     * An @Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
     * ```html
     * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
     * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
     * </igx-dialog>
     * ```
     */
    get closeOnOutsideSelect() {
        return this._closeOnOutsideSelect;
    }
    set closeOnOutsideSelect(val) {
        this._overlayDefaultSettings.closeOnOutsideClick = val;
        this._closeOnOutsideSelect = val;
    }
    /**
     * Get the position and animation settings used by the dialog.
     * ```typescript
     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     * let currentPosition: PositionSettings = this.alert.positionSettings
     * ```
     */
    get positionSettings() {
        return this._positionSettings;
    }
    /**
     * Set the position and animation settings used by the dialog.
     * ```typescript
     * import { slideInLeft, slideOutRight } from 'igniteui-angular';
     * ...
     * @ViewChild('alert', { static: true }) public alert: IgxDialogComponent;
     *  public newPositionSettings: PositionSettings = {
     *      openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }),
     *      closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }),
     *      horizontalDirection: HorizontalAlignment.Left,
     *      verticalDirection: VerticalAlignment.Middle,
     *      horizontalStartPoint: HorizontalAlignment.Left,
     *      verticalStartPoint: VerticalAlignment.Middle,
     *      minSize: { height: 100, width: 100 }
     *  };
     * this.alert.positionSettings = this.newPositionSettings;
     * ```
     */
    set positionSettings(settings) {
        this._positionSettings = settings;
        this._overlayDefaultSettings.positionStrategy = new GlobalPositionStrategy(this._positionSettings);
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Returns the value of state. Possible state values are "open" or "close".
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogState = this.dialog.state;
     * }
     * ```
     */
    get state() {
        return this.isOpen ? 'open' : 'close';
    }
    /**
     * Returns whether the dialog is visible to the end user.
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogOpen = this.dialog.isOpen;
     * }
     * ```
     */
    get isOpen() {
        return !this.toggleRef.collapsed;
    }
    get isCollapsed() {
        return this.toggleRef.collapsed;
    }
    /**
     * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
     * ```typescript
     * @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogRole = this.dialog.role;
     * }
     *  ```
     */
    get role() {
        if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
            return 'dialog';
        }
        else if (this.leftButtonLabel !== '' ||
            this.rightButtonLabel !== '') {
            return 'alertdialog';
        }
        else {
            return 'alert';
        }
    }
    /**
     * Returns the value of the title id.
     * ```typescript
     *  @ViewChild("MyDialog")
     * public dialog: IgxDialogComponent;
     * ngAfterViewInit() {
     *     let dialogTitle = this.dialog.titleId;
     * }
     * ```
     */
    get titleId() {
        return this._titleId;
    }
    ngAfterContentInit() {
        this.toggleRef.onClosing.pipe(takeUntil(this.destroy$)).subscribe(() => this.emitCloseFromDialog());
    }
    emitCloseFromDialog() {
        this.onClose.emit({ dialog: this, event: null });
    }
    /**
     * A method that opens the dialog.
     * @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    open(overlaySettings = this._overlayDefaultSettings) {
        this.toggleRef.open(overlaySettings);
        this.onOpen.emit({ dialog: this, event: null });
        if (!this.leftButtonLabel && !this.rightButtonLabel) {
            this.toggleRef.element.focus();
        }
    }
    /**
     * A method that that closes the dialog.
     *  @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    close() {
        // `onClose` will emit from `toggleRef.onClosing` subscription
        this.toggleRef.close();
    }
    /**
     * A method that opens/closes the dialog.
     * @memberOf {@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     */
    toggle() {
        this.isOpen ? this.close() : this.open();
    }
    /**
     * @hidden
     */
    onDialogSelected(event) {
        event.stopPropagation();
        if (this.isOpen &&
            this.closeOnOutsideSelect &&
            event.target.classList.contains(IgxDialogComponent_1.DIALOG_CLASS)) {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onInternalLeftButtonSelect(event) {
        this.onLeftButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     */
    onInternalRightButtonSelect(event) {
        this.onRightButtonSelect.emit({ dialog: this, event });
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    }
};
IgxDialogComponent.ɵfac = function IgxDialogComponent_Factory(t) { return new (t || IgxDialogComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxDialogComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDialogComponent, selectors: [["igx-dialog"]], viewQuery: function IgxDialogComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(IgxToggleDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleRef = _t.first);
    } }, hostVars: 4, hostBindings: function IgxDialogComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-dialog--hidden", ctx.isCollapsed);
    } }, inputs: { id: "id", title: "title", message: "message", leftButtonLabel: "leftButtonLabel", leftButtonType: "leftButtonType", leftButtonColor: "leftButtonColor", leftButtonBackgroundColor: "leftButtonBackgroundColor", leftButtonRipple: "leftButtonRipple", rightButtonLabel: "rightButtonLabel", rightButtonType: "rightButtonType", rightButtonColor: "rightButtonColor", rightButtonBackgroundColor: "rightButtonBackgroundColor", rightButtonRipple: "rightButtonRipple", isModal: "isModal", closeOnOutsideSelect: "closeOnOutsideSelect", positionSettings: "positionSettings", isOpen: "isOpen", role: "role", titleId: "titleId" }, outputs: { onOpen: "onOpen", onClose: "onClose", onLeftButtonSelect: "onLeftButtonSelect", onRightButtonSelect: "onRightButtonSelect" }, ngContentSelectors: _c198, decls: 10, vars: 8, consts: [["tabindex", "0", "igxToggle", "", 1, "igx-dialog", 3, "click"], ["dialog", ""], [1, "igx-dialog__window"], ["dialogWindow", ""], ["class", "igx-dialog__window-title", 4, "ngIf"], [4, "ngIf"], ["class", "igx-dialog__window-content", 4, "ngIf"], ["class", "igx-dialog__window-actions", 4, "ngIf"], [1, "igx-dialog__window-title"], [1, "igx-dialog__window-content"], [1, "igx-dialog__window-actions"], ["type", "button", 3, "igxFocus", "igxButton", "igxButtonColor", "igxButtonBackground", "igxRipple", "click", 4, "ngIf"], ["type", "button", 3, "igxFocus", "igxButton", "igxButtonColor", "igxButtonBackground", "igxRipple", "click"]], template: function IgxDialogComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c197);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("click", function IgxDialogComponent_Template_div_click_0_listener($event) { return ctx.onDialogSelected($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵtemplate(4, IgxDialogComponent_div_4_Template, 2, 2, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxDialogComponent_5_Template, 1, 0, undefined, 5);
        ɵngcc0.ɵɵtemplate(6, IgxDialogComponent_div_6_Template, 2, 1, "div", 6);
        ɵngcc0.ɵɵtemplate(7, IgxDialogComponent_7_Template, 1, 0, undefined, 5);
        ɵngcc0.ɵɵtemplate(8, IgxDialogComponent_div_8_Template, 3, 2, "div", 7);
        ɵngcc0.ɵɵtemplate(9, IgxDialogComponent_9_Template, 1, 0, undefined, 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-labelledby", ctx.titleId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.leftButtonLabel || ctx.rightButtonLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.leftButtonLabel && !ctx.rightButtonLabel);
    } }, directives: [IgxToggleDirective, ɵngcc2.NgIf, IgxFocusDirective,
        IgxButtonDirective,
        IgxRippleDirective], encapsulation: 2 });
IgxDialogComponent.NEXT_ID = 1;
IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
IgxDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    ViewChild(IgxToggleDirective, { static: true })
], IgxDialogComponent.prototype, "toggleRef", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxDialogComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "isModal", null);
__decorate([
    Input()
], IgxDialogComponent.prototype, "title", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "message", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "leftButtonLabel", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "leftButtonType", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "leftButtonColor", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "leftButtonBackgroundColor", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "leftButtonRipple", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "rightButtonLabel", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "rightButtonType", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "rightButtonColor", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "rightButtonBackgroundColor", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "rightButtonRipple", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "closeOnOutsideSelect", null);
__decorate([
    Input()
], IgxDialogComponent.prototype, "positionSettings", null);
__decorate([
    Output()
], IgxDialogComponent.prototype, "onOpen", void 0);
__decorate([
    Output()
], IgxDialogComponent.prototype, "onClose", void 0);
__decorate([
    Output()
], IgxDialogComponent.prototype, "onLeftButtonSelect", void 0);
__decorate([
    Output()
], IgxDialogComponent.prototype, "onRightButtonSelect", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxDialogComponent.prototype, "tabindex", void 0);
__decorate([
    Input()
], IgxDialogComponent.prototype, "isOpen", null);
__decorate([
    HostBinding('class.igx-dialog--hidden')
], IgxDialogComponent.prototype, "isCollapsed", null);
__decorate([
    Input()
], IgxDialogComponent.prototype, "role", null);
__decorate([
    Input()
], IgxDialogComponent.prototype, "titleId", null);
IgxDialogComponent = IgxDialogComponent_1 = __decorate([ __param(1, Optional())
], IgxDialogComponent);
/**
 * @hidden
 */
let IgxDialogModule = class IgxDialogModule {
};
IgxDialogModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDialogModule });
IgxDialogModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDialogModule_Factory(t) { return new (t || IgxDialogModule)(); }, imports: [[CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]] });

/**
 * @hidden
 */
let IgxGridSortingPipe = class IgxGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expressions, sorting, id, pipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection), expressions, sorting);
        }
        grid.setFilteredSortedData(result, pinned);
        return result;
    }
};
IgxGridSortingPipe.ɵfac = function IgxGridSortingPipe_Factory(t) { return new (t || IgxGridSortingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridSortingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridSort", type: IgxGridSortingPipe, pure: true });
IgxGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
let IgxGridGroupingPipe = class IgxGridGroupingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        const state = { expressions: [], expansion: [], defaultExpanded };
        const grid = this.gridAPI.grid;
        state.expressions = grid.groupingExpressions;
        let result;
        const fullResult = { data: [], metadata: [] };
        if (!state.expressions.length) {
            // empty the array without changing reference
            groupsRecords.splice(0, groupsRecords.length);
            result = {
                data: collection,
                metadata: collection
            };
        }
        else {
            state.expansion = grid.groupingExpansionState;
            state.defaultExpanded = grid.groupsExpanded;
            result = DataUtil.group(cloneArray(collection), state, grid, groupsRecords, fullResult);
        }
        grid.groupingFlatResult = result.data;
        grid.groupingResult = fullResult.data;
        grid.groupingMetadata = fullResult.metadata;
        return result;
    }
};
IgxGridGroupingPipe.ɵfac = function IgxGridGroupingPipe_Factory(t) { return new (t || IgxGridGroupingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridGroupingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridGroupBy", type: IgxGridGroupingPipe, pure: true });
IgxGridGroupingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
let IgxGridPagingPipe = class IgxGridPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        DataUtil.correctPagingState(state, collection.data.length);
        const result = {
            data: DataUtil.page(cloneArray(collection.data), state),
            metadata: DataUtil.page(cloneArray(collection.metadata), state)
        };
        if (this.gridAPI.grid.page !== state.index) {
            this.gridAPI.grid.page = state.index;
        }
        this.gridAPI.grid.pagingState = state;
        return result;
    }
};
IgxGridPagingPipe.ɵfac = function IgxGridPagingPipe_Factory(t) { return new (t || IgxGridPagingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridPagingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridPaging", type: IgxGridPagingPipe, pure: true });
IgxGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
let IgxGridFilteringPipe = class IgxGridFilteringPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, expressionsTree, filterStrategy, advancedExpressionsTree, id, pipeTrigger, filteringPipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        const state = {
            expressionsTree: expressionsTree,
            strategy: filterStrategy,
            advancedExpressionsTree: advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        const result = DataUtil.filter(cloneArray(collection), state);
        grid.setFilterData(result, pinned);
        return result;
    }
};
IgxGridFilteringPipe.ɵfac = function IgxGridFilteringPipe_Factory(t) { return new (t || IgxGridFilteringPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridFilteringPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridFiltering", type: IgxGridFilteringPipe, pure: true });
IgxGridFilteringPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

var IgxGridRowComponent_1;
let IgxGridRowComponent = IgxGridRowComponent_1 = class IgxGridRowComponent extends IgxRowDirective {
    // R.K. TODO: Remove
    constructor(gridAPI, crudService, selectionService, element, cdr) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        super(gridAPI, crudService, selectionService, element, cdr);
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.element = element;
        this.cdr = cdr;
    }
    get hasColumnLayouts() {
        return this.grid.hasColumnLayouts;
    }
    getContext(col, row) {
        return {
            $implicit: col,
            row: row
        };
    }
    get mrlRightPinnedOffset() {
        return !this.grid.isPinningToStart ?
            -this.grid.pinnedWidth - this.grid.headerFeaturesWidth + 'px' :
            null;
    }
    getContextMRL(pinnedCols, row) {
        return {
            $implicit: pinnedCols,
            row: row
        };
    }
    get expanded() {
        return this.gridAPI.get_row_expansion_state(this.rowData);
    }
};
IgxGridRowComponent.ɵfac = function IgxGridRowComponent_Factory(t) { return new (t || IgxGridRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridRowComponent, selectors: [["igx-grid-row"]], hostVars: 2, hostBindings: function IgxGridRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-grid__tr--mrl", ctx.hasColumnLayouts);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxGridRowComponent_1) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 17, vars: 5, consts: [[4, "ngIf"], ["mrlPinnedTemplate", ""], ["rowSelectorBaseTemplate", ""], ["cellTemplate", ""], ["expandableCellTemplate", ""], ["mrlCellTemplate", ""], ["mrlExpandableCellTemplate", ""], [3, "igxRowDrag", "ghostTemplate", "click"], [4, "ngTemplateOutlet"], [1, "igx-grid__cbx-selection", 3, "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForScrollOrientation", "igxForContainerSize", "igxForSizePropName", "igxForTrackBy"], ["igxDirRef", ""], ["ngFor", "", 3, "ngForOf"], [1, "igx-grid__mrl-block", 3, "ngStyle"], ["class", "igx-grid__mrl-block", 3, "igx-grid__td--pinned-last", "igx-grid__td--pinned-first", "left", "ngStyle", 4, "ngFor", "ngForOf"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "checked", "readonly", "disabled", "disableTransitions", "aria-label"], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "lastPinned", "firstPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], ["cell", ""], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", 3, "ngClass", "ngStyle", "expanded", "editMode", "column", "formatter", "row", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "lastPinned", "firstPinned", "formatter", "row", "rowData", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", 3, "ngClass", "ngStyle", "expanded", "editMode", "column", "lastPinned", "formatter", "row", "rowData", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"]], template: function IgxGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridRowComponent_ng_container_0_Template, 2, 3, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxGridRowComponent_ng_container_1_Template, 3, 5, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, IgxGridRowComponent_ng_container_2_Template, 3, 8, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(3, IgxGridRowComponent_ng_container_3_Template, 6, 10, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(4, IgxGridRowComponent_ng_container_4_Template, 6, 10, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(5, IgxGridRowComponent_ng_template_5_Template, 2, 3, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxGridRowComponent_ng_template_7_Template, 2, 6, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxGridRowComponent_ng_template_9_Template, 4, 55, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxGridRowComponent_ng_template_11_Template, 4, 53, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(13, IgxGridRowComponent_ng_template_13_Template, 4, 62, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(15, IgxGridRowComponent_ng_template_15_Template, 4, 62, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.groupingExpressions.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.grid.hasColumnLayouts);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.grid.hasColumnLayouts);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxRowDragDirective, ɵngcc2.NgTemplateOutlet, IgxGridForOfDirective, ɵngcc2.NgForOf, ɵngcc2.NgStyle, IgxCheckboxComponent,
        IgxGridCellComponent, ɵngcc2.NgClass, IgxGridExpandableCellComponent]; }, pipes: function () { return [IgxGridNotGroupedPipe,
        IgxGridTopLevelColumns,
        IgxGridCellStyleClassesPipe,
        IgxGridCellStylesPipe]; }, encapsulation: 2, changeDetection: 0 });
IgxGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: IgxGridCRUDService },
    { type: IgxGridSelectionService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
__decorate([
    HostBinding('class.igx-grid__tr--mrl')
], IgxGridRowComponent.prototype, "hasColumnLayouts", null);

/** @hidden */
let IgxGridSummaryPipe = class IgxGridSummaryPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
        if (!collection.data || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return collection.data;
        }
        return this.addSummaryRows(id, collection, summaryPosition);
    }
    addSummaryRows(gridId, collection, summaryPosition) {
        const recordsWithSummary = [];
        const lastChildMap = new Map();
        const grid = this.gridAPI.grid;
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        if (collection.metadata.length && !grid.isGroupByRecord(collection.data[0]) &&
            grid.isGroupByRecord(collection.metadata[0]) && summaryPosition === GridSummaryPosition.bottom) {
            const groups = [];
            groups.push(collection.metadata[0]);
            while (groups[groups.length - 1].groupParent) {
                groups.push(groups[groups.length - 1].groupParent);
            }
            groups.reverse();
            groups.forEach(g => g.skip = true);
            collection.data.splice(0, 0, ...groups);
        }
        for (let i = 0; i < collection.data.length; i++) {
            const record = collection.data[i];
            let skipAdd = false;
            let recordId;
            let groupByRecord = null;
            if (grid.isGroupByRecord(record)) {
                skipAdd = !!record.skip;
                record.skip = null;
                groupByRecord = record;
                recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
            }
            else {
                recordId = this.gridAPI.get_row_id(record);
            }
            if (!skipAdd) {
                recordsWithSummary.push(record);
            }
            if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                const groupRecords = lastChildMap.get(recordId);
                for (let j = 0; j < groupRecords.length; j++) {
                    const groupRecord = groupRecords[j];
                    const groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                    const records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                    const summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                    const summaryRecord = {
                        summaries: summaries,
                        max: maxSummaryHeight
                    };
                    recordsWithSummary.push(summaryRecord);
                }
            }
            if (groupByRecord === null || !grid.isExpandedGroup(groupByRecord)) {
                continue;
            }
            if (summaryPosition === GridSummaryPosition.top) {
                const records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                const summaries = grid.summaryService.calculateSummaries(recordId, records);
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            else if (summaryPosition === GridSummaryPosition.bottom) {
                let lastChild = groupByRecord;
                while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                    lastChild = lastChild.groups[lastChild.groups.length - 1];
                }
                let lastChildId;
                if (grid.isExpandedGroup(lastChild)) {
                    lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                }
                else {
                    lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                }
                let groupRecords = lastChildMap.get(lastChildId);
                if (!groupRecords) {
                    groupRecords = [];
                    lastChildMap.set(lastChildId, groupRecords);
                }
                groupRecords.unshift(groupByRecord);
            }
        }
        return recordsWithSummary;
    }
    removeDeletedRecord(grid, data) {
        if (!grid.transactions.enabled) {
            return data;
        }
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        deletedRows.forEach(rowID => {
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
};
IgxGridSummaryPipe.ɵfac = function IgxGridSummaryPipe_Factory(t) { return new (t || IgxGridSummaryPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridSummaryPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridSummary", type: IgxGridSummaryPipe, pure: true });
IgxGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/** @hidden */
let IgxGridDetailsPipe = class IgxGridDetailsPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, hasDetails, expansionStates, pipeTrigger) {
        if (!hasDetails) {
            return collection;
        }
        const res = this.addDetailRows(collection, expansionStates);
        return res;
    }
    addDetailRows(collection, expansionStates) {
        const result = [];
        collection.forEach((v) => {
            result.push(v);
            if (!this.gridAPI.grid.isGroupByRecord(v) && !this.gridAPI.grid.isSummaryRow(v) &&
                this.gridAPI.get_row_expansion_state(v)) {
                const detailsObj = { detailsData: v };
                result.push(detailsObj);
            }
        });
        return result;
    }
};
IgxGridDetailsPipe.ɵfac = function IgxGridDetailsPipe_Factory(t) { return new (t || IgxGridDetailsPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridDetailsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridDetails", type: IgxGridDetailsPipe, pure: true });
IgxGridDetailsPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

let IgxGridExpandableCellComponent = class IgxGridExpandableCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.expanded = false;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        const expansionState = this.gridAPI.get_row_expansion_state(this.row.rowData);
        this.gridAPI.set_row_expansion_state(this.row.rowID, !expansionState, event);
    }
    /**
     * @hidden
     */
    onIndicatorFocus() {
        this.gridAPI.submit_value();
    }
    /**
     * @hidden
     */
    calculateSizeToFit(range) {
        const indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        const indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        const indicatorMargin = parseFloat(indicatorStyle.marginRight);
        let leftPadding = 0;
        if (this.indentationDiv) {
            const indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        const largestWidth = Math.max(...Array.from(this.nativeElement.children)
            .map((child) => getNodeSizeViaRange(range, child)));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden
     */
    get showExpanderIndicator() {
        const isGhost = this.row.pinned && this.row.disabled;
        return !this.editMode && (!this.row.pinned || isGhost);
    }
};
IgxGridExpandableCellComponent.ɵfac = function IgxGridExpandableCellComponent_Factory(t) { return new (t || IgxGridExpandableCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxGridExpandableCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxGridExpandableCellComponent, selectors: [["igx-expandable-grid-cell"]], viewQuery: function IgxGridExpandableCellComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c201, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c202, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c118, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c119, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.indentationDiv = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);
    } }, inputs: { expanded: "expanded" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 13, vars: 5, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["inlineEditor", ""], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], ["displayDensity", "compact"], ["igxInput", "", 3, "ngModel", "igxFocus", "ngModelChange"], ["igxInput", "", "type", "number", 3, "ngModel", "igxFocus", "ngModelChange"], [3, "value", "checked", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"], [1, "igx-grid__tree-grouping-indicator", 3, "click", "focus"], ["indicator", ""], ["fontSet", "material"]], template: function IgxGridExpandableCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxGridExpandableCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxGridExpandableCellComponent_ng_template_2_Template, 6, 21, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxGridExpandableCellComponent_ng_template_4_Template, 4, 4, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxGridExpandableCellComponent_ng_container_6_Template, 4, 4, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(7, IgxGridExpandableCellComponent_ng_container_7_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(8, IgxGridExpandableCellComponent_ng_container_8_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(9, IgxGridExpandableCellComponent_ng_template_9_Template, 2, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxGridExpandableCellComponent_ng_template_11_Template, 2, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showExpanderIndicator);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxChipComponent,
        IgxTextHighlightDirective,
        IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxFocusDirective, ɵngcc3.NumberValueAccessor, IgxCheckboxComponent,
        IgxDatePickerComponent,
        IgxIconComponent], pipes: [IgxDecimalPipeComponent,
        IgxDatePipeComponent], encapsulation: 2, changeDetection: 0 });
IgxGridExpandableCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
__decorate([
    Input()
], IgxGridExpandableCellComponent.prototype, "expanded", void 0);
__decorate([
    ViewChild('indicator', { read: ElementRef })
], IgxGridExpandableCellComponent.prototype, "indicator", void 0);
__decorate([
    ViewChild('indentationDiv', { read: ElementRef })
], IgxGridExpandableCellComponent.prototype, "indentationDiv", void 0);
__decorate([
    ViewChild('defaultExpandedTemplate', { read: TemplateRef, static: true })
], IgxGridExpandableCellComponent.prototype, "defaultExpandedTemplate", void 0);
__decorate([
    ViewChild('defaultCollapsedTemplate', { read: TemplateRef, static: true })
], IgxGridExpandableCellComponent.prototype, "defaultCollapsedTemplate", void 0);
IgxGridExpandableCellComponent = __decorate([ __param(7, Inject(DOCUMENT))
], IgxGridExpandableCellComponent);

/**
 * @hidden
 */
let IgxGridModule = class IgxGridModule {
};
IgxGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxGridModule });
IgxGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxGridModule_Factory(t) { return new (t || IgxGridModule)(); }, imports: [[
            IgxGridCommonModule,
        ],
        IgxGridCommonModule] });

let IgxTreeGridAPIService = class IgxTreeGridAPIService extends GridBaseAPIService {
    get_all_data(transactions) {
        const grid = this.grid;
        const data = transactions ? grid.dataWithAddedInTransactionRows : grid.flatData;
        return data ? data : [];
    }
    get_summary_data() {
        const grid = this.grid;
        const data = grid.processedRootRecords.filter(row => row.isFilteredOutParent === undefined || row.isFilteredOutParent === false)
            .map(rec => rec.data);
        if (grid.transactions.enabled) {
            const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === TransactionType.DELETE).map(t => t.id);
            deletedRows.forEach(rowID => {
                const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
                const index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
        }
        return data;
    }
    allow_expansion_state_change(rowID, expanded) {
        const grid = this.grid;
        const row = grid.records.get(rowID);
        if (row.expanded === expanded ||
            ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
            return false;
        }
        return true;
    }
    expand_path_to_record(record) {
        const grid = this.grid;
        const expandedStates = grid.expansionStates;
        while (record.parent) {
            record = record.parent;
            const expanded = this.get_row_expansion_state(record);
            if (!expanded) {
                expandedStates.set(record.rowID, true);
            }
        }
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    }
    get_row_expansion_state(record) {
        const grid = this.grid;
        const states = grid.expansionStates;
        const expanded = states.get(record.rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return record.children && record.children.length && record.level < grid.expansionDepth;
        }
    }
    update_row_in_array(value, rowID, index) {
        const grid = this.grid;
        if (grid.primaryKey && grid.foreignKey) {
            super.update_row_in_array(value, rowID, index);
        }
        else {
            const record = grid.records.get(rowID);
            const childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
            index = grid.primaryKey ? childData.map(c => c[grid.primaryKey]).indexOf(rowID) :
                childData.indexOf(rowID);
            childData[index] = value;
        }
    }
    should_apply_number_style(column) {
        return column.dataType === DataType.Number && column.visibleIndex !== 0;
    }
    deleteRowById(rowID) {
        const treeGrid = this.grid;
        const flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
            treeGrid.foreignKey &&
            treeGrid.cascadeOnDelete &&
            treeGrid.transactions.enabled;
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.startPending();
        }
        super.deleteRowById(rowID);
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.endPending(true);
        }
    }
    deleteRowFromData(rowID, index) {
        const treeGrid = this.grid;
        const record = treeGrid.records.get(rowID);
        if (treeGrid.primaryKey && treeGrid.foreignKey) {
            index = treeGrid.primaryKey ?
                treeGrid.data.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                treeGrid.data.indexOf(rowID);
            super.deleteRowFromData(rowID, index);
            if (treeGrid.cascadeOnDelete) {
                if (record && record.children && record.children.length > 0) {
                    for (let i = 0; i < record.children.length; i++) {
                        const child = record.children[i];
                        super.deleteRowById(child.rowID);
                    }
                }
            }
        }
        else {
            const collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
            index = treeGrid.primaryKey ?
                collection.map(c => c[treeGrid.primaryKey]).indexOf(rowID) :
                collection.indexOf(rowID);
            const selectedChildren = [];
            this.get_selected_children(record, selectedChildren);
            if (selectedChildren.length > 0) {
                treeGrid.deselectRows(selectedChildren);
            }
            if (treeGrid.transactions.enabled) {
                const path = treeGrid.generateRowPath(rowID);
                treeGrid.transactions.add({
                    id: rowID,
                    type: TransactionType.DELETE,
                    newValue: null,
                    path: path
                }, collection[index]);
            }
            else {
                collection.splice(index, 1);
            }
        }
    }
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    updateData(grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            const path = grid.generateRowPath(rowID);
            const transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue,
                path: path
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    }
    get_selected_children(record, selectedRowIDs) {
        const grid = this.grid;
        if (!record.children || record.children.length === 0) {
            return;
        }
        for (const child of record.children) {
            if (grid.selectionService.isRowSelected(child.rowID)) {
                selectedRowIDs.push(child.rowID);
            }
            this.get_selected_children(child, selectedRowIDs);
        }
    }
    row_deleted_transaction(rowID) {
        return this.row_deleted_parent(rowID) || super.row_deleted_transaction(rowID);
    }
    get_rec_by_id(rowID) {
        return this.grid.records.get(rowID);
    }
    row_deleted_parent(rowID) {
        const grid = this.grid;
        if (!grid) {
            return false;
        }
        if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
            let node = grid.records.get(rowID);
            while (node) {
                const state = grid.transactions.getState(node.rowID);
                if (state && state.type === TransactionType.DELETE) {
                    return true;
                }
                node = node.parent;
            }
        }
        return false;
    }
};
IgxTreeGridAPIService.ɵfac = function IgxTreeGridAPIService_Factory(t) { return ɵIgxTreeGridAPIService_BaseFactory(t || IgxTreeGridAPIService); };
IgxTreeGridAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxTreeGridAPIService, factory: IgxTreeGridAPIService.ɵfac });

/**
 * @hidden
 */
let IgxRowLoadingIndicatorTemplateDirective = class IgxRowLoadingIndicatorTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxRowLoadingIndicatorTemplateDirective.ɵfac = function IgxRowLoadingIndicatorTemplateDirective_Factory(t) { return new (t || IgxRowLoadingIndicatorTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxRowLoadingIndicatorTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRowLoadingIndicatorTemplateDirective, selectors: [["", "igxRowLoadingIndicator", ""]] });
IgxRowLoadingIndicatorTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

var IgxTreeGridComponent_1;
let NEXT_ID$n = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
let IgxTreeGridComponent = IgxTreeGridComponent_1 = class IgxTreeGridComponent extends IgxGridBaseDirective {
    constructor() {
        super(...arguments);
        this._id = `igx-tree-grid-${NEXT_ID$n++}`;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * @memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * @memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * An @Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        this._expansionDepth = Infinity;
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._filteredData = null;
    }
    /**
     * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value;
    }
    /**
     * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxTreeGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * @memberof IgxTreeGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Get transactions service for the grid.
     * @experimental @hidden
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon fontSet="material">loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     * @memberof IgxTreeGridComponent
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    // Kind of stupid
    get _gridAPI() {
        return this.gridAPI;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        super.ngOnInit();
        this.onRowToggle.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
    }
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                });
            }
        }
    }
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            let parent = this.records.get(parentID);
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                const path = [];
                while (parent) {
                    path.push(parent.rowID);
                    parent = parent.parent;
                }
                let collection = this.data;
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this._pipeTrigger++;
    }
    cloneMap(mapIn) {
        const mapCloned = new Map();
        mapIn.forEach((value, key, mapObj) => {
            mapCloned.set(key, value);
        });
        return mapCloned;
    }
    getDefaultExpandState(record) {
        return record.children && record.children.length && record.level < this.expansionDepth;
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     *
     * ```typescript
     * this.grid.collapseAll();
     *  ```
     * @memberof IgxTreeGridComponent
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    addRow(data, parentRowID) {
        if (parentRowID !== undefined && parentRowID !== null) {
            super.endEdit(true);
            const state = this.transactions.getState(parentRowID);
            // we should not allow adding of rows as child of deleted row
            if (state && state.type === TransactionType.DELETE) {
                throw Error(`Cannot add child row to deleted parent row`);
            }
            const parentRecord = this.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.primaryKey && this.foreignKey) {
                data[this.foreignKey] = parentRowID;
                super.addRow(data);
            }
            else {
                const parentData = parentRecord.data;
                const childKey = this.childDataKey;
                if (this.transactions.enabled) {
                    const rowId = this.primaryKey ? data[this.primaryKey] : data;
                    const path = [];
                    path.push(...this.generateRowPath(parentRowID));
                    path.push(parentRowID);
                    this.transactions.add({
                        id: rowId,
                        path: path,
                        newValue: data,
                        type: TransactionType.ADD
                    }, null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
                this.onRowAdded.emit({ data });
                this._pipeTrigger++;
                this.notifyChanges();
            }
        }
        else {
            if (this.primaryKey && this.foreignKey) {
                const rowID = data[this.foreignKey];
                this.summaryService.clearSummaryCache({ rowID: rowID });
            }
            super.addRow(data);
        }
    }
    /** @hidden */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    }
    /** @hidden */
    generateRowPath(rowId) {
        const path = [];
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    }
    /**
     * @hidden @internal
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     */
    scrollTo(row, column) {
        let delayScrolling = false;
        let record;
        if (typeof (row) !== 'number') {
            const rowData = row;
            const rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                const page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first$1()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.unpinnedDataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        return {
            $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
            index: this.getDataViewIndex(rowIndex, pinned),
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow',
            disabled: this.isGhostRecord(rowData) ? rowData.recordRef.isFilteredOutParent === undefined : false
        };
    }
    /**
     * @hidden
     * @internal
     */
    getInitialPinnedIndex(rec) {
        return this._pinnedRecordIDs.indexOf(rec.rowID);
    }
    /**
     * @inheritdoc
     */
    getSelectedData(formatters = false, headers = false) {
        let source = [];
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.unpinnedDataView.forEach(process);
        source = this.isRowPinningToTop ? [...this.pinnedDataView, ...source] : [...source, ...this.pinnedDataView];
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * @hidden
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
};
IgxTreeGridComponent.ɵfac = function IgxTreeGridComponent_Factory(t) { return ɵIgxTreeGridComponent_BaseFactory(t || IgxTreeGridComponent); };
IgxTreeGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTreeGridComponent, selectors: [["igx-tree-grid"]], contentQueries: function IgxTreeGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowLoadingIndicatorTemplateDirective, true, IgxRowLoadingIndicatorTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rowLoadingTemplate = _t.first);
    } }, viewQuery: function IgxTreeGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c140, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c154, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c157, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.recordTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.summaryTemplate = _t.first);
    } }, hostVars: 1, hostBindings: function IgxTreeGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { cascadeOnDelete: "cascadeOnDelete", id: "id", data: "data", expansionDepth: "expansionDepth", rowLoadingIndicatorTemplate: "rowLoadingIndicatorTemplate", childDataKey: "childDataKey", foreignKey: "foreignKey", hasChildrenKey: "hasChildrenKey", loadChildrenOnDemand: "loadChildrenOnDemand" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxGridSelectionService,
            IgxGridCRUDService,
            IgxGridSummaryService,
            IgxGridNavigationService,
            { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxTreeGridComponent_1) },
            IgxFilteringService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService,
            IgxRowIslandAPIService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c173, decls: 96, vars: 178, consts: [["role", "toolbar", 3, "max-width", "flex-basis", "gridID", "displayDensity", 4, "ngIf"], [1, "igx-grid__thead"], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__thead-wrapper", 3, "focus", "keydown"], ["theadRow", ""], ["role", "row", 1, "igx-grid__tr"], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], ["id", "left", "class", "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["hContainer", ""], [3, "column", 4, "ngIf"], [1, "igx-grid__thead-thumb", 3, "hidden"], ["loadingOverlay", ""], [3, "indeterminate", 4, "ngIf"], ["id", "right", "class", "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop", 4, "ngIf"], ["igxGridBody", "", 1, "igx-grid__tbody", 3, "keydown.control.c", "copy"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tbody-content", 3, "igxGridDragSelect", "focus", "keydown", "onDragStop", "onDragScroll", "scroll"], ["tbody", ""], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", 4, "ngIf"], ["pinnedRecordsTemplate", ""], [4, "ngTemplateOutlet"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForItemSize", "onChunkPreload"], ["verticalScrollContainer", ""], ["record_template", ""], ["pinned_record_template", ""], ["summary_template", ""], ["igxOverlayOutlet", "", 1, "igx-grid__row-editing-outlet"], ["igxRowEditingOverlayOutlet", ""], [1, "igx-grid__tbody-scrollbar", 3, "hidden"], [1, "igx-grid__tbody-scrollbar-start"], [1, "igx-grid__tbody-scrollbar-main"], ["igxGridFor", "", 3, "igxGridForOf"], ["verticalScrollHolder", ""], [1, "igx-grid__tbody-scrollbar-end"], ["role", "rowgroup", "tabindex", "0", 1, "igx-grid__tfoot", 3, "focus", "keydown"], ["tfoot", ""], ["role", "row", "class", "igx-grid__summaries", 3, "width", "height", "gridID", "summaries", "index", 4, "ngIf"], [1, "igx-grid__tfoot-thumb", 3, "hidden"], [1, "igx-grid__scroll", 3, "hidden"], ["scr", ""], [1, "igx-grid__scroll-start"], [1, "igx-grid__scroll-main"], ["scrollContainer", ""], [1, "igx-grid__scroll-end", 3, "hidden"], [1, "igx-grid__footer"], ["footer", ""], ["defaultPaginator", ""], ["emptyFilteredGrid", ""], ["defaultEmptyGrid", ""], ["defaultLoadingGrid", ""], ["igxToggle", "", 4, "ngIf"], ["defaultRowEditText", ""], ["defaultRowEditActions", ""], ["defaultRowEditTemplate", ""], ["dragIndicatorIconBase", ""], ["igxHeadSelector", ""], ["headSelectorBaseTemplate", ""], ["igxOverlayOutlet", "", 1, "igx-grid__loading-outlet"], ["igxLoadingOverlayOutlet", ""], ["igxOverlayOutlet", "", 1, "igx-grid__outlet", 3, "keydown"], ["igxFilteringOverlayOutlet", ""], ["role", "toolbar", 3, "gridID", "displayDensity"], ["toolbar", ""], ["id", "left", 1, "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop"], ["id", "left", 1, "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop"], [1, "igx-grid__drag-indicator"], ["headerDragContainer", ""], [2, "visibility", "hidden"], [1, "igx-grid__cbx-selection", 3, "ngClass", "click"], ["headerSelectorContainer", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["headSelector", ""], ["ngFor", "", 3, "ngForOf"], [3, "column", "gridID"], [3, "column"], ["filteringRow", ""], [3, "indeterminate"], ["id", "right", 1, "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop"], ["class", "igx-grid__tr--pinned", 3, "ngClass", "width", 4, "ngIf"], [1, "igx-grid__tr--pinned", 3, "ngClass"], ["pinContainer", ""], [4, "ngFor", "ngForOf"], [3, "igxTemplateOutlet", "igxTemplateOutletContext", "onCachedViewLoaded"], [3, "gridID", "index", "treeRow", "disabled"], ["row", ""], [3, "gridID", "index", "treeRow"], ["row", "", "pinnedRow", ""], [1, "igx-grid__summaries--body", 3, "gridID", "summaries", "firstCellIndentation", "index"], ["summaryRow", ""], ["role", "row", 1, "igx-grid__summaries", 3, "gridID", "summaries", "index"], [3, "displayDensity", "page", "totalRecords", "perPage", "pageChange", "perPageChange"], [1, "igx-grid__tbody-message"], [1, "igx-grid__loading"], ["igxToggle", ""], [3, "className"], ["igxButton", "", "igxRowEditTabStop", "", 3, "click"], [1, "igx-banner__message"], [1, "igx-banner__text"], [1, "igx-banner__actions"], [1, "igx-banner__row"], ["fontSet", "material"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "checked", "ngStyle", "readonly", "indeterminate", "aria-label"], ["headerCheckbox", ""]], template: function IgxTreeGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c169);
        ɵngcc0.ɵɵtemplate(0, IgxTreeGridComponent_igx_grid_toolbar_0_Template, 2, 6, "igx-grid-toolbar", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵlistener("focus", function IgxTreeGridComponent_Template_div_focus_2_listener() { return ctx.navigation.focusFirstCell(); })("keydown", function IgxTreeGridComponent_Template_div_keydown_2_listener($event) { return ctx.navigation.headerNavigation($event); });
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxTreeGridComponent_span_5_Template, 1, 4, "span", 5);
        ɵngcc0.ɵɵtemplate(6, IgxTreeGridComponent_span_6_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(7, IgxTreeGridComponent_ng_container_7_Template, 5, 1, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(8, IgxTreeGridComponent_ng_container_8_Template, 4, 10, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(9, IgxTreeGridComponent_ng_container_9_Template, 3, 3, "ng-container", 7);
        ɵngcc0.ɵɵtemplate(10, IgxTreeGridComponent_ng_template_10_Template, 1, 6, "ng-template", 8, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(12, "igxTopLevel");
        ɵngcc0.ɵɵtemplate(13, IgxTreeGridComponent_ng_container_13_Template, 3, 3, "ng-container", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(14, IgxTreeGridComponent_igx_grid_filtering_row_14_Template, 2, 1, "igx-grid-filtering-row", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(15, "div", 11);
        ɵngcc0.ɵɵelementStart(16, "div", null, 12);
        ɵngcc0.ɵɵtemplate(18, IgxTreeGridComponent_igx_circular_bar_18_Template, 1, 1, "igx-circular-bar", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(19, IgxTreeGridComponent_span_19_Template, 1, 2, "span", 14);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "div", 15);
        ɵngcc0.ɵɵlistener("keydown.control.c", function IgxTreeGridComponent_Template_div_keydown_control_c_20_listener() { return ctx.copyHandlerIE(); })("copy", function IgxTreeGridComponent_Template_div_copy_20_listener($event) { return ctx.copyHandler($event); });
        ɵngcc0.ɵɵelementStart(21, "div", 16, 17);
        ɵngcc0.ɵɵlistener("focus", function IgxTreeGridComponent_Template_div_focus_21_listener($event) { return ctx.navigation.focusTbody($event); })("keydown", function IgxTreeGridComponent_Template_div_keydown_21_listener($event) { return ctx.navigation.handleNavigation($event); })("onDragStop", function IgxTreeGridComponent_Template_div_onDragStop_21_listener($event) { return ctx.selectionService.dragMode = $event; })("onDragScroll", function IgxTreeGridComponent_Template_div_onDragScroll_21_listener($event) { return ctx.dragScroll($event); })("scroll", function IgxTreeGridComponent_Template_div_scroll_21_listener($event) { return ctx.preventContainerScroll($event); });
        ɵngcc0.ɵɵtemplate(23, IgxTreeGridComponent_span_23_Template, 1, 2, "span", 18);
        ɵngcc0.ɵɵtemplate(24, IgxTreeGridComponent_span_24_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(25, IgxTreeGridComponent_ng_template_25_Template, 7, 46, "ng-template", null, 19, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(27, IgxTreeGridComponent_ng_container_27_Template, 1, 0, "ng-container", 20);
        ɵngcc0.ɵɵtemplate(28, IgxTreeGridComponent_ng_template_28_Template, 1, 2, "ng-template", 21, 22, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(30, "gridRowPinning");
        ɵngcc0.ɵɵpipe(31, "treeGridSummary");
        ɵngcc0.ɵɵpipe(32, "treeGridPaging");
        ɵngcc0.ɵɵpipe(33, "treeGridFlattening");
        ɵngcc0.ɵɵpipe(34, "treeGridSorting");
        ɵngcc0.ɵɵpipe(35, "treeGridFiltering");
        ɵngcc0.ɵɵpipe(36, "treeGridHierarchizing");
        ɵngcc0.ɵɵpipe(37, "visibleColumns");
        ɵngcc0.ɵɵpipe(38, "treeGridTransaction");
        ɵngcc0.ɵɵlistener("onChunkPreload", function IgxTreeGridComponent_Template_ng_template_onChunkPreload_28_listener($event) { return ctx.dataLoading($event); });
        ɵngcc0.ɵɵtemplate(39, IgxTreeGridComponent_ng_container_39_Template, 1, 0, "ng-container", 20);
        ɵngcc0.ɵɵtemplate(40, IgxTreeGridComponent_ng_template_40_Template, 2, 4, "ng-template", null, 23, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(42, IgxTreeGridComponent_ng_template_42_Template, 3, 3, "ng-template", null, 24, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(44, IgxTreeGridComponent_ng_template_44_Template, 2, 4, "ng-template", null, 25, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(46, IgxTreeGridComponent_ng_container_46_Template, 1, 0, "ng-container", 20);
        ɵngcc0.ɵɵelement(47, "div", 26, 27);
        ɵngcc0.ɵɵelement(49, "igc-trial-watermark");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(50, IgxTreeGridComponent_span_50_Template, 1, 2, "span", 14);
        ɵngcc0.ɵɵelementStart(51, "div", 28);
        ɵngcc0.ɵɵelement(52, "div", 29);
        ɵngcc0.ɵɵelementStart(53, "div", 30);
        ɵngcc0.ɵɵtemplate(54, IgxTreeGridComponent_ng_template_54_Template, 0, 0, "ng-template", 31, 32, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(56, "div", 33);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(57, "div", 34, 35);
        ɵngcc0.ɵɵlistener("focus", function IgxTreeGridComponent_Template_div_focus_57_listener() { return ctx.navigation.focusFirstCell(false); })("keydown", function IgxTreeGridComponent_Template_div_keydown_57_listener($event) { return ctx.navigation.summaryNav($event); });
        ɵngcc0.ɵɵtemplate(59, IgxTreeGridComponent_igx_grid_summary_row_59_Template, 3, 10, "igx-grid-summary-row", 36);
        ɵngcc0.ɵɵelement(60, "div", 37);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(61, "div", 38, 39);
        ɵngcc0.ɵɵelement(63, "div", 40);
        ɵngcc0.ɵɵelementStart(64, "div", 41);
        ɵngcc0.ɵɵtemplate(65, IgxTreeGridComponent_ng_template_65_Template, 0, 0, "ng-template", 31, 42, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(67, "div", 43);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(68, "div", 44, 45);
        ɵngcc0.ɵɵprojection(70);
        ɵngcc0.ɵɵtemplate(71, IgxTreeGridComponent_ng_container_71_Template, 2, 4, "ng-container", 7);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(72, IgxTreeGridComponent_ng_template_72_Template, 1, 4, "ng-template", null, 46, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(74, IgxTreeGridComponent_ng_template_74_Template, 2, 1, "ng-template", null, 47, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(76, IgxTreeGridComponent_ng_template_76_Template, 2, 1, "ng-template", null, 48, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(78, IgxTreeGridComponent_ng_template_78_Template, 2, 1, "ng-template", null, 49, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(80, IgxTreeGridComponent_div_80_Template, 3, 6, "div", 50);
        ɵngcc0.ɵɵtemplate(81, IgxTreeGridComponent_ng_template_81_Template, 1, 1, "ng-template", null, 51, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(83, IgxTreeGridComponent_ng_template_83_Template, 4, 0, "ng-template", null, 52, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(85, IgxTreeGridComponent_ng_template_85_Template, 6, 8, "ng-template", null, 53, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(87, IgxTreeGridComponent_ng_template_87_Template, 2, 0, "ng-template", null, 54, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(89, IgxTreeGridComponent_ng_template_89_Template, 3, 8, "ng-template", 55, 56, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(91, IgxTreeGridComponent_igx_grid_column_resizer_91_Template, 1, 0, "igx-grid-column-resizer", 7);
        ɵngcc0.ɵɵelement(92, "div", 57, 58);
        ɵngcc0.ɵɵelementStart(94, "div", 59, 60);
        ɵngcc0.ɵɵlistener("keydown", function IgxTreeGridComponent_Template_div_keydown_94_listener($event) { return ctx.gridOutletKeyboardHandler($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1156 = ɵngcc0.ɵɵreference(26);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToolbar);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(12, 80, ctx.unpinnedColumns))("igxForScrollOrientation", "horizontal")("igxForScrollContainer", ctx.parentVirtDir)("igxForContainerSize", ctx.unpinnedWidth)("igxForTrackBy", ctx.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteringService.isFilterRowVisible);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldOverlayLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px")("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵproperty("igxGridDragSelect", ctx.selectionService.dragMode);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r1156 : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind4(30, 82, ɵngcc0.ɵɵpipeBindV(31, 87, ɵngcc0.ɵɵpureFunction7(168, _c170, ɵngcc0.ɵɵpipeBindV(32, 95, ɵngcc0.ɵɵpureFunction5(162, _c171, ɵngcc0.ɵɵpipeBindV(33, 101, ɵngcc0.ɵɵpureFunction5(156, _c171, ɵngcc0.ɵɵpipeBindV(34, 107, ɵngcc0.ɵɵpureFunction5(150, _c171, ɵngcc0.ɵɵpipeBindV(35, 113, ɵngcc0.ɵɵpureFunction7(142, _c170, ɵngcc0.ɵɵpipeBindV(36, 121, ɵngcc0.ɵɵpureFunction6(135, _c203, ɵngcc0.ɵɵpipeBind2(37, 128, ɵngcc0.ɵɵpipeBind3(38, 131, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.primaryKey, ctx.foreignKey, ctx.childDataKey, ctx.id, ctx.pipeTrigger)), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.id, ctx.expansionDepth, ctx.expansionStates, ctx.pipeTrigger)), ctx.page, ctx.perPage, ctx.id, ctx.pipeTrigger)), ctx.hasSummarizedColumns, ctx.summaryCalculationMode, ctx.summaryPosition, ctx.id, ctx.pipeTrigger, ctx.summaryPipeTrigger)), ctx.id, false, ctx.pipeTrigger))("igxForScrollOrientation", "vertical")("igxForScrollContainer", ctx.verticalScroll)("igxForContainerSize", ctx.calcHeight)("igxForItemSize", ctx.renderedRowHeight);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r1156 : null);
        ɵngcc0.ɵɵadvance(7);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px")("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(176, _c172));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px")("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.isHorizontalScrollHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px")("min-width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.unpinnedWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(177, _c172));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("float", "right")("width", ctx.pinnedWidth, "px")("min-width", ctx.pinnedWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.pinnedWidth === 0 || ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.paging && ctx.totalRecords);
        ɵngcc0.ɵɵadvance(9);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowEditable);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.colResizingService.showResizer);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxGridForOfDirective,
        IgxGridBodyDirective,
        IgxGridDragSelectDirective, ɵngcc2.NgTemplateOutlet, IgxOverlayOutletDirective,
        IgxHeadSelectorDirective,
        IgxGridToolbarComponent,
        IgxColumnMovingDropDirective, ɵngcc2.NgClass, ɵngcc2.NgForOf, IgxGridHeaderGroupComponent,
        IgxGridFilteringRowComponent,
        IgxCircularProgressBarComponent,
        IgxTemplateOutletDirective,
        IgxTreeGridRowComponent,
        IgxSummaryRowComponent,
        IgxPaginatorComponent,
        IgxToggleDirective,
        IgxButtonDirective,
        IgxRowEditTabStopDirective,
        IgxIconComponent,
        IgxCheckboxComponent, ɵngcc2.NgStyle, IgxGridColumnResizerComponent]; }, pipes: function () { return [IgxGridTopLevelColumns,
        IgxGridRowPinningPipe,
        IgxTreeGridSummaryPipe,
        IgxTreeGridPagingPipe,
        IgxTreeGridFlatteningPipe,
        IgxTreeGridSortingPipe,
        IgxTreeGridFilteringPipe,
        IgxTreeGridHierarchizingPipe,
        IgxHasVisibleColumnsPipe,
        IgxTreeGridTransactionPipe,
        IgxTreeGridNormalizeRecordsPipe,
        IgxSummaryDataPipe]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxTreeGridComponent.prototype, "id", null);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "data", null);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "childDataKey", void 0);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "foreignKey", void 0);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "hasChildrenKey", void 0);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "cascadeOnDelete", void 0);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "expansionDepth", null);
__decorate([
    ContentChild(IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective })
], IgxTreeGridComponent.prototype, "rowLoadingTemplate", void 0);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", null);
__decorate([
    Input()
], IgxTreeGridComponent.prototype, "loadChildrenOnDemand", void 0);
__decorate([
    ViewChild('dragIndicatorIconBase', { read: TemplateRef, static: true })
], IgxTreeGridComponent.prototype, "dragIndicatorIconBase", void 0);
__decorate([
    ViewChild('record_template', { read: TemplateRef, static: true })
], IgxTreeGridComponent.prototype, "recordTemplate", void 0);
__decorate([
    ViewChild('summary_template', { read: TemplateRef, static: true })
], IgxTreeGridComponent.prototype, "summaryTemplate", void 0);

var IgxTreeGridRowComponent_1;
let IgxTreeGridRowComponent = IgxTreeGridRowComponent_1 = class IgxTreeGridRowComponent extends IgxRowDirective {
    /**
     * The `ITreeGridRecord` passed to the row component.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const treeRow = row.treeRow;
     * ```
     */
    get treeRow() {
        return this._treeRow;
    }
    set treeRow(value) {
        if (this._treeRow !== value) {
            this._treeRow = value;
            this.rowData = this._treeRow.data;
        }
    }
    /**
     * Gets whether the row is pinned.
     * ```typescript
     * let isPinned = row.pinned;
     * ```
     */
    get pinned() {
        return this.grid.isRecordPinned(this._treeRow);
    }
    /**
     * Sets whether the row is pinned.
     * Default value is `false`.
     * ```typescript
     * this.grid.selectedRows[0].pinned = true;
     * ```
     */
    set pinned(value) {
        if (value) {
            this.grid.pinRow(this.rowID);
        }
        else {
            this.grid.unpinRow(this.rowID);
        }
    }
    /**
     * Returns a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * const expanded = row.expanded;
     * ```
     */
    get expanded() {
        return this._treeRow.expanded;
    }
    /**
     * Sets a value indicating whether the row component is expanded.
     *
     * ```typescript
     * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
     * row.expanded = true;
     * ```
     */
    set expanded(value) {
        this.gridAPI.set_row_expansion_state(this._treeRow.rowID, value);
    }
    /**
     * @hidden
     * @internal
     */
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * @hidden
     */
    get showIndicator() {
        return this.grid.loadChildrenOnDemand ?
            this.grid.expansionStates.has(this.rowID) ?
                this.treeRow.children && this.treeRow.children.length :
                this.grid.hasChildrenKey ?
                    this.rowData[this.grid.hasChildrenKey] :
                    true :
            this.treeRow.children && this.treeRow.children.length;
    }
    /**
     * @hidden
     */
    resolveClasses() {
        const classes = super.resolveClasses();
        const filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
        return `${classes} ${filteredClass}`;
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
        super.ngDoCheck();
    }
};
IgxTreeGridRowComponent.ɵfac = function IgxTreeGridRowComponent_Factory(t) { return ɵIgxTreeGridRowComponent_BaseFactory(t || IgxTreeGridRowComponent); };
IgxTreeGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTreeGridRowComponent, selectors: [["igx-tree-grid-row"]], viewQuery: function IgxTreeGridRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c204, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cells = _t);
    } }, hostVars: 1, hostBindings: function IgxTreeGridRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded);
    } }, inputs: { treeRow: "treeRow" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxTreeGridRowComponent_1) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 12, consts: [[4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForScrollOrientation", "igxForContainerSize", "igxForSizePropName", "igxForTrackBy"], ["igxDirRef", ""], ["rowSelectorBaseTemplate", ""], ["pinnedCellsTemplate", ""], [3, "igxRowDrag", "ghostTemplate", "click"], [4, "ngTemplateOutlet"], [1, "igx-grid__cbx-selection", 3, "click"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cellTemplate", ""], ["treeCellTemplate", ""], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], ["treeCell", ""], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", 3, "ngClass", "ngStyle", "level", "expanded", "showIndicator", "editMode", "column", "formatter", "row", "rowData", "width", "visibleColumnIndex", "value", "isLoading", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "disabled", "disableTransitions", "aria-label"], ["ngFor", "", 3, "ngForOf"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--pinned", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "firstPinned", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--tree-cell", "igx-grid__td--pinned", 3, "ngClass", "ngStyle", "level", "expanded", "showIndicator", "editMode", "column", "formatter", "row", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "isLoading", "cellTemplate", "lastSearchInfo", "active", "cellSelectionMode", "displayPinnedChip"]], template: function IgxTreeGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTreeGridRowComponent_ng_container_0_Template, 3, 5, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, IgxTreeGridRowComponent_ng_container_1_Template, 3, 8, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(2, IgxTreeGridRowComponent_ng_container_2_Template, 2, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(3, IgxTreeGridRowComponent_ng_template_3_Template, 5, 1, "ng-template", 1, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(5, "igxNotGrouped");
        ɵngcc0.ɵɵtemplate(6, IgxTreeGridRowComponent_ng_container_6_Template, 2, 2, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(7, IgxTreeGridRowComponent_ng_template_7_Template, 2, 6, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxTreeGridRowComponent_ng_template_9_Template, 2, 3, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.grid.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(5, 10, ctx.unpinnedColumns))("igxForScrollContainer", ctx.grid.parentVirtDir)("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx.grid.unpinnedWidth)("igxForSizePropName", "calcPixelWidth")("igxForTrackBy", ctx.grid.trackColumnChanges);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.grid.isPinningToStart);
    } }, directives: function () { return [ɵngcc2.NgIf, IgxGridForOfDirective,
        IgxRowDragDirective, ɵngcc2.NgTemplateOutlet, IgxGridCellComponent, ɵngcc2.NgClass, ɵngcc2.NgStyle, IgxTreeGridCellComponent,
        IgxCheckboxComponent, ɵngcc2.NgForOf]; }, pipes: function () { return [IgxGridNotGroupedPipe,
        IgxGridCellStyleClassesPipe,
        IgxGridCellStylesPipe]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ViewChildren('treeCell')
], IgxTreeGridRowComponent.prototype, "_cells", void 0);
__decorate([
    Input()
], IgxTreeGridRowComponent.prototype, "treeRow", null);
__decorate([
    HostBinding('attr.aria-expanded')
], IgxTreeGridRowComponent.prototype, "expanded", null);

/**
 * @hidden
 */
let IgxTreeGridHierarchizingPipe = class IgxTreeGridHierarchizingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, primaryKey, foreignKey, childDataKey, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        let hierarchicalRecords = [];
        const treeGridRecordsMap = new Map();
        const flatData = [];
        if (primaryKey && foreignKey) {
            hierarchicalRecords = this.hierarchizeFlatData(id, collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
        }
        else if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(id, collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
        }
        grid.flatData = flatData;
        grid.records = treeGridRecordsMap;
        grid.rootRecords = hierarchicalRecords;
        return hierarchicalRecords;
    }
    getRowID(primaryKey, rowData) {
        return primaryKey ? rowData[primaryKey] : rowData;
    }
    hierarchizeFlatData(id, collection, primaryKey, foreignKey, map, flatData) {
        const result = [];
        const missingParentRecords = [];
        collection.forEach(row => {
            const record = {
                rowID: this.getRowID(primaryKey, row),
                data: row,
                children: []
            };
            const parent = map.get(row[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                missingParentRecords.push(record);
            }
            map.set(row[primaryKey], record);
        });
        missingParentRecords.forEach(record => {
            const parent = map.get(record.data[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                result.push(record);
            }
        });
        this.setIndentationLevels(id, result, 0, flatData);
        return result;
    }
    setIndentationLevels(id, collection, indentationLevel, flatData) {
        for (let i = 0; i < collection.length; i++) {
            const record = collection[i];
            record.level = indentationLevel;
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);
            if (record.children && record.children.length > 0) {
                this.setIndentationLevels(id, record.children, indentationLevel + 1, flatData);
            }
        }
    }
    hierarchizeRecursive(id, collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map) {
        const result = [];
        for (let i = 0; i < collection.length; i++) {
            const item = collection[i];
            const record = {
                rowID: this.getRowID(primaryKey, item),
                data: item,
                parent: parent,
                level: indentationLevel
            };
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map.set(record.rowID, record);
            record.children = item[childDataKey] ?
                this.hierarchizeRecursive(id, item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map) :
                undefined;
            result.push(record);
        }
        return result;
    }
};
IgxTreeGridHierarchizingPipe.ɵfac = function IgxTreeGridHierarchizingPipe_Factory(t) { return new (t || IgxTreeGridHierarchizingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridHierarchizingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridHierarchizing", type: IgxTreeGridHierarchizingPipe, pure: true });
IgxTreeGridHierarchizingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
let IgxTreeGridFlatteningPipe = class IgxTreeGridFlatteningPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, expandedLevels, expandedStates, pipeTrigger) {
        const grid = this.gridAPI.grid;
        const data = [];
        grid.processedRootRecords = collection;
        grid.processedRecords = new Map();
        this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, id, true);
        grid.processedExpandedFlatData = data.map(r => r.data);
        return data;
    }
    getFlatDataRecursive(collection, data, expandedLevels, expandedStates, gridID, parentExpanded) {
        if (!collection || !collection.length) {
            return;
        }
        const grid = this.gridAPI.grid;
        for (let i = 0; i < collection.length; i++) {
            const hierarchicalRecord = collection[i];
            if (parentExpanded) {
                data.push(hierarchicalRecord);
            }
            hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
            grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, gridID, parentExpanded && hierarchicalRecord.expanded);
        }
    }
    updateNonProcessedRecordExpansion(grid, record) {
        const rec = grid.records.get(record.rowID);
        rec.expanded = record.expanded;
    }
};
IgxTreeGridFlatteningPipe.ɵfac = function IgxTreeGridFlatteningPipe_Factory(t) { return new (t || IgxTreeGridFlatteningPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridFlatteningPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridFlattening", type: IgxTreeGridFlatteningPipe, pure: true });
IgxTreeGridFlatteningPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
let IgxTreeGridSortingPipe = class IgxTreeGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(hierarchicalData, expressions, sorting, id, pipeTrigger, pinned) {
        const grid = this.gridAPI.grid;
        let result;
        if (!expressions.length) {
            result = hierarchicalData;
        }
        else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions, sorting);
        }
        const filteredSortedData = [];
        this.flattenTreeGridRecords(result, filteredSortedData);
        grid.setFilteredSortedData(filteredSortedData, pinned);
        return result;
    }
    flattenTreeGridRecords(records, flatData) {
        if (records && records.length) {
            for (const record of records) {
                flatData.push(record.data);
                this.flattenTreeGridRecords(record.children, flatData);
            }
        }
    }
};
IgxTreeGridSortingPipe.ɵfac = function IgxTreeGridSortingPipe_Factory(t) { return new (t || IgxTreeGridSortingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridSortingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridSorting", type: IgxTreeGridSortingPipe, pure: true });
IgxTreeGridSortingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
let IgxTreeGridPagingPipe = class IgxTreeGridPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (!grid.paging) {
            return collection;
        }
        const len = collection.length;
        const totalPages = Math.ceil(len / perPage);
        const state = {
            index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
            recordsPerPage: perPage
        };
        const result = DataUtil.page(cloneArray(collection), state);
        grid.pagingState = state;
        grid._page = state.index;
        return result;
    }
};
IgxTreeGridPagingPipe.ɵfac = function IgxTreeGridPagingPipe_Factory(t) { return new (t || IgxTreeGridPagingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridPagingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridPaging", type: IgxTreeGridPagingPipe, pure: true });
IgxTreeGridPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/** @hidden */
let IgxTreeGridTransactionPipe = class IgxTreeGridTransactionPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, id, pipeTrigger) {
        const grid = this.gridAPI.grid;
        if (grid.transactions.enabled) {
            const aggregatedChanges = grid.transactions.getAggregatedChanges(true);
            if (aggregatedChanges.length > 0) {
                const primaryKey = grid.primaryKey;
                if (!primaryKey) {
                    return collection;
                }
                const foreignKey = grid.foreignKey;
                const childDataKey = grid.childDataKey;
                if (foreignKey) {
                    const flatDataClone = cloneArray(collection);
                    return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                }
                else if (childDataKey) {
                    const hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                    return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                }
            }
        }
        return collection;
    }
};
IgxTreeGridTransactionPipe.ɵfac = function IgxTreeGridTransactionPipe_Factory(t) { return new (t || IgxTreeGridTransactionPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridTransactionPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridTransaction", type: IgxTreeGridTransactionPipe, pure: true });
IgxTreeGridTransactionPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * This pipe maps the original record to ITreeGridRecord format used in TreeGrid.
 */
let IgxTreeGridNormalizeRecordsPipe = class IgxTreeGridNormalizeRecordsPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, pipeTrigger) {
        const grid = this.gridAPI.grid;
        const primaryKey = grid.primaryKey;
        // using flattened data because origin data may be hierarchical.
        const flatData = grid.flatData;
        const res = flatData.map(rec => ({
            rowID: grid.primaryKey ? rec[primaryKey] : rec,
            data: rec,
            level: 0,
            children: []
        }));
        return res;
    }
};
IgxTreeGridNormalizeRecordsPipe.ɵfac = function IgxTreeGridNormalizeRecordsPipe_Factory(t) { return new (t || IgxTreeGridNormalizeRecordsPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridNormalizeRecordsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridNormalizeRecord", type: IgxTreeGridNormalizeRecordsPipe, pure: true });
IgxTreeGridNormalizeRecordsPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

let IgxTreeGridCellComponent = class IgxTreeGridCellComponent extends IgxGridExpandableCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil);
        this.zone = zone;
        this.document = document;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.level = 0;
        /**
         * @hidden
         */
        this.showIndicator = false;
        this.treeGridAPI = gridAPI;
    }
    /**
     * @hidden
     */
    toggle(event) {
        event.stopPropagation();
        this.treeGridAPI.set_row_expansion_state(this.row.rowID, !this.row.expanded, event);
    }
    /**
     * @hidden
     */
    onLoadingDblClick(event) {
        event.stopPropagation();
    }
};
IgxTreeGridCellComponent.ɵfac = function IgxTreeGridCellComponent_Factory(t) { return new (t || IgxTreeGridCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxTreeGridCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTreeGridCellComponent, selectors: [["igx-tree-grid-cell"]], inputs: { level: "level", showIndicator: "showIndicator", isLoading: "isLoading" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 12, vars: 3, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["inlineEditor", ""], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], ["displayDensity", "compact"], ["igxInput", "", 3, "ngModel", "igxFocus", "ngModelChange"], ["igxInput", "", "type", "number", 3, "ngModel", "igxFocus", "ngModelChange"], [3, "value", "checked", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"], ["class", "igx-grid__tree-grouping-indicator", 3, "ngStyle", "click", "focus", 4, "ngIf"], ["class", "igx-grid__tree-loading-indicator", 3, "dblclick", 4, "ngIf"], ["defaultLoadingIndicatorTemplate", ""], ["indentationDiv", ""], [1, "igx-grid__tree-grouping-indicator", 3, "ngStyle", "click", "focus"], ["indicator", ""], [1, "igx-grid__tree-loading-indicator", 3, "dblclick"], [4, "ngTemplateOutlet"], [3, "indeterminate"], ["fontSet", "material"]], template: function IgxTreeGridCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTreeGridCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTreeGridCellComponent_ng_template_2_Template, 6, 21, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxTreeGridCellComponent_ng_template_4_Template, 4, 4, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxTreeGridCellComponent_ng_container_6_Template, 6, 3, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(7, IgxTreeGridCellComponent_ng_container_7_Template, 1, 0, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(8, IgxTreeGridCellComponent_ng_template_8_Template, 2, 0, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(10, IgxTreeGridCellComponent_ng_template_10_Template, 2, 0, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.editMode);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxChipComponent,
        IgxTextHighlightDirective,
        IgxInputGroupComponent, ɵngcc3.DefaultValueAccessor, IgxInputDirective, ɵngcc3.NgControlStatus, ɵngcc3.NgModel, IgxFocusDirective, ɵngcc3.NumberValueAccessor, IgxCheckboxComponent,
        IgxDatePickerComponent, ɵngcc2.NgStyle, IgxCircularProgressBarComponent,
        IgxIconComponent], pipes: [IgxDecimalPipeComponent,
        IgxDatePipeComponent], encapsulation: 2, changeDetection: 0 });
IgxTreeGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: PlatformUtil }
];
__decorate([
    Input()
], IgxTreeGridCellComponent.prototype, "level", void 0);
__decorate([
    Input()
], IgxTreeGridCellComponent.prototype, "showIndicator", void 0);
__decorate([
    Input()
], IgxTreeGridCellComponent.prototype, "isLoading", void 0);
IgxTreeGridCellComponent = __decorate([ __param(7, Inject(DOCUMENT))
], IgxTreeGridCellComponent);

/** @hidden */
let IgxTreeGridSummaryPipe = class IgxTreeGridSummaryPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(flatData, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
        const grid = this.gridAPI.grid;
        if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
        }
        return this.addSummaryRows(grid, flatData, summaryPosition);
    }
    addSummaryRows(grid, collection, summaryPosition) {
        const recordsWithSummary = [];
        const maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        for (let i = 0; i < collection.length; i++) {
            const record = collection[i];
            recordsWithSummary.push(record);
            const isExpanded = record.children && record.children.length > 0 && record.expanded;
            if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
                let childRecord = record;
                let parent = record.parent;
                while (parent) {
                    const children = parent.children;
                    if (children[children.length - 1] === childRecord) {
                        let childData = children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                        childData = this.removeDeletedRecord(grid, parent.rowID, childData);
                        const summaries = grid.summaryService.calculateSummaries(parent.rowID, childData);
                        const summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight,
                            cellIndentation: parent.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                        childRecord = parent;
                        parent = childRecord.parent;
                    }
                    else {
                        break;
                    }
                }
            }
            else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
                let childData = record.children.filter(r => !r.isFilteredOutParent).map(r => r.data);
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                const summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                const summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
        }
        return recordsWithSummary;
    }
    removeDeletedRecord(grid, rowId, data) {
        if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
            return data;
        }
        const deletedRows = grid.transactions.getTransactionLog().filter(t => t.type === 'delete').map(t => t.id);
        let row = grid.records.get(rowId);
        if (!row && deletedRows.lenght === 0) {
            return [];
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowId = row.rowID;
            if (deletedRows.indexOf(rowId) !== -1) {
                return [];
            }
            row = row.parent;
        }
        deletedRows.forEach(rowID => {
            const tempData = grid.primaryKey ? data.map(rec => rec[grid.primaryKey]) : data;
            const index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    }
};
IgxTreeGridSummaryPipe.ɵfac = function IgxTreeGridSummaryPipe_Factory(t) { return new (t || IgxTreeGridSummaryPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxTreeGridSummaryPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "treeGridSummary", type: IgxTreeGridSummaryPipe, pure: true });
IgxTreeGridSummaryPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @hidden
 */
let IgxTreeGridModule = class IgxTreeGridModule {
};
IgxTreeGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTreeGridModule });
IgxTreeGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTreeGridModule_Factory(t) { return new (t || IgxTreeGridModule)(); }, imports: [[
            IgxGridCommonModule,
        ],
        IgxGridCommonModule] });

let IgxChildGridRowComponent = class IgxChildGridRowComponent {
    constructor(gridAPI, element, resolver, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * @hidden
         */
        this.role = 'row';
        this.resolver = resolver;
    }
    /**
     * @hidden
     */
    get parentHasScroll() {
        return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     */
    // TODO: Refactor
    get parentGrid() {
        return this.gridAPI.grid;
    }
    get level() {
        return this.layout.level;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.layout.onLayoutChange.subscribe((ch) => {
            this._handleLayoutChanges(ch);
        });
        const changes = this.layout.initialChanges;
        changes.forEach(change => {
            this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        // handler logic that re-emits hgrid events on the row island
        this.setupEventEmitters();
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.hGrid.childLayoutList = this.layout.children;
        const layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach((l) => this.hGrid.hgridAPI.registerChildRowIsland(l));
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.layout.onGridInitialized.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
        this.hGrid.cdr.detectChanges();
    }
    setupEventEmitters() {
        const destructor = takeUntil(this.hGrid.destroy$);
        const factory = this.resolver.resolveComponentFactory(IgxGridComponent);
        // exclude outputs related to two-way binding functionality
        const inputNames = factory.inputs.map(input => input.propName);
        const outputs = factory.outputs.filter(o => {
            const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
        });
        outputs.forEach(output => {
            if (this.hGrid[output.propName]) {
                this.hGrid[output.propName].pipe(destructor).subscribe((args) => {
                    if (!args) {
                        args = {};
                    }
                    args.owner = this.hGrid;
                    this.layout[output.propName].emit(args);
                });
            }
        });
    }
    _handleLayoutChanges(changes) {
        for (const change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    }
};
IgxChildGridRowComponent.ɵfac = function IgxChildGridRowComponent_Factory(t) { return new (t || IgxChildGridRowComponent)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxChildGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxChildGridRowComponent, selectors: [["igx-child-grid-row"]], viewQuery: function IgxChildGridRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c205, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hGrid = _t.first);
    } }, hostVars: 2, hostBindings: function IgxChildGridRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("data-level", ctx.level);
    } }, inputs: { rowData: "rowData", layout: "layout", parentGridID: "parentGridID", index: "index" }, decls: 3, vars: 4, consts: [[1, "igx-grid__hierarchical-indent", 3, "ngClass"], [3, "data"], ["hgrid", ""]], template: function IgxChildGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelement(1, "igx-hierarchical-grid", 1, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(2, _c206, ctx.parentHasScroll));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("data", ctx.rowData.childGridsData[ctx.layout.key]);
    } }, directives: function () { return [ɵngcc2.NgClass, IgxHierarchicalGridComponent]; }, encapsulation: 2, changeDetection: 0 });
IgxChildGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef }
];
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "layout", void 0);
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "parentGridID", void 0);
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "rowData", void 0);
__decorate([
    Input()
], IgxChildGridRowComponent.prototype, "index", void 0);
__decorate([
    ViewChild('hgrid', { static: true })
], IgxChildGridRowComponent.prototype, "hGrid", void 0);
__decorate([
    HostBinding('attr.role')
], IgxChildGridRowComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.data-level')
], IgxChildGridRowComponent.prototype, "level", null);

let IgxHierarchicalGridNavigationService = class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell))) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.onChunkLoad.pipe(first$1()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const rowObj = this.grid.getRowByIndex(rowIndex);
        if (!rowObj) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(rowObj, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.onChunkLoad.pipe(first$1()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            args.target.grid.tbody.nativeElement.focus();
            this._pendingNavigation = false;
            cb(args);
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(rowObj, isNext) {
        let rowElem = rowObj.nativeElement;
        if (rowObj instanceof IgxChildGridRowComponent) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: rowObj.rowData.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.hgridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        const isInView = isNext ? diffBottom <= 0 : diffTop >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode) {
            this.activeNode.row = null;
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets closest element by its tag name.
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev: prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev: prev };
    }
};
IgxHierarchicalGridNavigationService.ɵfac = function IgxHierarchicalGridNavigationService_Factory(t) { return ɵIgxHierarchicalGridNavigationService_BaseFactory(t || IgxHierarchicalGridNavigationService); };
IgxHierarchicalGridNavigationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxHierarchicalGridNavigationService, factory: IgxHierarchicalGridNavigationService.ɵfac });

const IgxHierarchicalTransactionServiceFactory = {
    provide: IgxGridTransaction,
    useFactory: hierarchicalTransactionServiceFactory
};
function hierarchicalTransactionServiceFactory() {
    return new IgxTransactionService();
}
let IgxHierarchicalGridBaseDirective = class IgxHierarchicalGridBaseDirective extends IgxGridBaseDirective {
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        super(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.showExpandAll = false;
        this.hgridAPI = gridAPI;
    }
    /**
     * @hidden
     */
    get maxLevelHeaderDepth() {
        if (this._maxLevelHeaderDepth === null) {
            this._maxLevelHeaderDepth = this.columnList.reduce((acc, col) => Math.max(acc, col.level), 0);
        }
        return this._maxLevelHeaderDepth;
    }
    /**
     * @hidden
     */
    get outlet() {
        return this.rootGrid ? this.rootGrid.outletDirective : this.outletDirective;
    }
    /**
     * @hidden
     */
    createColumnsList(cols) {
        const columns = [];
        const topLevelCols = this.onlyTopLevel(cols);
        topLevelCols.forEach((col) => {
            const ref = this._createColumn(col);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        const result = flatten$1(columns);
        this.columnList.reset(result);
        this.columnList.notifyOnChanges();
        this.initPinning();
    }
    _createColumn(col) {
        let ref;
        if (col instanceof IgxColumnGroupComponent) {
            ref = this._createColGroupComponent(col);
        }
        else {
            ref = this._createColComponent(col);
        }
        return ref;
    }
    _createColGroupComponent(col) {
        const factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
        const ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
        ref.changeDetectorRef.detectChanges();
        factoryGroup.inputs.forEach((input) => {
            const propName = input.propName;
            ref.instance[propName] = col[propName];
        });
        if (col.children.length > 0) {
            const newChildren = [];
            col.children.forEach(child => {
                const newCol = this._createColumn(child).instance;
                newCol.parent = ref.instance;
                newChildren.push(newCol);
            });
            ref.instance.children.reset(newChildren);
            ref.instance.children.notifyOnChanges();
        }
        return ref;
    }
    _createColComponent(col) {
        const factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
        const ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
        factoryColumn.inputs.forEach((input) => {
            const propName = input.propName;
            if (!(col[propName] instanceof IgxSummaryOperand)) {
                ref.instance[propName] = col[propName];
            }
            else {
                ref.instance[propName] = col[propName].constructor;
            }
        });
        return ref;
    }
    getGridsForIsland(rowIslandID) {
        return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
    }
    getChildGrid(path) {
        if (!path) {
            return;
        }
        return this.hgridAPI.getChildGrid(path);
    }
};
IgxHierarchicalGridBaseDirective.ɵfac = function IgxHierarchicalGridBaseDirective_Factory(t) { return new (t || IgxHierarchicalGridBaseDirective)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridTransaction), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(IgxHierarchicalGridNavigationService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxGridSummaryService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8)); };
IgxHierarchicalGridBaseDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHierarchicalGridBaseDirective, selectors: [["", "igxHierarchicalGridBase", ""]], viewQuery: function IgxHierarchicalGridBaseDirective_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c140, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dragIndicatorIconBase = _t.first);
    } }, inputs: { showExpandAll: "showExpandAll", expandChildren: "expandChildren", hasChildrenKey: "hasChildrenKey" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
IgxHierarchicalGridBaseDirective.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
];
__decorate([
    Input()
], IgxHierarchicalGridBaseDirective.prototype, "expandChildren", void 0);
__decorate([
    Input()
], IgxHierarchicalGridBaseDirective.prototype, "hasChildrenKey", void 0);
__decorate([
    Input()
], IgxHierarchicalGridBaseDirective.prototype, "showExpandAll", void 0);
__decorate([
    ViewChild('dragIndicatorIconBase', { read: TemplateRef, static: true })
], IgxHierarchicalGridBaseDirective.prototype, "dragIndicatorIconBase", void 0);
IgxHierarchicalGridBaseDirective = __decorate([ __param(4, Inject(IgxGridTransaction)),
    __param(7, Inject(DOCUMENT)),
    __param(14, Inject(IgxOverlayService)),
    __param(16, Optional()), __param(16, Inject(DisplayDensityToken))
], IgxHierarchicalGridBaseDirective);
function flatten$1(arr) {
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            result = result.concat(flatten$1(el.children.toArray()));
        }
    });
    return result;
}

let IgxHierarchicalGridAPIService = class IgxHierarchicalGridAPIService extends GridBaseAPIService {
    constructor() {
        super(...arguments);
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    registerChildRowIsland(rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    }
    unsetChildRowIsland(rowIsland) {
        this.childGrids.delete(rowIsland.key);
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    }
    getChildRowIsland(key) {
        return this.childRowIslands.get(key);
    }
    getChildGrid(path) {
        const currPath = path;
        let grid;
        const pathElem = currPath.shift();
        const childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
        if (childrenForLayout) {
            const childGrid = childrenForLayout.get(pathElem.rowID);
            if (currPath.length === 0) {
                grid = childGrid;
            }
            else {
                grid = childGrid.hgridAPI.getChildGrid(currPath);
            }
        }
        return grid;
    }
    getChildGrids(inDepth) {
        const allChildren = [];
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid) => {
                allChildren.push(grid);
                if (inDepth) {
                    const children = grid.hgridAPI.getChildGrids(inDepth);
                    children.forEach((item) => {
                        allChildren.push(item);
                    });
                }
            });
        });
        return allChildren;
    }
    getParentRowId(childGrid) {
        let rowID;
        this.childGrids.forEach((layoutMap) => {
            layoutMap.forEach((grid, key) => {
                if (grid === childGrid) {
                    rowID = key;
                    return;
                }
            });
        });
        return rowID;
    }
    registerChildGrid(parentRowID, rowIslandKey, grid) {
        let childrenForLayout = this.childGrids.get(rowIslandKey);
        if (!childrenForLayout) {
            this.childGrids.set(rowIslandKey, new Map());
            childrenForLayout = this.childGrids.get(rowIslandKey);
        }
        childrenForLayout.set(parentRowID, grid);
    }
    getChildGridsForRowIsland(rowIslandKey) {
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        const children = [];
        if (childrenForLayout) {
            childrenForLayout.forEach((child) => {
                children.push(child);
            });
        }
        return children;
    }
    getChildGridByID(rowIslandKey, rowID) {
        const childrenForLayout = this.childGrids.get(rowIslandKey);
        return childrenForLayout.get(rowID);
    }
    get_row_expansion_state(record) {
        let inState;
        if (record.childGridsData !== undefined) {
            const ri = record.rowID;
            const rec = this.grid.primaryKey ? this.get_rec_by_id(ri) : ri;
            inState = !!super.get_row_expansion_state(rec);
        }
        else {
            inState = !!super.get_row_expansion_state(record);
        }
        return inState && this.grid.childLayoutList.length !== 0;
    }
    allow_expansion_state_change(rowID, expanded) {
        const rec = this.get_rec_by_id(rowID);
        const grid = this.grid;
        if (grid.hasChildrenKey && !rec[grid.hasChildrenKey]) {
            return false;
        }
        return !!rec && this.grid.expansionStates.get(rowID) !== expanded;
    }
    get_rec_by_id(rowID) {
        const data = this.get_all_data(false);
        const index = this.get_row_index_in_data(rowID);
        return data[index];
    }
};
IgxHierarchicalGridAPIService.ɵfac = function IgxHierarchicalGridAPIService_Factory(t) { return ɵIgxHierarchicalGridAPIService_BaseFactory(t || IgxHierarchicalGridAPIService); };
IgxHierarchicalGridAPIService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: IgxHierarchicalGridAPIService, factory: IgxHierarchicalGridAPIService.ɵfac });

var IgxRowIslandComponent_1;
let IgxRowIslandComponent = IgxRowIslandComponent_1 = class IgxRowIslandComponent extends IgxHierarchicalGridBaseDirective {
    constructor(selectionService, crudService, colResizingService, gridAPI, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI) {
        super(selectionService, crudService, colResizingService, gridAPI, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions);
        this.selectionService = selectionService;
        this.colResizingService = colResizingService;
        this.transactionFactory = transactionFactory;
        this.document = document;
        this.overlayService = overlayService;
        this.summaryService = summaryService;
        this._displayDensityOptions = _displayDensityOptions;
        this.rowIslandAPI = rowIslandAPI;
        /**
         * @hidden
         */
        this.children = new QueryList();
        /**
         * @hidden
         */
        this.childColumns = new QueryList();
        /**
         * @hidden
         */
        this.onLayoutChange = new EventEmitter();
        /**
         * Event emmited when a grid is being created based on this row island.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * @memberof IgxRowIslandComponent
         */
        this.onGridCreated = new EventEmitter();
        /**
         * Emitted after a grid is being initialized for this row island.
         * The emitting is done in `ngAfterViewInit`.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridInitialized)="gridInitialized($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * @memberof IgxRowIslandComponent
         */
        this.onGridInitialized = new EventEmitter();
        /**
         * @hidden
         */
        this.initialChanges = [];
        /**
         * @hidden
         */
        this.rootGrid = null;
        this.layout_id = `igx-row-island-`;
        this.isInit = false;
        this.hgridAPI = gridAPI;
    }
    /**
     * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
     *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
     *          <!-- ... -->
     *      </igx-row-island>
     * </igx-hierarchical-grid>
     * ```
     * @memberof IgxRowIslandComponent
     */
    set expandChildren(value) {
        this._defaultExpandState = value;
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            if (document.body.contains(grid.nativeElement)) {
                // Detect changes right away if the grid is visible
                grid.expandChildren = value;
                grid.markForCheck();
            }
            else {
                // Else defer the detection on changes when the grid gets into view for performance.
                grid.updateOnRender = true;
            }
        });
    }
    /**
     * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
     * ```typescript
     * const expanded = this.rowIsland.expandChildren;
     * ```
     * @memberof IgxRowIslandComponent
     */
    get expandChildren() {
        return this._defaultExpandState;
    }
    /**
     * @hidden
     */
    get id() {
        const pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
        return this.layout_id + pId + this.key;
    }
    /**
     * @hidden
     */
    get parentId() {
        return this.parentIsland ? this.parentIsland.id : null;
    }
    /**
     * @hidden
     */
    get level() {
        let ptr = this.parentIsland;
        let lvl = 0;
        while (ptr) {
            lvl++;
            ptr = ptr.parentIsland;
        }
        return lvl + 1;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.rootGrid = this.hgridAPI.grid;
        this.rowIslandAPI.rowIsland = this;
    }
    /**
     * @hidden
     */
    ngDoCheck() {
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.updateChildren();
        this.children.notifyOnChanges();
        this.children.changes.pipe(takeUntil(this.destroy$))
            .subscribe((change) => {
            this.updateChildren();
            // update existing grids since their child ri have been changed.
            this.getGridsForIsland(this.key).forEach(grid => {
                grid.onRowIslandChange(this.children);
            });
        });
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const topCols = this.columnList.filter((item) => {
            return colsArray.indexOf(item) === -1;
        });
        this.childColumns.reset(topCols);
        this.columnList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
            Promise.resolve().then(() => {
                this.updateColumnList();
            });
        });
    }
    updateChildren() {
        if (this.children.first === this) {
            this.children.reset(this.children.toArray().slice(1));
        }
        this.children.forEach(child => {
            child.parentIsland = this;
        });
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.rowIslandAPI.register(this);
        if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.registerChildRowIsland(this);
        }
        this._init = false;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.onLayoutChange.emit(changes);
        if (!this.isInit) {
            this.initialChanges.push(changes);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        // Override the base destroy because we don't have rendered anything to use removeEventListener on
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
        this.rowIslandAPI.unset(this.id);
        if (this.parentIsland) {
            this.getGridsForIsland(this.key).forEach(grid => {
                this.cleanGridState(grid);
                grid.hgridAPI.unsetChildRowIsland(this);
            });
            this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.unsetChildRowIsland(this);
            this.cleanGridState(this.rootGrid);
        }
    }
    cleanGridState(grid) {
        grid.childGridTemplates.forEach((tmpl) => {
            tmpl.owner.cleanView(tmpl.context.templateID);
        });
        grid.childGridTemplates.clear();
        grid.onRowIslandChange();
    }
    /**
     * @hidden
     */
    reflow() { }
    /**
     * @hidden
     */
    calculateGridHeight() { }
    updateColumnList() {
        const nestedColumns = this.children.map((layout) => layout.columnList.toArray());
        const colsArray = [].concat.apply([], nestedColumns);
        const topCols = this.columnList.filter((item) => {
            if (colsArray.indexOf(item) === -1) {
                /* Reset the default width of the columns that come into this row island,
                because the root catches them first during the detectChanges() and sets their defaultWidth. */
                item.defaultWidth = undefined;
                return true;
            }
            return false;
        });
        this.childColumns.reset(topCols);
        if (this.parentIsland) {
            this.parentIsland.columnList.notifyOnChanges();
        }
        else {
            this.rootGrid.columnList.notifyOnChanges();
        }
        this.rowIslandAPI.getChildGrids().forEach((grid) => {
            grid.createColumnsList(this.childColumns.toArray());
            if (!document.body.contains(grid.nativeElement)) {
                grid.updateOnRender = true;
            }
        });
    }
};
IgxRowIslandComponent.ɵfac = function IgxRowIslandComponent_Factory(t) { return new (t || IgxRowIslandComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(IgxColumnResizingService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(IgxGridTransaction), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(IgxHierarchicalGridNavigationService), ɵngcc0.ɵɵdirectiveInject(IgxFilteringService), ɵngcc0.ɵɵdirectiveInject(IgxOverlayService), ɵngcc0.ɵɵdirectiveInject(IgxGridSummaryService), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(IgxRowIslandAPIService)); };
IgxRowIslandComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxRowIslandComponent, selectors: [["igx-row-island"]], contentQueries: function IgxRowIslandComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent_1, false, IgxRowIslandComponent_1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxColumnComponent, false, IgxColumnComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childColumns = _t);
    } }, inputs: { expandChildren: "expandChildren", key: "key" }, outputs: { onLayoutChange: "onLayoutChange", onGridCreated: "onGridCreated", onGridInitialized: "onGridInitialized" }, features: [ɵngcc0.ɵɵProvidersFeature([IgxRowIslandAPIService]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function IgxRowIslandComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
IgxRowIslandComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: IgxColumnResizingService },
    { type: GridBaseAPIService },
    { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
    { type: ElementRef },
    { type: NgZone },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: IterableDiffers },
    { type: ViewContainerRef },
    { type: IgxHierarchicalGridNavigationService },
    { type: IgxFilteringService },
    { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
    { type: IgxGridSummaryService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: IgxRowIslandAPIService }
];
__decorate([
    Input()
], IgxRowIslandComponent.prototype, "key", void 0);
__decorate([
    Input()
], IgxRowIslandComponent.prototype, "expandChildren", null);
__decorate([
    ContentChildren(IgxRowIslandComponent_1, { read: IgxRowIslandComponent_1, descendants: false })
], IgxRowIslandComponent.prototype, "children", void 0);
__decorate([
    ContentChildren(IgxColumnComponent, { read: IgxColumnComponent, descendants: false })
], IgxRowIslandComponent.prototype, "childColumns", void 0);
__decorate([
    Output()
], IgxRowIslandComponent.prototype, "onLayoutChange", void 0);
__decorate([
    Output()
], IgxRowIslandComponent.prototype, "onGridCreated", void 0);
__decorate([
    Output()
], IgxRowIslandComponent.prototype, "onGridInitialized", void 0);
IgxRowIslandComponent = IgxRowIslandComponent_1 = __decorate([ __param(4, Inject(IgxGridTransaction)),
    __param(7, Inject(DOCUMENT)),
    __param(14, Inject(IgxOverlayService)),
    __param(16, Optional()), __param(16, Inject(DisplayDensityToken))
], IgxRowIslandComponent);

var IgxHierarchicalGridComponent_1;
let NEXT_ID$o = 0;
let IgxHierarchicalGridComponent = IgxHierarchicalGridComponent_1 = class IgxHierarchicalGridComponent extends IgxHierarchicalGridBaseDirective {
    constructor() {
        super(...arguments);
        /**
         * @hidden
         */
        this.childLayoutKeys = [];
        /**
         * @hidden
         */
        this.highlightedRowID = null;
        /**
         * @hidden
         */
        this.updateOnRender = false;
        /**
         * @hidden
         */
        this.parent = null;
        this._filteredData = null;
        this.h_id = `igx-hierarchical-grid-${NEXT_ID$o++}`;
        this.childGridTemplates = new Map();
        this.scrollTop = 0;
        this.scrollLeft = 0;
    }
    /**
     * Gets/Sets the value of the `id` attribute.
     * @remarks
     * If not provided it will be automatically generated.
     * @example
     * ```html
     * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     */
    get id() {
        return this.h_id;
    }
    set id(value) {
        this.h_id = value;
    }
    /**
     * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
     * ```html
     * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
            this.reflow();
        }
        this.cdr.markForCheck();
        if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
            // If the height will change based on how much data there is, recalculate sizes in igxForOf.
            this.notifyChanges(true);
        }
    }
    /**
     * Returns an array of data set to the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get data() {
        return this._data;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
     * Defult value is false.
     * ```html
     * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    set expandChildren(value) {
        this._defaultExpandState = value;
        this.expansionStates = new Map();
    }
    /**
     * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
     * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
     * ```typescript
     * const expanded = this.grid.expandChildren;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get expandChildren() {
        return this._defaultExpandState;
    }
    /**
     * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
     * parent grid is set or an object reference of the parent record otherwise.
     * ```typescript
     * const foreignKey = this.grid.foreignKey;
     * ```
     * @memberof IgxHierarchicalGridComponent
     */
    get foreignKey() {
        if (!this.parent) {
            return null;
        }
        return this.parent.hgridAPI.getParentRowId(this);
    }
    /**
     * @hidden
     */
    get hasExpandableChildren() {
        return !!this.childLayoutKeys.length;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this._transactions instanceof IgxTransactionService) {
            // transaction service cannot be injected in a derived class in a factory manner
            this._transactions = new IgxTransactionService();
        }
        this.expansionStatesChange.pipe(takeUntil(this.destroy$)).subscribe((value) => {
            const res = Array.from(value.entries()).filter(({ 1: v }) => v === true).map(([k]) => k);
        });
        super.ngOnInit();
    }
    ngDoCheck() {
        if (this._cdrRequestRepaint && !this._init) {
            this.updateSizes();
        }
        super.ngDoCheck();
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.verticalScrollContainer.getScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
        this.headerContainer.getScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe((view) => {
            const rowData = view.context.$implicit;
            if (this.isChildGridRecord(rowData)) {
                const cachedData = this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    const tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
        if (this.parent) {
            this._displayDensity = this.rootGrid._displayDensity;
            this.rootGrid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(() => {
                this._displayDensity = this.rootGrid._displayDensity;
                this.notifyChanges(true);
                this.cdr.markForCheck();
            });
            this.childLayoutKeys = this.parentIsland.children.map((item) => item.key);
        }
        this.toolbarCustomContentTemplates = this.parentIsland ?
            this.parentIsland.toolbarCustomContentTemplates :
            this.toolbarCustomContentTemplates;
        this.headSelectorsTemplates = this.parentIsland ?
            this.parentIsland.headSelectorsTemplates :
            this.headSelectorsTemplates;
        this.rowSelectorsTemplates = this.parentIsland ?
            this.parentIsland.rowSelectorsTemplates :
            this.rowSelectorsTemplates;
        this.dragIndicatorIconTemplate = this.parentIsland ?
            this.parentIsland.dragIndicatorIconTemplate :
            this.dragIndicatorIconTemplate;
        this.rowExpandedIndicatorTemplate = this.rootGrid.rowExpandedIndicatorTemplate;
        this.rowCollapsedIndicatorTemplate = this.rootGrid.rowCollapsedIndicatorTemplate;
        this.headerCollapseIndicatorTemplate = this.rootGrid.headerCollapseIndicatorTemplate;
        this.headerExpandIndicatorTemplate = this.rootGrid.headerExpandIndicatorTemplate;
        this.hasChildrenKey = this.parentIsland ?
            this.parentIsland.hasChildrenKey || this.rootGrid.hasChildrenKey :
            this.rootGrid.hasChildrenKey;
        this.showExpandAll = this.parentIsland ?
            this.parentIsland.showExpandAll : this.rootGrid.showExpandAll;
    }
    updateSizes() {
        if (document.body.contains(this.nativeElement) && this.isPercentWidth) {
            this.reflow();
            this.hgridAPI.getChildGrids(false).forEach((grid) => {
                grid.updateSizes();
            });
        }
    }
    _shouldAutoSize(renderedHeight) {
        if (this.isPercentHeight && this.parent) {
            return true;
        }
        return super._shouldAutoSize(renderedHeight);
    }
    get outletDirective() {
        return this.rootGrid._outletDirective;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        this.updateColumnList(false);
        this.childLayoutKeys = this.parent ?
            this.parentIsland.children.map((item) => item.key) :
            this.childLayoutKeys = this.childLayoutList.map((item) => item.key);
        this.childLayoutList.notifyOnChanges();
        this.childLayoutList.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.onRowIslandChange());
        super.ngAfterContentInit();
    }
    /** @hidden */
    featureColumnsWidth() {
        return super.featureColumnsWidth(this.headerHierarchyExpander);
    }
    /**
     * @hidden
     */
    onRowIslandChange() {
        if (this.parent) {
            this.childLayoutKeys = this.parentIsland.children.filter(item => !item._destroyed).map((item) => item.key);
        }
        else {
            this.childLayoutKeys = this.childLayoutList.filter(item => !item._destroyed).map((item) => item.key);
        }
        if (!this.cdr.destroyed) {
            this.cdr.detectChanges();
        }
    }
    setupColumns() {
        if (this.parentIsland && this.parentIsland.childColumns.length > 0 && !this.autoGenerate) {
            this.createColumnsList(this.parentIsland.childColumns.toArray());
        }
        super.setupColumns();
    }
    onColumnsChanged(change) {
        Promise.resolve().then(() => {
            this.updateColumnList();
            const cols = change.filter(c => c.gridAPI.grid === this);
            if (cols.length > 0 || this.autoGenerate) {
                this.columnList.reset(cols);
                super.onColumnsChanged(this.columnList);
            }
        });
    }
    updateColumnList(recalcColSizes = true) {
        const childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
        const nestedColumns = childLayouts.map((layout) => {
            return layout.columnList.toArray();
        });
        const colsArray = [].concat.apply([], nestedColumns);
        const colLength = this.columnList.length;
        if (colsArray.length > 0) {
            const topCols = this.columnList.filter((item) => {
                return colsArray.indexOf(item) === -1;
            });
            this.columnList.reset(topCols);
            if (recalcColSizes && this.columnList.length !== colLength) {
                this.calculateGridSizes(false);
            }
        }
    }
    ngOnDestroy() {
        if (!this.parent) {
            this.hgridAPI.getChildGrids(true).forEach((grid) => {
                if (!grid.childRow.cdr.destroyed) {
                    grid.childRow.cdr.destroy();
                }
            });
        }
        if (this.parent && this.selectionService.activeElement) {
            // in case selection is in destroyed child grid, selection should be cleared.
            this._clearSeletionHighlights();
        }
        super.ngOnDestroy();
    }
    _clearSeletionHighlights() {
        [this.rootGrid, ...this.rootGrid.getChildGrids(true)].forEach(grid => {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden
     */
    isRowHighlighted(rowData) {
        return this.highlightedRowID === rowData.rowID;
    }
    /**
     * @hidden
     */
    isHierarchicalRecord(record) {
        if (this.isGhostRecord(record)) {
            record = record.recordRef;
        }
        return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
    }
    /**
     * @hidden
     */
    isChildGridRecord(record) {
        // Can be null when there is defined layout but no child data was found
        return record.childGridsData !== undefined;
    }
    /**
     * @hidden
     */
    trackChanges(index, rec) {
        if (rec.childGridsData !== undefined) {
            // if is child rec
            return rec.rowID;
        }
        return rec;
    }
    /**
     * @hidden
     */
    getContext(rowData, rowIndex, pinned) {
        if (this.isChildGridRecord(rowData)) {
            const cachedData = this.childGridTemplates.get(rowData.rowID);
            if (cachedData) {
                const view = cachedData.view;
                const tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.dataView.indexOf(rowData)
                };
            }
            else {
                const rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData,
                    templateID: 'childRow-' + rowID,
                    index: this.dataView.indexOf(rowData)
                };
            }
        }
        else {
            return {
                $implicit: this.isGhostRecord(rowData) ? rowData.recordRef : rowData,
                templateID: 'dataRow',
                index: this.getDataViewIndex(rowIndex, pinned),
                disabled: this.isGhostRecord(rowData)
            };
        }
    }
    /**
     * @hidden
     */
    get rootGrid() {
        let currGrid = this;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
        else {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
    }
    /**
     * @hidden
     * @internal
     */
    getDragGhostCustomTemplate() {
        if (this.parentIsland) {
            return this.parentIsland.getDragGhostCustomTemplate();
        }
        return super.getDragGhostCustomTemplate();
    }
    /**
     * @hidden
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - hierarchical grid should not allow column layouts
            // remove column layouts
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     */
    getVisibleContentHeight() {
        let height = super.getVisibleContentHeight();
        if (this.parent) {
            const rootHeight = this.rootGrid.getVisibleContentHeight();
            const topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
            height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
        }
        return height;
    }
    /**
     * @hidden
     */
    toggleAll() {
        const expanded = this.hasExpandedRecords() && this.hasExpandableChildren;
        if (!expanded && this.showExpandAll) {
            this.expandAll();
        }
        else {
            this.collapseAll();
        }
    }
    /**
     * @hidden
     * @internal
     */
    hasExpandedRecords() {
        if (this.expandChildren) {
            return true;
        }
        let hasExpandedEntry = false;
        this.expansionStates.forEach((value, key) => {
            if (value) {
                hasExpandedEntry = value;
            }
        });
        return hasExpandedEntry;
    }
    getDefaultExpandState(record) {
        if (this.hasChildrenKey && !record[this.hasChildrenKey]) {
            return false;
        }
        return this.expandChildren;
    }
    /**
     * @hidden
     */
    isExpanded(record) {
        return this.gridAPI.get_row_expansion_state(record);
    }
    /**
     * @hidden
     */
    viewCreatedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            const key = args.context.$implicit.rowID;
            this.childGridTemplates.set(key, args);
        }
    }
    /**
     * @hidden
     */
    viewMovedHandler(args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            // view was moved, update owner in cache
            const key = args.context.$implicit.rowID;
            const cachedData = this.childGridTemplates.get(key);
            cachedData.owner = args.owner;
            this.childLayoutList.forEach((layout) => {
                const relatedGrid = this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                if (relatedGrid && relatedGrid.updateOnRender) {
                    // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                    relatedGrid.notifyChanges(true);
                    relatedGrid.updateOnRender = false;
                }
            });
            const childGrids = this.getChildGrids(true);
            childGrids.forEach((grid) => {
                if (grid.isPercentWidth) {
                    grid.notifyChanges(true);
                }
                grid.updateScrollPosition();
            });
        }
    }
    /**
     * @hidden
     */
    updateScrollPosition() {
        const vScr = this.verticalScrollContainer.getScroll();
        const hScr = this.headerContainer.getScroll();
        if (vScr) {
            vScr.scrollTop = this.scrollTop;
        }
        if (hScr) {
            hScr.scrollLeft = this.scrollLeft;
        }
    }
    getChildGrids(inDeph) {
        return this.hgridAPI.getChildGrids(inDeph);
    }
    generateDataFields(data) {
        return super.generateDataFields(data).filter((field) => {
            const layoutsList = this.parentIsland ? this.parentIsland.children : this.childLayoutList;
            const keys = layoutsList.map((item) => item.key);
            return keys.indexOf(field) === -1;
        });
    }
    hg_verticalScrollHandler(event) {
        this.scrollTop = event.target.scrollTop;
    }
    onContainerScroll() {
        this.hideOverlays();
    }
    hg_horizontalScrollHandler(event) {
        this.scrollLeft = event.target.scrollLeft;
    }
};
IgxHierarchicalGridComponent.ɵfac = function IgxHierarchicalGridComponent_Factory(t) { return ɵIgxHierarchicalGridComponent_BaseFactory(t || IgxHierarchicalGridComponent); };
IgxHierarchicalGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxHierarchicalGridComponent, selectors: [["igx-hierarchical-grid"]], contentQueries: function IgxHierarchicalGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, false, IgxRowIslandComponent);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxRowIslandComponent, true, IgxRowIslandComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childLayoutList = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.allLayoutList = _t);
    } }, viewQuery: function IgxHierarchicalGridComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c207, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c208, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c209, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxTemplateOutletDirective, true, IgxTemplateOutletDirective);
        ɵngcc0.ɵɵviewQuery(IgxChildGridRowComponent, true, IgxChildGridRowComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hierarchicalRecordTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.childTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerHierarchyExpander = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateOutlets = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hierarchicalRows = _t);
    } }, hostVars: 1, hostBindings: function IgxHierarchicalGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", data: "data", expandChildren: "expandChildren" }, features: [ɵngcc0.ɵɵProvidersFeature([
            IgxGridSelectionService,
            IgxGridCRUDService,
            { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
            { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxHierarchicalGridComponent_1) },
            IgxGridSummaryService,
            IgxFilteringService,
            IgxHierarchicalGridNavigationService,
            IgxForOfSyncService,
            IgxForOfScrollSyncService,
            IgxRowIslandAPIService
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c173, decls: 102, vars: 161, consts: [["role", "toolbar", 3, "max-width", "flex-basis", "gridID", "displayDensity", 4, "ngIf"], [1, "igx-grid__thead"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__thead-wrapper", 3, "focus", "keydown"], ["theadRow", ""], ["role", "row", 1, "igx-grid__tr"], ["id", "left", "class", "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop", 4, "ngIf"], ["id", "left", "class", "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop", "left", 4, "ngIf"], [3, "hidden", "ngClass", "click", "mousedown"], ["headerHierarchyExpander", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForTrackBy", "igxForSizePropName"], ["hContainer", ""], [3, "width", "column", 4, "ngIf"], ["loadingOverlay", ""], [3, "indeterminate", 4, "ngIf"], ["id", "right", "class", "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop", 4, "ngIf"], [1, "igx-grid__thead-thumb", 3, "hidden"], ["igxGridBody", "", 1, "igx-grid__tbody", 3, "keydown.control.c", "copy"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tbody-content", 3, "igxGridDragSelect", "focus", "keydown", "onDragStop", "onDragScroll", "scroll"], ["tbody", ""], ["pinnedRecordsTemplate", ""], [4, "ngTemplateOutlet"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollOrientation", "igxForScrollContainer", "igxForContainerSize", "igxForItemSize", "igxForTrackBy", "onChunkPreload"], ["verticalScrollContainer", ""], ["hierarchical_record_template", ""], ["pinned_hierarchical_record_template", ""], ["child_record_template", ""], ["igxOverlayOutlet", "", 1, "igx-grid__row-editing-outlet"], ["igxRowEditingOverlayOutlet", ""], [1, "igx-grid__tbody-scrollbar", 3, "hidden"], [1, "igx-grid__tbody-scrollbar-start"], [1, "igx-grid__tbody-scrollbar-main"], ["igxGridFor", "", 3, "igxGridForOf"], ["verticalScrollHolder", ""], [1, "igx-grid__tbody-scrollbar-end"], ["tabindex", "0", "role", "rowgroup", 1, "igx-grid__tfoot", 3, "focus", "keydown"], ["tfoot", ""], ["role", "row", "class", "igx-grid__summaries", 3, "width", "height", "gridID", "summaries", "index", 4, "ngIf"], [1, "igx-grid__tfoot-thumb", 3, "hidden"], [1, "igx-grid__scroll", 3, "hidden"], ["scr", ""], [1, "igx-grid__scroll-start"], [1, "igx-grid__scroll-main"], ["scrollContainer", ""], [1, "igx-grid__scroll-end", 3, "hidden"], [1, "igx-grid__footer"], ["footer", ""], ["defaultPaginator", ""], ["emptyFilteredGrid", ""], ["defaultEmptyGrid", ""], ["defaultLoadingGrid", ""], ["defaultCollapsedTemplate", ""], ["defaultExpandedTemplate", ""], ["igxToggle", "", 4, "ngIf"], ["defaultRowEditText", ""], ["defaultRowEditActions", ""], ["defaultRowEditTemplate", ""], ["dragIndicatorIconBase", ""], ["igxHeadSelector", ""], ["headSelectorBaseTemplate", ""], ["igxOverlayOutlet", "", 1, "igx-grid__loading-outlet"], ["igxLoadingOverlayOutlet", ""], ["igxOverlayOutlet", "", 1, "igx-grid__outlet", 3, "keydown"], ["igxFilteringOverlayOutlet", ""], ["role", "toolbar", 3, "gridID", "displayDensity"], ["toolbar", ""], ["id", "left", 1, "igx-grid__scroll-on-drag-left", 3, "igxColumnMovingDrop"], ["id", "left", 1, "igx-grid__scroll-on-drag-pinned", 3, "igxColumnMovingDrop"], [1, "igx-grid__drag-indicator", 3, "ngClass"], ["headerDragContainer", ""], [2, "visibility", "hidden"], [1, "igx-grid__cbx-selection", 3, "ngClass", "click"], ["headerSelectorContainer", ""], ["headSelector", ""], ["ngFor", "", 3, "ngForOf"], [3, "column", "gridID"], [3, "column"], ["filteringRow", ""], [3, "indeterminate"], ["id", "right", 1, "igx-grid__scroll-on-drag-right", 3, "igxColumnMovingDrop"], ["class", "igx-grid__tr--pinned", 3, "ngClass", "width", 4, "ngIf"], [1, "igx-grid__tr--pinned", 3, "ngClass"], ["pinContainer", ""], [4, "ngFor", "ngForOf"], [3, "igxTemplateOutlet", "igxTemplateOutletContext", "onViewCreated", "onViewMoved", "onCachedViewLoaded"], [3, "gridID", "index", "disabled", "rowData"], ["row", ""], [3, "gridID", "index", "rowData"], ["row", "", "pinnedRow", ""], [2, "overflow", "auto", "width", "100%", 3, "ngClass", "scroll"], [3, "parentGridID", "index", "rowData", "layout", 4, "ngFor", "ngForOf"], [3, "parentGridID", "index", "rowData", "layout"], ["role", "row", 1, "igx-grid__summaries", 3, "gridID", "summaries", "index"], ["summaryRow", ""], [3, "displayDensity", "page", "totalRecords", "perPage", "pageChange", "perPageChange"], [1, "igx-grid__tbody-message"], [1, "igx-grid__loading"], ["role", "button", "fontSet", "material"], ["role", "button", "fontSet", "material", 3, "isActive"], ["igxToggle", ""], [3, "className"], ["igxButton", "", "igxRowEditTabStop", "", 3, "click"], [1, "igx-banner__message"], [1, "igx-banner__text"], [1, "igx-banner__actions"], [1, "igx-banner__row"], ["fontSet", "material"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "ngStyle", "indeterminate", "aria-label"], ["headerCheckbox", ""]], template: function IgxHierarchicalGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c169);
        ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridComponent_igx_grid_toolbar_0_Template, 2, 6, "igx-grid-toolbar", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵlistener("focus", function IgxHierarchicalGridComponent_Template_div_focus_2_listener() { return ctx.navigation.focusFirstCell(); })("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_2_listener($event) { return ctx.navigation.headerNavigation($event); });
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxHierarchicalGridComponent_span_5_Template, 1, 2, "span", 5);
        ɵngcc0.ɵɵtemplate(6, IgxHierarchicalGridComponent_span_6_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵelementStart(7, "div", 7, 8);
        ɵngcc0.ɵɵlistener("click", function IgxHierarchicalGridComponent_Template_div_click_7_listener() { return ctx.toggleAll(); })("mousedown", function IgxHierarchicalGridComponent_Template_div_mousedown_7_listener($event) { return $event.preventDefault(); });
        ɵngcc0.ɵɵtemplate(9, IgxHierarchicalGridComponent_ng_container_9_Template, 1, 0, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(10, IgxHierarchicalGridComponent_ng_container_10_Template, 5, 4, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(11, IgxHierarchicalGridComponent_ng_container_11_Template, 4, 12, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(12, IgxHierarchicalGridComponent_ng_container_12_Template, 3, 3, "ng-container", 10);
        ɵngcc0.ɵɵtemplate(13, IgxHierarchicalGridComponent_ng_template_13_Template, 1, 6, "ng-template", 11, 12, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(15, "igxTopLevel");
        ɵngcc0.ɵɵtemplate(16, IgxHierarchicalGridComponent_ng_container_16_Template, 3, 3, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(17, IgxHierarchicalGridComponent_igx_grid_filtering_row_17_Template, 2, 3, "igx-grid-filtering-row", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(18, "div", null, 14);
        ɵngcc0.ɵɵtemplate(20, IgxHierarchicalGridComponent_igx_circular_bar_20_Template, 1, 1, "igx-circular-bar", 15);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(21, IgxHierarchicalGridComponent_span_21_Template, 1, 2, "span", 16);
        ɵngcc0.ɵɵelement(22, "div", 17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(23, "div", 18);
        ɵngcc0.ɵɵlistener("keydown.control.c", function IgxHierarchicalGridComponent_Template_div_keydown_control_c_23_listener() { return ctx.copyHandlerIE(); })("copy", function IgxHierarchicalGridComponent_Template_div_copy_23_listener($event) { return ctx.copyHandler($event); });
        ɵngcc0.ɵɵelementStart(24, "div", 19, 20);
        ɵngcc0.ɵɵlistener("focus", function IgxHierarchicalGridComponent_Template_div_focus_24_listener($event) { return ctx.navigation.focusTbody($event); })("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_24_listener($event) { return ctx.navigation.handleNavigation($event); })("onDragStop", function IgxHierarchicalGridComponent_Template_div_onDragStop_24_listener($event) { return ctx.selectionService.dragMode = $event; })("onDragScroll", function IgxHierarchicalGridComponent_Template_div_onDragScroll_24_listener($event) { return ctx.dragScroll($event); })("scroll", function IgxHierarchicalGridComponent_Template_div_scroll_24_listener($event) { return ctx.preventContainerScroll($event); });
        ɵngcc0.ɵɵtemplate(26, IgxHierarchicalGridComponent_span_26_Template, 1, 2, "span", 5);
        ɵngcc0.ɵɵtemplate(27, IgxHierarchicalGridComponent_span_27_Template, 1, 4, "span", 6);
        ɵngcc0.ɵɵtemplate(28, IgxHierarchicalGridComponent_ng_template_28_Template, 6, 43, "ng-template", null, 21, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(30, IgxHierarchicalGridComponent_ng_container_30_Template, 1, 0, "ng-container", 22);
        ɵngcc0.ɵɵtemplate(31, IgxHierarchicalGridComponent_ng_template_31_Template, 1, 2, "ng-template", 23, 24, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(33, "gridRowPinning");
        ɵngcc0.ɵɵpipe(34, "gridHierarchical");
        ɵngcc0.ɵɵpipe(35, "gridHierarchicalPaging");
        ɵngcc0.ɵɵpipe(36, "gridSort");
        ɵngcc0.ɵɵpipe(37, "gridFiltering");
        ɵngcc0.ɵɵpipe(38, "visibleColumns");
        ɵngcc0.ɵɵpipe(39, "gridTransaction");
        ɵngcc0.ɵɵlistener("onChunkPreload", function IgxHierarchicalGridComponent_Template_ng_template_onChunkPreload_31_listener($event) { return ctx.dataLoading($event); });
        ɵngcc0.ɵɵtemplate(40, IgxHierarchicalGridComponent_ng_template_40_Template, 2, 4, "ng-template", null, 25, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(42, IgxHierarchicalGridComponent_ng_template_42_Template, 3, 3, "ng-template", null, 26, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(44, IgxHierarchicalGridComponent_ng_template_44_Template, 2, 5, "ng-template", null, 27, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(46, IgxHierarchicalGridComponent_ng_container_46_Template, 1, 0, "ng-container", 22);
        ɵngcc0.ɵɵtemplate(47, IgxHierarchicalGridComponent_ng_container_47_Template, 1, 0, "ng-container", 22);
        ɵngcc0.ɵɵtemplate(48, IgxHierarchicalGridComponent_span_48_Template, 1, 2, "span", 16);
        ɵngcc0.ɵɵelement(49, "div", 28, 29);
        ɵngcc0.ɵɵtemplate(51, IgxHierarchicalGridComponent_igc_trial_watermark_51_Template, 1, 0, "igc-trial-watermark", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(52, IgxHierarchicalGridComponent_span_52_Template, 1, 2, "span", 16);
        ɵngcc0.ɵɵelementStart(53, "div", 30);
        ɵngcc0.ɵɵelement(54, "div", 31);
        ɵngcc0.ɵɵelementStart(55, "div", 32);
        ɵngcc0.ɵɵtemplate(56, IgxHierarchicalGridComponent_ng_template_56_Template, 0, 0, "ng-template", 33, 34, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(58, "div", 35);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(59, "div", 36, 37);
        ɵngcc0.ɵɵlistener("focus", function IgxHierarchicalGridComponent_Template_div_focus_59_listener() { return ctx.navigation.focusFirstCell(false); })("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_59_listener($event) { return ctx.navigation.summaryNav($event); });
        ɵngcc0.ɵɵtemplate(61, IgxHierarchicalGridComponent_igx_grid_summary_row_61_Template, 3, 10, "igx-grid-summary-row", 38);
        ɵngcc0.ɵɵelement(62, "div", 39);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(63, "div", 40, 41);
        ɵngcc0.ɵɵelement(65, "div", 42);
        ɵngcc0.ɵɵelementStart(66, "div", 43);
        ɵngcc0.ɵɵtemplate(67, IgxHierarchicalGridComponent_ng_template_67_Template, 0, 0, "ng-template", 33, 44, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(69, "div", 45);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(70, "div", 46, 47);
        ɵngcc0.ɵɵprojection(72);
        ɵngcc0.ɵɵtemplate(73, IgxHierarchicalGridComponent_ng_container_73_Template, 2, 4, "ng-container", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(74, IgxHierarchicalGridComponent_ng_template_74_Template, 1, 4, "ng-template", null, 48, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(76, IgxHierarchicalGridComponent_ng_template_76_Template, 2, 1, "ng-template", null, 49, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(78, IgxHierarchicalGridComponent_ng_template_78_Template, 2, 1, "ng-template", null, 50, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(80, IgxHierarchicalGridComponent_ng_template_80_Template, 2, 1, "ng-template", null, 51, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(82, IgxHierarchicalGridComponent_ng_template_82_Template, 2, 0, "ng-template", null, 52, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(84, IgxHierarchicalGridComponent_ng_template_84_Template, 2, 1, "ng-template", null, 53, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(86, IgxHierarchicalGridComponent_div_86_Template, 3, 6, "div", 54);
        ɵngcc0.ɵɵtemplate(87, IgxHierarchicalGridComponent_ng_template_87_Template, 1, 1, "ng-template", null, 55, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(89, IgxHierarchicalGridComponent_ng_template_89_Template, 4, 0, "ng-template", null, 56, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(91, IgxHierarchicalGridComponent_ng_template_91_Template, 6, 8, "ng-template", null, 57, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(93, IgxHierarchicalGridComponent_ng_template_93_Template, 2, 0, "ng-template", null, 58, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(95, IgxHierarchicalGridComponent_ng_template_95_Template, 3, 8, "ng-template", 59, 60, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(97, IgxHierarchicalGridComponent_igx_grid_column_resizer_97_Template, 1, 0, "igx-grid-column-resizer", 10);
        ɵngcc0.ɵɵelement(98, "div", 61, 62);
        ɵngcc0.ɵɵelementStart(100, "div", 63, 64);
        ɵngcc0.ɵɵlistener("keydown", function IgxHierarchicalGridComponent_Template_div_keydown_100_listener($event) { return ctx.gridOutletKeyboardHandler($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1358 = ɵngcc0.ɵɵreference(29);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToolbar);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasExpandableChildren || !ctx.hasVisibleColumns)("ngClass", ɵngcc0.ɵɵpureFunction3(126, _c212, ctx.hasExpandableChildren, ctx.filteringService.isFilterRowVisible, ctx.isRowSelectable || ctx.rowDraggable));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.iconTemplate)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(130, _c13, ctx));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(15, 85, ctx.unpinnedColumns))("igxForScrollOrientation", "horizontal")("igxForScrollContainer", ctx.parentVirtDir)("igxForContainerSize", ctx.unpinnedWidth)("igxForTrackBy", ctx.trackColumnChanges)("igxForSizePropName", "calcPixelWidth");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.filteringService.isFilterRowVisible);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.shouldOverlayLoading);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", ctx.totalHeight, "px")("width", ctx.calcWidth, "px");
        ɵngcc0.ɵɵproperty("igxGridDragSelect", ctx.selectionService.dragMode);
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length <= 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn && ctx.pinnedColumns.length > 0);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && ctx.isRowPinningToTop ? _r1358 : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind4(33, 87, ɵngcc0.ɵɵpipeBindV(34, 92, ɵngcc0.ɵɵpureFunction6(152, _c203, ɵngcc0.ɵɵpipeBindV(35, 99, ɵngcc0.ɵɵpureFunction5(146, _c171, ɵngcc0.ɵɵpipeBindV(36, 105, ɵngcc0.ɵɵpureFunction5(140, _c171, ɵngcc0.ɵɵpipeBindV(37, 111, ɵngcc0.ɵɵpureFunction7(132, _c170, ɵngcc0.ɵɵpipeBind2(38, 119, ɵngcc0.ɵɵpipeBind3(39, 122, ctx.data, ctx.id, ctx.pipeTrigger), ctx.hasVisibleColumns), ctx.filteringExpressionsTree, ctx.filterStrategy, ctx.advancedFilteringExpressionsTree, ctx.id, ctx.pipeTrigger, ctx.filteringPipeTrigger)), ctx.sortingExpressions, ctx.sortStrategy, ctx.id, ctx.pipeTrigger)), ctx.page, ctx.perPage, ctx.id, ctx.pipeTrigger)), ctx.expansionStates, ctx.id, ctx.primaryKey, ctx.childLayoutKeys, ctx.pipeTrigger)), ctx.id, false, ctx.pipeTrigger))("igxForScrollOrientation", "vertical")("igxForScrollContainer", ctx.verticalScroll)("igxForContainerSize", ctx.calcHeight)("igxForItemSize", ctx.renderedRowHeight)("igxForTrackBy", ctx.trackChanges);
        ɵngcc0.ɵɵadvance(15);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasPinnedRecords && !ctx.isRowPinningToTop ? _r1358 : null);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.parent);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasMovableColumns && ctx.draggedColumn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.calcHeight, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(159, _c172));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("height", !ctx.isRowPinningToTop ? ctx.pinnedRowHeight : 0, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px");
        ɵngcc0.ɵɵattribute("aria-activedescendant", ctx.activeDescendant);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasSummarizedColumns && ctx.rootSummariesEnabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("height", ctx.summariesHeight, "px")("width", ctx.scrollWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", !ctx.hasVerticalScroll());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.isHorizontalScrollHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px")("min-width", ctx.isPinningToStart ? ctx.pinnedWidth : ctx.headerFeaturesWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.unpinnedWidth, "px");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpureFunction0(160, _c172));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵstyleProp("float", "right")("width", ctx.pinnedWidth, "px")("min-width", ctx.pinnedWidth, "px");
        ɵngcc0.ɵɵproperty("hidden", ctx.pinnedWidth === 0 || ctx.isPinningToStart);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.paging && ctx.totalRecords);
        ɵngcc0.ɵɵadvance(13);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowEditable);
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", ctx.colResizingService.showResizer);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, IgxGridForOfDirective,
        IgxGridBodyDirective,
        IgxGridDragSelectDirective,
        IgxOverlayOutletDirective,
        IgxHeadSelectorDirective,
        IgxGridToolbarComponent,
        IgxColumnMovingDropDirective, ɵngcc2.NgForOf, IgxGridHeaderGroupComponent,
        IgxGridFilteringRowComponent,
        IgxCircularProgressBarComponent,
        IgxTemplateOutletDirective,
        IgxHierarchicalRowComponent,
        IgxChildGridRowComponent,
        IgxSummaryRowComponent,
        IgxPaginatorComponent,
        IgxIconComponent,
        IgxToggleDirective,
        IgxButtonDirective,
        IgxRowEditTabStopDirective,
        IgxCheckboxComponent, ɵngcc2.NgStyle, IgxGridColumnResizerComponent]; }, pipes: function () { return [IgxGridTopLevelColumns,
        IgxGridRowPinningPipe,
        IgxGridHierarchicalPipe,
        IgxGridHierarchicalPagingPipe,
        IgxGridSortingPipe,
        IgxGridFilteringPipe,
        IgxHasVisibleColumnsPipe,
        IgxGridTransactionPipe,
        IgxSummaryDataPipe]; }, encapsulation: 2, changeDetection: 0 });
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxHierarchicalGridComponent.prototype, "id", null);
__decorate([
    Input()
], IgxHierarchicalGridComponent.prototype, "data", null);
__decorate([
    Input()
], IgxHierarchicalGridComponent.prototype, "expandChildren", null);
__decorate([
    ContentChildren(IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false })
], IgxHierarchicalGridComponent.prototype, "childLayoutList", void 0);
__decorate([
    ContentChildren(IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true })
], IgxHierarchicalGridComponent.prototype, "allLayoutList", void 0);
__decorate([
    ViewChild('hierarchical_record_template', { read: TemplateRef, static: true })
], IgxHierarchicalGridComponent.prototype, "hierarchicalRecordTemplate", void 0);
__decorate([
    ViewChild('child_record_template', { read: TemplateRef, static: true })
], IgxHierarchicalGridComponent.prototype, "childTemplate", void 0);
__decorate([
    ViewChild('headerHierarchyExpander', { read: ElementRef, static: true })
], IgxHierarchicalGridComponent.prototype, "headerHierarchyExpander", void 0);
__decorate([
    ViewChildren(IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective })
], IgxHierarchicalGridComponent.prototype, "templateOutlets", void 0);
__decorate([
    ViewChildren(IgxChildGridRowComponent, { read: IgxChildGridRowComponent })
], IgxHierarchicalGridComponent.prototype, "hierarchicalRows", void 0);

let IgxHierarchicalGridCellComponent = class IgxHierarchicalGridCellComponent extends IgxGridCellComponent {
    constructor(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil) {
        super(selectionService, crudService, gridAPI, cdr, helement, zone, touchManager, platformUtil);
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        this.helement = helement;
        this.zone = zone;
        this.platformUtil = platformUtil;
    }
    ngOnInit() {
        super.ngOnInit();
        this._rootGrid = this._getRootGrid();
    }
    _getRootGrid() {
        let currGrid = this.grid;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    }
    // TODO: Extend the new selection service to avoid complete traversal
    _clearAllHighlights() {
        [this._rootGrid, ...this._rootGrid.getChildGrids(true)].forEach(grid => {
            grid.selectionService.clear();
            if (grid.navigation.activeNode) {
                grid.navigation.activeNode.row = null;
            }
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    }
    /**
     * @hidden
     * @internal
     */
    activate(event) {
        this._clearAllHighlights();
        const currentElement = this.grid.nativeElement;
        let parentGrid = this.grid;
        let childGrid;
        // add highligh to the current grid
        if (this._rootGrid.id !== currentElement.id) {
            currentElement.classList.add('igx-grid__tr--highlighted');
        }
        this.grid.navigation.activeNode = this.selectionNode;
        // add highligh to the current grid
        while (this._rootGrid.id !== parentGrid.id) {
            childGrid = parentGrid;
            parentGrid = parentGrid.parent;
            const parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
            parentGrid.highlightedRowID = parentRowID;
        }
        super.activate(event);
    }
};
IgxHierarchicalGridCellComponent.ɵfac = function IgxHierarchicalGridCellComponent_Factory(t) { return new (t || IgxHierarchicalGridCellComponent)(ɵngcc0.ɵɵdirectiveInject(IgxGridSelectionService), ɵngcc0.ɵɵdirectiveInject(IgxGridCRUDService), ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxHierarchicalGridCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxHierarchicalGridCellComponent, selectors: [["igx-hierarchical-grid-cell"]], features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 8, vars: 4, consts: [["defaultPinnedIndicator", ""], ["defaultCell", ""], ["inlineEditor", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity", 4, "ngIf"], [1, "igx-grid__td--pinned-chip", 3, "disabled", "displayDensity"], ["igxTextHighlight", "", 1, "igx-grid__td-text", 2, "pointer-events", "none", 3, "cssClass", "activeCssClass", "groupName", "value", "row", "column", "containerClass", "metadata"], [4, "ngIf"], ["displayDensity", "compact"], ["igxInput", "", 3, "value", "igxFocus", "input"], ["igxInput", "", "type", "number", 3, "value", "igxFocus", "input"], [3, "value", "checked", "igxFocus", "disableRipple", "change"], ["mode", "dropdown", 3, "outlet", "locale", "value", "igxFocus", "labelVisibility", "valueChange"]], template: function IgxHierarchicalGridCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxHierarchicalGridCellComponent_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxHierarchicalGridCellComponent_ng_template_2_Template, 6, 21, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxHierarchicalGridCellComponent_ng_template_4_Template, 4, 4, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(6, IgxHierarchicalGridCellComponent_ng_container_6_Template, 1, 0, "ng-container", 3);
        ɵngcc0.ɵɵtemplate(7, IgxHierarchicalGridCellComponent_ng_container_7_Template, 1, 0, "ng-container", 3);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.pinnedIndicatorTemplate)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxChipComponent,
        IgxTextHighlightDirective,
        IgxInputGroupComponent,
        IgxInputDirective,
        IgxFocusDirective,
        IgxCheckboxComponent,
        IgxDatePickerComponent], pipes: [IgxDecimalPipeComponent,
        IgxDatePipeComponent], encapsulation: 2, changeDetection: 0 });
IgxHierarchicalGridCellComponent.ctorParameters = () => [
    { type: IgxGridSelectionService },
    { type: IgxGridCRUDService },
    { type: GridBaseAPIService },
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];

var IgxHierarchicalRowComponent_1;
let IgxHierarchicalRowComponent = IgxHierarchicalRowComponent_1 = class IgxHierarchicalRowComponent extends IgxRowDirective {
    constructor() {
        super(...arguments);
        this.expanderClass = 'igx-grid__hierarchical-expander';
        /**
         * @hidden
         * @internal
         */
        this.select = () => {
            this.grid.selectRows([this.rowID]);
        };
        /**
         * @hidden
         * @internal
         */
        this.deselect = () => {
            this.grid.deselectRows([this.rowID]);
        };
    }
    /**
     * @hidden
     */
    get expanderClassResolved() {
        return {
            [this.expanderClass]: !this.pinned || this.disabled,
            [`${this.expanderClass}--empty`]: this.pinned && !this.disabled
        };
    }
    get viewIndex() {
        return this.index + this.grid.page * this.grid.perPage;
    }
    /**
     * Returns whether the row is expanded.
     * ```typescript
     * const RowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
    get expanded() {
        return this.gridAPI.get_row_expansion_state(this.rowData);
    }
    /**
     * @hidden
     */
    get expandedClass() {
        return this.expanded && !this.pinned;
    }
    get hasChildren() {
        return !!this.grid.childLayoutKeys.length;
    }
    /**
     * @hidden
     */
    get highlighted() {
        return this.grid && this.grid.highlightedRowID === this.rowID;
    }
    /**
     * @hidden
     */
    expanderClick(event) {
        event.stopPropagation();
        this.toggle();
    }
    /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    toggle() {
        if (this.added) {
            return;
        }
        const grid = this.gridAPI.grid;
        this.endEdit(grid.rootGrid);
        this.gridAPI.set_row_expansion_state(this.rowID, !this.expanded);
        grid.cdr.detectChanges();
    }
    /**
     * @hidden
     */
    get iconTemplate() {
        let expandable = true;
        if (this.grid.hasChildrenKey) {
            expandable = this.rowData[this.grid.hasChildrenKey];
        }
        if (!expandable || (this.pinned && !this.disabled)) {
            return this.defaultEmptyTemplate;
        }
        if (this.expanded) {
            return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    endEdit(grid) {
        if (grid.crudService.inEditMode) {
            grid.endEdit();
        }
        grid.hgridAPI.getChildGrids(true).forEach(g => {
            if (g.crudService.inEditMode) {
                g.endEdit();
            }
        });
    }
};
IgxHierarchicalRowComponent.ɵfac = function IgxHierarchicalRowComponent_Factory(t) { return ɵIgxHierarchicalRowComponent_BaseFactory(t || IgxHierarchicalRowComponent); };
IgxHierarchicalRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxHierarchicalRowComponent, selectors: [["igx-hierarchical-grid-row"]], viewQuery: function IgxHierarchicalRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c213, true, ElementRef);
        ɵngcc0.ɵɵstaticViewQuery(_c118, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c214, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c119, true, TemplateRef);
        ɵngcc0.ɵɵviewQuery(IgxHierarchicalGridCellComponent, true, IgxHierarchicalGridCellComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.expander = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultExpandedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultEmptyTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultCollapsedTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cells = _t);
    } }, hostVars: 4, hostBindings: function IgxHierarchicalRowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-grid__tr--expanded", ctx.expandedClass)("igx-grid__tr--highlighted", ctx.highlighted);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxHierarchicalRowComponent_1) }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 18, vars: 13, consts: [[3, "ngClass", "click", "mousedown", 4, "ngIf"], ["defaultExpandedTemplate", ""], ["defaultCollapsedTemplate", ""], ["defaultEmptyTemplate", ""], [4, "ngIf"], ["igxGridFor", "", 3, "igxGridForOf", "igxForScrollContainer", "igxForSizePropName", "igxForScrollOrientation", "igxForContainerSize", "igxForTrackBy"], ["igxDirRef", ""], ["rowSelectorBaseTemplate", ""], ["pinnedCellsTemplate", ""], [3, "ngClass", "click", "mousedown"], ["expander", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["fontSet", "material", 3, "isActive"], ["fontSet", "material"], [3, "igxRowDrag", "ghostTemplate", "click"], [4, "ngTemplateOutlet"], [1, "igx-grid__cbx-selection", 3, "click"], [1, "igx-grid__td", "igx-grid__td--fw", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "active", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "cellSelectionMode", "displayPinnedChip"], [1, "igx-grid__cbx-padding"], ["disableRipple", "true", 3, "tabindex", "readonly", "checked", "disabled", "disableTransitions", "aria-label"], ["class", "igx-grid__td igx-grid__td--fw igx-grid__td--pinned", 3, "igx-grid__td--number", "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "active", "firstPinned", "lastPinned", "min-height", "rowData", "min-width", "max-width", "flex-basis", "left", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "cellSelectionMode", "displayPinnedChip", 4, "ngFor", "ngForOf"], [1, "igx-grid__td", "igx-grid__td--fw", "igx-grid__td--pinned", 3, "ngClass", "ngStyle", "editMode", "column", "formatter", "row", "active", "firstPinned", "lastPinned", "rowData", "width", "visibleColumnIndex", "value", "cellTemplate", "lastSearchInfo", "cellSelectionMode", "displayPinnedChip"]], template: function IgxHierarchicalRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxHierarchicalRowComponent_div_0_Template, 3, 5, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxHierarchicalRowComponent_ng_template_1_Template, 2, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, IgxHierarchicalRowComponent_ng_template_3_Template, 2, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxHierarchicalRowComponent_ng_template_5_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxHierarchicalRowComponent_ng_container_7_Template, 3, 5, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(8, IgxHierarchicalRowComponent_ng_container_8_Template, 3, 10, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(9, IgxHierarchicalRowComponent_ng_container_9_Template, 2, 2, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(10, IgxHierarchicalRowComponent_ng_template_10_Template, 3, 49, "ng-template", 5, 6, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵpipe(12, "igxNotGrouped");
        ɵngcc0.ɵɵtemplate(13, IgxHierarchicalRowComponent_ng_container_13_Template, 2, 2, "ng-container", 4);
        ɵngcc0.ɵɵtemplate(14, IgxHierarchicalRowComponent_ng_template_14_Template, 2, 6, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(16, IgxHierarchicalRowComponent_ng_template_16_Template, 2, 3, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasChildren);
        ɵngcc0.ɵɵadvance(7);
        ɵngcc0.ɵɵproperty("ngIf", ctx.rowDraggable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showRowSelectors);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && ctx.grid.isPinningToStart);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("igxGridForOf", ɵngcc0.ɵɵpipeBind1(12, 11, ctx.unpinnedColumns))("igxForScrollContainer", ctx.grid.parentVirtDir)("igxForSizePropName", "calcPixelWidth")("igxForScrollOrientation", "horizontal")("igxForContainerSize", ctx.grid.unpinnedWidth)("igxForTrackBy", ctx.grid.trackColumnChanges);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.pinnedColumns.length > 0 && !ctx.grid.isPinningToStart);
    } }, directives: [ɵngcc2.NgIf, IgxGridForOfDirective, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet, IgxIconComponent,
        IgxRowDragDirective,
        IgxHierarchicalGridCellComponent, ɵngcc2.NgStyle, IgxCheckboxComponent, ɵngcc2.NgForOf], pipes: [IgxGridNotGroupedPipe,
        IgxGridCellStyleClassesPipe,
        IgxGridCellStylesPipe], encapsulation: 2, changeDetection: 0 });
__decorate([
    ViewChildren(forwardRef(() => IgxHierarchicalGridCellComponent), { read: IgxHierarchicalGridCellComponent })
], IgxHierarchicalRowComponent.prototype, "_cells", void 0);
__decorate([
    ViewChild('expander', { read: ElementRef })
], IgxHierarchicalRowComponent.prototype, "expander", void 0);
__decorate([
    ViewChild('defaultExpandedTemplate', { read: TemplateRef, static: true })
], IgxHierarchicalRowComponent.prototype, "defaultExpandedTemplate", void 0);
__decorate([
    ViewChild('defaultEmptyTemplate', { read: TemplateRef, static: true })
], IgxHierarchicalRowComponent.prototype, "defaultEmptyTemplate", void 0);
__decorate([
    ViewChild('defaultCollapsedTemplate', { read: TemplateRef, static: true })
], IgxHierarchicalRowComponent.prototype, "defaultCollapsedTemplate", void 0);
__decorate([
    HostBinding('class.igx-grid__tr--expanded')
], IgxHierarchicalRowComponent.prototype, "expandedClass", null);
__decorate([
    HostBinding('class.igx-grid__tr--highlighted')
], IgxHierarchicalRowComponent.prototype, "highlighted", null);

/**
 * @hidden
 */
let IgxGridHierarchicalPipe = class IgxGridHierarchicalPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, state = new Map(), id, primaryKey, childKeys, pipeTrigger) {
        if (childKeys.length === 0) {
            return collection;
        }
        const grid = this.gridAPI.grid;
        const result = this.addHierarchy(grid, cloneArray(collection), state, primaryKey, childKeys);
        return result;
    }
    addHierarchy(grid, data, state, primaryKey, childKeys) {
        const result = [];
        data.forEach((v) => {
            result.push(v);
            const childGridsData = {};
            childKeys.forEach((childKey) => {
                const childData = v[childKey] ? v[childKey] : null;
                childGridsData[childKey] = childData;
            });
            if (grid.gridAPI.get_row_expansion_state(v)) {
                result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData: childGridsData });
            }
        });
        return result;
    }
};
IgxGridHierarchicalPipe.ɵfac = function IgxGridHierarchicalPipe_Factory(t) { return new (t || IgxGridHierarchicalPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridHierarchicalPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridHierarchical", type: IgxGridHierarchicalPipe, pure: true });
IgxGridHierarchicalPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];
/**
 * @hidden
 */
let IgxGridHierarchicalPagingPipe = class IgxGridHierarchicalPagingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, page = 0, perPage = 15, id, pipeTrigger) {
        if (!this.gridAPI.grid.paging) {
            return collection;
        }
        const state = {
            index: page,
            recordsPerPage: perPage
        };
        const result = DataUtil.page(cloneArray(collection), state);
        this.gridAPI.grid.pagingState = state;
        return result;
    }
};
IgxGridHierarchicalPagingPipe.ɵfac = function IgxGridHierarchicalPagingPipe_Factory(t) { return new (t || IgxGridHierarchicalPagingPipe)(ɵngcc0.ɵɵdirectiveInject(GridBaseAPIService)); };
IgxGridHierarchicalPagingPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "gridHierarchicalPaging", type: IgxGridHierarchicalPagingPipe, pure: true });
IgxGridHierarchicalPagingPipe.ctorParameters = () => [
    { type: GridBaseAPIService }
];

/**
 * @hidden
 */
let IgxHierarchicalGridModule = class IgxHierarchicalGridModule {
};
IgxHierarchicalGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxHierarchicalGridModule });
IgxHierarchicalGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxHierarchicalGridModule_Factory(t) { return new (t || IgxHierarchicalGridModule)(); }, imports: [[
            IgxGridModule,
        ],
        IgxGridModule] });

var IgxNavbarComponent_1;
/**
 * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
 */
let IgxActionIconDirective = class IgxActionIconDirective {
};
IgxActionIconDirective.ɵfac = function IgxActionIconDirective_Factory(t) { return new (t || IgxActionIconDirective)(); };
IgxActionIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxActionIconDirective, selectors: [["igx-action-icon"]] });
let NEXT_ID$p = 0;
/**
 * **Ignite UI for Angular Navbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
 *
 * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
 * state such as a "Go Back" button. It also supports other actions represented by icons.
 *
 * Example:
 * ```html
 * <igx-navbar title="Sample App" actionButtonIcon="menu">
 *   <igx-icon>search</igx-icon>
 *   <igx-icon>favorite</igx-icon>
 *   <igx-icon>more_vert</igx-icon>
 * </igx-navbar>
 * ```
 */
let IgxNavbarComponent = IgxNavbarComponent_1 = class IgxNavbarComponent {
    constructor() {
        this.isVisible = true;
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.id = `igx-navbar-${NEXT_ID$p++}`;
        /**
         * The event that will be thrown when the action is executed,
         * provides reference to the `IgxNavbar` component as argument
         * ```typescript
         * public actionExc(event){
         *     alert("Action Execute!");
         * }
         *  //..
         * ```
         * ```html
         * <igx-navbar (onAction)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.onAction = new EventEmitter();
        /**
         * An @Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
         * ```html
         * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.titleId = `igx-navbar-${IgxNavbarComponent_1.NEXT_ID++}`;
    }
    /**
     * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
     * ```typescript
     *  @ViewChild("MyChild")
     * public navBar: IgxNavbarComponent;
     * ngAfterViewInit(){
     *     let actionButtonVisibile = this.navBar.isActionButtonVisible;
     * }
     * ```
     */
    get isActionButtonVisible() {
        if (this.actionIconTemplate || !this.actionButtonIcon) {
            return false;
        }
        return this.isVisible;
    }
    /**
     * Sets whether the action button of the `IgxNavbarComponent` is visible.
     * ```html
     * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
     * ```
     */
    set isActionButtonVisible(value) {
        this.isVisible = value;
    }
    /**
     * @hidden
     */
    _triggerAction() {
        this.onAction.emit(this);
    }
};
IgxNavbarComponent.ɵfac = function IgxNavbarComponent_Factory(t) { return new (t || IgxNavbarComponent)(); };
IgxNavbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxNavbarComponent, selectors: [["igx-navbar"]], contentQueries: function IgxNavbarComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxActionIconDirective, true, IgxActionIconDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.actionIconTemplate = _t.first);
    } }, hostVars: 1, hostBindings: function IgxNavbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", titleId: "titleId", isActionButtonVisible: "isActionButtonVisible", actionButtonIcon: "actionButtonIcon", title: "title" }, outputs: { onAction: "onAction" }, ngContentSelectors: _c217, decls: 8, vars: 4, consts: [["role", "navigation", 1, "igx-navbar"], [1, "igx-navbar__left"], ["fontSet", "material", 3, "click", 4, "ngIf"], [1, "igx-navbar__title"], [1, "igx-navbar__right"], ["fontSet", "material", 3, "click"]], template: function IgxNavbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c216);
        ɵngcc0.ɵɵelementStart(0, "nav", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, IgxNavbarComponent_igx_icon_2_Template, 2, 1, "igx-icon", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementStart(4, "h1", 3);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "div", 4);
        ɵngcc0.ɵɵprojection(7, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.titleId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isActionButtonVisible);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("id", ctx.titleId);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
    } }, directives: [ɵngcc2.NgIf, IgxIconComponent], styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"] });
IgxNavbarComponent.NEXT_ID = 1;
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxNavbarComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxNavbarComponent.prototype, "isActionButtonVisible", null);
__decorate([
    Input()
], IgxNavbarComponent.prototype, "actionButtonIcon", void 0);
__decorate([
    Input()
], IgxNavbarComponent.prototype, "title", void 0);
__decorate([
    Output()
], IgxNavbarComponent.prototype, "onAction", void 0);
__decorate([
    Input()
], IgxNavbarComponent.prototype, "titleId", void 0);
__decorate([
    ContentChild(IgxActionIconDirective, { read: IgxActionIconDirective })
], IgxNavbarComponent.prototype, "actionIconTemplate", void 0);
/**
 * @hidden
 */
let IgxNavbarModule = class IgxNavbarModule {
};
IgxNavbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxNavbarModule });
IgxNavbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxNavbarModule_Factory(t) { return new (t || IgxNavbarModule)(); }, imports: [[IgxButtonModule, IgxIconModule, CommonModule]] });

let IgxNavDrawerItemDirective = class IgxNavDrawerItemDirective {
    constructor() {
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.isHeader = false;
        /**
         * @hidden
         */
        this.activeClass = 'igx-nav-drawer__item--active';
    }
    /**
     * @hidden
     */
    get defaultCSS() {
        return !this.active && !this.isHeader;
    }
    /**
     * @hidden
     */
    get currentCSS() {
        return this.active && !this.isHeader;
    }
    /**
     * @hidden
     */
    get headerCSS() {
        return this.isHeader;
    }
};
IgxNavDrawerItemDirective.ɵfac = function IgxNavDrawerItemDirective_Factory(t) { return new (t || IgxNavDrawerItemDirective)(); };
IgxNavDrawerItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavDrawerItemDirective, selectors: [["", "igxDrawerItem", ""]], hostVars: 6, hostBindings: function IgxNavDrawerItemDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__item", ctx.defaultCSS)("igx-nav-drawer__item--active", ctx.currentCSS)("igx-nav-drawer__item--header", ctx.headerCSS);
    } }, inputs: { active: "active", isHeader: "isHeader" }, exportAs: ["igxDrawerItem"] });
__decorate([
    Input('active')
], IgxNavDrawerItemDirective.prototype, "active", void 0);
__decorate([
    Input('isHeader')
], IgxNavDrawerItemDirective.prototype, "isHeader", void 0);
__decorate([
    HostBinding('class.igx-nav-drawer__item')
], IgxNavDrawerItemDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-nav-drawer__item--active')
], IgxNavDrawerItemDirective.prototype, "currentCSS", null);
__decorate([
    HostBinding('class.igx-nav-drawer__item--header')
], IgxNavDrawerItemDirective.prototype, "headerCSS", null);
let IgxNavDrawerTemplateDirective = class IgxNavDrawerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxNavDrawerTemplateDirective.ɵfac = function IgxNavDrawerTemplateDirective_Factory(t) { return new (t || IgxNavDrawerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxNavDrawerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavDrawerTemplateDirective, selectors: [["", "igxDrawer", ""]] });
IgxNavDrawerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
let IgxNavDrawerMiniTemplateDirective = class IgxNavDrawerMiniTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxNavDrawerMiniTemplateDirective.ɵfac = function IgxNavDrawerMiniTemplateDirective_Factory(t) { return new (t || IgxNavDrawerMiniTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxNavDrawerMiniTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxNavDrawerMiniTemplateDirective, selectors: [["", "igxDrawerMini", ""]] });
IgxNavDrawerMiniTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

let NEXT_ID$q = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
let IgxNavigationDrawerComponent = class IgxNavigationDrawerComponent {
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        /** @hidden @internal */
        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID$q++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /** Pan animation properties */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            let deltaX;
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.addClass(this.overlay, 'panning');
                this.renderer.addClass(this.drawer, 'panning');
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            let visibleWidth;
            let newX;
            let percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     */
    get isOpen() {
        return this._isOpen;
    }
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /** @hidden */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this.renderer.addClass(this.styleDummy, this.css.mini);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                    this.renderer.removeClass(this.styleDummy, this.css.mini);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    // force class for width calc. TODO?
                    this.renderer.addClass(this.styleDummy, this.css.drawer);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.removeClass(this.styleDummy, this.css.drawer);
                }
                return this._widthCache.width;
            }
        }
    }
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    updateEdgeZone() {
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.removeClass(this.overlay, 'panning');
        this.renderer.removeClass(this.drawer, 'panning');
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                this.renderer.setStyle(this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                this.renderer.setStyle(this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                this.renderer.setStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
};
IgxNavigationDrawerComponent.ɵfac = function IgxNavigationDrawerComponent_Factory(t) { return new (t || IgxNavigationDrawerComponent)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(HammerGesturesManager), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxNavigationDrawerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxNavigationDrawerComponent, selectors: [["igx-nav-drawer"]], contentQueries: function IgxNavigationDrawerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavDrawerMiniTemplateDirective, true, IgxNavDrawerMiniTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxNavDrawerTemplateDirective, true, IgxNavDrawerTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.miniTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTemplate = _t.first);
    } }, viewQuery: function IgxNavigationDrawerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c218, true);
        ɵngcc0.ɵɵstaticViewQuery(_c219, true);
        ɵngcc0.ɵɵstaticViewQuery(_c220, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._drawer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._overlay = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._styleDummy = _t.first);
    } }, hostVars: 7, hostBindings: function IgxNavigationDrawerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.flexWidth)("order", ctx.isPinnedRight);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer", ctx.cssClass);
    } }, inputs: { id: "id", position: "position", enableGestures: "enableGestures", pin: "pin", pinThreshold: "pinThreshold", width: "width", miniWidth: "miniWidth", isOpen: "isOpen" }, outputs: { isOpenChange: "isOpenChange", pinChange: "pinChange", opening: "opening", opened: "opened", closing: "closing", closed: "closed" }, features: [ɵngcc0.ɵɵProvidersFeature([HammerGesturesManager]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 9, vars: 14, consts: [["defaultItemsTemplate", ""], [1, "igx-nav-drawer__overlay", 3, "hidden", "click"], ["overlay", ""], ["role", "navigation", 1, "igx-nav-drawer__aside"], ["aside", ""], [4, "ngTemplateOutlet"], [1, "igx-nav-drawer__style-dummy"], ["dummy", ""], ["igxDrawerItem", "", 3, "isHeader"], ["igxDrawerItem", ""]], template: function IgxNavigationDrawerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxNavigationDrawerComponent_ng_template_0_Template, 13, 1, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵlistener("click", function IgxNavigationDrawerComponent_Template_div_click_2_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "aside", 3, 4);
        ɵngcc0.ɵɵtemplate(6, IgxNavigationDrawerComponent_ng_container_6_Template, 1, 0, "ng-container", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "div", 6, 7);
    } if (rf & 2) {
        const _r1533 = ɵngcc0.ɵɵreference(1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__overlay--hidden", !ctx.isOpen);
        ɵngcc0.ɵɵproperty("hidden", ctx.pin);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("igx-nav-drawer__aside--collapsed", !ctx.miniTemplate && !ctx.isOpen)("igx-nav-drawer__aside--mini", ctx.miniTemplate && !ctx.isOpen)("igx-nav-drawer__aside--normal", !ctx.miniTemplate || ctx.isOpen)("igx-nav-drawer__aside--pinned", ctx.pin)("igx-nav-drawer__aside--right", ctx.position == "right");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template || _r1533);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxNavDrawerItemDirective], styles: ["[_nghost-%COMP%] {\n            display: block;\n            height: 100%;\n        }"] });
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
__decorate([
    HostBinding('class.igx-nav-drawer')
], IgxNavigationDrawerComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxNavigationDrawerComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "position", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "enableGestures", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "isOpen", null);
__decorate([
    Output()
], IgxNavigationDrawerComponent.prototype, "isOpenChange", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "pin", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "pinThreshold", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "width", void 0);
__decorate([
    Input()
], IgxNavigationDrawerComponent.prototype, "miniWidth", void 0);
__decorate([
    Output()
], IgxNavigationDrawerComponent.prototype, "pinChange", void 0);
__decorate([
    Output()
], IgxNavigationDrawerComponent.prototype, "opening", void 0);
__decorate([
    Output()
], IgxNavigationDrawerComponent.prototype, "opened", void 0);
__decorate([
    Output()
], IgxNavigationDrawerComponent.prototype, "closing", void 0);
__decorate([
    Output()
], IgxNavigationDrawerComponent.prototype, "closed", void 0);
__decorate([
    ContentChild(IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective })
], IgxNavigationDrawerComponent.prototype, "miniTemplate", null);
__decorate([
    ContentChild(IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective })
], IgxNavigationDrawerComponent.prototype, "contentTemplate", void 0);
__decorate([
    HostBinding('style.flexBasis')
], IgxNavigationDrawerComponent.prototype, "flexWidth", null);
__decorate([
    HostBinding('style.order')
], IgxNavigationDrawerComponent.prototype, "isPinnedRight", null);
__decorate([
    ViewChild('aside', { static: true })
], IgxNavigationDrawerComponent.prototype, "_drawer", void 0);
__decorate([
    ViewChild('overlay', { static: true })
], IgxNavigationDrawerComponent.prototype, "_overlay", void 0);
__decorate([
    ViewChild('dummy', { static: true })
], IgxNavigationDrawerComponent.prototype, "_styleDummy", void 0);
IgxNavigationDrawerComponent = __decorate([ __param(0, Inject(ElementRef)),
    __param(1, Optional())
], IgxNavigationDrawerComponent);

/**
 * @hidden
 */
let IgxNavigationDrawerModule = class IgxNavigationDrawerModule {
};
IgxNavigationDrawerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxNavigationDrawerModule });
IgxNavigationDrawerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxNavigationDrawerModule_Factory(t) { return new (t || IgxNavigationDrawerModule)(); }, imports: [[CommonModule]] });

/**
 * Template directive that allows you to set a custom template representing the lower label value of the {@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbFrom let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * @context {@link IgxSliderComponent.context}
 */
let IgxThumbFromTemplateDirective = class IgxThumbFromTemplateDirective {
};
IgxThumbFromTemplateDirective.ɵfac = function IgxThumbFromTemplateDirective_Factory(t) { return new (t || IgxThumbFromTemplateDirective)(); };
IgxThumbFromTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxThumbFromTemplateDirective, selectors: [["", "igxSliderThumbFrom", ""]] });
/**
 * Template directive that allows you to set a custom template representing the upper label value of the {@link IgxSliderComponent}
 *
 * ```html
 * <igx-slider>
 *  <ng-template igxSliderThumbTo let-value let-labels>{{value}}</ng-template>
 * </igx-slider>
 * ```
 *
 * @context {@link IgxSliderComponent.context}
 */
let IgxThumbToTemplateDirective = class IgxThumbToTemplateDirective {
};
IgxThumbToTemplateDirective.ɵfac = function IgxThumbToTemplateDirective_Factory(t) { return new (t || IgxThumbToTemplateDirective)(); };
IgxThumbToTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxThumbToTemplateDirective, selectors: [["", "igxSliderThumbTo", ""]] });
/**
 * Template directive that allows you to set a custom template, represeting primary/secondary tick labels of the {@link IgxSliderComponent}
 *
 * @context {@link IgxTicksComponent.context}
 */
let IgxTickLabelTemplateDirective = class IgxTickLabelTemplateDirective {
};
IgxTickLabelTemplateDirective.ɵfac = function IgxTickLabelTemplateDirective_Factory(t) { return new (t || IgxTickLabelTemplateDirective)(); };
IgxTickLabelTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTickLabelTemplateDirective, selectors: [["", "igxSliderTickLabel", ""]] });
var IgxSliderType;
(function (IgxSliderType) {
    /**
     * Slider with single thumb.
     */
    IgxSliderType[IgxSliderType["SLIDER"] = 0] = "SLIDER";
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    IgxSliderType[IgxSliderType["RANGE"] = 1] = "RANGE";
})(IgxSliderType || (IgxSliderType = {}));
var SliderHandle;
(function (SliderHandle) {
    SliderHandle[SliderHandle["FROM"] = 0] = "FROM";
    SliderHandle[SliderHandle["TO"] = 1] = "TO";
})(SliderHandle || (SliderHandle = {}));
/**
 * Slider Tick labels Orientation
 */
var TickLabelsOrientation;
(function (TickLabelsOrientation) {
    TickLabelsOrientation[TickLabelsOrientation["Horizontal"] = 0] = "Horizontal";
    TickLabelsOrientation[TickLabelsOrientation["TopToBottom"] = 1] = "TopToBottom";
    TickLabelsOrientation[TickLabelsOrientation["BottomToTop"] = 2] = "BottomToTop";
})(TickLabelsOrientation || (TickLabelsOrientation = {}));
/**
 * Slider Ticks orientation
 */
var TicksOrientation;
(function (TicksOrientation) {
    TicksOrientation[TicksOrientation["Top"] = 0] = "Top";
    TicksOrientation[TicksOrientation["Bottom"] = 1] = "Bottom";
    TicksOrientation[TicksOrientation["Mirror"] = 2] = "Mirror";
})(TicksOrientation || (TicksOrientation = {}));

/**
 * @hidden
 */
let IgxSliderThumbComponent = class IgxSliderThumbComponent {
    constructor(_elementRef, _dir) {
        this._elementRef = _elementRef;
        this._dir = _dir;
        this._isActive = false;
        this._isPressed = false;
        this._destroy$ = new Subject();
        this.isActive = false;
        this.onThumbValueChange = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onHoverChange = new EventEmitter();
        this.tabindex = 0;
        this.zIndex = 0;
    }
    get thumbPositionX() {
        const thumbBounderies = this.nativeElement.getBoundingClientRect();
        const thumbCenter = (thumbBounderies.right - thumbBounderies.left) / 2;
        return thumbBounderies.left + thumbCenter;
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this._isActive;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this._isActive;
    }
    get thumbPressedClass() {
        return this.isActive && this._isPressed;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get destroy() {
        return this._destroy$;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.onPan
            .pipe(takeUntil(this._destroy$))
            .subscribe(mouseX => this.updateThumbValue(mouseX));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    onPinterEnter() {
        this.onHoverChange.emit(true);
    }
    onPointerLeave() {
        this.onHoverChange.emit(false);
    }
    onKeyDown(event) {
        if (this.disabled) {
            return;
        }
        let increment = 0;
        if (event.key.endsWith('Left')) {
            increment = this.step * -1;
        }
        else if (event.key.endsWith('Right')) {
            increment = this.step;
        }
        else {
            return;
        }
        this.onChange.emit();
        this.onThumbValueChange.emit(increment);
    }
    onBlur() {
        this.isActive = false;
        this.zIndex = 0;
    }
    onFocusListener() {
        this.isActive = true;
        this.zIndex = 1;
    }
    /**
     * Show thumb label and ripple.
     */
    showThumbIndicators() {
        this.toggleThumbIndicators(true);
    }
    /**
     * Hide thumb label and ripple.
     */
    hideThumbIndicators() {
        this.toggleThumbIndicators(false);
    }
    updateThumbValue(mouseX) {
        const updateValue = this.calculateTrackUpdate(mouseX);
        if (this.isActive && updateValue !== 0) {
            this.onThumbValueChange.emit(updateValue);
        }
    }
    calculateTrackUpdate(mouseX) {
        const scaleX = this._dir.rtl ? this.thumbPositionX - mouseX : mouseX - this.thumbPositionX;
        const stepDistanceCenter = this.stepDistance / 2;
        // If the thumb scale range (slider update) is less thàn a half step,
        // the position stays the same.
        const scaleXPositive = Math.abs(scaleX);
        if (scaleXPositive < stepDistanceCenter) {
            return 0;
        }
        return this.stepToProceed(scaleX, this.stepDistance);
    }
    stepToProceed(scaleX, stepDist) {
        return Math.round(scaleX / stepDist) * this.step;
    }
    toggleThumbIndicators(visible) {
        this._isPressed = visible;
        if (this.continuous || this.deactiveState) {
            this._isActive = false;
        }
        else {
            this._isActive = visible;
        }
    }
};
IgxSliderThumbComponent.ɵfac = function IgxSliderThumbComponent_Factory(t) { return new (t || IgxSliderThumbComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxDirectionality)); };
IgxSliderThumbComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSliderThumbComponent, selectors: [["igx-thumb"]], hostVars: 12, hostBindings: function IgxSliderThumbComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerenter", function IgxSliderThumbComponent_pointerenter_HostBindingHandler() { return ctx.onPinterEnter(); })("pointerleave", function IgxSliderThumbComponent_pointerleave_HostBindingHandler() { return ctx.onPointerLeave(); })("keydown", function IgxSliderThumbComponent_keydown_HostBindingHandler($event) { return ctx.onKeyDown($event); })("blur", function IgxSliderThumbComponent_blur_HostBindingHandler() { return ctx.onBlur(); })("focus", function IgxSliderThumbComponent_focus_HostBindingHandler() { return ctx.onFocusListener(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("z-index", ctx.zIndex);
        ɵngcc0.ɵɵclassProp("igx-slider__thumb-from", ctx.thumbFromClass)("igx-slider__thumb-to", ctx.thumbToClass)("igx-slider__thumb-from--active", ctx.thumbFromActiveClass)("igx-slider__thumb-to--active", ctx.thumbToActiveClass)("igx-slider__thumb--pressed", ctx.thumbPressedClass);
    } }, inputs: { value: "value", continuous: "continuous", thumbLabelVisibilityDuration: "thumbLabelVisibilityDuration", disabled: "disabled", onPan: "onPan", stepDistance: "stepDistance", step: "step", templateRef: "templateRef", context: "context", type: "type", deactiveState: "deactiveState" }, outputs: { onThumbValueChange: "onThumbValueChange", onChange: "onChange", onHoverChange: "onHoverChange" }, decls: 1, vars: 0, consts: [[1, "dot"]], template: function IgxSliderThumbComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0);
    } }, encapsulation: 2 });
IgxSliderThumbComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxDirectionality }
];
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "continuous", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "thumbLabelVisibilityDuration", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "onPan", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "stepDistance", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "step", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "templateRef", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "context", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxSliderThumbComponent.prototype, "deactiveState", void 0);
__decorate([
    Output()
], IgxSliderThumbComponent.prototype, "onThumbValueChange", void 0);
__decorate([
    Output()
], IgxSliderThumbComponent.prototype, "onChange", void 0);
__decorate([
    Output()
], IgxSliderThumbComponent.prototype, "onHoverChange", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxSliderThumbComponent.prototype, "tabindex", void 0);
__decorate([
    HostBinding('attr.z-index')
], IgxSliderThumbComponent.prototype, "zIndex", void 0);
__decorate([
    HostBinding('class.igx-slider__thumb-from')
], IgxSliderThumbComponent.prototype, "thumbFromClass", null);
__decorate([
    HostBinding('class.igx-slider__thumb-to')
], IgxSliderThumbComponent.prototype, "thumbToClass", null);
__decorate([
    HostBinding('class.igx-slider__thumb-from--active')
], IgxSliderThumbComponent.prototype, "thumbFromActiveClass", null);
__decorate([
    HostBinding('class.igx-slider__thumb-to--active')
], IgxSliderThumbComponent.prototype, "thumbToActiveClass", null);
__decorate([
    HostBinding('class.igx-slider__thumb--pressed')
], IgxSliderThumbComponent.prototype, "thumbPressedClass", null);
__decorate([
    HostListener('pointerenter')
], IgxSliderThumbComponent.prototype, "onPinterEnter", null);
__decorate([
    HostListener('pointerleave')
], IgxSliderThumbComponent.prototype, "onPointerLeave", null);
__decorate([
    HostListener('keydown', ['$event'])
], IgxSliderThumbComponent.prototype, "onKeyDown", null);
__decorate([
    HostListener('blur')
], IgxSliderThumbComponent.prototype, "onBlur", null);
__decorate([
    HostListener('focus')
], IgxSliderThumbComponent.prototype, "onFocusListener", null);

let IgxThumbLabelComponent = class IgxThumbLabelComponent {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    get thumbFromClass() {
        return this.type === SliderHandle.FROM;
    }
    get thumbToClass() {
        return this.type === SliderHandle.TO;
    }
    get thumbFromActiveClass() {
        return this.type === SliderHandle.FROM && this.active;
    }
    get thumbToActiveClass() {
        return this.type === SliderHandle.TO && this.active;
    }
    get nativeElement() {
        return this._elementRef.nativeElement;
    }
    get active() {
        return this._active;
    }
    set active(val) {
        if (this.continuous || this.deactiveState) {
            this._active = false;
        }
        else {
            this._active = val;
        }
    }
};
IgxThumbLabelComponent.ɵfac = function IgxThumbLabelComponent_Factory(t) { return new (t || IgxThumbLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxThumbLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxThumbLabelComponent, selectors: [["igx-thumb-label"]], hostVars: 8, hostBindings: function IgxThumbLabelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-slider__label-from", ctx.thumbFromClass)("igx-slider__label-to", ctx.thumbToClass)("igx-slider__label-from--active", ctx.thumbFromActiveClass)("igx-slider__label-to--active", ctx.thumbToActiveClass);
    } }, inputs: { value: "value", templateRef: "templateRef", context: "context", type: "type", continuous: "continuous", deactiveState: "deactiveState" }, decls: 4, vars: 2, consts: [[1, "label"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["thumbFromDefaultTemplate", ""]], template: function IgxThumbLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxThumbLabelComponent_ng_container_1_Template, 1, 0, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, IgxThumbLabelComponent_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1540 = ɵngcc0.ɵɵreference(3);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.templateRef ? ctx.templateRef : _r1540)("ngTemplateOutletContext", ctx.context);
    } }, directives: [ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
IgxThumbLabelComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], IgxThumbLabelComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxThumbLabelComponent.prototype, "templateRef", void 0);
__decorate([
    Input()
], IgxThumbLabelComponent.prototype, "context", void 0);
__decorate([
    Input()
], IgxThumbLabelComponent.prototype, "type", void 0);
__decorate([
    Input()
], IgxThumbLabelComponent.prototype, "continuous", void 0);
__decorate([
    Input()
], IgxThumbLabelComponent.prototype, "deactiveState", void 0);
__decorate([
    HostBinding('class.igx-slider__label-from')
], IgxThumbLabelComponent.prototype, "thumbFromClass", null);
__decorate([
    HostBinding('class.igx-slider__label-to')
], IgxThumbLabelComponent.prototype, "thumbToClass", null);
__decorate([
    HostBinding('class.igx-slider__label-from--active')
], IgxThumbLabelComponent.prototype, "thumbFromActiveClass", null);
__decorate([
    HostBinding('class.igx-slider__label-to--active')
], IgxThumbLabelComponent.prototype, "thumbToActiveClass", null);

/**
 * @hidden
 */
let IgxTicksComponent = class IgxTicksComponent {
    constructor() {
        /**
         * @hidden
         */
        this.ticksClass = true;
    }
    /**
     * @hidden
     */
    get ticksTopClass() {
        return this.ticksOrientation === TicksOrientation.Top;
    }
    /**
     * @hidden
     */
    get hasPrimaryClass() {
        return this.primaryTicks > 0;
    }
    /**
     * @hidden
     */
    get labelsTopToBottomClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.TopToBottom;
    }
    /**
     * @hidden
     */
    get labelsBottomToTopClass() {
        return this.tickLabelsOrientation === TickLabelsOrientation.BottomToTop;
    }
    /**
     * Returns the template context corresponding to
     * {@link IgxTickLabelTemplateDirective}
     *
     * ```typescript
     * return {
     *  $implicit //returns the value per each tick label.
     *  isPrimery //returns if the tick is primary.
     *  labels // returns the {@link labels} collection.
     *  index // returns the index per each tick of the whole sequence.
     * }
     * ```
     *
     * @param idx the index per each tick label.
     */
    context(idx) {
        return {
            $implicit: this.tickLabel(idx),
            isPrimary: this.isPrimary(idx),
            labels: this.labels,
            index: idx
        };
    }
    /**
     * @hidden
     */
    get ticksLength() {
        return this.primaryTicks > 0 ?
            ((this.primaryTicks - 1) * this.secondaryTicks) + this.primaryTicks :
            this.secondaryTicks > 0 ? this.secondaryTicks : 0;
    }
    hiddenTickLabels(idx) {
        return this.isPrimary(idx) ? this.primaryTickLabels : this.secondaryTickLabels;
    }
    /**
     * @hidden
     */
    isPrimary(idx) {
        return this.primaryTicks <= 0 ? false :
            idx % (this.secondaryTicks + 1) === 0;
    }
    /**
     * @hidden
     */
    tickLabel(idx) {
        if (this.labelsViewEnabled) {
            return this.labels[idx];
        }
        const labelStep = (Math.max(this.minValue, this.maxValue) - Math.min(this.minValue, this.maxValue)) / (this.ticksLength - 1);
        const labelVal = labelStep * idx;
        return (this.minValue + labelVal).toFixed(2);
    }
};
IgxTicksComponent.ɵfac = function IgxTicksComponent_Factory(t) { return new (t || IgxTicksComponent)(); };
IgxTicksComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTicksComponent, selectors: [["igx-ticks"]], hostVars: 10, hostBindings: function IgxTicksComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-slider__ticks", ctx.ticksClass)("igx-slider__ticks--top", ctx.ticksTopClass)("igx-slider__ticks--tall", ctx.hasPrimaryClass)("igx-slider__tick-labels--top-bottom", ctx.labelsTopToBottomClass)("igx-slider__tick-labels--bottom-top", ctx.labelsBottomToTopClass);
    } }, inputs: { primaryTicks: "primaryTicks", secondaryTicks: "secondaryTicks", primaryTickLabels: "primaryTickLabels", secondaryTickLabels: "secondaryTickLabels", ticksOrientation: "ticksOrientation", tickLabelsOrientation: "tickLabelsOrientation", maxValue: "maxValue", minValue: "minValue", labelsViewEnabled: "labelsViewEnabled", labels: "labels", tickLabelTemplateRef: "tickLabelTemplateRef" }, decls: 3, vars: 2, consts: [["class", "igx-slider__ticks-group", 3, "ngClass", 4, "ngFor", "ngForOf"], ["tickLabelDefaultTemplate", ""], [1, "igx-slider__ticks-group", 3, "ngClass"], [1, "igx-slider__ticks-tick"], [1, "igx-slider__ticks-label", 3, "ngClass"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function IgxTicksComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTicksComponent_div_0_Template, 4, 8, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ɵngcc0.ɵɵpureFunction0(1, _c172).constructor(ctx.ticksLength));
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgClass, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
__decorate([
    Input()
], IgxTicksComponent.prototype, "primaryTicks", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "secondaryTicks", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "primaryTickLabels", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "secondaryTickLabels", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "ticksOrientation", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "tickLabelsOrientation", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "maxValue", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "minValue", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "labelsViewEnabled", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "labels", void 0);
__decorate([
    Input()
], IgxTicksComponent.prototype, "tickLabelTemplateRef", void 0);
__decorate([
    HostBinding('class.igx-slider__ticks')
], IgxTicksComponent.prototype, "ticksClass", void 0);
__decorate([
    HostBinding('class.igx-slider__ticks--top')
], IgxTicksComponent.prototype, "ticksTopClass", null);
__decorate([
    HostBinding('class.igx-slider__ticks--tall')
], IgxTicksComponent.prototype, "hasPrimaryClass", null);
__decorate([
    HostBinding('class.igx-slider__tick-labels--top-bottom')
], IgxTicksComponent.prototype, "labelsTopToBottomClass", null);
__decorate([
    HostBinding('class.igx-slider__tick-labels--bottom-top')
], IgxTicksComponent.prototype, "labelsBottomToTopClass", null);

let IgxTickLabelsPipe = class IgxTickLabelsPipe {
    transform(labels, secondaryTicks) {
        if (!labels) {
            return;
        }
        const result = [];
        labels.forEach(item => {
            result.push(item);
            for (let i = 0; i < secondaryTicks; i++) {
                result.push('');
            }
        });
        return result;
    }
};
IgxTickLabelsPipe.ɵfac = function IgxTickLabelsPipe_Factory(t) { return new (t || IgxTickLabelsPipe)(); };
IgxTickLabelsPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "spreadTickLabels", type: IgxTickLabelsPipe, pure: true });

var IgxSliderComponent_1;
const noop$7 = () => {
};
const ɵ0$8 = noop$7;
let NEXT_ID$r = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
let IgxSliderComponent = IgxSliderComponent_1 = class IgxSliderComponent {
    constructor(renderer, _el, _cdr, _ngZone, _dir) {
        this.renderer = renderer;
        this._el = _el;
        this._cdr = _cdr;
        this._ngZone = _ngZone;
        this._dir = _dir;
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._continuous = false;
        this._disabled = false;
        this._step = 1;
        this._value = 0;
        // ticks
        this._primaryTicks = 0;
        this._secondaryTicks = 0;
        this._labels = new Array();
        this._type = IgxSliderType.SLIDER;
        this._destroyer$ = new Subject();
        this._indicatorsDestroyer$ = new Subject();
        this._onChangeCallback = noop$7;
        this._onTouchedCallback = noop$7;
        /**
         * @hidden
         */
        this.thumbs = new QueryList();
        /**
         * @hidden
         */
        this.labelRefs = new QueryList();
        /**
         * @hidden
         */
        this.stepDistance = this._step;
        /**
         * @hidden
         */
        this.onPan = new Subject();
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = `igx-slider-${NEXT_ID$r++}`;
        /**
         * An @Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * Show/hide slider ticks
         * ```html
         * <igx-slier [showTicks]="true" [primaryTicks]="5"></igx-slier>
         * ```
         */
        this.showTicks = false;
        /**
         * show/hide primary tick labels
         * ```html
         * <igx-slider [primaryTicks]="5" [primaryTickLabels]="false"></igx-slider>
         * ```
         */
        this.primaryTickLabels = true;
        /**
         * show/hide secondary tick labels
         * ```html
         * <igx-slider [secondaryTicks]="5" [secondaryTickLabels]="false"></igx-slider>
         * ```
         */
        this.secondaryTickLabels = true;
        /**
         * Changes ticks orientation:
         * bottom - The default orienation, below the slider track.
         * top - Above the slider track
         * mirror - combines top and bottom orientation.
         * ```html
         * <igx-slider [primaryTicks]="5" [ticksOrientation]="ticksOrientation"></igx-slider>
         * ```
         */
        this.ticksOrientation = TicksOrientation.Bottom;
        /**
         * Changes tick labels rotation:
         * horizontal - The default rotation
         * toptobottom - Rotates tick labels vertically to 90deg
         * bottomtotop - Rotate tick labels vertically to -90deg
         * ```html
         * <igx-slider [primaryTicks]="5" [secondaryTicks]="3" [tickLabelsOrientation]="tickLabelsOrientaiton"></igx-slider>
         * ```
         */
        this.tickLabelsOrientation = TickLabelsOrientation.Horizontal;
        /**
         * This event is emitted every time the value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
        /**
         * This event is emitted at the end of every slide interaction.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChanged)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChanged = new EventEmitter();
    }
    get thumbFrom() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.FROM);
    }
    get thumbTo() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.TO);
    }
    get labelFrom() {
        return this.labelRefs.find(label => label.type === SliderHandle.FROM);
    }
    get labelTo() {
        return this.labelRefs.find(label => label.type === SliderHandle.TO);
    }
    /**
     * @hidden
     */
    get valuemin() {
        return this.minValue;
    }
    /**
     * @hidden
     */
    get valuemax() {
        return this.maxValue;
    }
    /**
     * @hidden
     */
    get readonly() {
        return this.disabled;
    }
    /**
     * @hidden
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * An @Input property that gets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     */
    get type() {
        return this._type;
    }
    /**
     * An @Input property that sets the type of the `IgxSliderComponent`.
     * The slider can be IgxSliderType.SLIDER(default) or IgxSliderType.RANGE.
     * ```typescript
     * sliderType: IgxSliderType = IgxSliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     */
    set type(type) {
        this._type = type;
        if (type === IgxSliderType.SLIDER) {
            this.lowerValue = 0;
        }
        if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
            this.upperValue = this.labels.length - 1;
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {@link maxValue}, {@link minValue}, {@link step}.
     * This means that the manipulation for those properties won't be allowed.
     */
    get labels() {
        return this._labels;
    }
    set labels(labels) {
        this._labels = labels;
        this._pMax = this.valueToFraction(this.upperBound, 0, 1);
        this._pMin = this.valueToFraction(this.lowerBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the template context corresponding
     * to {@link IgxThumbFromTemplateDirective} and {@link IgxThumbToTemplateDirective} templates.
     *
     * ```typescript
     * return {
     *  $implicit // returns the value of the label,
     *  labels // returns the labels collection the user has passed.
     * }
     * ```
     */
    get context() {
        return {
            $implicit: this.value,
            labels: this.labels
        };
    }
    /**
     * An @Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     */
    set step(step) {
        this._step = step;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.normalizeByStep(this.value);
            this.setTickInterval();
        }
    }
    /**
     * Returns the incremental/decremental dragging step of the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     */
    get step() {
        return this.labelsViewEnabled ? 1 : this._step;
    }
    /**
     * Returns if the {@link IgxSliderComponent} is disabled.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * An @Input property that disables or enables UI interaction.
     * ```html
     * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set disabled(disable) {
        this._disabled = disable;
        if (this._hasViewInit) {
            this.changeThumbFocusableState(disable);
        }
    }
    /**
     * Returns if the {@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     */
    get continuous() {
        return this._continuous;
    }
    /**
     * An @Input property that marks the {@link IgxSliderComponent} as continuous.
     * By default is considered that the {@link IgxSliderComponent} is discrete.
     * Discrete {@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     */
    set continuous(continuous) {
        this._continuous = continuous;
        if (this._hasViewInit) {
            this.setTickInterval();
        }
    }
    /**
     * Returns the minimal value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderMin = this.slider.minValue;
     * }
     * ```
     */
    get minValue() {
        if (this.labelsViewEnabled) {
            return 0;
        }
        return this._minValue;
    }
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     */
    set minValue(value) {
        if (value >= this.maxValue) {
            return;
        }
        else {
            this._minValue = value;
        }
        if (value > this.upperBound) {
            this.updateUpperBoundAndMaxTravelZone();
            this.lowerBound = value;
        }
        // Refresh min travel zone limit.
        this._pMin = 0;
        // Recalculate step distance.
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the maximum value for the {@link IgxSliderComponent}.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderMax = this.slider.maxValue;
     * }
     *  ```
     */
    get maxValue() {
        return this.labelsViewEnabled ?
            this.labels.length - 1 :
            this._maxValue;
    }
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     */
    set maxValue(value) {
        if (value <= this._minValue) {
            return;
        }
        else {
            this._maxValue = value;
        }
        if (value < this.lowerBound) {
            this.updateLowerBoundAndMinTravelZone();
            this.upperBound = value;
        }
        // refresh max travel zone limits.
        this._pMax = 1;
        // recalculate step distance.
        this.positionHandlersAndUpdateTrack();
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.setTickInterval();
        }
    }
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderLowBound = this.slider.lowerBound;
     * }
     * ```
     */
    get lowerBound() {
        if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
            return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
        }
        return this.minValue;
    }
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     */
    set lowerBound(value) {
        if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
            return;
        }
        this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh min travel zone.
        this._pMin = this.valueToFraction(this._lowerBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
    }
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     * }
     * ```
     */
    get upperBound() {
        if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
            return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
        }
        return this.maxValue;
    }
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     */
    set upperBound(value) {
        if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
            return;
        }
        this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMax = this.valueToFraction(this._upperBound, 0, 1);
        this.positionHandlersAndUpdateTrack();
    }
    /**
     * Returns the slider value. If the slider is of type {@link IgxSliderType.SLIDER} the returned value is number.
     * If the slider type is {@link IgxSliderType.RANGE}.
     * The returned value represents an object of {@link lowerValue} and {@link upperValue}.
     * ```typescript
     * @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public sliderValue(event){
     *     let sliderVal = this.slider.value;
     * }
     * ```
     */
    get value() {
        if (this.isRange) {
            return {
                lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
            };
        }
        else {
            return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
        }
    }
    /**
     * Sets the slider value.
     * If the slider is of type {@link IgxSliderType.SLIDER}.
     * The argument is number. By default the {@link value} gets the {@link lowerBound}.
     * If the slider type is {@link IgxSliderType.RANGE} the argument
     * represents an object of {@link lowerValue} and {@link upperValue} properties.
     * By default the object is associated with the {@link lowerBound} and {@link upperBound} property values.
     * ```typescript
     * rangeValue = {
     *   lower: 30,
     *   upper: 60
     * };
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     */
    set value(value) {
        if (this._hasViewInit) {
            this.setValue(value);
            this.positionHandlersAndUpdateTrack();
        }
        else {
            this._value = value;
        }
        this._onChangeCallback(value);
    }
    /**
     * Returns the number of the presented primary ticks.
     * ```typescript
     * const primaryTicks = this.slider.primaryTicks;
     * ```
     */
    get primaryTicks() {
        if (this.labelsViewEnabled) {
            return this._primaryTicks = this.labels.length;
        }
        return this._primaryTicks;
    }
    /**
     * Sets the number of primary ticks. If {@link @labels} is enabled, this property won't function.
     * Insted enable ticks by {@link showTicks} property.
     * ```typescript
     * this.slider.primaryTicks = 5;
     * ```
     */
    set primaryTicks(val) {
        if (val <= 1) {
            return;
        }
        this._primaryTicks = val;
    }
    /**
     * Returns the number of the presented secondary ticks.
     * ```typescript
     * const secondaryTicks = this.slider.secondaryTicks;
     * ```
     */
    get secondaryTicks() {
        return this._secondaryTicks;
    }
    /**
     * Sets the number of secondary ticks. The property functions even when {@link labels} is enabled,
     * but all secondary ticks won't present any tick labels.
     * ```typescript
     * this.slider.secondaryTicks = 5;
     * ```
     */
    set secondaryTicks(val) {
        if (val < 1) {
            return;
        }
        this._secondaryTicks = val;
    }
    /**
     * @hidden
     */
    get deactivateThumbLabel() {
        return ((this.primaryTicks && this.primaryTickLabels) || (this.secondaryTicks && this.secondaryTickLabels)) &&
            (this.ticksOrientation === TicksOrientation.Top || this.ticksOrientation === TicksOrientation.Mirror);
    }
    /**
     * @hidden
     */
    onPointerDown($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
        activeThumb.nativeElement.setPointerCapture($event.pointerId);
        this.showSliderIndicators();
        $event.preventDefault();
    }
    /**
     * @hidden
     */
    onPointerUp($event) {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
        activeThumb.nativeElement.releasePointerCapture($event.pointerId);
        this.hideSliderIndicators();
        this.onValueChanged.emit(this.value);
    }
    /**
     * @hidden
     */
    onFocus() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     */
    onPanListener($event) {
        this.update($event.srcEvent.clientX);
    }
    /**
     * Returns whether the `IgxSliderComponent` type is RANGE.
     * ```typescript
     *  @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let sliderRange = this.slider.isRange;
     * }
     * ```
     */
    get isRange() {
        return this.type === IgxSliderType.RANGE;
    }
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     * }
     * ```
     */
    get lowerValue() {
        if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
            return this._lowerValue;
        }
        return this.lowerBound;
    }
    /**
     * Sets the lower value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *     this.slider.lowerValue = 120;
     * }
     * ```
     */
    set lowerValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._lowerValue = value;
    }
    /**
     * Returns the upper value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *     let upperValue = this.slider.upperValue;
     * }
     * ```
     */
    get upperValue() {
        if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
            return this._upperValue;
        }
        return this.upperBound;
    }
    /**
     * Sets the upper value of the `IgxSliderComponent`.
     * ```typescript
     *  @ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *     this.slider.upperValue = 120;
     * }
     * ```
     */
    set upperValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._upperValue = value;
    }
    /**
     * Returns the value corresponding the lower label.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     * ```
     */
    get lowerLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.lowerValue] :
            this.lowerValue;
    }
    /**
     * Returns the value corresponding the upper label.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     * ```
     */
    get upperLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.upperValue] :
            this.upperValue;
    }
    /**
     * Returns if label view is enabled.
     * If the {@link labels} is set, the view is automatically activated.
     * ```typescript
     * @ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     * ```
     */
    get labelsViewEnabled() {
        return !!(this.labels && this.labels.length > 1);
    }
    /**
     * @hidden
     */
    get showTopTicks() {
        return this.ticksOrientation === TicksOrientation.Top ||
            this.ticksOrientation === TicksOrientation.Mirror;
    }
    /**
     * @hidden
     */
    get showBottomTicks() {
        return this.ticksOrientation === TicksOrientation.Bottom ||
            this.ticksOrientation === TicksOrientation.Mirror;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        if (changes.minValue && changes.maxValue &&
            changes.minValue.currentValue < changes.maxValue.currentValue) {
            this._maxValue = changes.maxValue.currentValue;
            this._minValue = changes.minValue.currentValue;
        }
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    }
    ngAfterContentInit() {
        this.setValue(this._value);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this._hasViewInit = true;
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlersAndUpdateTrack();
        this.setTickInterval();
        this.changeThumbFocusableState(this.disabled);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            const thumbFrom = change.find((thumb) => thumb.type === SliderHandle.FROM);
            this.positionHandler(thumbFrom, null, this.lowerValue);
            this.subscribeTo(thumbFrom, this.thumbChanged.bind(this));
            this.changeThumbFocusableState(this.disabled);
        });
        this.labelRefs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            const labelFrom = this.labelRefs.find((label) => label.type === SliderHandle.FROM);
            this.positionHandler(null, labelFrom, this.lowerValue);
        });
        this._ngZone.runOutsideAngular(() => {
            resizeObservable(this._el.nativeElement).pipe(throttleTime(40), takeUntil(this._destroyer$)).subscribe(() => this._ngZone.run(() => {
                this.stepDistance = this.calculateStepDistance();
            }));
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroyer$.next(true);
        this._destroyer$.complete();
        this._indicatorsDestroyer$.next(true);
        this._indicatorsDestroyer$.complete();
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (!value) {
            return;
        }
        this.normalizeByStep(value);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /** @hidden */
    getEditElement() {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    }
    /**
     *
     * @hidden
     */
    update(mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlersAndUpdateTrack the DOM
        // based on data values
        this.positionHandlersAndUpdateTrack();
        this._onTouchedCallback();
    }
    /**
     * @hidden
     */
    thumbChanged(value, thumbType) {
        const oldValue = this.value;
        let newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: this.value.lower + value,
                    upper: this.value.upper
                };
            }
            else {
                newVal = {
                    lower: this.value.lower,
                    upper: this.value.upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = this.value + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    }
    /**
     * @hidden
     */
    onThumbChange() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     */
    onHoverChange(state) {
        return state ? this.showSliderIndicators() : this.hideSliderIndicators();
    }
    swapThumb(value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    }
    findClosestThumb(event) {
        if (this.isRange) {
            this.closestHandle(event);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
    }
    updateLowerBoundAndMinTravelZone() {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    }
    updateUpperBoundAndMaxTravelZone() {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    }
    sliderSetup() {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this._upperValue === undefined) {
            this._upperValue = this.lowerBound;
        }
    }
    calculateStepDistance() {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    }
    toggleThumb() {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    }
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    generateTickMarks(color, interval) {
        return interval !== null ? `repeating-linear-gradient(
            ${'to left'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        ), repeating-linear-gradient(
            ${'to right'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        )` : interval;
    }
    positionHandler(thumbHandle, labelHandle, position) {
        const percent = `${this.valueToFraction(position) * 100}%`;
        const dir = this._dir.rtl ? 'right' : 'left';
        if (thumbHandle) {
            thumbHandle.nativeElement.style[dir] = percent;
        }
        if (labelHandle) {
            labelHandle.nativeElement.style[dir] = percent;
        }
    }
    positionHandlersAndUpdateTrack() {
        if (!this.isRange) {
            this.positionHandler(this.thumbTo, this.labelTo, this.value);
        }
        else {
            this.positionHandler(this.thumbTo, this.labelTo, this.value.upper);
            this.positionHandler(this.thumbFrom, this.labelFrom, this.value.lower);
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    closestHandle(event) {
        const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        const xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            this.thumbTo.nativeElement.focus();
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
    }
    setTickInterval() {
        let interval;
        const trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            const trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        const renderCallbackExecution = !this.continuous ? this.generateTickMarks('white', interval) : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
    }
    showSliderIndicators() {
        if (this.disabled) {
            return;
        }
        if (this._indicatorsTimer) {
            this._indicatorsDestroyer$.next(true);
            this._indicatorsTimer = null;
        }
        this.thumbTo.showThumbIndicators();
        this.labelTo.active = true;
        if (this.thumbFrom) {
            this.thumbFrom.showThumbIndicators();
        }
        if (this.labelFrom) {
            this.labelFrom.active = true;
        }
    }
    hideSliderIndicators() {
        if (this.disabled) {
            return;
        }
        this._indicatorsTimer = timer(this.thumbLabelVisibilityDuration);
        this._indicatorsTimer.pipe(takeUntil(this._indicatorsDestroyer$)).subscribe(() => {
            this.thumbTo.hideThumbIndicators();
            this.labelTo.active = false;
            if (this.thumbFrom) {
                this.thumbFrom.hideThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = false;
            }
        });
    }
    toggleSliderIndicators() {
        this.showSliderIndicators();
        this.hideSliderIndicators();
    }
    changeThumbFocusableState(state) {
        const value = state ? -1 : 1;
        if (this.isRange) {
            this.thumbFrom.tabindex = value;
        }
        this.thumbTo.tabindex = value;
        this._cdr.detectChanges();
    }
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    }
    valueToFraction(value, pMin = this._pMin, pMax = this._pMax) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    }
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {@link this.step} is set.
     * @param value
     */
    normalizeByStep(value) {
        if (this.isRange) {
            this.value = {
                lower: value.lower - (value.lower % this.step),
                upper: value.upper - (value.upper % this.step)
            };
        }
        else {
            this.value = value - (value % this.step);
        }
        this._cdr.detectChanges();
    }
    updateTrack() {
        const fromPosition = this.valueToFraction(this.lowerValue);
        const toPosition = this.valueToFraction(this.upperValue);
        const positionGap = toPosition - fromPosition;
        let trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            trackLeftIndention = this._dir.rtl ? -trackLeftIndention : trackLeftIndention;
            this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${positionGap}) translateX(${trackLeftIndention}%)`);
        }
        else {
            this.renderer.setStyle(this.trackRef.nativeElement, 'transform', `scaleX(${toPosition})`);
        }
    }
    validateInitialValue(value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    }
    subscribeTo(thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(takeUntil(this.unsubscriber(thumb)))
            .subscribe(value => callback(value, thumb.type));
    }
    unsubscriber(thumb) {
        return merge(this._destroyer$, thumb.destroy);
    }
    hasValueChanged(oldValue) {
        const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        const isRangeWithOneDifferentValue = this.isRange &&
            (oldValue.lower !== this.value.lower ||
                oldValue.upper !== this.value.upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    }
    setValue(value) {
        if (!this.isRange) {
            this.upperValue = value - (value % this.step);
        }
        else {
            value = this.validateInitialValue(value);
            this.upperValue = value.upper;
            this.lowerValue = value.lower;
        }
    }
    emitValueChanged(oldValue) {
        this.onValueChange.emit({ oldValue, value: this.value });
    }
};
IgxSliderComponent.ɵfac = function IgxSliderComponent_Factory(t) { return new (t || IgxSliderComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(IgxDirectionality)); };
IgxSliderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSliderComponent, selectors: [["igx-slider"]], contentQueries: function IgxSliderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxThumbFromTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxThumbToTemplateDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTickLabelTemplateDirective, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbFromTemplateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbToTemplateRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tickLabelTemplateRef = _t.first);
    } }, viewQuery: function IgxSliderComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c223, true);
        ɵngcc0.ɵɵstaticViewQuery(_c224, true);
        ɵngcc0.ɵɵviewQuery(IgxSliderThumbComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxThumbLabelComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ticks = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.trackRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.labelRefs = _t);
    } }, hostVars: 9, hostBindings: function IgxSliderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("pointerdown", function IgxSliderComponent_pointerdown_HostBindingHandler($event) { return ctx.onPointerDown($event); })("pointerup", function IgxSliderComponent_pointerup_HostBindingHandler($event) { return ctx.onPointerUp($event); })("focus", function IgxSliderComponent_focus_HostBindingHandler() { return ctx.onFocus(); })("pan", function IgxSliderComponent_pan_HostBindingHandler($event) { return ctx.onPanListener($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("id", ctx.id)("aria-valuemin", ctx.valuemin)("aria-valuemax", ctx.valuemax)("aria-readonly", ctx.readonly);
        ɵngcc0.ɵɵclassProp("igx-slider", ctx.slierClass)("igx-slider--disabled", ctx.disabledClass);
    } }, inputs: { id: "id", thumbLabelVisibilityDuration: "thumbLabelVisibilityDuration", showTicks: "showTicks", primaryTickLabels: "primaryTickLabels", secondaryTickLabels: "secondaryTickLabels", ticksOrientation: "ticksOrientation", tickLabelsOrientation: "tickLabelsOrientation", type: "type", labels: "labels", step: "step", disabled: "disabled", continuous: "continuous", minValue: "minValue", lowerBound: "lowerBound", maxValue: "maxValue", upperBound: "upperBound", value: "value", primaryTicks: "primaryTicks", secondaryTicks: "secondaryTicks" }, outputs: { onValueChange: "onValueChange", onValueChanged: "onValueChanged" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent_1, multi: true }]), ɵngcc0.ɵɵNgOnChangesFeature], decls: 13, vars: 21, consts: [[1, "igx-slider__track"], [3, "ticksOrientation", "primaryTicks", "secondaryTicks", "primaryTickLabels", "secondaryTickLabels", "tickLabelsOrientation", "labelsViewEnabled", "labels", "tickLabelTemplateRef", "minValue", "maxValue", 4, "ngIf"], [1, "igx-slider__track-fill"], ["track", ""], [1, "igx-slider__track-steps"], ["ticks", ""], [1, "igx-slider__thumbs"], [3, "type", "value", "templateRef", "continuous", "context", "deactiveState", 4, "ngIf"], [3, "type", "value", "disabled", "continuous", "onPan", "stepDistance", "step", "templateRef", "context", "deactiveState", "thumbLabelVisibilityDuration", "onChange", "onHoverChange", 4, "ngIf"], [3, "value", "type", "templateRef", "continuous", "context", "deactiveState"], [3, "type", "value", "disabled", "continuous", "onPan", "stepDistance", "step", "templateRef", "context", "deactiveState", "thumbLabelVisibilityDuration", "onChange", "onHoverChange"], ["thumbTo", ""], [3, "ticksOrientation", "primaryTicks", "secondaryTicks", "primaryTickLabels", "secondaryTickLabels", "tickLabelsOrientation", "labelsViewEnabled", "labels", "tickLabelTemplateRef", "minValue", "maxValue"], [3, "type", "value", "templateRef", "continuous", "context", "deactiveState"], ["thumbFrom", ""]], template: function IgxSliderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, IgxSliderComponent_igx_ticks_1_Template, 2, 14, "igx-ticks", 1);
        ɵngcc0.ɵɵelement(2, "div", 2, 3);
        ɵngcc0.ɵɵelement(4, "div", 4, 5);
        ɵngcc0.ɵɵtemplate(6, IgxSliderComponent_igx_ticks_6_Template, 2, 14, "igx-ticks", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 6);
        ɵngcc0.ɵɵtemplate(8, IgxSliderComponent_igx_thumb_label_8_Template, 1, 6, "igx-thumb-label", 7);
        ɵngcc0.ɵɵtemplate(9, IgxSliderComponent_igx_thumb_9_Template, 2, 11, "igx-thumb", 8);
        ɵngcc0.ɵɵelement(10, "igx-thumb-label", 9);
        ɵngcc0.ɵɵelementStart(11, "igx-thumb", 10, 11);
        ɵngcc0.ɵɵlistener("onChange", function IgxSliderComponent_Template_igx_thumb_onChange_11_listener() { return ctx.onThumbChange(); })("onHoverChange", function IgxSliderComponent_Template_igx_thumb_onHoverChange_11_listener($event) { return ctx.onHoverChange($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTicks && ctx.showTopTicks);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTicks && ctx.showBottomTicks);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRange);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isRange);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("value", ctx.upperLabel)("type", 1)("templateRef", ctx.thumbToTemplateRef)("continuous", ctx.continuous)("context", ctx.context)("deactiveState", ctx.deactivateThumbLabel);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("type", 1)("value", ctx.upperLabel)("disabled", ctx.disabled)("continuous", ctx.continuous)("onPan", ctx.onPan)("stepDistance", ctx.stepDistance)("step", ctx.step)("templateRef", ctx.thumbToTemplateRef)("context", ctx.context)("deactiveState", ctx.deactivateThumbLabel)("thumbLabelVisibilityDuration", ctx.thumbLabelVisibilityDuration);
    } }, directives: [ɵngcc2.NgIf, IgxThumbLabelComponent,
        IgxSliderThumbComponent,
        IgxTicksComponent], pipes: [IgxTickLabelsPipe], encapsulation: 2 });
IgxSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: IgxDirectionality }
];
__decorate([
    ViewChild('ticks', { static: true })
], IgxSliderComponent.prototype, "ticks", void 0);
__decorate([
    ViewChildren(IgxSliderThumbComponent)
], IgxSliderComponent.prototype, "thumbs", void 0);
__decorate([
    ViewChildren(IgxThumbLabelComponent)
], IgxSliderComponent.prototype, "labelRefs", void 0);
__decorate([
    ViewChild('track', { static: true })
], IgxSliderComponent.prototype, "trackRef", void 0);
__decorate([
    ContentChild(IgxThumbFromTemplateDirective, { read: TemplateRef })
], IgxSliderComponent.prototype, "thumbFromTemplateRef", void 0);
__decorate([
    ContentChild(IgxThumbToTemplateDirective, { read: TemplateRef })
], IgxSliderComponent.prototype, "thumbToTemplateRef", void 0);
__decorate([
    ContentChild(IgxTickLabelTemplateDirective, { read: TemplateRef, static: false })
], IgxSliderComponent.prototype, "tickLabelTemplateRef", void 0);
__decorate([
    HostBinding(`attr.role`)
], IgxSliderComponent.prototype, "role", void 0);
__decorate([
    HostBinding(`attr.aria-valuemin`)
], IgxSliderComponent.prototype, "valuemin", null);
__decorate([
    HostBinding(`attr.aria-valuemax`)
], IgxSliderComponent.prototype, "valuemax", null);
__decorate([
    HostBinding(`attr.aria-readonly`)
], IgxSliderComponent.prototype, "readonly", null);
__decorate([
    HostBinding('class.igx-slider')
], IgxSliderComponent.prototype, "slierClass", void 0);
__decorate([
    HostBinding('class.igx-slider--disabled')
], IgxSliderComponent.prototype, "disabledClass", null);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxSliderComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxSliderComponent.prototype, "type", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "thumbLabelVisibilityDuration", void 0);
__decorate([
    Input()
], IgxSliderComponent.prototype, "labels", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "step", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "disabled", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "continuous", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "minValue", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "maxValue", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "lowerBound", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "upperBound", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "value", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "primaryTicks", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "secondaryTicks", null);
__decorate([
    Input()
], IgxSliderComponent.prototype, "showTicks", void 0);
__decorate([
    Input()
], IgxSliderComponent.prototype, "primaryTickLabels", void 0);
__decorate([
    Input()
], IgxSliderComponent.prototype, "secondaryTickLabels", void 0);
__decorate([
    Input()
], IgxSliderComponent.prototype, "ticksOrientation", void 0);
__decorate([
    Input()
], IgxSliderComponent.prototype, "tickLabelsOrientation", void 0);
__decorate([
    Output()
], IgxSliderComponent.prototype, "onValueChange", void 0);
__decorate([
    Output()
], IgxSliderComponent.prototype, "onValueChanged", void 0);
__decorate([
    HostListener('pointerdown', ['$event'])
], IgxSliderComponent.prototype, "onPointerDown", null);
__decorate([
    HostListener('pointerup', ['$event'])
], IgxSliderComponent.prototype, "onPointerUp", null);
__decorate([
    HostListener('focus')
], IgxSliderComponent.prototype, "onFocus", null);
__decorate([
    HostListener('pan', ['$event'])
], IgxSliderComponent.prototype, "onPanListener", null);
/**
 * @hidden
 */
let IgxSliderModule = class IgxSliderModule {
};
IgxSliderModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSliderModule });
IgxSliderModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSliderModule_Factory(t) { return new (t || IgxSliderModule)(); }, imports: [[CommonModule, FormsModule]] });

let NEXT_ID$s = 0;
/**
 * **Ignite UI for Angular Snackbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
 *
 * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
 * include a link to an action such as Undo.
 *
 * Example:
 * ```html
 * <button (click)="snackbar.show()">Send message</button>
 * <div>
 *   <igx-snackbar #snackbar message="Message sent">
 *   </igx-snackbar>
 * </div>
 * ```
 */
let IgxSnackbarComponent = class IgxSnackbarComponent {
    constructor(zone) {
        this.zone = zone;
        /**
         * Sets/gets the `id` of the snackbar.
         * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
         * ```html
         * <igx-snackbar id = "Snackbar1"></igx-snackbar>
         * ```
         * ```typescript
         * let snackbarId = this.snackbar.id;
         * ```
         * @memberof IgxSnackbarComponent
         */
        this.id = `igx-snackbar-${NEXT_ID$s++}`;
        /**
         * Enables/Disables the visibility of the snackbar.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-snackbar [isVisible] = "true"></igx-snackbar>
         * ```
         * ```typescript
         * let isVisible =  this.snackbar.isVisible;
         * ```
         */
        this.isVisible = false;
        /**
         * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-snackbar [autoHide] = "false"></igx-snackbar>
         * ```
         * ```typescript
         * let autoHide =  this.snackbar.autoHide;
         * ```
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
         * Default value is 4000.
         * ```html
         * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
         * ```
         * ```typescript
         * let displayTime = this.snackbar.displayTime;
         * ```
         */
        this.displayTime = 4000;
        /**
         * An event that will be emitted when the action is executed.
         * Provides reference to the `IgxSnackbarComponent` as an argument.
         * ```html
         * <igx-snackbar (onAction) = "onAction($event)"></igx-snackbar>
         * ```
         */
        this.onAction = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation starts.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
         * ```
         */
        this.animationStarted = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation ends.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
         * ```
         */
        this.animationDone = new EventEmitter();
    }
    /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     */
    show() {
        clearTimeout(this.timeoutId);
        setTimeout(this.timeoutId);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(() => {
                this.hide();
            }, this.displayTime);
        }
    }
    /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     */
    hide() {
        this.isVisible = false;
        clearTimeout(this.timeoutId);
    }
    /**
     * @hidden
     */
    triggerAction() {
        this.onAction.emit(this);
    }
    /**
     * @hidden
     * @memberof IgxSnackbarComponent
     */
    snackbarAnimationStarted(evt) {
        if (evt.fromState === 'void') {
            this.animationStarted.emit(evt);
        }
    }
    /**
     * @hidden
     * @memberof IgxSnackbarComponent
     */
    snackbarAnimationDone(evt) {
        if (evt.fromState === 'show') {
            this.animationDone.emit(evt);
        }
    }
};
IgxSnackbarComponent.ɵfac = function IgxSnackbarComponent_Factory(t) { return new (t || IgxSnackbarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxSnackbarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSnackbarComponent, selectors: [["igx-snackbar"]], hostVars: 1, hostBindings: function IgxSnackbarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", isVisible: "isVisible", autoHide: "autoHide", displayTime: "displayTime", message: "message", actionText: "actionText" }, outputs: { onAction: "onAction", animationStarted: "animationStarted", animationDone: "animationDone" }, ngContentSelectors: _c2, decls: 1, vars: 1, consts: [["class", "igx-snackbar", 4, "ngIf"], [1, "igx-snackbar"], [1, "igx-snackbar__message"], ["class", "igx-snackbar__button", "igxRipple", "white", 3, "click", 4, "ngIf"], ["igxRipple", "white", 1, "igx-snackbar__button", 3, "click"]], template: function IgxSnackbarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxSnackbarComponent_div_0_Template, 5, 4, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isVisible);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"], data: { animation: [
            trigger('slideInOut', [
                transition('void => *', [
                    useAnimation(slideInBottom, {
                        params: {
                            duration: '.35s',
                            easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                            fromPosition: 'translateY(100%)',
                            toPosition: 'translateY(0)'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(slideOutBottom, {
                        params: {
                            duration: '.2s',
                            easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                            fromPosition: 'translateY(0)',
                            toOpacity: 1,
                            toPosition: 'translateY(100%)'
                        }
                    })
                ])
            ]),
            trigger('fadeInOut', [
                transition('void => *', [
                    useAnimation(fadeIn, {
                        params: {
                            duration: '.35s',
                            easing: 'ease-out'
                        }
                    })
                ]),
                transition('* => void', [
                    useAnimation(fadeOut, {
                        params: {
                            duration: '.2s',
                            easing: 'ease-out'
                        }
                    })
                ])
            ])
        ] } });
IgxSnackbarComponent.ctorParameters = () => [
    { type: NgZone }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxSnackbarComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxSnackbarComponent.prototype, "message", void 0);
__decorate([
    Input()
], IgxSnackbarComponent.prototype, "isVisible", void 0);
__decorate([
    Input()
], IgxSnackbarComponent.prototype, "autoHide", void 0);
__decorate([
    Input()
], IgxSnackbarComponent.prototype, "displayTime", void 0);
__decorate([
    Input()
], IgxSnackbarComponent.prototype, "actionText", void 0);
__decorate([
    Output()
], IgxSnackbarComponent.prototype, "onAction", void 0);
__decorate([
    Output()
], IgxSnackbarComponent.prototype, "animationStarted", void 0);
__decorate([
    Output()
], IgxSnackbarComponent.prototype, "animationDone", void 0);
/**
 * @hidden
 */
let IgxSnackbarModule = class IgxSnackbarModule {
};
IgxSnackbarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSnackbarModule });
IgxSnackbarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSnackbarModule_Factory(t) { return new (t || IgxSnackbarModule)(); }, imports: [[CommonModule]] });

var IgxSwitchComponent_1;
var SwitchLabelPosition;
(function (SwitchLabelPosition) {
    SwitchLabelPosition["BEFORE"] = "before";
    SwitchLabelPosition["AFTER"] = "after";
})(SwitchLabelPosition || (SwitchLabelPosition = {}));
const noop$8 = () => { };
const ɵ0$9 = noop$8;
let nextId$3 = 0;
/**
 *
 * The Switch component is a binary choice selection component.
 *
 * @igxModule IgxSwitchModule
 *
 * @igxTheme igx-switch-theme, igx-tooltip-theme
 *
 * @igxKeywords switch, states, tooltip
 *
 * @igxGroup Data Entry & Display
 *
 * @remarks
 *
 * The Ignite UI Switch lets the user toggle between on/off or true/false states.
 *
 * @example
 * ```html
 * <igx-switch [checked]="true">
 *   Simple switch
 * </igx-switch>
 * ```
 */
let IgxSwitchComponent = IgxSwitchComponent_1 = class IgxSwitchComponent {
    constructor() {
        /**
         * Sets/gets the `id` of the switch component.
         * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
         *
         * @example
         * ```html
         * <igx-switch id="my-first-switch"></igx-switch>
         * ```
         */
        this.id = `igx-switch-${nextId$3++}`;
        /**
         * Sets/gets the id of the `label` element of the switch component.
         * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
         *
         * @example
         * ```html
         * <igx-switch labelId="Label1"></igx-switch>
         * ```
         */
        this.labelId = `${this.id}-label`;
        /**
         * Sets/gets the value of the `tabindex` attribute.
         *
         * @example
         * ```html
         * <igx-switch [tabindex]="1"></igx-switch>
         * ```
         */
        this.tabindex = null;
        /**
         * Sets/gets the position of the `label` in the switch component.
         * If not set, `labelPosition` will have value `"after"`.
         *
         * @example
         * ```html
         * <igx-switch labelPosition="before"></igx-switch>
         * ```
         */
        this.labelPosition = 'after';
        /**
         * Enables/Disables the ripple effect
         * If not set, `disableRipple` will have value `false`.
         *
         * @example
         * ```html
         * <igx-switch [disableRipple]="true"></igx-switch>
         * ```
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether switch is required.
         * If not set, `required` will have value `false`.
         *
         * @example
         * ```html
         * <igx-switch [required]="true"></igx-switch>
         * ```
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledBy` attribute.
         * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
         *
         * @example
         * ```html
         * <igx-switch aria-labelledby = "Label1"></igx-switch>
         * ```
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         *
         * @example
         * ```html
         * <igx-switch aria-label="Label1"></igx-switch>
         * ```
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the switch state is changed.
         * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
         */
        this.change = new EventEmitter();
        /**
         * @hidden
         * @internal
         */
        this._onTouchedCallback = noop$8;
        /**
         * @hidden
         * @internal
         */
        this._onChangeCallback = noop$8;
        /**
         * Returns the class of the switch component.
         *
         * @example
         * ```typescript
         * let switchClass = this.switch.cssClass;
         * ```
         */
        this.cssClass = 'igx-switch';
        /**
         * Sets/gets whether the switch is on or off.
         * Default value is 'false'.
         *
         * @example
         * ```html
         *  <igx-switch [checked]="true"></igx-switch>
         * ```
         */
        this.checked = false;
        /**
         * Sets/gets the `disabled` attribute.
         * Default value is `false`.
         *
         * @example
         * ```html
         * <igx-switch [disabled]="true"><igx-switch>
         * ```
         */
        this.disabled = false;
        /**
         * Sets/gets whether the switch component is on focus.
         * Default value is `false`.
         *
         * @example
         * ```typescript
         * this.switch.focused = true;
         * ```
         */
        this.focused = false;
        /**
         * @hidden
         * @internal
         */
        this.inputId = `${this.id}-input`;
    }
    /**
     * Toggles the checked state of the switch.
     *
     * @example
     * ```typescript
     * this.switch.toggle();
     * ```
     */
    toggle() {
        if (this.disabled) {
            return;
        }
        this.checked = !this.checked;
        this.focused = false;
        this.change.emit({ checked: this.checked, switch: this });
        this._onChangeCallback(this.checked);
    }
    /**
     * @hidden
     * @internal
     */
    _onSwitchChange(event) {
        event.stopPropagation();
    }
    /**
     * @hidden
     * @internal
     */
    _onSwitchClick(event) {
        event.stopPropagation();
        this.toggle();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
    }
    /**
     * @hidden
     * @internal
     */
    _onLabelClick(event) {
        this.toggle();
    }
    /**
     * @hidden
     * @internal
     */
    onFocus(event) {
        this.focused = true;
    }
    /**
     * @hidden
     * @internal
     */
    onBlur(event) {
        this.focused = false;
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @internal
     */
    writeValue(value) {
        this._value = value;
        this.checked = !!this._value;
    }
    /**
     * @hidden
     * @internal
     */
    getEditElement() {
        return this.nativeCheckbox.nativeElement;
    }
    /**
     * @hidden
     * @internal
     */
    get labelClass() {
        switch (this.labelPosition) {
            case SwitchLabelPosition.BEFORE:
                return `${this.cssClass}__label--before`;
            case SwitchLabelPosition.AFTER:
            default:
                return `${this.cssClass}__label`;
        }
    }
    /**
     * @hidden
     * @internal
     */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /**
     * @hidden
     * @internal
     */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
};
IgxSwitchComponent.ɵfac = function IgxSwitchComponent_Factory(t) { return new (t || IgxSwitchComponent)(); };
IgxSwitchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSwitchComponent, selectors: [["igx-switch"]], viewQuery: function IgxSwitchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c17, true);
        ɵngcc0.ɵɵstaticViewQuery(_c18, true);
        ɵngcc0.ɵɵstaticViewQuery(_c11, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeCheckbox = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nativeLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.placeholderLabel = _t.first);
    } }, hostVars: 9, hostBindings: function IgxSwitchComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵclassProp("igx-switch", ctx.cssClass)("igx-switch--checked", ctx.checked)("igx-switch--disabled", ctx.disabled)("igx-switch--focused", ctx.focused);
    } }, inputs: { id: "id", labelId: "labelId", tabindex: "tabindex", labelPosition: "labelPosition", disableRipple: "disableRipple", required: "required", ariaLabelledBy: ["aria-labelledby", "ariaLabelledBy"], ariaLabel: ["aria-label", "ariaLabel"], checked: "checked", disabled: "disabled", value: "value", name: "name" }, outputs: { change: "change" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent_1, multi: true }])], ngContentSelectors: _c2, decls: 9, vars: 17, consts: [["type", "checkbox", 1, "igx-switch__input", 3, "id", "name", "value", "tabindex", "disabled", "checked", "required", "change", "click", "focus", "blur"], ["checkbox", ""], ["igxRipple", "", "igxRippleTarget", ".igx-switch__ripple", 1, "igx-switch__composite", 3, "for", "igxRippleDisabled", "igxRippleCentered", "igxRippleDuration"], ["label", ""], [1, "igx-switch__composite-thumb"], [1, "igx-switch__ripple"], [3, "id", "click"], ["placeholderLabel", ""]], template: function IgxSwitchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "input", 0, 1);
        ɵngcc0.ɵɵlistener("change", function IgxSwitchComponent_Template_input_change_0_listener($event) { return ctx._onSwitchChange($event); })("click", function IgxSwitchComponent_Template_input_click_0_listener($event) { return ctx._onSwitchClick($event); })("focus", function IgxSwitchComponent_Template_input_focus_0_listener($event) { return ctx.onFocus($event); })("blur", function IgxSwitchComponent_Template_input_blur_0_listener($event) { return ctx.onBlur($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "label", 2, 3);
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵelement(5, "div", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "span", 6, 7);
        ɵngcc0.ɵɵlistener("click", function IgxSwitchComponent_Template_span_click_6_listener($event) { return ctx._onLabelClick($event); });
        ɵngcc0.ɵɵprojection(8);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.inputId)("name", ctx.name)("value", ctx.value)("tabindex", ctx.tabindex)("disabled", ctx.disabled)("checked", ctx.checked)("required", ctx.required);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked)("aria-labelledby", ctx.ariaLabelledBy)("aria-label", ctx.ariaLabel);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("for", ctx.inputId)("igxRippleDisabled", ctx.disableRipple)("igxRippleCentered", true)("igxRippleDuration", 300);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵclassMap(ctx.labelClass);
        ɵngcc0.ɵɵproperty("id", ctx.labelId);
    } }, directives: [IgxRippleDirective], encapsulation: 2 });
__decorate([
    ViewChild('checkbox', { static: true })
], IgxSwitchComponent.prototype, "nativeCheckbox", void 0);
__decorate([
    ViewChild('label', { static: true })
], IgxSwitchComponent.prototype, "nativeLabel", void 0);
__decorate([
    ViewChild('placeholderLabel', { static: true })
], IgxSwitchComponent.prototype, "placeholderLabel", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxSwitchComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "labelId", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "value", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "name", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "tabindex", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "labelPosition", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "disableRipple", void 0);
__decorate([
    Input()
], IgxSwitchComponent.prototype, "required", void 0);
__decorate([
    Input('aria-labelledby')
], IgxSwitchComponent.prototype, "ariaLabelledBy", void 0);
__decorate([
    Input('aria-label')
], IgxSwitchComponent.prototype, "ariaLabel", void 0);
__decorate([
    Output()
], IgxSwitchComponent.prototype, "change", void 0);
__decorate([
    HostBinding('class.igx-switch')
], IgxSwitchComponent.prototype, "cssClass", void 0);
__decorate([
    HostBinding('class.igx-switch--checked'),
    Input()
], IgxSwitchComponent.prototype, "checked", void 0);
__decorate([
    HostBinding('class.igx-switch--disabled'),
    Input()
], IgxSwitchComponent.prototype, "disabled", void 0);
__decorate([
    HostBinding('class.igx-switch--focused')
], IgxSwitchComponent.prototype, "focused", void 0);
const IGX_SWITCH_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => IgxSwitchRequiredDirective),
    multi: true
};
/* tslint:disable directive-selector */
let IgxSwitchRequiredDirective = class IgxSwitchRequiredDirective extends CheckboxRequiredValidator {
};
IgxSwitchRequiredDirective.ɵfac = function IgxSwitchRequiredDirective_Factory(t) { return ɵIgxSwitchRequiredDirective_BaseFactory(t || IgxSwitchRequiredDirective); };
IgxSwitchRequiredDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSwitchRequiredDirective, selectors: [["igx-switch", "required", "", "formControlName", ""], ["igx-switch", "required", "", "formControl", ""], ["igx-switch", "required", "", "ngModel", ""]], features: [ɵngcc0.ɵɵProvidersFeature([IGX_SWITCH_REQUIRED_VALIDATOR]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * @hidden
 */
let IgxSwitchModule = class IgxSwitchModule {
};
IgxSwitchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSwitchModule });
IgxSwitchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSwitchModule_Factory(t) { return new (t || IgxSwitchModule)(); }, imports: [[IgxRippleModule]] });

let NEXT_ID$t = 0;
let IgxTabTemplateDirective = class IgxTabTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxTabTemplateDirective.ɵfac = function IgxTabTemplateDirective_Factory(t) { return new (t || IgxTabTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTabTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTabTemplateDirective, selectors: [["", "igxTab", ""]] });
IgxTabTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * **Ignite UI for Angular Tab Bar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar.html)
 *
 * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
 *
 * Example:
 * ```html
 * <igx-bottom-nav>
 *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
 * </igx-bottom-nav>
 * ```
 */
let IgxBottomNavComponent = class IgxBottomNavComponent {
    constructor(_element) {
        this._element = _element;
        this._currentBottomNavId = NEXT_ID$t++;
        /**
         * Sets/gets the `id` of the tab bar.
         * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
         * ```html
         * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
         * ```
         * ```typescript
         * let tabBarId =  this.tabBar.id;
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.id = `igx-bottom-nav-${this._currentBottomNavId}`;
        /**
         * Emits an event when a new tab is selected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.onTabSelected = new EventEmitter();
        /**
         * Emits an event when a tab is deselected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.onTabDeselected = new EventEmitter();
        /**
         * Gets the `index` of selected tab/panel in the respective collection.
         * ```typescript
         * let index =  this.tabBar.selectedIndex;
         * ```
         * @memberof IgxBottomNavComponent
         */
        this.selectedIndex = -1;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-bottom-nav';
    }
    /**
     * Gets the `IgxTabComponent` elements for this bottom navigation component.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * let tabs: QueryList<IgxTabComponent> =  this.tabBar.tabs;
     * ```
     * @memberof IgxBottomNavComponent
     */
    get tabs() {
        return this.hasContentTabs ? this.contentTabs : this.viewTabs;
    }
    /**
     * Gets the `itemStyle` of the tab bar.
     * ```typescript
     * let itemStyle =  this.tabBar.itemStyle;
     * ```
     * @memberof IgxBottomNavComponent
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * @hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * Gets the selected tab in the tab bar.
     * ```typescript
     * let tab =  this.tabBar.selectedTab;
     * ```
     * @memberof IgxBottomNavComponent
     */
    get selectedTab() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        this.setPanelsAttributes();
        this._panelsChanges$ = this.panels.changes.subscribe(() => {
            this.setPanelsAttributes();
        });
        // initial selection
        setTimeout(() => {
            if (this.selectedIndex === -1) {
                const selectablePanels = this.panels.filter((p) => !p.disabled);
                const panel = selectablePanels[0];
                if (panel) {
                    panel.select();
                }
            }
        }, 0);
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._panelsChanges$) {
            this._panelsChanges$.unsubscribe();
        }
    }
    setPanelsAttributes() {
        const panelsArray = Array.from(this.panels);
        for (let index = 0; index < this.panels.length; index++) {
            const tabPanels = panelsArray[index];
            tabPanels.nativeElement.setAttribute('id', this.getTabPanelId(index));
            tabPanels.nativeElement.setAttribute('aria-labelledby', this.getTabId(index));
        }
    }
    /**
     * @hidden
     */
    _selectedPanelHandler(args) {
        if (this.hasContentTabs) {
            this.selectedIndex = args.tab.index;
            this.contentTabs.forEach((t) => {
                if (t !== args.tab) {
                    this._deselectTab(t);
                }
            });
        }
        else {
            if (args.panel) {
                this.selectedIndex = args.panel.index;
                this.panels.forEach((p) => {
                    if (p.index !== this.selectedIndex) {
                        this._deselectPanel(p);
                    }
                });
            }
        }
    }
    /**
     * @hidden
     */
    _deselectPanel(panel) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (panel.disabled || this.selectedTab.index === panel.index) {
            return;
        }
        panel.isSelected = false;
        this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel });
    }
    _deselectTab(aTab) {
        aTab.isSelected = false;
        this.onTabDeselected.emit({ tab: aTab, panel: null });
    }
    /**
     * @hidden
     */
    getTabId(index) {
        return `igx-tab-${this._currentBottomNavId}-${index}`;
    }
    /**
     * @hidden
     */
    getTabPanelId(index) {
        return `igx-tab-panel-${this._currentBottomNavId}-${index}`;
    }
};
IgxBottomNavComponent.ɵfac = function IgxBottomNavComponent_Factory(t) { return new (t || IgxBottomNavComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxBottomNavComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxBottomNavComponent, selectors: [["igx-bottom-nav"]], contentQueries: function IgxBottomNavComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabPanelComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTabs = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panels = _t);
    } }, viewQuery: function IgxBottomNavComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxTabComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewTabs = _t);
    } }, hostVars: 1, hostBindings: function IgxBottomNavComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("onTabSelected", function IgxBottomNavComponent_onTabSelected_HostBindingHandler($event) { return ctx._selectedPanelHandler($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id" }, outputs: { onTabSelected: "onTabSelected", onTabDeselected: "onTabDeselected" }, ngContentSelectors: _c226, decls: 5, vars: 6, consts: [[4, "ngIf"], ["role", "tablist", "aria-orientation", "horizontal"], ["tablist", ""], [3, "relatedPanel", "autoGenerated", "id", 4, "ngFor", "ngForOf"], [3, "relatedPanel", "autoGenerated", "id"]], template: function IgxBottomNavComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c225);
        ɵngcc0.ɵɵtemplate(0, IgxBottomNavComponent_div_0_Template, 2, 0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1, 2);
        ɵngcc0.ɵɵtemplate(3, IgxBottomNavComponent_ng_container_3_Template, 2, 1, "ng-container", 0);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTabs);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassMapInterpolate2("", ctx.itemStyle, "__menu ", ctx.itemStyle, "__menu--bottom");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTabs);
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgForOf, IgxTabComponent]; }, styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"] });
IgxBottomNavComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    ViewChildren(forwardRef(() => IgxTabComponent))
], IgxBottomNavComponent.prototype, "viewTabs", void 0);
__decorate([
    ContentChildren(forwardRef(() => IgxTabComponent))
], IgxBottomNavComponent.prototype, "contentTabs", void 0);
__decorate([
    ContentChildren(forwardRef(() => IgxTabPanelComponent))
], IgxBottomNavComponent.prototype, "panels", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxBottomNavComponent.prototype, "id", void 0);
__decorate([
    Output()
], IgxBottomNavComponent.prototype, "onTabSelected", void 0);
__decorate([
    Output()
], IgxBottomNavComponent.prototype, "onTabDeselected", void 0);
__decorate([
    HostListener('onTabSelected', ['$event'])
], IgxBottomNavComponent.prototype, "_selectedPanelHandler", null);
// ================================= IgxTabPanelComponent ======================================
let IgxTabPanelComponent = class IgxTabPanelComponent {
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-tab-panel';
        /**
         * @hidden
         */
        this._isSelected = false;
        /**
         * Gets the role of the tab panel.
         * ```typescript
         * let tabPanelRole = this.tabPanel.role;
         * ```
         * @memberof IgxTabPanelComponent
         */
        this.role = 'tabpanel';
    }
    /**
     * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
     * ```typescript
     * let styleClass = this.tabPanel.styleClass;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get styleClass() {
        return (!this.isSelected);
    }
    /**
     * Sets/gets whether a tab panel is selected.
     * ```typescript
     * this.tabPanel.isSelected = true;
     * ```
     * ```typescript
     * let isSelected =  this.tabPanel.isSelected;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(newValue) {
        if (this._isSelected !== newValue) {
            if (newValue) {
                this.select();
            }
            else {
                this._isSelected = newValue;
            }
        }
    }
    /**
     * Gets the `itemStyle` of the tab panel.
     * ```typescript
     * let itemStyle = this.tabPanel.itemStyle;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get itemStyle() {
        return this._itemStyle;
    }
    /**
     * Returns the native element of the tab-panel component
     * ```typescript
     *  const mytabPanelElement: HTMLElement = tabPanel.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * Gets the tab associated with the panel.
     * ```typescript
     * let tab = this.tabPanel.relatedTab;
     * ```
     * @memberof IgxTabPanelComponent
     */
    get relatedTab() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray()[this.index];
        }
    }
    /**
     * Gets the changes and updates accordingly applied to the tab/panel.
     *
     * @memberof IgxTabComponent
     */
    get changesCount() {
        return this.relatedTab ? this.relatedTab.changesCount : 0;
    }
    /**
     * Gets the index of a panel in the panels collection.
     * ```typescript
     * let panelIndex =  this.tabPanel.index
     * ```
     * @memberof IgxTabPanelComponent
     */
    get index() {
        if (this._tabBar.panels) {
            return this._tabBar.panels.toArray().indexOf(this);
        }
    }
    /**
     * Gets the tab template.
     * ```typescript
     * let tabTemplate = this.tabPanel.customTabTemplate
     * ```
     * @memberof IgxTabPanelComponent
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * Sets the tab template.
     * ```typescript
     * this.tabPanel.customTabTemplate(tabTemplate);
     * ```
     * @memberof IgxTabPanelComponent
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     * @memberof IgxTabPanelComponent
     */
    select() {
        if (this.disabled || this._tabBar.selectedIndex === this.index) {
            return;
        }
        this._isSelected = true;
        this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
    }
};
IgxTabPanelComponent.ɵfac = function IgxTabPanelComponent_Factory(t) { return new (t || IgxTabPanelComponent)(ɵngcc0.ɵɵdirectiveInject(IgxBottomNavComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTabPanelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabPanelComponent, selectors: [["igx-tab-panel"]], contentQueries: function IgxTabPanelComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabTemplateDirective, true, IgxTabTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabTemplate = _t.first);
    } }, hostVars: 5, hostBindings: function IgxTabPanelComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-bottom-nav__panel", ctx.styleClass)("igx-bottom-nav__panel--selected", ctx.isSelected);
    } }, inputs: { label: "label", icon: "icon", disabled: "disabled" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxTabPanelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxTabPanelComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: ElementRef }
];
__decorate([
    Input()
], IgxTabPanelComponent.prototype, "label", void 0);
__decorate([
    Input()
], IgxTabPanelComponent.prototype, "icon", void 0);
__decorate([
    Input()
], IgxTabPanelComponent.prototype, "disabled", void 0);
__decorate([
    HostBinding('attr.role')
], IgxTabPanelComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-bottom-nav__panel')
], IgxTabPanelComponent.prototype, "styleClass", null);
__decorate([
    HostBinding('class.igx-bottom-nav__panel--selected')
], IgxTabPanelComponent.prototype, "isSelected", null);
__decorate([
    ContentChild(IgxTabTemplateDirective, { read: IgxTabTemplateDirective })
], IgxTabPanelComponent.prototype, "tabTemplate", void 0);
// ======================================= IgxTabComponent ==========================================
let IgxTabComponent = class IgxTabComponent {
    constructor(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let tabRole = this.tab.role;
         * ```
         * @memberof IgxTabComponent
         */
        this.role = 'tab';
        /**
         * @hidden @internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden @internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden @internal
         */
        this.ariaSelected = this.isSelected;
        /**
         * @hidden
         */
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._disabled = false;
        this._selected = false;
    }
    /**
     * Sets/gets the `label` of the tab panel.
     * ```html
     * <igx-tab [label] = "'Tab label'"><igx-tab>
     * ```
     * ```typescript
     * let tabLabel = this.tab.label;
     * ```
     * @memberof IgxTabComponent
     */
    get label() {
        return this.relatedPanel ? this.relatedPanel.label : this._label;
    }
    set label(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.label = newValue;
        }
        this._label = newValue;
    }
    /**
     * Sets/gets  the `icon` of the tab panel.
     * ```html
     * <igx-tab [icon] = "tab_icon"><igx-tab>
     * ```
     * ```typescript
     * let tabIcon =  this.tab.icon;
     * ```
     * @memberof IgxTabComponent
     */
    get icon() {
        return this.relatedPanel ? this.relatedPanel.icon : this._icon;
    }
    set icon(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * Gets the changes and updates accordingly applied to the tab.
     *
     * @memberof IgxTabComponent
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * Gets whether the tab is disabled.
     * ```typescript
     * let isDisabled = this.tab.disabled;
     * ```
     * @memberof IgxTabComponent
     */
    get disabled() {
        return this.relatedPanel ? this.relatedPanel.disabled : this._disabled;
    }
    set disabled(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * let isSelected  = this.tab.isSelected;
     * ```
     * @memberof IgxTabComponent
     */
    set isSelected(newValue) {
        if (this.relatedPanel) {
            this.relatedPanel.isSelected = newValue;
        }
        else if (this._selected !== newValue) {
            this._selected = newValue;
            if (this._selected) {
                this._tabBar.onTabSelected.emit({ tab: this, panel: null });
            }
        }
    }
    get isSelected() {
        return this.relatedPanel ? this.relatedPanel.isSelected : this._selected;
    }
    get cssClassSelected() {
        return this.isSelected;
    }
    get cssClassDisabled() {
        return this.disabled;
    }
    get cssClass() {
        return (!this.disabled && !this.isSelected);
    }
    /**
     * Gets the `index` of the tab.
     * ```typescript
     * let tabIndex = this.tab.index;
     * ```
     * @memberof IgxTabComponent
     */
    get index() {
        if (this._tabBar.tabs) {
            return this._tabBar.tabs.toArray().indexOf(this);
        }
    }
    /**
     * Returns the `template` for this IgxTabComponent.
     * ```typescript
     * let tabItemTemplate = this.tabItem.template;
     * ```
     * @memberof IgxTabComponent
     */
    get template() {
        if (this.relatedPanel && this.relatedPanel.customTabTemplate) {
            return this.relatedPanel.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * Returns the `context` object for the template of this `IgxTabComponent`.
     * ```typescript
     * let tabItemContext = this.tabItem.context;
     * ```
     */
    get context() {
        return this.relatedPanel ? this.relatedPanel : this;
    }
    /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     * @memberof IgxTabComponent
     */
    select() {
        if (this.relatedPanel) {
            this.relatedPanel.select();
        }
        else {
            this._selected = true;
            this._tabBar.onTabSelected.emit({ tab: this, panel: null });
        }
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.autoGenerated) {
            this.select();
        }
    }
    elementRef() {
        return this._element;
    }
};
IgxTabComponent.ɵfac = function IgxTabComponent_Factory(t) { return new (t || IgxTabComponent)(ɵngcc0.ɵɵdirectiveInject(IgxBottomNavComponent), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabComponent, selectors: [["igx-tab"]], contentQueries: function IgxTabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabTemplateDirective, true, IgxTabTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTabTemplateDir = _t.first);
    } }, viewQuery: function IgxTabComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c227, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTabTemplate = _t.first);
    } }, hostVars: 10, hostBindings: function IgxTabComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxTabComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("aria-label", ctx.ariaLabel)("aria-disabled", ctx.ariaDisabled)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵclassProp("igx-bottom-nav__menu-item--selected", ctx.cssClassSelected)("igx-bottom-nav__menu-item--disabled", ctx.cssClassDisabled)("igx-bottom-nav__menu-item", ctx.cssClass);
    } }, inputs: { label: "label", icon: "icon", disabled: "disabled", isSelected: "isSelected", relatedPanel: "relatedPanel", autoGenerated: "autoGenerated" }, decls: 3, vars: 4, consts: [["defaultTabTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "tab-icon", 4, "ngIf"], ["ngClass", "tab-label", 4, "ngIf"], [1, "tab-icon"], ["fontSet", "material"], [3, "value", "hidden"], ["ngClass", "tab-label"]], template: function IgxTabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTabComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTabComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx.context));
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent,
        IgxBadgeComponent, ɵngcc2.NgClass], encapsulation: 2 });
IgxTabComponent.ctorParameters = () => [
    { type: IgxBottomNavComponent },
    { type: ElementRef }
];
__decorate([
    HostBinding('attr.role')
], IgxTabComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxTabComponent.prototype, "ariaLabel", void 0);
__decorate([
    HostBinding('attr.aria-disabled')
], IgxTabComponent.prototype, "ariaDisabled", void 0);
__decorate([
    HostBinding('attr.aria-selected')
], IgxTabComponent.prototype, "ariaSelected", void 0);
__decorate([
    Input()
], IgxTabComponent.prototype, "relatedPanel", void 0);
__decorate([
    Input()
], IgxTabComponent.prototype, "label", null);
__decorate([
    Input()
], IgxTabComponent.prototype, "icon", null);
__decorate([
    Input()
], IgxTabComponent.prototype, "disabled", null);
__decorate([
    Input()
], IgxTabComponent.prototype, "isSelected", null);
__decorate([
    Input()
], IgxTabComponent.prototype, "autoGenerated", void 0);
__decorate([
    HostBinding('class.igx-bottom-nav__menu-item--selected')
], IgxTabComponent.prototype, "cssClassSelected", null);
__decorate([
    HostBinding('class.igx-bottom-nav__menu-item--disabled')
], IgxTabComponent.prototype, "cssClassDisabled", null);
__decorate([
    HostBinding('class.igx-bottom-nav__menu-item')
], IgxTabComponent.prototype, "cssClass", null);
__decorate([
    ViewChild('defaultTabTemplate', { read: TemplateRef, static: true })
], IgxTabComponent.prototype, "defaultTabTemplate", void 0);
__decorate([
    ContentChild(IgxTabTemplateDirective, { read: IgxTabTemplateDirective })
], IgxTabComponent.prototype, "customTabTemplateDir", void 0);
__decorate([
    HostListener('click')
], IgxTabComponent.prototype, "onClick", null);
/**
 * @hidden
 */
let IgxBottomNavModule = class IgxBottomNavModule {
};
IgxBottomNavModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxBottomNavModule });
IgxBottomNavModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxBottomNavModule_Factory(t) { return new (t || IgxBottomNavModule)(); }, imports: [[CommonModule, IgxBadgeModule, IgxIconModule]] });

/** @hidden */
class IgxTabsBase {
    scrollElement(element, scrollRight) { }
    performSelectionChange(newTab) { }
    transformContentAnimation(tab, duration) { }
    transformIndicatorAnimation(element, duration) { }
}
/** @hidden */
class IgxTabItemBase {
    get index() { return 0; }
    select() { }
    setSelectedInternal(newValue) { }
}
/** @hidden */
class IgxTabsGroupBase {
    select() { }
    setSelectedInternal(newValue) { }
}

var ButtonStyle;
(function (ButtonStyle) {
    ButtonStyle["VISIBLE"] = "visible";
    ButtonStyle["HIDDEN"] = "hidden";
    ButtonStyle["NOT_DISPLAYED"] = "not_displayed";
})(ButtonStyle || (ButtonStyle = {}));
let IgxRightButtonStyleDirective = class IgxRightButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
    }
    get hiddenCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getRightButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
    }
    getRightButtonStyle() {
        const viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return ButtonStyle.NOT_DISPLAYED;
        }
        if (itemsContainerWidth > total) {
            return ButtonStyle.VISIBLE;
        }
        else {
            return ButtonStyle.HIDDEN;
        }
    }
};
IgxRightButtonStyleDirective.ɵfac = function IgxRightButtonStyleDirective_Factory(t) { return new (t || IgxRightButtonStyleDirective)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase)); };
IgxRightButtonStyleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxRightButtonStyleDirective, selectors: [["", "igxRightButtonStyle", ""]], hostVars: 6, hostBindings: function IgxRightButtonStyleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-tabs__header-button", ctx.visibleCSS)("igx-tabs__header-button--hidden", ctx.hiddenCSS)("igx-tabs__header-button--none", ctx.notDisplayedCSS);
    } } });
IgxRightButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
__decorate([
    HostBinding('class.igx-tabs__header-button')
], IgxRightButtonStyleDirective.prototype, "visibleCSS", null);
__decorate([
    HostBinding('class.igx-tabs__header-button--hidden')
], IgxRightButtonStyleDirective.prototype, "hiddenCSS", null);
__decorate([
    HostBinding('class.igx-tabs__header-button--none')
], IgxRightButtonStyleDirective.prototype, "notDisplayedCSS", null);
let IgxLeftButtonStyleDirective = class IgxLeftButtonStyleDirective {
    constructor(tabs) {
        this.tabs = tabs;
    }
    get visibleCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
    }
    get hiddenCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
    }
    get notDisplayedCSS() {
        return (this.getLeftButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
    }
    getLeftButtonStyle() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        const headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        const offset = this.tabs.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return ButtonStyle.NOT_DISPLAYED;
            }
            return ButtonStyle.HIDDEN;
        }
        else {
            return ButtonStyle.VISIBLE;
        }
    }
};
IgxLeftButtonStyleDirective.ɵfac = function IgxLeftButtonStyleDirective_Factory(t) { return new (t || IgxLeftButtonStyleDirective)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase)); };
IgxLeftButtonStyleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxLeftButtonStyleDirective, selectors: [["", "igxLeftButtonStyle", ""]], hostVars: 6, hostBindings: function IgxLeftButtonStyleDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-tabs__header-button", ctx.visibleCSS)("igx-tabs__header-button--hidden", ctx.hiddenCSS)("igx-tabs__header-button--none", ctx.notDisplayedCSS);
    } } });
IgxLeftButtonStyleDirective.ctorParameters = () => [
    { type: IgxTabsBase }
];
__decorate([
    HostBinding('class.igx-tabs__header-button')
], IgxLeftButtonStyleDirective.prototype, "visibleCSS", null);
__decorate([
    HostBinding('class.igx-tabs__header-button--hidden')
], IgxLeftButtonStyleDirective.prototype, "hiddenCSS", null);
__decorate([
    HostBinding('class.igx-tabs__header-button--none')
], IgxLeftButtonStyleDirective.prototype, "notDisplayedCSS", null);
let IgxTabItemTemplateDirective = class IgxTabItemTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxTabItemTemplateDirective.ɵfac = function IgxTabItemTemplateDirective_Factory(t) { return new (t || IgxTabItemTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTabItemTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTabItemTemplateDirective, selectors: [["", "igxTab", ""]] });
IgxTabItemTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];

let IgxTabItemComponent = class IgxTabItemComponent extends IgxTabItemBase {
    constructor(_tabs, _element, _ngZone) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        this._ngZone = _ngZone;
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        this._isSelected = false;
        this._disabled = false;
        /**
         * @hidden @internal
         */
        this.role = 'tab';
        /**
         * @hidden @internal
         */
        this.tabindex = -1;
        /**
         * @hidden @internal
         */
        this.ariaLabel = this.label;
        /**
         * @hidden @internal
         */
        this.ariaDisabled = this.disabled;
        /**
         * @hidden @internal
         */
        this.ariaSelected = this.isSelected;
        this._nativeTabItem = _element;
    }
    /**
     * An @Input property that sets the value of the `icon`.
     * The value should be valid icon name from {@link https://material.io/tools/icons/?style=baseline}.
     * ```html
     * <igx-tab-item label="Tab 1" icon="home">
     * ```
     */
    get icon() {
        return this.relatedGroup ? this.relatedGroup.icon : this._icon;
    }
    set icon(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.icon = newValue;
        }
        this._icon = newValue;
    }
    /**
     * An @Input property that sets the value of the `label`.
     * ```html
     * <igx-tabs-item label="Tab 2" icon="folder">
     * ```
     */
    get label() {
        return this.relatedGroup ? this.relatedGroup.label : this._label;
    }
    set label(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.label = newValue;
        }
        this._label = newValue;
    }
    get provideCssClassSelected() {
        return this.isSelected;
    }
    get provideCssClassDisabled() {
        return this.disabled;
    }
    get provideCssClass() {
        return (!this.disabled && !this.isSelected);
    }
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver = new ResizeObserver(() => {
                this._tabs.transformIndicatorAnimation(this._nativeTabItem.nativeElement, 0);
            });
        });
    }
    ngOnDestroy() {
        this._ngZone.runOutsideAngular(() => {
            this._resizeObserver.disconnect();
        });
    }
    /**
     * @hidden
     */
    onClick(event) {
        if (this.autoGenerated) {
            this.select();
        }
    }
    /**
     * @hidden
     */
    onKeydown(event) {
        const tabsArray = this._tabs.tabs.toArray();
        const startIndex = tabsArray.indexOf(this);
        let finalIndex = -1;
        let currentIndex = startIndex;
        switch (event.key) {
            case "ArrowRight" /* RIGHT_ARROW */:
            case "Right" /* RIGHT_ARROW_IE */:
                do {
                    currentIndex++;
                    if (currentIndex === tabsArray.length) {
                        currentIndex = -1;
                        continue;
                    }
                    else if (tabsArray[currentIndex].disabled === false) {
                        finalIndex = currentIndex;
                        break;
                    }
                } while (currentIndex !== startIndex);
                break;
            case "ArrowLeft" /* LEFT_ARROW */:
            case "Left" /* LEFT_ARROW_IE */:
                do {
                    currentIndex--;
                    if (currentIndex === -1) {
                        currentIndex = tabsArray.length;
                        continue;
                    }
                    else if (tabsArray[currentIndex].disabled === false) {
                        finalIndex = currentIndex;
                        break;
                    }
                } while (currentIndex !== startIndex);
                break;
            case "Home" /* HOME */:
                event.preventDefault();
                finalIndex = tabsArray.find(t => t.disabled === false).index;
                break;
            case "End" /* END */:
                event.preventDefault();
                finalIndex = tabsArray.slice().reverse().find(t => t.disabled === false).index;
                break;
            case "Enter" /* ENTER */:
                if (!this.autoGenerated) {
                    this.nativeTabItem.nativeElement.click();
                }
                break;
            case " " /* SPACE */:
            case "Spacebar" /* SPACE_IE */:
                event.preventDefault();
                if (!this.autoGenerated) {
                    this.nativeTabItem.nativeElement.click();
                }
                break;
            default:
                break;
        }
        if (finalIndex > -1) {
            const tab = tabsArray[finalIndex];
            tab.nativeTabItem.nativeElement.focus();
            if (this.autoGenerated) {
                tab.select();
            }
        }
    }
    /**
     * @hidden
     */
    get changesCount() {
        return this._changesCount;
    }
    /**
     * @hidden
     */
    get nativeTabItem() {
        return this._nativeTabItem;
    }
    /**
     * 	Gets whether the tab is disabled.
     * ```
     * const disabledItem = this.myTabComponent.tabs.first.disabled;
     * ```
     */
    get disabled() {
        return this.relatedGroup ? this.relatedGroup.disabled : this._disabled;
    }
    set disabled(newValue) {
        if (this.relatedGroup) {
            this.relatedGroup.disabled = newValue;
        }
        else {
            this._disabled = newValue;
        }
    }
    /**
     * Gets whether the tab is selected.
     * ```typescript
     * const selectedItem = this.myTabComponent.tabs.first.isSelected;
     * ```
     */
    get isSelected() {
        return this.relatedGroup ? this.relatedGroup.isSelected : this._isSelected;
    }
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this : null);
        }
    }
    /**
     * @hidden
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this);
        }
    }
    /**
     * @hidden
     */
    get index() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
        this._ngZone.runOutsideAngular(() => {
            if (this._resizeObserver) {
                if (this._isSelected) {
                    this._resizeObserver.observe(this._element.nativeElement);
                }
                else {
                    this._resizeObserver.disconnect();
                }
            }
        });
        this.tabindex = newValue ? 0 : -1;
    }
    /**
     * @hidden
     */
    get template() {
        if (this.relatedGroup && this.relatedGroup.customTabTemplate) {
            return this.relatedGroup.customTabTemplate;
        }
        if (this.customTabTemplateDir) {
            return this.customTabTemplateDir.template;
        }
        return this.defaultTabTemplate;
    }
    /**
     * @hidden
     */
    get context() {
        return this.relatedGroup ? this.relatedGroup : this;
    }
};
IgxTabItemComponent.ɵfac = function IgxTabItemComponent_Factory(t) { return new (t || IgxTabItemComponent)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
IgxTabItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabItemComponent, selectors: [["igx-tab-item"]], contentQueries: function IgxTabItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabItemTemplateDirective, true, IgxTabItemTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTabTemplateDir = _t.first);
    } }, viewQuery: function IgxTabItemComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c227, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTabTemplate = _t.first);
    } }, hostVars: 11, hostBindings: function IgxTabItemComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxTabItemComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("keydown", function IgxTabItemComponent_keydown_HostBindingHandler($event) { return ctx.onKeydown($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role)("tabindex", ctx.tabindex)("aria-label", ctx.ariaLabel)("aria-disabled", ctx.ariaDisabled)("aria-selected", ctx.ariaSelected);
        ɵngcc0.ɵɵclassProp("igx-tabs__header-menu-item--selected", ctx.provideCssClassSelected)("igx-tabs__header-menu-item--disabled", ctx.provideCssClassDisabled)("igx-tabs__header-menu-item", ctx.provideCssClass);
    } }, inputs: { icon: "icon", label: "label", disabled: "disabled", isSelected: "isSelected", relatedGroup: "relatedGroup", autoGenerated: "autoGenerated" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 3, vars: 4, consts: [["defaultTabTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "igx-tabs__header-menu-item-icon", 4, "ngIf"], ["ngClass", "igx-tabs__item-label", 4, "ngIf"], [1, "igx-tabs__header-menu-item-icon"], ["fontSet", "material"], [3, "value", "hidden"], ["ngClass", "igx-tabs__item-label"]], template: function IgxTabItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTabItemComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTabItemComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ɵngcc0.ɵɵpureFunction1(2, _c13, ctx.context));
    } }, directives: [ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, IgxIconComponent,
        IgxBadgeComponent, ɵngcc2.NgClass], encapsulation: 2 });
IgxTabItemComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: ElementRef },
    { type: NgZone }
];
__decorate([
    Input()
], IgxTabItemComponent.prototype, "relatedGroup", void 0);
__decorate([
    Input()
], IgxTabItemComponent.prototype, "icon", null);
__decorate([
    Input()
], IgxTabItemComponent.prototype, "label", null);
__decorate([
    Input()
], IgxTabItemComponent.prototype, "autoGenerated", void 0);
__decorate([
    ViewChild('defaultTabTemplate', { read: TemplateRef, static: true })
], IgxTabItemComponent.prototype, "defaultTabTemplate", void 0);
__decorate([
    ContentChild(IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective })
], IgxTabItemComponent.prototype, "customTabTemplateDir", void 0);
__decorate([
    HostBinding('class.igx-tabs__header-menu-item--selected')
], IgxTabItemComponent.prototype, "provideCssClassSelected", null);
__decorate([
    HostBinding('class.igx-tabs__header-menu-item--disabled')
], IgxTabItemComponent.prototype, "provideCssClassDisabled", null);
__decorate([
    HostBinding('class.igx-tabs__header-menu-item')
], IgxTabItemComponent.prototype, "provideCssClass", null);
__decorate([
    HostBinding('attr.role')
], IgxTabItemComponent.prototype, "role", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxTabItemComponent.prototype, "tabindex", void 0);
__decorate([
    HostBinding('attr.aria-label')
], IgxTabItemComponent.prototype, "ariaLabel", void 0);
__decorate([
    HostBinding('attr.aria-disabled')
], IgxTabItemComponent.prototype, "ariaDisabled", void 0);
__decorate([
    HostBinding('attr.aria-selected')
], IgxTabItemComponent.prototype, "ariaSelected", void 0);
__decorate([
    HostListener('click', ['$event'])
], IgxTabItemComponent.prototype, "onClick", null);
__decorate([
    HostListener('keydown', ['$event'])
], IgxTabItemComponent.prototype, "onKeydown", null);
__decorate([
    Input()
], IgxTabItemComponent.prototype, "disabled", null);
__decorate([
    Input()
], IgxTabItemComponent.prototype, "isSelected", null);

let IgxTabsGroupComponent = class IgxTabsGroupComponent extends IgxTabsGroupBase {
    constructor(_tabs, _element) {
        super();
        this._tabs = _tabs;
        this._element = _element;
        /**
         * An @Input property that allows you to enable/disable the `IgxTabGroupComponent`.
         * ```html
         * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
         * ```
         */
        this.disabled = false;
        this._isSelected = false;
        /**
         * @hidden
         */
        this.role = 'tabpanel';
        /**
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * Sets/gets whether a tab group is selected.
     * ```typescript
     * this.tabGroup.isSelected = true;
     * ```
     * ```typescript
     * let isSelected = this.tabGroup.isSelected;
     * ```
     * @memberof IgxTabsGroupComponent
     */
    get isSelected() {
        return this._isSelected;
    }
    set isSelected(newValue) {
        if (!this.disabled && this.isSelected !== newValue) {
            this._tabs.performSelectionChange(newValue ? this.relatedTab : null);
        }
    }
    /**
     * Returns the native element of the tabs-group component
     * ```typescript
     *  const mytabsGroupElement: HTMLElement = tabsGroup.nativeElement;
     * ```
     */
    get nativeElement() {
        return this._element.nativeElement;
    }
    /**
     * An accessor that returns the `IgxTabItemComponent` component.
     * ```typescript
     * @ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabComponent = this.tab.relatedTab;
     * }
     * ```
     */
    get relatedTab() {
        if (this._tabs.tabs) {
            return this._tabs.tabs.toArray()[this.index];
        }
    }
    /**
     * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
     * ```typescript
     * @ViewChild("MyTabsGroup")
     * public tab: IgxTabsGroupComponent;
     * ngAfterViewInIt(){
     *    let tabIndex = this.tab.index;
     * }
     * ```
     */
    get index() {
        if (this._tabs.groups) {
            return this._tabs.groups.toArray().indexOf(this);
        }
        return -1;
    }
    /**
     * @hidden
     */
    get customTabTemplate() {
        return this._tabTemplate;
    }
    /**
     * @hidden
     */
    set customTabTemplate(template) {
        this._tabTemplate = template;
    }
    /**
     * @hidden
     */
    ngAfterContentInit() {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    }
    /**
     * A method that sets the focus on a tab.
     * @memberof {@link IgxTabsGroupComponent}
     * ```typescript
     *  @ViewChild("MyChild")
     * public tab : IgxTabsGroupComponent;
     * ngAfterViewInit(){
     *     this.tab.select();
     * }
     * ```
     */
    select() {
        if (!this.disabled && !this.isSelected) {
            this._tabs.performSelectionChange(this.relatedTab);
        }
    }
    /**
     * @hidden
     */
    setSelectedInternal(newValue) {
        this._isSelected = newValue;
    }
};
IgxTabsGroupComponent.ɵfac = function IgxTabsGroupComponent_Factory(t) { return new (t || IgxTabsGroupComponent)(ɵngcc0.ɵɵdirectiveInject(IgxTabsBase), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxTabsGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabsGroupComponent, selectors: [["igx-tabs-group"]], contentQueries: function IgxTabsGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabItemTemplateDirective, true, IgxTabItemTemplateDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabTemplate = _t.first);
    } }, hostVars: 3, hostBindings: function IgxTabsGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
        ɵngcc0.ɵɵclassProp("igx-tabs__group", ctx.styleClass);
    } }, inputs: { disabled: "disabled", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c2, decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function IgxTabsGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, IgxTabsGroupComponent_0_Template, 1, 0, undefined, 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isSelected);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
IgxTabsGroupComponent.ctorParameters = () => [
    { type: IgxTabsBase },
    { type: ElementRef }
];
__decorate([
    Input()
], IgxTabsGroupComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxTabsGroupComponent.prototype, "icon", void 0);
__decorate([
    Input()
], IgxTabsGroupComponent.prototype, "label", void 0);
__decorate([
    ContentChild(IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective })
], IgxTabsGroupComponent.prototype, "tabTemplate", void 0);
__decorate([
    HostBinding('attr.role')
], IgxTabsGroupComponent.prototype, "role", void 0);
__decorate([
    HostBinding('class.igx-tabs__group')
], IgxTabsGroupComponent.prototype, "styleClass", void 0);

var IgxTabsComponent_1;
var IgxTabsType;
(function (IgxTabsType) {
    IgxTabsType["FIXED"] = "fixed";
    IgxTabsType["CONTENTFIT"] = "contentfit";
})(IgxTabsType || (IgxTabsType = {}));
let NEXT_TABS_ID = 0;
let IgxTabsComponent = IgxTabsComponent_1 = class IgxTabsComponent {
    constructor(_element, _ngZone, platformUtil) {
        this._element = _element;
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        this._currentTabsId = NEXT_TABS_ID++;
        /**
         * @hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs type="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.type = 'contentfit';
        /**
         * Sets/gets the `id` of the tabs.
         *
         * @remarks
         * If not set, the `id` will have value `"igx-tabs-0"`.
         *
         * @example
         * ```html
         * <igx-tabs id="my-first-tabs"></igx-tabs>
         * ```
         * @memberof IgxTabsComponent
         */
        this.id = `igx-tabs-${this._currentTabsId}`;
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    /**
     * An @Input property that sets the value of the `selectedIndex`.
     * Default value is 0.
     * ```html
     * <igx-tabs selectedIndex="1">
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tabs [(selectedIndex)]="model.selectedIndex">
     * ```
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        const newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
        if (this._selectedIndex !== newIndex) {
            if (this.tabs && this.tabs.length > 0) {
                const newTab = this.tabs.toArray()[newIndex];
                if (newTab) {
                    this.performSelectionChange(newTab);
                }
            }
            else {
                this._selectedIndex = newIndex;
            }
        }
    }
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * First try to get them as content children if not available get them as view children.
     * ```typescript
     * const tabItems = this.myTabComponent.tabs;
     * ```
     */
    get tabs() {
        if (this.hasContentTabs) {
            return this.contentTabs;
        }
        return this.viewTabs;
    }
    /**
     * @hidden
     */
    get hasContentTabs() {
        return (this.contentTabs && this.contentTabs.length > 0);
    }
    /**
     * @hidden
     */
    get cssClass() {
        const defaultStyle = `igx-tabs`;
        const fixedStyle = `igx-tabs--fixed`;
        const iconStyle = `igx-tabs--icons`;
        const iconLabelFoundInGroups = this.groups.find((group) => group.icon != null && group.label != null);
        const iconLabelFoundInTabs = this.contentTabs.find((tab) => tab.icon != null && tab.label != null);
        let css;
        switch (IgxTabsType[this.type.toUpperCase()]) {
            case IgxTabsType.FIXED: {
                css = fixedStyle;
                break;
            }
            default: {
                css = defaultStyle;
                break;
            }
        }
        // Layout fix for items with icons
        if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
            css = `${css} ${iconStyle}`;
        }
        return `${css} ${this.class}`;
    }
    /**
     * @hidden
     */
    scrollLeft(event) {
        this.scroll(false);
    }
    /**
     * @hidden
     */
    scrollRight(event) {
        this.scroll(true);
    }
    /**
     * @hidden
     */
    scrollElement(element, scrollRight) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = `translate(${-this.offset}px)`;
    }
    /**
     * Gets the selected `IgxTabItemComponent`.
     * ```
     * const selectedItem = this.myTabComponent.selectedTabItem;
     * ```
     */
    get selectedTabItem() {
        if (this.tabs && this.selectedIndex !== undefined) {
            return this.tabs.toArray()[this.selectedIndex];
        }
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this._selectedIndex === -1) {
            this.tabs.forEach((t) => {
                if (t.isSelected) {
                    this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                const newTab = this.tabs.toArray()[this._selectedIndex];
                if (newTab) {
                    this.performSelection(newTab);
                }
                else {
                    this.hideIndicator();
                }
            });
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver = new ResizeObserver(() => {
                    if (!this.hasContentTabs && this._selectedIndex >= 0 && this._selectedIndex < this.tabs.length) {
                        const newTab = this.tabs.toArray()[this._selectedIndex];
                        this.transformContentAnimation(newTab, 0);
                    }
                });
                this._resizeObserver.observe(this.tabsContainer.nativeElement);
            });
        }
        this.setGroupsAttributes();
        this._groupChanges$ = this.groups.changes.subscribe(() => {
            this.setGroupsAttributes();
            this.resetSelectionOnCollectionChanged();
        });
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(() => {
                this._resizeObserver.disconnect();
            });
        }
    }
    setGroupsAttributes() {
        const groupsArray = Array.from(this.groups);
        for (let index = 0; index < this.groups.length; index++) {
            const tabsGroup = groupsArray[index];
            tabsGroup.nativeElement.setAttribute('id', this.getTabsGroupId(index));
            tabsGroup.nativeElement.setAttribute('aria-labelledby', this.getTabItemId(index));
        }
    }
    resetSelectionOnCollectionChanged() {
        requestAnimationFrame(() => {
            const currentTab = this.tabs.toArray()[this.selectedIndex];
            if (currentTab) {
                this.performSelectionChange(currentTab);
            }
            else if (this.selectedIndex >= this.tabs.length) {
                this.performSelectionChange(this.tabs.last);
            }
            else {
                this.hideIndicator();
            }
        });
    }
    scroll(scrollRight) {
        const tabsArray = this.tabs.toArray();
        for (const tab of tabsArray) {
            const element = tab.nativeTabItem.nativeElement;
            if (scrollRight) {
                if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
            else {
                if (element.offsetWidth + element.offsetLeft >= this.offset) {
                    this.scrollElement(element, scrollRight);
                    break;
                }
            }
        }
    }
    /**
     * @hidden
     */
    performSelectionChange(newTab) {
        const oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    }
    performDeselection(oldTab) {
        oldTab.setSelectedInternal(false);
        const oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    }
    performSelection(newTab) {
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        let newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(() => {
            // bring the new selected tab into view if it is not
            this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!this.hasContentTabs) {
                this.transformContentAnimation(newTab, 0.2);
            }
        });
    }
    bringNewTabIntoView(newTab) {
        const tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        const delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    }
    /**
     * @hidden
     */
    getTabItemId(index) {
        return `igx-tab-item-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     */
    getTabsGroupId(index) {
        return `igx-tabs-group-${this._currentTabsId}-${index}`;
    }
    /**
     * @hidden
     */
    // animation for the new panel/group (not needed for tab only mode)
    transformContentAnimation(tab, duration) {
        const contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
        this.contentsContainer.nativeElement.style.transform = `translate(${-contentOffset}px)`;
    }
    /**
     * @hidden
     */
    transformIndicatorAnimation(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
};
IgxTabsComponent.ɵfac = function IgxTabsComponent_Factory(t) { return new (t || IgxTabsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(PlatformUtil)); };
IgxTabsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTabsComponent, selectors: [["igx-tabs"]], contentQueries: function IgxTabsComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabsGroupComponent, false);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTabItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.groups = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentTabs = _t);
    } }, viewQuery: function IgxTabsComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c228, true);
        ɵngcc0.ɵɵstaticViewQuery(_c229, true);
        ɵngcc0.ɵɵstaticViewQuery(_c230, true);
        ɵngcc0.ɵɵviewQuery(_c231, true);
        ɵngcc0.ɵɵstaticViewQuery(_c232, true);
        ɵngcc0.ɵɵstaticViewQuery(_c233, true);
        ɵngcc0.ɵɵviewQuery(IgxTabItemComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.contentsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.headerContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.selectedIndicator = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabsContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewPort = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewTabs = _t);
    } }, hostVars: 2, hostBindings: function IgxTabsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id)("class", ctx.cssClass);
    } }, inputs: { type: "type", id: "id", class: "class", selectedIndex: "selectedIndex" }, outputs: { selectedIndexChange: "selectedIndexChange", onTabItemDeselected: "onTabItemDeselected", onTabItemSelected: "onTabItemSelected" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxTabsBase, useExisting: IgxTabsComponent_1 }])], ngContentSelectors: _c235, decls: 21, vars: 2, consts: [["tabsContainer", ""], [1, "igx-tabs__header"], ["headerContainer", ""], ["igxRipple", "", "igxButton", "icon", "igxLeftButtonStyle", "", 1, "igx-tabs__header-button", 3, "click"], ["fontSet", "material"], [1, "igx-tabs__header-wrapper-fixed"], ["viewPort", ""], [1, "igx-tabs__header-wrapper-fluid"], ["itemsContainer", ""], [4, "ngIf"], ["class", "igx-tabs__header-menu-item-indicator", 4, "ngIf"], ["igxRipple", "", "igxButton", "icon", "igxRightButtonStyle", "", 1, "igx-tabs__header-button", 3, "click"], [1, "igx-tabs__content-fixed"], [1, "igx-tabs__content-fluid"], ["contentsContainer", ""], ["igxRipple", "", 3, "relatedGroup", "autoGenerated", "id", 4, "ngFor", "ngForOf"], ["igxRipple", "", 3, "relatedGroup", "autoGenerated", "id"], [1, "igx-tabs__header-menu-item-indicator"], ["selectedIndicator", ""]], template: function IgxTabsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c234);
        ɵngcc0.ɵɵelementStart(0, "div", null, 0);
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "button", 3);
        ɵngcc0.ɵɵlistener("click", function IgxTabsComponent_Template_button_click_4_listener($event) { return ctx.scrollLeft($event); });
        ɵngcc0.ɵɵelementStart(5, "igx-icon", 4);
        ɵngcc0.ɵɵtext(6, "navigate_before");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 5, 6);
        ɵngcc0.ɵɵelementStart(9, "div", 7, 8);
        ɵngcc0.ɵɵtemplate(11, IgxTabsComponent_ng_container_11_Template, 2, 1, "ng-container", 9);
        ɵngcc0.ɵɵprojection(12);
        ɵngcc0.ɵɵtemplate(13, IgxTabsComponent_div_13_Template, 2, 0, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "button", 11);
        ɵngcc0.ɵɵlistener("click", function IgxTabsComponent_Template_button_click_14_listener($event) { return ctx.scrollRight($event); });
        ɵngcc0.ɵɵelementStart(15, "igx-icon", 4);
        ɵngcc0.ɵɵtext(16, "navigate_next");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(17, "div", 12);
        ɵngcc0.ɵɵelementStart(18, "div", 13, 14);
        ɵngcc0.ɵɵprojection(20, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(11);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.hasContentTabs);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.groups.length > 0 || ctx.contentTabs.length > 0);
    } }, directives: [IgxRippleDirective,
        IgxLeftButtonStyleDirective,
        IgxIconComponent, ɵngcc2.NgIf, IgxRightButtonStyleDirective, ɵngcc2.NgForOf, IgxTabItemComponent], encapsulation: 2 });
IgxTabsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: PlatformUtil }
];
__decorate([
    ContentChildren(forwardRef(() => IgxTabsGroupComponent))
], IgxTabsComponent.prototype, "groups", void 0);
__decorate([
    ContentChildren(forwardRef(() => IgxTabItemComponent))
], IgxTabsComponent.prototype, "contentTabs", void 0);
__decorate([
    Input()
], IgxTabsComponent.prototype, "selectedIndex", null);
__decorate([
    Output()
], IgxTabsComponent.prototype, "selectedIndexChange", void 0);
__decorate([
    Input('type')
], IgxTabsComponent.prototype, "type", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxTabsComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxTabsComponent.prototype, "class", void 0);
__decorate([
    Output()
], IgxTabsComponent.prototype, "onTabItemDeselected", void 0);
__decorate([
    Output()
], IgxTabsComponent.prototype, "onTabItemSelected", void 0);
__decorate([
    ViewChild('contentsContainer', { static: true })
], IgxTabsComponent.prototype, "contentsContainer", void 0);
__decorate([
    ViewChild('headerContainer', { static: true })
], IgxTabsComponent.prototype, "headerContainer", void 0);
__decorate([
    ViewChild('itemsContainer', { static: true })
], IgxTabsComponent.prototype, "itemsContainer", void 0);
__decorate([
    ViewChild('selectedIndicator')
], IgxTabsComponent.prototype, "selectedIndicator", void 0);
__decorate([
    ViewChild('tabsContainer', { static: true })
], IgxTabsComponent.prototype, "tabsContainer", void 0);
__decorate([
    ViewChild('viewPort', { static: true })
], IgxTabsComponent.prototype, "viewPort", void 0);
__decorate([
    ViewChildren(forwardRef(() => IgxTabItemComponent))
], IgxTabsComponent.prototype, "viewTabs", void 0);
__decorate([
    HostBinding('attr.class')
], IgxTabsComponent.prototype, "cssClass", null);
/**
 * @hidden
 */
let IgxTabsModule = class IgxTabsModule {
};
IgxTabsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTabsModule });
IgxTabsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTabsModule_Factory(t) { return new (t || IgxTabsModule)(); }, imports: [[CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]] });

/** @hidden */
const IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';

/** @hidden */
let IgxItemListDirective = class IgxItemListDirective {
    constructor(timePicker, elementRef) {
        this.timePicker = timePicker;
        this.elementRef = elementRef;
        this.tabindex = 0;
    }
    get defaultCSS() {
        return true;
    }
    get hourCSS() {
        return this.type === 'hourList';
    }
    get minuteCSS() {
        return this.type === 'minuteList';
    }
    get secondsCSS() {
        return this.type === 'secondsList';
    }
    get ampmCSS() {
        return this.type === 'ampmList';
    }
    onFocus() {
        this.isActive = true;
    }
    onBlur() {
        this.isActive = false;
    }
    nextItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.nextHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.nextMinute();
                break;
            }
            case 'secondsList': {
                this.timePicker.nextSeconds();
                break;
            }
            case 'ampmList': {
                this.timePicker.nextAmPm();
                break;
            }
        }
    }
    prevItem() {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.prevHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.prevMinute();
                break;
            }
            case 'secondsList': {
                this.timePicker.prevSeconds();
                break;
            }
            case 'ampmList': {
                this.timePicker.prevAmPm();
                break;
            }
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowDown(event) {
        event.preventDefault();
        this.nextItem();
    }
    /**
     * @hidden
     */
    onKeydownArrowUp(event) {
        event.preventDefault();
        this.prevItem();
    }
    /**
     * @hidden
     */
    onKeydownArrowRight(event) {
        event.preventDefault();
        const listName = event.target.className;
        if (listName.indexOf('hourList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1) && this.timePicker.secondsList) {
            this.timePicker.secondsList.nativeElement.focus();
        }
        else if ((listName.indexOf('hourList') !== -1 || listName.indexOf('minuteList') !== -1 ||
            listName.indexOf('secondsList') !== -1) && this.timePicker.ampmList) {
            this.timePicker.ampmList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownArrowLeft(event) {
        event.preventDefault();
        const listName = event.target.className;
        if (listName.indexOf('ampmList') !== -1 && this.timePicker.secondsList) {
            this.timePicker.secondsList.nativeElement.focus();
        }
        else if (listName.indexOf('secondsList') !== -1 && this.timePicker.secondsList
            && listName.indexOf('minutesList') && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if (listName.indexOf('ampmList') !== -1 && this.timePicker.minuteList) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if ((listName.indexOf('ampmList') !== -1 || listName.indexOf('secondsList') !== -1 ||
            listName.indexOf('minuteList') !== -1) && this.timePicker.hourList) {
            this.timePicker.hourList.nativeElement.focus();
        }
    }
    /**
     * @hidden
     */
    onKeydownEnter(event) {
        event.preventDefault();
        if (this.timePicker.mode === InteractionMode.DropDown) {
            this.timePicker.close();
            return;
        }
        this.timePicker.okButtonClick();
    }
    /**
     * @hidden
     */
    onKeydownEscape(event) {
        event.preventDefault();
        this.timePicker.cancelButtonClick();
    }
    /**
     * @hidden
     */
    onHover() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * @hidden
     */
    onScroll(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.nextItem();
        }
        else if (event.deltaY < 0) {
            this.prevItem();
        }
    }
    /**
     * @hidden
     */
    onPanMove(event) {
        if (event.deltaY < 0) {
            this.nextItem();
        }
        else if (event.deltaY > 0) {
            this.prevItem();
        }
    }
};
IgxItemListDirective.ɵfac = function IgxItemListDirective_Factory(t) { return new (t || IgxItemListDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxItemListDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxItemListDirective, selectors: [["", "igxItemList", ""]], hostVars: 11, hostBindings: function IgxItemListDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function IgxItemListDirective_focus_HostBindingHandler() { return ctx.onFocus(); })("blur", function IgxItemListDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("keydown.arrowdown", function IgxItemListDirective_keydown_arrowdown_HostBindingHandler($event) { return ctx.onKeydownArrowDown($event); })("keydown.arrowup", function IgxItemListDirective_keydown_arrowup_HostBindingHandler($event) { return ctx.onKeydownArrowUp($event); })("keydown.arrowright", function IgxItemListDirective_keydown_arrowright_HostBindingHandler($event) { return ctx.onKeydownArrowRight($event); })("keydown.arrowleft", function IgxItemListDirective_keydown_arrowleft_HostBindingHandler($event) { return ctx.onKeydownArrowLeft($event); })("keydown.enter", function IgxItemListDirective_keydown_enter_HostBindingHandler($event) { return ctx.onKeydownEnter($event); })("keydown.escape", function IgxItemListDirective_keydown_escape_HostBindingHandler($event) { return ctx.onKeydownEscape($event); })("mouseover", function IgxItemListDirective_mouseover_HostBindingHandler() { return ctx.onHover(); })("wheel", function IgxItemListDirective_wheel_HostBindingHandler($event) { return ctx.onScroll($event); })("panmove", function IgxItemListDirective_panmove_HostBindingHandler($event) { return ctx.onPanMove($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex);
        ɵngcc0.ɵɵclassProp("igx-time-picker__column", ctx.defaultCSS)("igx-time-picker__hourList", ctx.hourCSS)("igx-time-picker__minuteList", ctx.minuteCSS)("igx-time-picker__secondsList", ctx.secondsCSS)("igx-time-picker__ampmList", ctx.ampmCSS);
    } }, inputs: { type: ["igxItemList", "type"] } });
IgxItemListDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: ElementRef }
];
__decorate([
    Input('igxItemList')
], IgxItemListDirective.prototype, "type", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxItemListDirective.prototype, "tabindex", void 0);
__decorate([
    HostBinding('class.igx-time-picker__column')
], IgxItemListDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__hourList')
], IgxItemListDirective.prototype, "hourCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__minuteList')
], IgxItemListDirective.prototype, "minuteCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__secondsList')
], IgxItemListDirective.prototype, "secondsCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__ampmList')
], IgxItemListDirective.prototype, "ampmCSS", null);
__decorate([
    HostListener('focus')
], IgxItemListDirective.prototype, "onFocus", null);
__decorate([
    HostListener('blur')
], IgxItemListDirective.prototype, "onBlur", null);
__decorate([
    HostListener('keydown.arrowdown', ['$event'])
], IgxItemListDirective.prototype, "onKeydownArrowDown", null);
__decorate([
    HostListener('keydown.arrowup', ['$event'])
], IgxItemListDirective.prototype, "onKeydownArrowUp", null);
__decorate([
    HostListener('keydown.arrowright', ['$event'])
], IgxItemListDirective.prototype, "onKeydownArrowRight", null);
__decorate([
    HostListener('keydown.arrowleft', ['$event'])
], IgxItemListDirective.prototype, "onKeydownArrowLeft", null);
__decorate([
    HostListener('keydown.enter', ['$event'])
], IgxItemListDirective.prototype, "onKeydownEnter", null);
__decorate([
    HostListener('keydown.escape', ['$event'])
], IgxItemListDirective.prototype, "onKeydownEscape", null);
__decorate([
    HostListener('mouseover')
], IgxItemListDirective.prototype, "onHover", null);
__decorate([
    HostListener('wheel', ['$event'])
], IgxItemListDirective.prototype, "onScroll", null);
__decorate([
    HostListener('panmove', ['$event'])
], IgxItemListDirective.prototype, "onPanMove", null);
IgxItemListDirective = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], IgxItemListDirective);
/**
 * @hidden
 */
let IgxHourItemDirective = class IgxHourItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedHour;
    }
    get activeCSS() {
        return this.isSelectedHour && this.itemList.isActive;
    }
    get isSelectedHour() {
        return this.timePicker.selectedHour === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollHourIntoView(item);
        }
    }
};
IgxHourItemDirective.ɵfac = function IgxHourItemDirective_Factory(t) { return new (t || IgxHourItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxHourItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxHourItemDirective, selectors: [["", "igxHourItem", ""]], hostVars: 6, hostBindings: function IgxHourItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxHourItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxHourItem", "value"] } });
IgxHourItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
__decorate([
    Input('igxHourItem')
], IgxHourItemDirective.prototype, "value", void 0);
__decorate([
    HostBinding('class.igx-time-picker__item')
], IgxHourItemDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--selected')
], IgxHourItemDirective.prototype, "selectedCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--active')
], IgxHourItemDirective.prototype, "activeCSS", null);
__decorate([
    HostListener('click', ['value'])
], IgxHourItemDirective.prototype, "onClick", null);
IgxHourItemDirective = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], IgxHourItemDirective);
/**
 * @hidden
 */
let IgxMinuteItemDirective = class IgxMinuteItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedMinute;
    }
    get activeCSS() {
        return this.isSelectedMinute && this.itemList.isActive;
    }
    get isSelectedMinute() {
        return this.timePicker.selectedMinute === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollMinuteIntoView(item);
        }
    }
};
IgxMinuteItemDirective.ɵfac = function IgxMinuteItemDirective_Factory(t) { return new (t || IgxMinuteItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxMinuteItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxMinuteItemDirective, selectors: [["", "igxMinuteItem", ""]], hostVars: 6, hostBindings: function IgxMinuteItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxMinuteItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxMinuteItem", "value"] } });
IgxMinuteItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
__decorate([
    Input('igxMinuteItem')
], IgxMinuteItemDirective.prototype, "value", void 0);
__decorate([
    HostBinding('class.igx-time-picker__item')
], IgxMinuteItemDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--selected')
], IgxMinuteItemDirective.prototype, "selectedCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--active')
], IgxMinuteItemDirective.prototype, "activeCSS", null);
__decorate([
    HostListener('click', ['value'])
], IgxMinuteItemDirective.prototype, "onClick", null);
IgxMinuteItemDirective = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], IgxMinuteItemDirective);
/**
 * @hidden
 */
let IgxSecondsItemDirective = class IgxSecondsItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedSeconds;
    }
    get activeCSS() {
        return this.isSelectedSeconds && this.itemList.isActive;
    }
    get isSelectedSeconds() {
        return this.timePicker.selectedSeconds === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollSecondsIntoView(item);
        }
    }
};
IgxSecondsItemDirective.ɵfac = function IgxSecondsItemDirective_Factory(t) { return new (t || IgxSecondsItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxSecondsItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxSecondsItemDirective, selectors: [["", "igxSecondsItem", ""]], hostVars: 6, hostBindings: function IgxSecondsItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxSecondsItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxSecondsItem", "value"] } });
IgxSecondsItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
__decorate([
    Input('igxSecondsItem')
], IgxSecondsItemDirective.prototype, "value", void 0);
__decorate([
    HostBinding('class.igx-time-picker__item')
], IgxSecondsItemDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--selected')
], IgxSecondsItemDirective.prototype, "selectedCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--active')
], IgxSecondsItemDirective.prototype, "activeCSS", null);
__decorate([
    HostListener('click', ['value'])
], IgxSecondsItemDirective.prototype, "onClick", null);
IgxSecondsItemDirective = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], IgxSecondsItemDirective);
/**
 * @hidden
 */
let IgxAmPmItemDirective = class IgxAmPmItemDirective {
    constructor(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    get defaultCSS() {
        return true;
    }
    get selectedCSS() {
        return this.isSelectedAmPm;
    }
    get activeCSS() {
        return this.isSelectedAmPm && this.itemList.isActive;
    }
    get isSelectedAmPm() {
        return this.timePicker.selectedAmPm === this.value;
    }
    onClick(item) {
        if (item !== '') {
            this.timePicker.scrollAmPmIntoView(item);
        }
    }
};
IgxAmPmItemDirective.ɵfac = function IgxAmPmItemDirective_Factory(t) { return new (t || IgxAmPmItemDirective)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT), ɵngcc0.ɵɵdirectiveInject(IgxItemListDirective)); };
IgxAmPmItemDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxAmPmItemDirective, selectors: [["", "igxAmPmItem", ""]], hostVars: 6, hostBindings: function IgxAmPmItemDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxAmPmItemDirective_click_HostBindingHandler() { return ctx.onClick(ctx.value); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-time-picker__item", ctx.defaultCSS)("igx-time-picker__item--selected", ctx.selectedCSS)("igx-time-picker__item--active", ctx.activeCSS);
    } }, inputs: { value: ["igxAmPmItem", "value"] } });
IgxAmPmItemDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
    { type: IgxItemListDirective }
];
__decorate([
    Input('igxAmPmItem')
], IgxAmPmItemDirective.prototype, "value", void 0);
__decorate([
    HostBinding('class.igx-time-picker__item')
], IgxAmPmItemDirective.prototype, "defaultCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--selected')
], IgxAmPmItemDirective.prototype, "selectedCSS", null);
__decorate([
    HostBinding('class.igx-time-picker__item--active')
], IgxAmPmItemDirective.prototype, "activeCSS", null);
__decorate([
    HostListener('click', ['value'])
], IgxAmPmItemDirective.prototype, "onClick", null);
IgxAmPmItemDirective = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], IgxAmPmItemDirective);
/**
 * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
 */
let IgxTimePickerTemplateDirective = class IgxTimePickerTemplateDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxTimePickerTemplateDirective.ɵfac = function IgxTimePickerTemplateDirective_Factory(t) { return new (t || IgxTimePickerTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTimePickerTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTimePickerTemplateDirective, selectors: [["", "igxTimePickerTemplate", ""]] });
IgxTimePickerTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
/**
 * This directive can be used to add custom action buttons to the dropdownb/dialog.
 */
let IgxTimePickerActionsDirective = class IgxTimePickerActionsDirective {
    constructor(template) {
        this.template = template;
    }
};
IgxTimePickerActionsDirective.ɵfac = function IgxTimePickerActionsDirective_Factory(t) { return new (t || IgxTimePickerActionsDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef)); };
IgxTimePickerActionsDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxTimePickerActionsDirective, selectors: [["", "igxTimePickerActions", ""]] });
IgxTimePickerActionsDirective.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element loses focus.
 */
let TimeDisplayFormatPipe = class TimeDisplayFormatPipe {
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    transform(value) {
        let hour, minutes, seconds, amPM;
        const maskAmPM = this.timePicker.parseMask();
        const mask = this.timePicker.parseMask(false);
        if (!value || value === mask || value === maskAmPM) {
            return '';
        }
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
        }
        if (this.timePicker.showSecondsList) {
            seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        const format = this.timePicker.format;
        const prompt = this.timePicker.promptChar;
        const regExp = new RegExp(this.timePicker.promptChar, 'g');
        if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
            hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
        }
        if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
            minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
        }
        if (format.indexOf('ss') !== -1 && seconds.indexOf(prompt) !== -1) {
            seconds = seconds === prompt + prompt ? '00' : seconds.replace(regExp, '0');
        }
        if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1 && hour !== undefined) {
            hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
            const hourVal = parseInt(hour, 10);
            hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
        }
        if (format.indexOf('mm') === -1 && minutes !== undefined) {
            minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
            const minutesVal = parseInt(minutes, 10);
            minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
        }
        if (format.indexOf('ss') === -1 && seconds !== undefined) {
            seconds = seconds.indexOf(prompt) !== -1 ? seconds.replace(regExp, '') : seconds;
            const secondsVal = parseInt(seconds, 10);
            seconds = !secondsVal ? '0' : secondsVal < 10 && secondsVal !== 0 ? seconds.replace('0', '') : seconds;
        }
        if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
            amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
        }
        let result = `${hour}:${minutes}:${seconds}`;
        if (!hour) {
            // remove the hours
            result = result.slice(result.indexOf(':') + 1);
        }
        if (!minutes) {
            if (hour) {
                // get the hours and seconds and concat them
                result = result.slice(0, result.indexOf(':')) +
                    result.slice(result.lastIndexOf(':'), result.length);
            }
            else {
                // remove the minutes
                result = result.slice(result.indexOf(':') + 1);
            }
        }
        if (!seconds) {
            // remove the seconds
            result = result.slice(0, result.lastIndexOf(':'));
        }
        return amPM ? `${result} ${amPM}` : result;
    }
};
TimeDisplayFormatPipe.ɵfac = function TimeDisplayFormatPipe_Factory(t) { return new (t || TimeDisplayFormatPipe)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT)); };
TimeDisplayFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "displayFormat", type: TimeDisplayFormatPipe, pure: true });
TimeDisplayFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
];
TimeDisplayFormatPipe = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], TimeDisplayFormatPipe);
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element gets focus.
 */
let TimeInputFormatPipe = class TimeInputFormatPipe {
    constructor(timePicker) {
        this.timePicker = timePicker;
    }
    transform(value) {
        const prompt = this.timePicker.promptChar;
        const regExp = new RegExp(prompt, 'g');
        let mask, hour, minutes, seconds, amPM;
        if (this.timePicker.cleared) {
            this.timePicker.cleared = false;
            mask = this.timePicker.parseMask(false);
        }
        else {
            mask = this.timePicker.parseMask();
        }
        // TODO: Pending refactoring.
        value = this.timePicker.displayValue;
        if (!value || value === mask) {
            return mask;
        }
        const sections = value.split(/[\s:]+/);
        if (this.timePicker.showHoursList) {
            hour = sections[0];
            hour = hour.replace(regExp, '');
            const leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
            hour = leadZeroHour ? '0' + hour : hour;
        }
        if (this.timePicker.showMinutesList) {
            minutes = this.timePicker.showHoursList ? sections[1] : sections[0];
            minutes = minutes.replace(regExp, '');
            const leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
            minutes = leadZeroMinutes ? '0' + minutes : minutes;
        }
        if (this.timePicker.showSecondsList) {
            seconds = sections[sections.length - (this.timePicker.showAmPmList ? 2 : 1)];
            seconds = seconds.replace(regExp, '');
            const leadZeroSeconds = (parseInt(seconds, 10) < 10 && !seconds.startsWith('0')) || seconds === '0';
            seconds = leadZeroSeconds ? '0' + seconds : seconds;
        }
        if (this.timePicker.showAmPmList) {
            amPM = sections[sections.length - 1];
        }
        let result = `${hour}:${minutes}:${seconds}`;
        if (!hour) {
            // remove the hours
            result = result.slice(result.indexOf(':') + 1);
        }
        if (!minutes) {
            if (hour) {
                // get the hours and seconds and concat them
                result = result.slice(0, result.indexOf(':')) +
                    result.slice(result.lastIndexOf(':'), result.length);
            }
            else {
                // remove the minutes
                result = result.slice(result.indexOf(':') + 1);
            }
        }
        if (!seconds) {
            // remove the seconds
            result = result.slice(0, result.lastIndexOf(':'));
        }
        return amPM ? `${result} ${amPM}` : result;
    }
};
TimeInputFormatPipe.ɵfac = function TimeInputFormatPipe_Factory(t) { return new (t || TimeInputFormatPipe)(ɵngcc0.ɵɵdirectiveInject(IGX_TIME_PICKER_COMPONENT)); };
TimeInputFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "inputFormat", type: TimeInputFormatPipe, pure: true });
TimeInputFormatPipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
];
TimeInputFormatPipe = __decorate([ __param(0, Inject(IGX_TIME_PICKER_COMPONENT))
], TimeInputFormatPipe);

var IgxTimePickerComponent_1;
let NEXT_ID$u = 0;
const ITEMS_COUNT = 7;
let TimePickerHammerConfig = class TimePickerHammerConfig extends HammerGestureConfig {
    constructor() {
        super(...arguments);
        this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
    }
};
TimePickerHammerConfig.ɵfac = function TimePickerHammerConfig_Factory(t) { return ɵTimePickerHammerConfig_BaseFactory(t || TimePickerHammerConfig); };
TimePickerHammerConfig.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TimePickerHammerConfig, factory: TimePickerHammerConfig.ɵfac });
const noop$9 = () => { };
const ɵ0$a = noop$9;
let IgxTimePickerComponent = IgxTimePickerComponent_1 = class IgxTimePickerComponent {
    constructor(_injector, _cdr) {
        this._injector = _injector;
        this._cdr = _cdr;
        /**
         * An @Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.id = `igx-time-picker-${NEXT_ID$u++}`;
        /**
         * An @Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
         * ```html
         * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.disabled = false;
        /**
         * An @Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
         * The seconds, minutes and hour spinning will wrap around by default.
         * ```html
         * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An @Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
         * ```html
         * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Sets the character used to prompt the user for input.
         * Default value is "'-'".
         * ```html
         * <igx-time-picker [promptChar] = "'_'">
         * ```
         * @memberof IgxTimePickerComponent
         */
        this.promptChar = '-';
        /**
         * An @Input property that allows you to switch the interaction mode between
         * a dialog picker or dropdown with editable masked input.
         * Deafult is dialog picker.
         * ```html
         * public mode = InteractionMode.DROPDOWN;
         *  //..
         * <igx-time-picker [mode]="mode"></igx-time-picker>
         * ```
         * @memberof IgxTimePickerComponent
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
         * ```typescript
         *  @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValueChanged(timepicker){
         *     this.toast.show()
         * }
         *  //...
         *  ```
         *  ```html
         * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
         * <igx-toast #toast message="The value has been changed!"></igx-toast>
         * ```
         */
        this.onValueChanged = new EventEmitter();
        /**
         * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
         * ```typescript
         * public min: string = "09:00";
         * public max: string = "18:00";
         *  @ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValidationFailed(timepicker){
         *     this.toast.show();
         * }
         *  //...
         *  ```
         *  ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
         * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /**
         * Emitted when a timePicker is opened.
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted when a timePicker is closed.
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted when a timePicker is being closed.
         */
        this.onClosing = new EventEmitter();
        /**
         * @hidden
         */
        this._hourItems = [];
        /**
         * @hidden
         */
        this._minuteItems = [];
        /**
         * @hidden
         */
        this._secondsItems = [];
        /**
         * @hidden
         */
        this._ampmItems = [];
        /**
         * @hidden
         */
        this.cleared = false;
        /**
         * @hidden
         */
        this.isNotEmpty = false;
        /**
         * @hidden
         */
        this.displayFormat = new TimeDisplayFormatPipe(this);
        /**
         * @hidden
         */
        this.inputFormat = new TimeInputFormatPipe(this);
        this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
        this._okButtonLabel = null;
        this._cancelButtonLabel = null;
        this._itemsDelta = { hours: 1, minutes: 1, seconds: 1 };
        this._isHourListLoop = this.isSpinLoop;
        this._isMinuteListLoop = this.isSpinLoop;
        this._isSecondsListLoop = this.isSpinLoop;
        this._hourView = [];
        this._minuteView = [];
        this._secondsView = [];
        this._ampmView = [];
        this._destroy$ = new Subject();
        this._onOpen = new EventEmitter();
        this._onClose = new EventEmitter();
        this._hoursPos = new Set();
        this._minutesPos = new Set();
        this._secondsPos = new Set();
        this._amPmPos = new Set();
        this._ngControl = null;
        //#region ControlValueAccessor
        this._onChangeCallback = noop$9;
        this._onTouchedCallback = noop$9;
    }
    /**
     * An accessor that allows you to set a time using the `value` input.
     * ```html
     * public date: Date = new Date(Date.now());
     *  //...
     * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set value(value) {
        if (this._isValueValid(value)) {
            const oldVal = this._value;
            this._value = value;
            this._onChangeCallback(value);
            const dispVal = this._formatTime(this.value, this.format);
            if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
                this.displayValue = dispVal;
            }
            const args = {
                oldValue: oldVal,
                newValue: value
            };
            this.onValueChanged.emit(args);
        }
        else {
            const args = {
                timePicker: this,
                currentValue: value,
                setThroughUI: false
            };
            this.onValidationFailed.emit(args);
        }
    }
    /**
     * An accessor that returns the value of `igx-time-picker` component.
     * ```html
     * @ViewChild("MyPick")
     * public pick: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let pickSelect = this.pick.value;
     * }
     * ```
     */
    get value() {
        return this._value;
    }
    /**
     * An accessor that sets the resource strings.
     * By default it uses EN resources.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
     * ```html
     * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set okButtonLabel(value) {
        this._okButtonLabel = value;
    }
    /**
     * An accessor that returns the label of ok button.
     */
    get okButtonLabel() {
        if (this._okButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_ok;
        }
        return this._okButtonLabel;
    }
    /**
     * An @Input property that renders cancel button with custom text.
     * By default `cancelButtonLabel` is set to Cancel.
     * ```html
     * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
     * ```
     */
    set cancelButtonLabel(value) {
        this._cancelButtonLabel = value;
    }
    /**
     * An accessor that returns the label of cancel button.
     */
    get cancelButtonLabel() {
        if (this._cancelButtonLabel === null) {
            return this.resourceStrings.igx_time_picker_cancel;
        }
        return this._cancelButtonLabel;
    }
    /**
     * An @Input property that gets/sets the delta by which hour and minute items would be changed <br>
     * when the user presses the Up/Down keys.
     * By default `itemsDelta` is set to `{hours: 1, minutes: 1, seconds: 1}`
     * ```html
     * <igx-time-picker [itemsDelta]="{hours:3, minutes:5, seconds:10}" id="time-picker"></igx-time-picker>
     * ```
     */
    set itemsDelta(value) {
        this._itemsDelta = Object.assign({ hours: 1, minutes: 1, seconds: 1 }, value);
    }
    get itemsDelta() {
        return this._itemsDelta;
    }
    /**
     * An @Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
     * By default `format` is set to hh:mm tt. <br>
     * List of time-flags: <br>
     * `h` : hours field in 12-hours format without leading zero <br>
     * `hh` : hours field in 12-hours format with leading zero <br>
     * `H` : hours field in 24-hours format without leading zero <br>
     * `HH` : hours field in 24-hours format with leading zero <br>
     * `m` : minutes field without leading zero <br>
     * `mm` : minutes field with leading zero <br>
     * `s` : seconds field without leading zero <br>
     * `ss` : seconds field with leading zero <br>
     * `tt` : 2 character string which represents AM/PM field <br>
     * ```html
     * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
     * ```
     */
    get format() {
        return this._format || 'hh:mm tt';
    }
    set format(formatValue) {
        this._format = formatValue;
        this.mask = this._format.indexOf('tt') !== -1 ? '00:00:00 LL' : '00:00:00';
        if (!this.showHoursList || !this.showMinutesList) {
            this.trimMask();
        }
        if (!this.showSecondsList) {
            this.trimMask();
        }
        if (this.displayValue) {
            this.displayValue = this._formatTime(this.value, this._format);
        }
        this.determineCursorPos();
    }
    /**
     * An @Input property that allows you to modify overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: true,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <igx-time-picker [overlaySettings]="settings"></igx-time-picker>
     * ```
     * @memberof IgxTimePickerComponent
     */
    set overlaySettings(value) {
        this._overlaySettings = value;
    }
    get overlaySettings() {
        return this._overlaySettings ? this._overlaySettings :
            (this.mode === InteractionMode.Dialog ? this._dialogOverlaySettings : this._dropDownOverlaySettings);
    }
    /** @hidden @internal */
    writeValue(value) {
        // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
        // against the real value when initializing the component and value is bound via ngModel
        this._dateFromModel = value;
        this._value = value;
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
        }
    }
    /** @hidden @internal */
    registerOnChange(fn) { this._onChangeCallback = fn; }
    /** @hidden @internal */
    registerOnTouched(fn) { this._onTouchedCallback = fn; }
    /** @hidden @internal */
    setDisabledState(isDisabled) { this.disabled = isDisabled; }
    //#endregion
    trimMask() {
        this.mask = this.mask.slice(this.mask.indexOf(':') + 1, this.mask.length);
    }
    /**
     * @hidden
     */
    get mask() {
        return this._mask || '00:00 LL';
    }
    set mask(val) {
        this._mask = val;
    }
    /**
     * @hidden
     */
    get displayValue() {
        if (this._displayValue === undefined) {
            return this._formatTime(this.value, this.format);
        }
        return this._displayValue;
    }
    set displayValue(value) {
        this._displayValue = value;
    }
    /**
     * Returns the current time formatted as string using the `format` option.
     * If there is no set time the return is an empty string.
     * ```typescript
     * @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let time = this.picker.displayTime;
     * }
     * ```
     */
    get displayTime() {
        if (this.value) {
            return this._formatTime(this.value, this.format);
        }
        return '';
    }
    /**
     * @hidden
     */
    get hourView() {
        return this._hourView;
    }
    /**
     * @hidden
     */
    get minuteView() {
        return this._minuteView;
    }
    /**
     * @hidden
     */
    get secondsView() {
        return this._secondsView;
    }
    /**
     * @hidden
     */
    get ampmView() {
        return this._ampmView;
    }
    /**
     * @hidden
     */
    get showClearButton() {
        return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
    }
    /**
     * @hidden
     */
    get showHoursList() {
        return this.format.indexOf('h') !== -1 || this.format.indexOf('H') !== -1;
    }
    /**
     * @hidden
     */
    get showMinutesList() {
        return this.format.indexOf('m') !== -1;
    }
    /**
     * @hidden
     */
    get showSecondsList() {
        return this.format.indexOf('s') !== -1;
    }
    /**
     * @hidden
     */
    get showAmPmList() {
        return this.format.indexOf('t') !== -1;
    }
    /**
     * @hidden
     */
    get validSecondsEntries() {
        const secondsEntries = [];
        for (let i = 0; i < 60; i++) {
            secondsEntries.push(i);
        }
        return secondsEntries;
    }
    /**
     * @hidden
     */
    get validMinuteEntries() {
        const minuteEntries = [];
        for (let i = 0; i < 60; i++) {
            minuteEntries.push(i);
        }
        return minuteEntries;
    }
    /**
     * @hidden
     */
    get validHourEntries() {
        const hourEntries = [];
        const index = this.format.indexOf('h') !== -1 ? 13 : 24;
        for (let i = 0; i < index; i++) {
            hourEntries.push(i);
        }
        return hourEntries;
    }
    /**
     * Gets the input group template.
     * ```typescript
     * let template = this.template();
     * ```
     * @memberof IgxTimePickerComponent
     */
    get template() {
        if (this.timePickerTemplateDirective) {
            return this.timePickerTemplateDirective.template;
        }
        return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
    }
    /**
     * Gets the context passed to the input group template.
     * @memberof IgxTimePickerComponent
     */
    get context() {
        return {
            value: this.value,
            displayTime: this.displayTime,
            displayValue: this.displayValue,
            openDialog: (target) => this.openDialog(target)
        };
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            // Run the validation with empty object to check if required is enabled.
            const error = this._ngControl.control.validator({});
            return error && error.required;
        }
        return false;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this._generateHours();
        this._generateMinutes();
        this._generateSeconds();
        if (this.format.indexOf('tt') !== -1) {
            this._generateAmPm();
        }
        this._dropDownOverlaySettings = {
            modal: false,
            closeOnOutsideClick: true,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy()
        };
        this._dialogOverlaySettings = {};
        this._ngControl = this._injector.get(NgControl, null);
    }
    /**
     * @hidden
     */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown && this._inputElementRef) {
            fromEvent(this._inputElementRef.nativeElement, 'keydown').pipe(throttle(() => interval(0, animationFrameScheduler)), takeUntil(this._destroy$)).subscribe((event) => {
                if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                    event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                    this.spinOnEdit(event);
                }
            });
        }
        if (this.toggleRef && this._inputGroup) {
            this.toggleRef.element.style.width = this._inputGroup.element.nativeElement.getBoundingClientRect().width + 'px';
        }
        if (this.toggleRef) {
            this.toggleRef.onClosed.pipe(takeUntil(this._destroy$)).subscribe(() => {
                if (this.mode === InteractionMode.DropDown) {
                    this._onDropDownClosed();
                }
                this.onClosed.emit(this);
            });
            this.toggleRef.onOpened.pipe(takeUntil(this._destroy$)).subscribe(() => {
                this.onOpened.emit(this);
            });
            this.toggleRef.onClosing.pipe(takeUntil(this._destroy$)).subscribe((event) => {
                this.onClosing.emit(event);
                // If canceled in a user onClosing handler
                if (event.cancel) {
                    return;
                }
                // Do not focus the input if clicking outside in dropdown mode
                const input = this.getEditElement();
                if (input && !(event.event && this.mode === InteractionMode.DropDown)) {
                    input.focus();
                }
                else {
                    this._updateValidityOnBlur();
                }
            });
            this.determineCursorPos();
            if (this._ngControl) {
                this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
            }
        }
    }
    ngAfterViewChecked() {
        // if one sets mode at run time this forces initialization of new igxInputGroup
        // As a result a new igxInputDirective is initialized too. In ngAfterViewInit of
        // the new directive isRequired of the igxInputGroup is set again. However
        // ngAfterViewInit of the time picker is not called again and we may finish with wrong
        // isRequired in igxInputGroup. This is why we should set it her, only when needed
        if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
            this._inputGroup.isRequired = this.required;
            this._cdr.detectChanges();
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this._destroy$.next(true);
        this._destroy$.complete();
    }
    /**
     * @hidden
     */
    onKeydownSpace(event) {
        this.openDialog(this.getInputGroupElement());
        event.preventDefault();
    }
    /**
     * @hidden
     */
    onAltArrowDown() {
        this.openDialog(this.getInputGroupElement());
    }
    determineCursorPos() {
        this.clearCursorPos();
        for (const char of this.format) {
            switch (char) {
                case 'H':
                case 'h':
                    this._hoursPos.size === 0 ? this._hoursPos.add(this.format.indexOf(char)) :
                        this._hoursPos.add(this.format.lastIndexOf(char));
                    this._hoursPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'M':
                case 'm':
                    this._minutesPos.size === 0 ? this._minutesPos.add(this.format.indexOf(char)) :
                        this._minutesPos.add(this.format.lastIndexOf(char));
                    this._minutesPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'S':
                case 's':
                    this._secondsPos.size === 0 ? this._secondsPos.add(this.format.indexOf(char)) :
                        this._secondsPos.add(this.format.lastIndexOf(char));
                    this._secondsPos.add(this.format.lastIndexOf(char) + 1);
                    break;
                case 'T':
                case 't':
                    this._amPmPos.size === 0 ? this._amPmPos.add(this.format.indexOf(char)) :
                        this._amPmPos.add(this.format.lastIndexOf(char));
                    this._amPmPos.add(this.format.lastIndexOf(char) + 1);
                    break;
            }
        }
    }
    clearCursorPos() {
        this._hoursPos.forEach(v => this._hoursPos.delete(v));
        this._minutesPos.forEach(v => this._minutesPos.delete(v));
        this._secondsPos.forEach(v => this._secondsPos.delete(v));
        this._amPmPos.forEach(v => this._amPmPos.delete(v));
    }
    _scrollItemIntoView(item, items, selectedItem, isListLoop, viewType) {
        let itemIntoView;
        if (items) {
            const index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
            let view;
            if (index !== -1) {
                if (isListLoop) {
                    if (index > 0) {
                        selectedItem = this._itemToString(items[index - 1], viewType);
                        itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                    }
                    else {
                        selectedItem = this._itemToString(items[1], viewType);
                        itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                    }
                }
                else {
                    view = items.slice(index - 3, index + 4);
                    selectedItem = this._itemToString(items[index], viewType);
                    itemIntoView = { selectedItem, view };
                }
                itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
            }
        }
        return itemIntoView;
    }
    _viewToString(view, viewType) {
        for (let i = 0; i < view.length; i++) {
            if (typeof (view[i]) !== 'string') {
                view[i] = this._itemToString(view[i], viewType);
            }
        }
        return view;
    }
    _itemToString(item, viewType) {
        if (item === null) {
            item = '';
        }
        else if (viewType && typeof (item) !== 'string') {
            const leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
            const leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
            const leadZeroSeconds = (item < 10 && this.format.indexOf('ss') !== -1);
            const leadZero = {
                hour: leadZeroHour,
                minute: leadZeroMinute,
                seconds: leadZeroSeconds
            }[viewType];
            item = (leadZero) ? '0' + item : `${item}`;
        }
        return item;
    }
    _prevItem(items, selectedItem, isListLoop, viewType) {
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        const itemsCount = items.length;
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex - 4 < 0) {
                view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3));
            }
            else if (selectedIndex + 4 > itemsCount) {
                view = items.slice(selectedIndex - 4, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
            }
            selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
        }
        else if (selectedIndex > 3) {
            view = items.slice(selectedIndex - 4, selectedIndex + 3);
            selectedItem = items[selectedIndex - 1];
        }
        else if (selectedIndex === 3) {
            view = items.slice(0, 7);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    _nextItem(items, selectedItem, isListLoop, viewType) {
        const selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        const itemsCount = items.length;
        let view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex < 2) {
                view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5));
            }
            else if (selectedIndex + 4 >= itemsCount) {
                view = items.slice(selectedIndex - 2, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
            }
            selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
        }
        else if (selectedIndex + 1 < itemsCount - 3) {
            view = items.slice(selectedIndex - 2, selectedIndex + 5);
            selectedItem = items[selectedIndex + 1];
        }
        else if (selectedIndex === itemsCount - 4) {
            view = items.slice(selectedIndex - 3, itemsCount);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem,
            view
        };
    }
    _formatTime(value, format) {
        if (!value) {
            return '';
        }
        else {
            let hour = value.getHours();
            let formattedSeconds, formattedMinute, formattedHour;
            const minute = value.getMinutes();
            const seconds = value.getSeconds();
            const amPM = (hour > 11) ? 'PM' : 'AM';
            if (format.indexOf('h') !== -1) {
                if (hour > 12) {
                    hour -= 12;
                    formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : `${hour}`;
                }
                else if (hour === 0) {
                    formattedHour = '12';
                }
                else if (hour < 10 && format.indexOf('hh') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            else {
                if (hour < 10 && format.indexOf('HH') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = `${hour}`;
                }
            }
            formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : `${minute}`;
            formattedSeconds = seconds < 10 && format.indexOf('ss') !== -1 ? '0' + seconds : `${seconds}`;
            return format.replace('hh', formattedHour).replace('h', formattedHour)
                .replace('HH', formattedHour).replace('H', formattedHour)
                .replace('mm', formattedMinute).replace('m', formattedMinute)
                .replace('ss', formattedSeconds).replace('s', formattedSeconds)
                .replace('tt', amPM);
        }
    }
    _updateHourView(start, end) {
        this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
    }
    _updateMinuteView(start, end) {
        this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
    }
    _updateSecondsView(start, end) {
        this._secondsView = this._viewToString(this._secondsItems.slice(start, end), 'seconds');
    }
    _updateAmPmView(start, end) {
        this._ampmView = this._ampmItems.slice(start, end);
    }
    _addEmptyItems(items) {
        for (let i = 0; i < 3; i++) {
            items.push(null);
        }
    }
    _generateHours() {
        let hourItemsCount = 24;
        if (this.format.indexOf('h') !== -1) {
            hourItemsCount = 13;
        }
        hourItemsCount /= this.itemsDelta.hours;
        let i = this.format.indexOf('H') !== -1 ? 0 : 1;
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
            this._isHourListLoop = false;
        }
        if (hourItemsCount > 1) {
            for (i; i < hourItemsCount; i++) {
                this._hourItems.push(i * this.itemsDelta.hours);
            }
        }
        else {
            this._hourItems.push(0);
        }
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
        }
    }
    _generateMinutes() {
        const minuteItemsCount = 60 / this.itemsDelta.minutes;
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
            this._isMinuteListLoop = false;
        }
        for (let i = 0; i < minuteItemsCount; i++) {
            this._minuteItems.push(i * this.itemsDelta.minutes);
        }
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
        }
    }
    _generateSeconds() {
        const secondsItemsCount = 60 / this.itemsDelta.seconds;
        if (secondsItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._secondsItems);
            this._isSecondsListLoop = false;
        }
        for (let i = 0; i < secondsItemsCount; i++) {
            this._secondsItems.push(i * this.itemsDelta.seconds);
        }
        if (secondsItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._secondsItems);
        }
    }
    _generateAmPm() {
        this._addEmptyItems(this._ampmItems);
        this._ampmItems.push('AM');
        this._ampmItems.push('PM');
        this._addEmptyItems(this._ampmItems);
    }
    _getSelectedTime() {
        const date = this.value ? new Date(this.value) : new Date();
        if (this.selectedHour) {
            date.setHours(parseInt(this.selectedHour, 10));
        }
        if (this.selectedMinute) {
            date.setMinutes(parseInt(this.selectedMinute, 10));
        }
        if (this.selectedSeconds) {
            date.setSeconds(parseInt(this.selectedSeconds, 10));
        }
        if (((this.showHoursList && this.selectedHour !== '12') || (!this.showHoursList && this.selectedHour <= '11')) &&
            this.selectedAmPm === 'PM') {
            date.setHours(date.getHours() + 12);
        }
        if (!this.showHoursList && this.selectedAmPm === 'AM' && this.selectedHour > '11') {
            date.setHours(date.getHours() - 12);
        }
        if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
            date.setHours(0);
        }
        return date;
    }
    _convertMinMaxValue(value) {
        const date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
        const sections = value.split(/[\s:]+/);
        let hour, minutes, seconds, amPM;
        date.setSeconds(0);
        if (this.showHoursList) {
            hour = sections[0];
            date.setHours(parseInt(hour, 10));
        }
        if (this.showMinutesList) {
            minutes = this.showHoursList ? sections[1] : sections[0];
            date.setMinutes(parseInt(minutes, 10));
        }
        if (this.showSecondsList) {
            seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            date.setSeconds(parseInt(seconds, 10));
        }
        if (this.showAmPmList) {
            amPM = sections[sections.length - 1];
            if (((this.showHoursList && date.getHours().toString() !== '12') ||
                (!this.showHoursList && date.getHours().toString() <= '11')) && amPM === 'PM') {
                date.setHours(date.getHours() + 12);
            }
            if (!this.showHoursList && amPM === 'AM' && date.getHours().toString() > '11') {
                date.setHours(date.getHours() - 12);
            }
            if (this.showHoursList && date.getHours() === 12 && amPM === 'AM') {
                date.setHours(0);
            }
        }
        return date;
    }
    _isValueValid(value) {
        if (this.maxValue && value > this._convertMinMaxValue(this.maxValue)) {
            return false;
        }
        else if (this.minValue && value < this._convertMinMaxValue(this.minValue)) {
            return false;
        }
        else {
            return true;
        }
    }
    _isEntryValid(val) {
        let validH = true;
        let validM = true;
        let validS = true;
        const sections = val.split(/[\s:]+/);
        const re = new RegExp(this.promptChar, 'g');
        if (this.showHoursList) {
            validH = this.validHourEntries.indexOf(parseInt(sections[0].replace(re, ''), 10)) !== -1;
        }
        if (this.showMinutesList) {
            const minutes = this.showHoursList ? sections[1] : sections[0];
            validM = this.validMinuteEntries.indexOf(parseInt(minutes.replace(re, ''), 10)) !== -1;
        }
        if (this.showSecondsList) {
            const seconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            validS = this.validSecondsEntries.indexOf(parseInt(seconds.replace(re, ''), 10)) !== -1;
        }
        return validH && validM && validS;
    }
    _getCursorPosition() {
        return this._inputElementRef.nativeElement.selectionStart;
    }
    _setCursorPosition(start, end = start) {
        this._inputElementRef.nativeElement.setSelectionRange(start, end);
    }
    _updateEditableInput() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
        }
    }
    _spinHours(currentVal, minVal, maxVal, hDelta, sign) {
        const oldVal = new Date(currentVal);
        currentVal.setMinutes(sign * hDelta);
        if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
            currentVal.setDate(oldVal.getDate());
        }
        let minutes = currentVal.getMinutes();
        if (currentVal.getTime() > maxVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                minVal.setMinutes(sign * minutes);
                return minVal;
            }
            else {
                return oldVal;
            }
        }
        else if (currentVal.getTime() < minVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                maxVal.setMinutes(minutes);
                return maxVal;
            }
            else {
                return oldVal;
            }
        }
        else {
            return currentVal;
        }
    }
    _spinMinutes(currentVal, mDelta, sign) {
        let minutes = currentVal.getMinutes() + (sign * mDelta);
        if (minutes < 0 || minutes >= 60) {
            minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
        }
        currentVal.setMinutes(minutes);
        return currentVal;
    }
    _spinSeconds(currentVal, sDelta, sign) {
        let seconds = currentVal.getSeconds() + (sign * sDelta);
        if (seconds < 0 || seconds >= 60) {
            seconds = this.isSpinLoop ? seconds - (sign * 60) : currentVal.getSeconds();
        }
        currentVal.setSeconds(seconds);
        return currentVal;
    }
    _initializeContainer() {
        if (this.value) {
            const formttedTime = this._formatTime(this.value, this.format);
            const sections = formttedTime.split(/[\s:]+/);
            if (this.showHoursList) {
                this.selectedHour = sections[0];
            }
            if (this.showMinutesList) {
                this.selectedMinute = this.showHoursList ? sections[1] : sections[0];
            }
            if (this.showSecondsList) {
                this.selectedSeconds = sections[sections.length - (this.showAmPmList ? 2 : 1)];
            }
            if (this.showAmPmList && this._ampmItems !== null) {
                this.selectedAmPm = sections[sections.length - 1];
            }
        }
        if (this.selectedHour === undefined) {
            this.selectedHour = !this.showHoursList && this.value ? this.value.getHours().toString() :
                this.showHoursList ? `${this._hourItems[3]}` : '0';
        }
        if (this.selectedMinute === undefined) {
            this.selectedMinute = !this.showMinutesList && this.value ? this.value.getMinutes().toString() : '0';
        }
        if (this.selectedSeconds === undefined) {
            this.selectedSeconds = !this.showSecondsList && this.value ? this.value.getSeconds().toString() : '0';
        }
        if (this.selectedAmPm === undefined && this._ampmItems !== null) {
            this.selectedAmPm = this._ampmItems[3];
        }
        this._prevSelectedHour = this.selectedHour;
        this._prevSelectedMinute = this.selectedMinute;
        this._prevSelectedSeconds = this.selectedSeconds;
        this._prevSelectedAmPm = this.selectedAmPm;
        this._onTouchedCallback();
        this._updateHourView(0, ITEMS_COUNT);
        this._updateMinuteView(0, ITEMS_COUNT);
        this._updateSecondsView(0, ITEMS_COUNT);
        this._updateAmPmView(0, ITEMS_COUNT);
        if (this.selectedHour) {
            this.scrollHourIntoView(this.selectedHour);
        }
        if (this.selectedMinute) {
            this.scrollMinuteIntoView(this.selectedMinute);
        }
        if (this.selectedSeconds) {
            this.scrollSecondsIntoView(this.selectedSeconds);
        }
        if (this.selectedAmPm) {
            this.scrollAmPmIntoView(this.selectedAmPm);
        }
        requestAnimationFrame(() => {
            if (this.hourList) {
                this.hourList.nativeElement.focus();
            }
            else if (this.minuteList) {
                this.minuteList.nativeElement.focus();
            }
            else if (this.secondsList) {
                this.secondsList.nativeElement.focus();
            }
        });
    }
    _onDropDownClosed() {
        const oldValue = this.value;
        const newVal = this._convertMinMaxValue(this.displayValue);
        if (this.displayValue === this.parseMask(false)) {
            return;
        }
        if (this._isValueValid(newVal)) {
            if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                this.value = newVal;
            }
        }
        else {
            this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
            const args = {
                timePicker: this,
                currentValue: newVal,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
        }
    }
    onStatusChanged() {
        if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
            (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
            const input = this._inputDirective || this._inputDirectiveUserTemplate;
            if (this._inputGroup.isFocused) {
                input.valid = this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
            }
            else {
                input.valid = this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
        }
        if (this._inputGroup && this._inputGroup.isRequired !== this.required) {
            this._inputGroup.isRequired = this.required;
        }
    }
    /**
     * @hidden
     */
    getEditElement() {
        return this._inputElementRef ? this._inputElementRef.nativeElement : null;
    }
    /**
     * @hidden
     */
    getInputGroupElement() {
        return this._inputGroup ? this._inputGroup.element.nativeElement : null;
    }
    /**
     * opens the dialog.
     * @param target HTMLElement - the target element to use for positioning the drop down container according to
     * ```html
     * <igx-time-picker [value]="date" mode="dropdown" #retemplated>
     *   <ng-template igxTimePickerTemplate let-openDialog="openDialog"
     *                let-displayTime="displayTime">
     *     <igx-input-group>
     *       <input #dropDownTarget igxInput [value]="displayTime" />
     *       <igx-suffix (click)="openDialog(dropDownTarget)">
     *         <igx-icon>alarm</igx-icon>
     *       </igx-suffix>
     *     </igx-input-group>
     *   </ng-template>
     * </igx-time-picker>
     * ```
     */
    openDialog(target) {
        if (!this.toggleRef.collapsed) {
            return this._onDropDownClosed();
        }
        const settings = this.overlaySettings;
        if (target && settings && settings.positionStrategy) {
            settings.positionStrategy.settings.target = target;
        }
        if (this.outlet) {
            settings.outlet = this.outlet;
        }
        this.toggleRef.open(settings);
        this._initializeContainer();
    }
    /**
     * Scrolls a hour item into view.
     * ```typescript
     * scrhintoView(picker) {
     * picker.scrollHourIntoView('2');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrhintoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollHourIntoView(item) {
        if (this.showHoursList) {
            const hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
            if (hourIntoView) {
                this._hourView = hourIntoView.view;
                this.selectedHour = hourIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a minute item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollMinuteIntoView('3');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollMinuteIntoView(item) {
        if (this.showMinutesList) {
            const minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
            if (minuteIntoView) {
                this._minuteView = minuteIntoView.view;
                this.selectedMinute = minuteIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls a seconds item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollSecondsIntoView('4');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollSecondsIntoView(item) {
        if (this.showSecondsList) {
            const secondsIntoView = this._scrollItemIntoView(item, this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
            if (secondsIntoView) {
                this._secondsView = secondsIntoView.view;
                this.selectedSeconds = secondsIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * Scrolls an ampm item into view.
     * ```typescript
     * scrAmPmIntoView(picker) {
     * picker.scrollAmPmIntoView('PM');
     * }
     *  ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpened)="scrAmPmIntoView(picker)"></igx-time-picker>
     * ```
     * @param item to be scrolled in view.
     */
    scrollAmPmIntoView(item) {
        if (this.showAmPmList) {
            const ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
            if (ampmIntoView) {
                this._ampmView = ampmIntoView.view;
                this.selectedAmPm = ampmIntoView.selectedItem;
                this._updateEditableInput();
            }
        }
    }
    /**
     * @hidden
     */
    nextHour() {
        const nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = nextHour.view;
        this.selectedHour = nextHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevHour() {
        const prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = prevHour.view;
        this.selectedHour = prevHour.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextMinute() {
        const nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = nextMinute.view;
        this.selectedMinute = nextMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevMinute() {
        const prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = prevMinute.view;
        this.selectedMinute = prevMinute.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextSeconds() {
        const nextSeconds = this._nextItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
        this._secondsView = nextSeconds.view;
        this.selectedSeconds = nextSeconds.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    prevSeconds() {
        const prevSeconds = this._prevItem(this._secondsItems, this.selectedSeconds, this._isSecondsListLoop, 'seconds');
        this._secondsView = prevSeconds.view;
        this.selectedSeconds = prevSeconds.selectedItem;
        this._updateEditableInput();
    }
    /**
     * @hidden
     */
    nextAmPm() {
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex + 1 < this._ampmItems.length - 3) {
            this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
            this.selectedAmPm = this._ampmItems[selectedIndex + 1];
            this._updateEditableInput();
        }
    }
    /**
     * @hidden
     */
    prevAmPm() {
        const selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex > 3) {
            this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
            this.selectedAmPm = this._ampmItems[selectedIndex - 1];
            this._updateEditableInput();
        }
    }
    /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     */
    okButtonClick() {
        const time = this._getSelectedTime();
        if (this._isValueValid(time)) {
            this.close();
            this.value = time;
            return true;
        }
        else {
            const args = {
                timePicker: this,
                currentValue: time,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
            return false;
        }
    }
    /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     */
    cancelButtonClick() {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this.value ? this._formatTime(this.value, this.format) : this.parseMask(false);
        }
        this.close();
        this.selectedHour = this._prevSelectedHour;
        this.selectedMinute = this._prevSelectedMinute;
        this.selectedSeconds = this._prevSelectedSeconds;
        this.selectedAmPm = this._prevSelectedAmPm;
    }
    /**
     * Returns an array of the hours currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let hInView = this.picker.hoursInView;
     * }
     * ```
     */
    hoursInView() {
        return this._hourView.filter((hour) => hour !== '');
    }
    /**
     * Returns an array of the minutes currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let minInView = this.picker.minutesInView;
     * }
     * ```
     */
    minutesInView() {
        return this._minuteView.filter((minute) => minute !== '');
    }
    /**
     * Returns an array of the seconds currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let minInView = this.picker.secondsInView;
     * }
     * ```
     */
    secondsInView() {
        return this._secondsView.filter((seconds) => seconds !== '');
    }
    /**
     * Returns an array of the AM/PM currently in view.
     * ```html
     *  @ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *     let ApInView = this.picker.ampmInView;
     * }
     * ```
     */
    ampmInView() {
        return this._ampmView.filter((ampm) => ampm !== '');
    }
    /**
     * Closes the dropdown/dialog.
     * ```html
     * <igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.close();
     * ```
     */
    close() {
        this.toggleRef.close();
    }
    /**
     * @hidden
     */
    parseMask(preserveAmPm = true) {
        const maskWithAmPm = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace('LL', 'AM');
        const pureMask = this.mask.replace(new RegExp('0', 'g'), this.promptChar).replace(new RegExp('L', 'g'), this.promptChar);
        return preserveAmPm ? maskWithAmPm : pureMask;
    }
    /**
     * @hidden
     */
    clear() {
        if (this.toggleRef.collapsed) {
            this.cleared = true;
            this.isNotEmpty = false;
            const oldVal = new Date(this.value);
            this.displayValue = '';
            this.value.setHours(0, 0);
            if (oldVal.getTime() !== this.value.getTime()) {
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
        else {
            this.close();
        }
    }
    /**
     * @hidden
     */
    onInput(event) {
        const val = event.target.value;
        const oldVal = new Date(this.value);
        this.isNotEmpty = val !== this.parseMask(false);
        // handle cases where all empty positions (promts) are filled and we want to update
        // timepicker own value property if it is a valid Date
        if (val.indexOf(this.promptChar) === -1) {
            if (this._isEntryValid(val)) {
                const newVal = this._convertMinMaxValue(val);
                if (oldVal.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                const args = {
                    timePicker: this,
                    currentValue: val,
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
            // handle cases where the user deletes the display value (when pressing backspace or delete)
        }
        else if (!this.value || !val || val === this.parseMask(false)) {
            this.isNotEmpty = false;
            this.value.setHours(0, 0);
            this.displayValue = val;
            if (oldVal.getTime() !== this.value.getTime()) {
                const args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
    }
    /**
     * @hidden
     */
    onFocus(event) {
        this.isNotEmpty = event.target.value !== this.parseMask(false);
    }
    /**
     * @hidden
     */
    onBlur(event) {
        if (this.mode === InteractionMode.DropDown) {
            const value = event.target.value;
            this.isNotEmpty = value !== '';
            this.displayValue = value;
            if (value && value !== this.parseMask()) {
                if (this._isEntryValid(value)) {
                    const newVal = this._convertMinMaxValue(value);
                    if (!this.value || this.value.getTime() !== newVal.getTime()) {
                        this.value = newVal;
                    }
                }
                else {
                    const args = {
                        timePicker: this,
                        currentValue: value,
                        setThroughUI: false
                    };
                    this.onValidationFailed.emit(args);
                }
            }
        }
        if (this.toggleRef.collapsed) {
            this._updateValidityOnBlur();
        }
    }
    mouseDown(event) {
        // if the click is not on the input but in input group
        // e.g. on prefix or suffix, prevent default and this way prevent blur
        if (event.target !== this.getEditElement()) {
            event.preventDefault();
        }
    }
    /**
     * @hidden
     */
    spinOnEdit(event) {
        event.preventDefault();
        let sign;
        let displayVal;
        const currentVal = new Date(this.value);
        const min = this.minValue ? this._convertMinMaxValue(this.minValue) : this._convertMinMaxValue('00:00');
        const max = this.maxValue ? this._convertMinMaxValue(this.maxValue) : this._convertMinMaxValue('24:00');
        const cursor = this._getCursorPosition();
        if (event.key) {
            const key = event.key;
            sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
        }
        if (event.deltaY) {
            sign = event.deltaY < 0 ? 1 : -1;
        }
        if (!this.displayValue) {
            this.value = min;
            displayVal = this._formatTime(this.value, this.format);
        }
        else {
            const hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
            const mDelta = this.itemsDelta.minutes;
            const sDelta = this.itemsDelta.seconds;
            if (this.cursorOnHours(cursor, this.showHoursList)) {
                this.value = this._spinHours(currentVal, min, max, hDelta, sign);
            }
            if (this.cursorOnMinutes(cursor, this.showHoursList, this.showMinutesList)) {
                this.value = this._spinMinutes(currentVal, mDelta, sign);
            }
            if (this.cursorOnSeconds(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList)) {
                this.value = this._spinSeconds(currentVal, sDelta, sign);
            }
            if (this.cursorOnAmPm(cursor, this.showHoursList, this.showMinutesList, this.showSecondsList, this.showAmPmList)) {
                const sections = this.displayValue.split(/[\s:]+/);
                sign = sections[sections.length - 1] === 'AM' ? 1 : -1;
                currentVal.setHours(currentVal.getHours() + (sign * 12));
                this.value = currentVal;
            }
            displayVal = this._formatTime(this.value, this.format);
        }
        // minor hack for preventing cursor jumping in IE
        this._displayValue = this.inputFormat.transform(displayVal);
        this._inputElementRef.nativeElement.value = this._displayValue;
        this._setCursorPosition(cursor);
        requestAnimationFrame(() => {
            this._setCursorPosition(cursor);
        });
    }
    cursorOnHours(cursor, showHours) {
        return showHours && this._hoursPos.has(cursor);
    }
    cursorOnMinutes(cursor, showHours, showMinutes) {
        return showMinutes &&
            (showHours && this._minutesPos.has(cursor)) ||
            (!showHours && this._minutesPos.has(cursor));
    }
    cursorOnSeconds(cursor, showHours, showMinutes, showSeconds) {
        return showSeconds &&
            (showHours && showMinutes && this._secondsPos.has(cursor)) ||
            ((!showHours || !showMinutes) && this._secondsPos.has(cursor)) ||
            (!showHours && !showMinutes && this._secondsPos.has(cursor));
    }
    cursorOnAmPm(cursor, showHours, showMinutes, showSeconds, showAmPm) {
        return showAmPm &&
            (showHours && showMinutes && showSeconds && this._amPmPos.has(cursor)) ||
            ((!showHours || !showMinutes || !showSeconds) && this._amPmPos.has(cursor)) ||
            (!showHours && (!showMinutes || !showSeconds) && this._amPmPos.has(cursor));
    }
    _updateValidityOnBlur() {
        this._onTouchedCallback();
        const input = this._inputDirective || this._inputDirectiveUserTemplate;
        if (this._ngControl && !this._ngControl.valid) {
            input.valid = IgxInputState.INVALID;
        }
        else {
            input.valid = IgxInputState.INITIAL;
        }
    }
};
IgxTimePickerComponent.ɵfac = function IgxTimePickerComponent_Factory(t) { return new (t || IgxTimePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
IgxTimePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxTimePickerComponent, selectors: [["igx-time-picker"]], contentQueries: function IgxTimePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTimePickerTemplateDirective, true, IgxTimePickerTemplateDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxTimePickerActionsDirective, true, IgxTimePickerActionsDirective);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true, IgxInputDirective);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timePickerTemplateDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.timePickerActionsDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirectiveUserTemplate = _t.first);
    } }, viewQuery: function IgxTimePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c236, true);
        ɵngcc0.ɵɵviewQuery(_c237, true);
        ɵngcc0.ɵɵviewQuery(_c238, true);
        ɵngcc0.ɵɵviewQuery(_c239, true);
        ɵngcc0.ɵɵstaticViewQuery(_c240, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(_c241, true, TemplateRef);
        ɵngcc0.ɵɵstaticViewQuery(IgxToggleDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true, IgxInputDirective);
        ɵngcc0.ɵɵviewQuery(IgxInputGroupComponent, true, IgxInputGroupComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.hourList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.minuteList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.secondsList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ampmList = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultTimePickerTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dropdownInputTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputElementRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._inputGroup = _t.first);
    } }, hostVars: 1, hostBindings: function IgxTimePickerComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown.spacebar", function IgxTimePickerComponent_keydown_spacebar_HostBindingHandler($event) { return ctx.onKeydownSpace($event); })("keydown.space", function IgxTimePickerComponent_keydown_space_HostBindingHandler($event) { return ctx.onKeydownSpace($event); })("keydown.Alt.ArrowDown", function IgxTimePickerComponent_keydown_Alt_ArrowDown_HostBindingHandler() { return ctx.onAltArrowDown(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
    } }, inputs: { id: "id", disabled: "disabled", isSpinLoop: "isSpinLoop", vertical: "vertical", promptChar: "promptChar", mode: "mode", value: "value", resourceStrings: "resourceStrings", okButtonLabel: "okButtonLabel", cancelButtonLabel: "cancelButtonLabel", itemsDelta: "itemsDelta", format: "format", overlaySettings: "overlaySettings", minValue: "minValue", maxValue: "maxValue", outlet: "outlet" }, outputs: { onValueChanged: "onValueChanged", onValidationFailed: "onValidationFailed", onOpened: "onOpened", onClosed: "onClosed", onClosing: "onClosing" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxTimePickerComponent_1,
                multi: true
            },
            {
                provide: HAMMER_GESTURE_CONFIG,
                useClass: TimePickerHammerConfig
            },
            {
                provide: IGX_TIME_PICKER_COMPONENT,
                useExisting: IgxTimePickerComponent_1
            }
        ])], decls: 16, vars: 12, consts: [["dropdownInputTemplate", ""], ["defaultTimePickerTemplate", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["defaultTimePickerActions", ""], ["igxToggle", "", 1, "igx-time-picker", 3, "ngClass"], ["class", "igx-time-picker__header", 4, "ngIf"], [1, "igx-time-picker__main"], [1, "igx-time-picker__body"], [3, "igxItemList", 4, "ngIf"], [4, "ngTemplateOutlet"], [3, "mousedown"], ["group", ""], ["igxLabel", ""], [3, "click"], ["type", "text", "igxInput", "", 3, "igxMask", "includeLiterals", "placeholder", "displayValuePipe", "focusedValuePipe", "promptChar", "value", "disabled", "input", "blur", "focus", "wheel"], ["igxRipple", "", 3, "click", 4, "ngIf"], ["igxRipple", "", 3, "click"], ["fontSet", "material"], [3, "click", "mousedown"], ["igxInput", "", "tabindex", "0", "readonly", "", 3, "value", "disabled", "blur"], ["class", "igx-time-picker__buttons", 4, "ngIf"], [1, "igx-time-picker__buttons"], ["igxButton", "flat", 3, "click", 4, "ngIf"], ["igxButton", "flat", 3, "click"], [1, "igx-time-picker__header"], [1, "igx-time-picker__header-ampm"], [1, "igx-time-picker__header-hour"], [3, "igxItemList"], ["hourList", ""], [3, "igxHourItem", 4, "ngFor", "ngForOf"], [3, "igxHourItem"], ["minuteList", ""], [3, "igxMinuteItem", 4, "ngFor", "ngForOf"], [3, "igxMinuteItem"], ["secondsList", ""], [3, "igxSecondsItem", 4, "ngFor", "ngForOf"], [3, "igxSecondsItem"], ["ampmList", ""], [3, "igxAmPmItem", 4, "ngFor", "ngForOf"], [3, "igxAmPmItem"]], template: function IgxTimePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, IgxTimePickerComponent_ng_template_0_Template, 9, 9, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, IgxTimePickerComponent_ng_template_2_Template, 7, 2, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(4, IgxTimePickerComponent_ng_container_4_Template, 1, 0, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(5, IgxTimePickerComponent_ng_template_5_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(7, "div", 4);
        ɵngcc0.ɵɵtemplate(8, IgxTimePickerComponent_div_8_Template, 12, 4, "div", 5);
        ɵngcc0.ɵɵelementStart(9, "div", 6);
        ɵngcc0.ɵɵelementStart(10, "div", 7);
        ɵngcc0.ɵɵtemplate(11, IgxTimePickerComponent_div_11_Template, 3, 2, "div", 8);
        ɵngcc0.ɵɵtemplate(12, IgxTimePickerComponent_div_12_Template, 3, 2, "div", 8);
        ɵngcc0.ɵɵtemplate(13, IgxTimePickerComponent_div_13_Template, 3, 2, "div", 8);
        ɵngcc0.ɵɵtemplate(14, IgxTimePickerComponent_div_14_Template, 3, 2, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(15, IgxTimePickerComponent_ng_container_15_Template, 1, 0, "ng-container", 9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1609 = ɵngcc0.ɵɵreference(6);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.context);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(9, _c242, ctx.mode === "dropdown", ctx.vertical && ctx.mode === "dialog"));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.mode === "dialog");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showHoursList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showMinutesList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showSecondsList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showAmPmList);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.timePickerActionsDirective ? ctx.timePickerActionsDirective.template : _r1609);
    } }, directives: [ɵngcc2.NgTemplateOutlet, IgxToggleDirective, ɵngcc2.NgClass, ɵngcc2.NgIf, IgxInputGroupComponent,
        IgxLabelDirective,
        IgxPrefixDirective,
        IgxIconComponent,
        IgxInputDirective,
        IgxMaskDirective,
        IgxSuffixDirective,
        IgxButtonDirective,
        IgxItemListDirective, ɵngcc2.NgForOf, IgxHourItemDirective,
        IgxMinuteItemDirective,
        IgxSecondsItemDirective,
        IgxAmPmItemDirective], styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"] });
IgxTimePickerComponent.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef }
];
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxTimePickerComponent.prototype, "id", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "value", null);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "resourceStrings", null);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "okButtonLabel", null);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "cancelButtonLabel", null);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "itemsDelta", null);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "minValue", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "maxValue", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "isSpinLoop", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "vertical", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "format", null);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "promptChar", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "mode", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "outlet", void 0);
__decorate([
    Input()
], IgxTimePickerComponent.prototype, "overlaySettings", null);
__decorate([
    Output()
], IgxTimePickerComponent.prototype, "onValueChanged", void 0);
__decorate([
    Output()
], IgxTimePickerComponent.prototype, "onValidationFailed", void 0);
__decorate([
    Output()
], IgxTimePickerComponent.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxTimePickerComponent.prototype, "onClosed", void 0);
__decorate([
    Output()
], IgxTimePickerComponent.prototype, "onClosing", void 0);
__decorate([
    ViewChild('hourList')
], IgxTimePickerComponent.prototype, "hourList", void 0);
__decorate([
    ViewChild('minuteList')
], IgxTimePickerComponent.prototype, "minuteList", void 0);
__decorate([
    ViewChild('secondsList')
], IgxTimePickerComponent.prototype, "secondsList", void 0);
__decorate([
    ViewChild('ampmList')
], IgxTimePickerComponent.prototype, "ampmList", void 0);
__decorate([
    ViewChild('defaultTimePickerTemplate', { read: TemplateRef, static: true })
], IgxTimePickerComponent.prototype, "defaultTimePickerTemplate", void 0);
__decorate([
    ViewChild('dropdownInputTemplate', { read: TemplateRef, static: true })
], IgxTimePickerComponent.prototype, "dropdownInputTemplate", void 0);
__decorate([
    ContentChild(IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective })
], IgxTimePickerComponent.prototype, "timePickerTemplateDirective", void 0);
__decorate([
    ContentChild(IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective })
], IgxTimePickerComponent.prototype, "timePickerActionsDirective", void 0);
__decorate([
    ViewChild(IgxToggleDirective, { static: true })
], IgxTimePickerComponent.prototype, "toggleRef", void 0);
__decorate([
    ViewChild(IgxInputDirective, { read: ElementRef })
], IgxTimePickerComponent.prototype, "_inputElementRef", void 0);
__decorate([
    ViewChild(IgxInputDirective, { read: IgxInputDirective })
], IgxTimePickerComponent.prototype, "_inputDirective", void 0);
__decorate([
    ContentChild(IgxInputDirective, { read: IgxInputDirective })
], IgxTimePickerComponent.prototype, "_inputDirectiveUserTemplate", void 0);
__decorate([
    ViewChild(IgxInputGroupComponent, { read: IgxInputGroupComponent })
], IgxTimePickerComponent.prototype, "_inputGroup", void 0);
__decorate([
    HostListener('keydown.spacebar', ['$event']),
    HostListener('keydown.space', ['$event'])
], IgxTimePickerComponent.prototype, "onKeydownSpace", null);
__decorate([
    HostListener('keydown.Alt.ArrowDown')
], IgxTimePickerComponent.prototype, "onAltArrowDown", null);
/**
 * @hidden
 */
let IgxTimePickerModule = class IgxTimePickerModule {
};
IgxTimePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxTimePickerModule });
IgxTimePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxTimePickerModule_Factory(t) { return new (t || IgxTimePickerModule)(); }, providers: [], imports: [[
            CommonModule,
            IgxInputGroupModule,
            IgxIconModule,
            IgxButtonModule,
            IgxMaskModule,
            IgxToggleModule
        ]] });

let NEXT_ID$v = 0;
/**
 * Enumeration for toast position
 * Can be:
 * Bottom
 * Middle
 * Top
 */
var IgxToastPosition;
(function (IgxToastPosition) {
    IgxToastPosition[IgxToastPosition["Bottom"] = 0] = "Bottom";
    IgxToastPosition[IgxToastPosition["Middle"] = 1] = "Middle";
    IgxToastPosition[IgxToastPosition["Top"] = 2] = "Top";
})(IgxToastPosition || (IgxToastPosition = {}));
/**
 * **Ignite UI for Angular Toast** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast.html)
 *
 * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
 * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
 *
 * Example:
 * ```html
 * <button (click)="toast.show()">Show notification</button>
 * <igx-toast #toast
 *           message="Notification displayed"
 *           displayTime="1000">
 * </igx-toast>
 * ```
 */
let IgxToastComponent = class IgxToastComponent {
    constructor(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        this._isVisible = false;
        /**
         * @hidden
         */
        this.animationState = 'invisible';
        /**
         * Sets/gets the `id` of the toast.
         * If not set, the `id` will have value `"igx-toast-0"`.
         * ```html
         * <igx-toast id = "my-first-toast"></igx-toast>
         * ```
         * ```typescript
         * let toastId = this.toast.id;
         * ```
         */
        this.id = `igx-toast-${NEXT_ID$v++}`;
        /**
         * Emits an event prior the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShowing) = "onShowing($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onShowing = new EventEmitter();
        /**
         * Emits an event when the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShown) = "onShown($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onShown = new EventEmitter();
        /**
         * Emits an event prior the toast is hidden.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHiding) = "onHiding($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onHiding = new EventEmitter();
        /**
         *  Emits an event when the toast is hidden.
         *  Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHidden) = "onHidden($event)"></igx-toast>
         * ```
         * @memberof IgxToastComponent
         */
        this.onHidden = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         * If not set, `role` will have value `"alert"`.
         * ```html
         * <igx-toast [role] = "'notify'"></igx-toast>
         * ```
         * ```typescript
         * let toastRole = this.toast.role;
         * ```
         * @memberof IgxToastComponent
         */
        this.role = 'alert';
        /**
         * Sets/gets whether the toast will be hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-toast [autoHide] = "false"></igx-toast>
         * ```
         * ```typescript
         * let autoHide = this.toast.autoHide;
         * ```
         * @memberof IgxToastComponent
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
         * after it is being shown.
         * Default value is `4000`.
         * ```html
         * <igx-toast [displayTime] = "2500"></igx-toast>
         * ```
         * ```typescript
         * let displayTime = this.toast.displayTime;
         * ```
         * @memberof IgxToastComponent
         */
        this.displayTime = 4000;
        /**
         * @hidden
         */
        this.isVisibleChange = new EventEmitter();
        /**
         * @hidden
         */
        this.message = '';
        /**
         * Sets/gets the position of the toast.
         * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
         * ```html
         * <igx-toast [position] = "top"></igx-toast>
         * ```
         * ```typescript
         * let toastPosition = this.toast.position;
         * ```
         * @memberof IgxToastComponent
         */
        this.position = IgxToastPosition.Bottom;
    }
    /**
     * Enables/Disables the visibility of the toast.
     * If not set, the `isVisible` attribute will have value `false`.
     * ```html
     * <igx-toast [isVisible] = "true"></igx-toast>
     * ```
     * ```typescript
     * let isVisible = this.toast.isVisible;
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-toast [(isVisible)] = "model.isVisible"></igx-toast>
     * ```
     * @memberof IgxToastComponent
     */
    get isVisible() {
        return this._isVisible;
    }
    set isVisible(value) {
        this._isVisible = value;
        this.isVisibleChange.emit(this._isVisible);
    }
    /**
     * Gets the nativeElement of the toast.
     * ```typescript
     * let nativeElement = this.toast.element;
     * ```
     * @memberof IgxToastComponent
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     * ```typescript
     * this.toast.show();
     * ```
     * @memberof IgxToastComponent
     */
    show() {
        clearInterval(this.timeoutId);
        this.onShowing.emit(this);
        this.isVisible = true;
        this.animationState = 'visible';
        if (this.autoHide) {
            this.timeoutId = window.setTimeout(() => {
                this.hide();
            }, this.displayTime);
        }
        this.onShown.emit(this);
    }
    /**
     * Hides the toast.
     * ```typescript
     * this.toast.hide();
     * ```
     * @memberof IgxToastComponent
     */
    hide() {
        this.onHiding.emit(this);
        this.isVisible = false;
        this.onHidden.emit(this);
        this.animationState = 'invisible';
        clearInterval(this.timeoutId);
    }
    /**
     * Wraps @show() method due @IToggleView interface implementation.
     * @hidden
     */
    open() {
        this.show();
    }
    /**
     * Wraps @hide() method due @IToggleView interface implementation.
     * @hidden
     */
    close() {
        this.hide();
    }
    /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     * @memberof IgxToastComponent
     */
    toggle() {
        this.isVisible ? this.close() : this.open();
    }
    /**
     * @hidden
     */
    get cssClassTop() {
        return this.position === IgxToastPosition.Top;
    }
    /**
     * @hidden
     */
    get cssClassMiddle() {
        return this.position === IgxToastPosition.Middle;
    }
    /**
     * @hidden
     */
    get cssClassBottom() {
        return this.position === IgxToastPosition.Bottom;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    }
};
IgxToastComponent.ɵfac = function IgxToastComponent_Factory(t) { return new (t || IgxToastComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(IgxNavigationService, 8)); };
IgxToastComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxToastComponent, selectors: [["igx-toast"]], hostVars: 8, hostBindings: function IgxToastComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.id);
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@animate", ctx.animationState);
        ɵngcc0.ɵɵclassProp("igx-toast--top", ctx.cssClassTop)("igx-toast--middle", ctx.cssClassMiddle)("igx-toast--bottom", ctx.cssClassBottom);
    } }, inputs: { id: "id", role: "role", autoHide: "autoHide", displayTime: "displayTime", message: "message", position: "position", isVisible: "isVisible" }, outputs: { onShowing: "onShowing", onShown: "onShown", onHiding: "onHiding", onHidden: "onHidden", isVisibleChange: "isVisibleChange" }, ngContentSelectors: _c2, decls: 3, vars: 1, template: function IgxToastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "span");
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.message);
    } }, styles: ["[_nghost-%COMP%] {\n            display: block;\n        }"], data: { animation: [
            trigger('animate', [
                state('visible', style({
                    opacity: 1
                })),
                transition('invisible => visible', animate('.20s ease')),
                transition('visible => invisible', animate('.40s ease-out'))
            ])
        ] } });
IgxToastComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IgxNavigationService, decorators: [{ type: Optional }] }
];
__decorate([
    HostBinding('@animate')
], IgxToastComponent.prototype, "animationState", void 0);
__decorate([
    HostBinding('attr.id'),
    Input()
], IgxToastComponent.prototype, "id", void 0);
__decorate([
    Output()
], IgxToastComponent.prototype, "onShowing", void 0);
__decorate([
    Output()
], IgxToastComponent.prototype, "onShown", void 0);
__decorate([
    Output()
], IgxToastComponent.prototype, "onHiding", void 0);
__decorate([
    Output()
], IgxToastComponent.prototype, "onHidden", void 0);
__decorate([
    Input()
], IgxToastComponent.prototype, "role", void 0);
__decorate([
    Input()
], IgxToastComponent.prototype, "autoHide", void 0);
__decorate([
    Input()
], IgxToastComponent.prototype, "displayTime", void 0);
__decorate([
    Input()
], IgxToastComponent.prototype, "isVisible", null);
__decorate([
    Output()
], IgxToastComponent.prototype, "isVisibleChange", void 0);
__decorate([
    Input()
], IgxToastComponent.prototype, "message", void 0);
__decorate([
    Input()
], IgxToastComponent.prototype, "position", void 0);
__decorate([
    HostBinding('class.igx-toast--top')
], IgxToastComponent.prototype, "cssClassTop", null);
__decorate([
    HostBinding('class.igx-toast--middle')
], IgxToastComponent.prototype, "cssClassMiddle", null);
__decorate([
    HostBinding('class.igx-toast--bottom')
], IgxToastComponent.prototype, "cssClassBottom", null);
IgxToastComponent = __decorate([ __param(1, Optional())
], IgxToastComponent);
/**
 * @hidden
 */
let IgxToastModule = class IgxToastModule {
};
IgxToastModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxToastModule });
IgxToastModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxToastModule_Factory(t) { return new (t || IgxToastModule)(); }, imports: [[CommonModule]] });

/**
 * Represents individual resizable/collapsible panes.
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
let IgxSplitterPaneComponent = class IgxSplitterPaneComponent {
    constructor(el) {
        this.el = el;
        this._size = 'auto';
        this._collapsed = false;
        /**
         * Gets/Sets whether pane is resizable.
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (onToggle)='onPaneToggle($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.onToggle = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` and `minWidth` properties of the current pane.
         */
        this.minHeight = 0;
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` and `maxWidth` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the size of the current pane.
     *  * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
        this.el.nativeElement.style.flex = this.flex;
    }
    /**
     *
     * @hidden @internal
     * Gets the host native element.
     */
    get element() {
        return this.el.nativeElement;
    }
    /**
     * @hidden @internal
     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
     */
    get flex() {
        const grow = this.size !== 'auto' ? 0 : 1;
        const shrink = this.size !== 'auto' ? 0 : 1;
        return `${grow} ${shrink} ${this.size}`;
    }
    /**
     * Gets/Sets whether current pane is collapsed.
     * @example
     * ```typescript
     * const isCollapsed = pane.collapsed;
     * ```
     */
    set collapsed(value) {
        this._collapsed = value;
        this.display = this._collapsed ? 'none' : 'flex';
    }
    get collapsed() {
        return this._collapsed;
    }
    /** @hidden @internal */
    _getSiblings() {
        const panes = this.owner.panes.toArray();
        const index = panes.indexOf(this);
        const siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    }
    /**
     * Toggles the collapsed state of the pane.
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    toggle() {
        // reset sibling sizes when pane collapse state changes.
        this._getSiblings().forEach(sibling => sibling.size = 'auto');
        this.collapsed = !this.collapsed;
        this.onToggle.emit(this);
    }
};
IgxSplitterPaneComponent.ɵfac = function IgxSplitterPaneComponent_Factory(t) { return new (t || IgxSplitterPaneComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
IgxSplitterPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitterPaneComponent, selectors: [["igx-splitter-pane"]], hostVars: 16, hostBindings: function IgxSplitterPaneComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("overflow", ctx.overflow)("min-height", ctx.minHeight)("min-width", ctx.minHeight)("max-height", ctx.maxHeight)("max-width", ctx.maxHeight)("display", ctx.display)("flex", ctx.flex)("order", ctx.order);
    } }, inputs: { resizable: "resizable", size: "size", collapsed: "collapsed", minSize: "minSize", maxSize: "maxSize" }, outputs: { onToggle: "onToggle" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxSplitterPaneComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
IgxSplitterPaneComponent.ctorParameters = () => [
    { type: ElementRef }
];
__decorate([
    Input()
], IgxSplitterPaneComponent.prototype, "size", null);
__decorate([
    Input()
], IgxSplitterPaneComponent.prototype, "minSize", void 0);
__decorate([
    Input()
], IgxSplitterPaneComponent.prototype, "maxSize", void 0);
__decorate([
    Input()
], IgxSplitterPaneComponent.prototype, "resizable", void 0);
__decorate([
    Output()
], IgxSplitterPaneComponent.prototype, "onToggle", void 0);
__decorate([
    HostBinding('style.order')
], IgxSplitterPaneComponent.prototype, "order", void 0);
__decorate([
    HostBinding('style.overflow')
], IgxSplitterPaneComponent.prototype, "overflow", void 0);
__decorate([
    HostBinding('style.min-height'),
    HostBinding('style.min-width')
], IgxSplitterPaneComponent.prototype, "minHeight", void 0);
__decorate([
    HostBinding('style.max-height'),
    HostBinding('style.max-width')
], IgxSplitterPaneComponent.prototype, "maxHeight", void 0);
__decorate([
    HostBinding('style.flex')
], IgxSplitterPaneComponent.prototype, "flex", null);
__decorate([
    HostBinding('style.display')
], IgxSplitterPaneComponent.prototype, "display", void 0);
__decorate([
    Input()
], IgxSplitterPaneComponent.prototype, "collapsed", null);

/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
let IgxSplitterComponent = class IgxSplitterComponent {
    constructor() {
        this._type = SplitterType.Horizontal;
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
    }
    /**
     * Gets/Sets the splitter orientation.
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => x.size = 'auto');
        }
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.panes.forEach(pane => pane.owner = this);
        this.assignFlexOrder();
        this.panes.changes.subscribe(() => {
            this.panes.forEach(pane => pane.owner = this);
            this.assignFlexOrder();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        if (this.pane.size === 'auto') {
            this.pane.size = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        }
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        if (this.sibling.size === 'auto') {
            this.sibling.size = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        }
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.size = paneSize + 'px';
        this.sibling.size = siblingSize + 'px';
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
};
IgxSplitterComponent.ɵfac = function IgxSplitterComponent_Factory(t) { return new (t || IgxSplitterComponent)(); };
IgxSplitterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitterComponent, selectors: [["igx-splitter"]], contentQueries: function IgxSplitterComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxSplitterPaneComponent, false, IgxSplitterPaneComponent);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panes = _t);
    } }, hostVars: 6, hostBindings: function IgxSplitterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("overflow", ctx.overflow)("display", ctx.display)("flex-direction", ctx.direction);
    } }, inputs: { type: "type" }, ngContentSelectors: _c244, decls: 2, vars: 1, consts: [[4, "ngFor", "ngForOf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving", 4, "ngIf"], ["role", "separator", 3, "order", "type", "pane", "siblings", "moveStart", "moving"]], template: function IgxSplitterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c243);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵtemplate(1, IgxSplitterComponent_ng_container_1_Template, 2, 1, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.panes);
    } }, directives: function () { return [ɵngcc2.NgForOf, ɵngcc2.NgIf, IgxSplitBarComponent]; }, encapsulation: 2 });
__decorate([
    Input()
], IgxSplitterComponent.prototype, "type", null);
__decorate([
    ContentChildren(IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent })
], IgxSplitterComponent.prototype, "panes", void 0);
__decorate([
    HostBinding('style.flex-direction')
], IgxSplitterComponent.prototype, "direction", null);
__decorate([
    HostBinding('style.overflow')
], IgxSplitterComponent.prototype, "overflow", void 0);
__decorate([
    HostBinding('style.display')
], IgxSplitterComponent.prototype, "display", void 0);

const SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
/**
 * @hidden @internal
 * Represents the draggable bar that visually separates panes and allows for changing their sizes.
 */
let IgxSplitBarComponent = class IgxSplitBarComponent {
    constructor() {
        /**
         * Set css class to the host element.
         */
        this.cssClass = 'igx-splitter-bar-host';
        /**
         * Gets/Sets the orientation.
         */
        this.type = SplitterType.Horizontal;
        /**
         * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
         */
        this.moveStart = new EventEmitter();
        /**
         * An event that is emitted while we are dragging the current `SplitBarComponent`.
         */
        this.moving = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get tabindex() {
        return this.resizeDisallowed ? null : 0;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * @hidden
     * @internal
     */
    get cursor() {
        if (this.resizeDisallowed) {
            return '';
        }
        return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';
    }
    /**
     * @hidden @internal
     */
    get prevButtonHidden() {
        return this.siblings[0].collapsed && !this.siblings[1].collapsed;
    }
    /**
     * @hidden @internal
     */
    keyEvent(event) {
        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey;
        event.stopPropagation();
        if (SPLITTER_INTERACTION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'arrowup':
            case 'up':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowdown':
            case 'down':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            case 'arrowleft':
            case 'left':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowright':
            case 'right':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    get dragDir() {
        return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;
    }
    /**
     * @hidden @internal
     */
    get nextButtonHidden() {
        return this.siblings[1].collapsed && !this.siblings[0].collapsed;
    }
    /**
     * @hidden @internal
     */
    onDragStart(event) {
        if (this.resizeDisallowed) {
            event.cancel = true;
            return;
        }
        this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;
        this.moveStart.emit(this.pane);
    }
    /**
     * @hidden @internal
     */
    onDragMove(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.moving.emit(delta);
            event.cancel = true;
            event.owner.element.nativeElement.style.transform = '';
        }
    }
    get resizeDisallowed() {
        const relatedTabs = this.siblings;
        return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);
    }
    /**
     * @hidden @internal
     */
    onCollapsing(next) {
        const prevSibling = this.siblings[0];
        const nextSibling = this.siblings[1];
        let target;
        if (next) {
            // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
            target = prevSibling.collapsed ? prevSibling : nextSibling;
        }
        else {
            // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
            target = nextSibling.collapsed ? nextSibling : prevSibling;
        }
        target.toggle();
    }
};
IgxSplitBarComponent.ɵfac = function IgxSplitBarComponent_Factory(t) { return new (t || IgxSplitBarComponent)(); };
IgxSplitBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxSplitBarComponent, selectors: [["igx-splitter-bar"]], hostVars: 6, hostBindings: function IgxSplitBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keydown", function IgxSplitBarComponent_keydown_HostBindingHandler($event) { return ctx.keyEvent($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("tabindex", ctx.tabindex)("aria-orientation", ctx.orientation);
        ɵngcc0.ɵɵstyleProp("order", ctx.order);
        ɵngcc0.ɵɵclassProp("igx-splitter-bar-host", ctx.cssClass);
    } }, inputs: { type: "type", order: "order", pane: "pane", siblings: "siblings" }, outputs: { moveStart: "moveStart", moving: "moving" }, decls: 4, vars: 8, consts: [["igxDrag", "", 1, "igx-splitter-bar", 3, "ghost", "dragDirection", "dragStart", "dragMove"], ["igxDragIgnore", "", 1, "igx-splitter-bar__expander--start", 3, "hidden", "click"], [1, "igx-splitter-bar__handle"], ["igxDragIgnore", "", 1, "igx-splitter-bar__expander--end", 3, "hidden", "click"]], template: function IgxSplitBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("dragStart", function IgxSplitBarComponent_Template_div_dragStart_0_listener($event) { return ctx.onDragStart($event); })("dragMove", function IgxSplitBarComponent_Template_div_dragMove_0_listener($event) { return ctx.onDragMove($event); });
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵlistener("click", function IgxSplitBarComponent_Template_div_click_1_listener() { return ctx.onCollapsing(false); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵlistener("click", function IgxSplitBarComponent_Template_div_click_3_listener() { return ctx.onCollapsing(true); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("cursor", ctx.cursor);
        ɵngcc0.ɵɵclassProp("igx-splitter-bar--vertical", ctx.type === 0);
        ɵngcc0.ɵɵproperty("ghost", false)("dragDirection", ctx.dragDir);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("hidden", ctx.prevButtonHidden);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("hidden", ctx.nextButtonHidden);
    } }, directives: [IgxDragDirective,
        IgxDragIgnoreDirective], encapsulation: 2 });
__decorate([
    HostBinding('class.igx-splitter-bar-host')
], IgxSplitBarComponent.prototype, "cssClass", void 0);
__decorate([
    Input()
], IgxSplitBarComponent.prototype, "type", void 0);
__decorate([
    HostBinding('style.order'),
    Input()
], IgxSplitBarComponent.prototype, "order", void 0);
__decorate([
    HostBinding('attr.tabindex')
], IgxSplitBarComponent.prototype, "tabindex", null);
__decorate([
    HostBinding('attr.aria-orientation')
], IgxSplitBarComponent.prototype, "orientation", null);
__decorate([
    Input()
], IgxSplitBarComponent.prototype, "pane", void 0);
__decorate([
    Input()
], IgxSplitBarComponent.prototype, "siblings", void 0);
__decorate([
    Output()
], IgxSplitBarComponent.prototype, "moveStart", void 0);
__decorate([
    Output()
], IgxSplitBarComponent.prototype, "moving", void 0);
__decorate([
    HostListener('keydown', ['$event'])
], IgxSplitBarComponent.prototype, "keyEvent", null);

let IgxSplitterModule = class IgxSplitterModule {
};
IgxSplitterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxSplitterModule });
IgxSplitterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxSplitterModule_Factory(t) { return new (t || IgxSplitterModule)(); }, imports: [[
            CommonModule, IgxIconModule, IgxDragDropModule
        ]] });

var IgxDateRangeInputsBaseComponent_1, IgxDateRangeStartComponent_1, IgxDateRangeEndComponent_1;
/** @hidden @internal */
let DateRangePickerFormatPipe = class DateRangePickerFormatPipe {
    transform(values, inputFormat, locale) {
        if (!values) {
            return '';
        }
        const { start, end } = values;
        // TODO: move default locale from IgxDateTimeEditorDirective to its commons file/use displayFormat
        const startDate = inputFormat ? formatDate(start, inputFormat, locale || 'en') : start === null || start === void 0 ? void 0 : start.toLocaleDateString();
        const endDate = inputFormat ? formatDate(end, inputFormat, locale || 'en') : end === null || end === void 0 ? void 0 : end.toLocaleDateString();
        let formatted;
        if (start) {
            formatted = `${startDate} - `;
            if (end) {
                formatted += endDate;
            }
        }
        // TODO: no need to set format twice
        return formatted ? formatted : '';
    }
};
DateRangePickerFormatPipe.ɵfac = function DateRangePickerFormatPipe_Factory(t) { return new (t || DateRangePickerFormatPipe)(); };
DateRangePickerFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "dateRange", type: DateRangePickerFormatPipe, pure: true });
/** @hidden @internal */
let IgxDateRangeInputsBaseComponent = IgxDateRangeInputsBaseComponent_1 = class IgxDateRangeInputsBaseComponent extends IgxInputGroupComponent {
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    setFocus() {
        this.input.focus();
    }
    /** @hidden @internal */
    updateInputValue(value) {
        if (this.ngControl) {
            this.ngControl.control.setValue(value);
        }
        else {
            this.dateTimeEditor.value = value;
        }
    }
    /** @hidden @internal */
    updateInputValidity(state) {
        this.inputDirective.valid = state;
    }
};
IgxDateRangeInputsBaseComponent.ɵfac = function IgxDateRangeInputsBaseComponent_Factory(t) { return ɵIgxDateRangeInputsBaseComponent_BaseFactory(t || IgxDateRangeInputsBaseComponent); };
IgxDateRangeInputsBaseComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangeInputsBaseComponent, selectors: [["igx-date-range-base"]], contentQueries: function IgxDateRangeInputsBaseComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NgControl, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDateTimeEditorDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxInputDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.ngControl = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateTimeEditor = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: IgxInputGroupBase, useExisting: IgxDateRangeInputsBaseComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function IgxDateRangeInputsBaseComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChild(NgControl)
], IgxDateRangeInputsBaseComponent.prototype, "ngControl", void 0);
__decorate([
    ContentChild(IgxDateTimeEditorDirective)
], IgxDateRangeInputsBaseComponent.prototype, "dateTimeEditor", void 0);
__decorate([
    ContentChild(IgxInputDirective)
], IgxDateRangeInputsBaseComponent.prototype, "inputDirective", void 0);
/**
 * Templates the default icon in the `IgxDateRangePicker`.
 *
 * @igxModule IgxDateRangePickerModule
 *
 * @igxKeyWords date range icon, date picker icon
 *
 * @igxGroup scheduling
 *
 * @example
 * ```html
 * <igx-date-range-picker>
 *   <igx-picker-toggle igxSuffix>
 *      <igx-icon>calendar_view_day</igx-icon>
 *   </igx-picker-toggle>
 * </igx-date-range-picker>
 * ```
 */
let IgxPickerToggleComponent = class IgxPickerToggleComponent {
    constructor() {
        this.clicked = new EventEmitter();
    }
    onClick(event) {
        // do not focus input on click
        event.stopPropagation();
        this.clicked.emit();
    }
};
IgxPickerToggleComponent.ɵfac = function IgxPickerToggleComponent_Factory(t) { return new (t || IgxPickerToggleComponent)(); };
IgxPickerToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxPickerToggleComponent, selectors: [["igx-picker-toggle"]], hostBindings: function IgxPickerToggleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function IgxPickerToggleComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, outputs: { clicked: "clicked" }, ngContentSelectors: _c2, decls: 1, vars: 0, template: function IgxPickerToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate([
    Output()
], IgxPickerToggleComponent.prototype, "clicked", void 0);
__decorate([
    HostListener('click', ['$event'])
], IgxPickerToggleComponent.prototype, "onClick", null);
/**
 * Defines the start input for a date range picker
 *
 * @igxModule IgxDateRangePickerModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * When templating, start input has to be templated separately
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown">
 *      <igx-date-range-start>
 *          <input igxInput igxDateTimeEditor type="text">
 *      </igx-date-range-start>
 *      ...
 * </igx-date-range-picker>
 * ```
 */
let IgxDateRangeStartComponent = IgxDateRangeStartComponent_1 = class IgxDateRangeStartComponent extends IgxDateRangeInputsBaseComponent {
};
IgxDateRangeStartComponent.ɵfac = function IgxDateRangeStartComponent_Factory(t) { return ɵIgxDateRangeStartComponent_BaseFactory(t || IgxDateRangeStartComponent); };
IgxDateRangeStartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangeStartComponent, selectors: [["igx-date-range-start"]], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: IgxInputGroupBase, useExisting: IgxDateRangeStartComponent_1 },
            { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeStartComponent_1 }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 11, vars: 2, consts: [["class", "igx-input-group__wrapper", 4, "ngIf", "ngIfElse"], [1, "igx-input-group__hint"], ["label", ""], ["input", ""], ["inputBundle", ""], ["bundle", ""], [1, "igx-input-group__wrapper"], [4, "ngTemplateOutlet"], [4, "ngIf"], [1, "igx-input-group__bundle"], ["class", "igx-input-group__bundle-main", 4, "ngIf", "ngIfElse"], ["class", "igx-input-group__border", 4, "ngIf"], [1, "igx-input-group__bundle-main"], [1, "igx-input-group__border"]], template: function IgxDateRangeStartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, IgxDateRangeStartComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, IgxDateRangeStartComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxDateRangeStartComponent_ng_template_5_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxDateRangeStartComponent_ng_template_7_Template, 2, 2, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxDateRangeStartComponent_ng_template_9_Template, 6, 4, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1667 = ɵngcc0.ɵɵreference(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTypeBox)("ngIfElse", _r1667);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
/**
 * Defines the end input for a date range picker
 *
 * @igxModule IgxDateRangeModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * When templating, end input has to be template separately
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown">
 *      <igx-date-range-end>
 *          <input igxInput igxDateTimeEditor type="text">
 *      </igx-date-range-end>
 *      ...
 * </igx-date-range-picker>
 * ```
 */
let IgxDateRangeEndComponent = IgxDateRangeEndComponent_1 = class IgxDateRangeEndComponent extends IgxDateRangeInputsBaseComponent {
};
IgxDateRangeEndComponent.ɵfac = function IgxDateRangeEndComponent_Factory(t) { return ɵIgxDateRangeEndComponent_BaseFactory(t || IgxDateRangeEndComponent); };
IgxDateRangeEndComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangeEndComponent, selectors: [["igx-date-range-end"]], features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: IgxInputGroupBase, useExisting: IgxDateRangeEndComponent_1 },
            { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeEndComponent_1 }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c8, decls: 11, vars: 2, consts: [["class", "igx-input-group__wrapper", 4, "ngIf", "ngIfElse"], [1, "igx-input-group__hint"], ["label", ""], ["input", ""], ["inputBundle", ""], ["bundle", ""], [1, "igx-input-group__wrapper"], [4, "ngTemplateOutlet"], [4, "ngIf"], [1, "igx-input-group__bundle"], ["class", "igx-input-group__bundle-main", 4, "ngIf", "ngIfElse"], ["class", "igx-input-group__border", 4, "ngIf"], [1, "igx-input-group__bundle-main"], [1, "igx-input-group__border"]], template: function IgxDateRangeEndComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c7);
        ɵngcc0.ɵɵtemplate(0, IgxDateRangeEndComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, IgxDateRangeEndComponent_ng_template_3_Template, 1, 0, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(5, IgxDateRangeEndComponent_ng_template_5_Template, 1, 0, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(7, IgxDateRangeEndComponent_ng_template_7_Template, 2, 2, "ng-template", null, 4, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxDateRangeEndComponent_ng_template_9_Template, 6, 4, "ng-template", null, 5, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1687 = ɵngcc0.ɵɵreference(10);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isTypeBox)("ngIfElse", _r1687);
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet], encapsulation: 2 });
let IgxDateRangeSeparatorDirective = class IgxDateRangeSeparatorDirective {
};
IgxDateRangeSeparatorDirective.ɵfac = function IgxDateRangeSeparatorDirective_Factory(t) { return new (t || IgxDateRangeSeparatorDirective)(); };
IgxDateRangeSeparatorDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: IgxDateRangeSeparatorDirective, selectors: [["", "igxDateRangeSeparator", ""]] });

var IgxDateRangePickerComponent_1;
/**
 * Provides the ability to select a range of dates from a calendar UI or editable inputs.
 *
 * @igxModule IgxDateRangeModule
 *
 * @igxTheme igx-input-group-theme, igx-calendar-theme, igx-date-range-picker-theme
 *
 * @igxKeywords date, range, date range, date picker
 *
 * @igxGroup scheduling
 *
 * @remarks
 * It displays the range selection in a single or two input fields.
 * The default template displays a single *readonly* input field
 * while projecting `igx-date-range-start` and `igx-date-range-end`
 * displays two *editable* input fields.
 *
 * @example
 * ```html
 * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
 * ```
 */
let IgxDateRangePickerComponent = IgxDateRangePickerComponent_1 = class IgxDateRangePickerComponent extends DisplayDensityBase {
    constructor(element, _displayDensityOptions, _locale, _injector) {
        super(_displayDensityOptions);
        this.element = element;
        this._displayDensityOptions = _displayDensityOptions;
        this._locale = _locale;
        this._injector = _injector;
        /**
         * Display calendar in either `dialog` or `dropdown` mode.
         * @remarks
         * Default mode is `dialog`
         *
         * @example
         * ```html
         * <igx-date-range-picker mode="dropdown"></igx-date-range-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * The number of displayed month views.
         *
         * @remarks
         * Default is `2`.
         *
         * @example
         * ```html
         * <igx-date-range-picker [monthsViewNumber]="3"></igx-date-range-picker>
         * ```
         */
        this.monthsViewNumber = 2;
        /**
         * The start day of the week.
         *
         * @remarks
         * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
         *
         * @example
         * ```html
         * <igx-date-range-picker [weekStart]="1"></igx-date-range-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * The default text of the calendar dialog `done` button.
         *
         * @remarks
         * Default value is `Done`.
         * The button will only show up in `dialog` mode.
         *
         * @example
         * ```html
         * <igx-date-range-picker doneButtonText="完了"></igx-date-range-picker>
         * ```
         */
        this.doneButtonText = 'Done';
        /**
         * Sets the `placeholder` for single-input `IgxDateRangePickerComponent`.
         *   @example
         * ```html
         * <igx-date-range-picker [placeholder]="'Choose your dates'"></igx-date-range-picker>
         * ```
         */
        this.placeholder = '';
        /**
         * Emitted when a range is selected.
         *
         * @example
         * ```html
         * <igx-date-range-picker (rangeSelected)="handleSelected($event)"></igx-date-range-picker>
         * ```
         */
        this.rangeSelected = new EventEmitter();
        /**
         * Emitted when the calendar starts opening, cancelable.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onOpening)="handleOpening($event)"></igx-date-range-picker>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted when the `IgxDateRangeComponent` is opened.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onOpened)="handleOpened($event)"></igx-date-range-picker>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted when the calendar starts closing, cancelable.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onClosing)="handleClosing($event)"></igx-date-range-picker>
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted when the `IgxDateRangeComponent` is closed.
         *
         * @example
         * ```html
         * <igx-date-range-picker (onClosed)="handleClosed($event)"></igx-date-range-picker>
         * ```
         */
        this.onClosed = new EventEmitter();
        /** @hidden @internal */
        this.cssClass = 'igx-date-range-picker';
        /** @hidden @internal */
        this.dateSeparator = CurrentResourceStrings.DateRangePickerResStrings.igx_date_range_picker_date_separator;
        this._collapsed = true;
        this.$destroy = new Subject();
        this.$toggleClickNotifier = new Subject();
        this._dialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true
        };
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false
        };
        this.onChangeCallback = (dateRange) => { };
        this.onTouchCallback = () => { };
        this.onValidatorChange = () => { };
        this.onStatusChanged = () => {
            if ((this._ngControl.control.touched || this._ngControl.control.dirty) &&
                (this._ngControl.control.validator || this._ngControl.control.asyncValidator)) {
                if (this.inputGroup) {
                    this.inputDirective.valid = this.getInputState(this.inputGroup.isFocused);
                }
                else if (this.hasProjectedInputs) {
                    this.projectedInputs
                        .forEach(i => { i.inputDirective.valid = this.getInputState(i.isFocused); });
                }
            }
            this.setRequiredToInputs();
        };
        this.locale = this.locale || this._locale;
    }
    /**
     * The minimum value in a valid range.
     *
     * @example
     * <igx-date-range-picker [minValue]="minDate"></igx-date-range-picker>
     */
    set minValue(value) {
        this._minValue = value;
        this.onValidatorChange();
    }
    get minValue() {
        return this._minValue;
    }
    /**
     * The maximum value in a valid range.
     *
     * @example
     * <igx-date-range-picker [maxValue]="maxDate"></igx-date-range-picker>
     */
    set maxValue(value) {
        this._maxValue = value;
        this.onValidatorChange();
    }
    get maxValue() {
        return this._maxValue;
    }
    /** @hidden @internal */
    get appliedFormat() {
        if (this.formatter) {
            return this.formatter(this.value);
        }
        if (!this.hasProjectedInputs) {
            if (this.placeholder !== '') {
                return this.placeholder;
            }
            // TODO: use displayFormat - see how shortDate, longDate can be defined
            return this.inputFormat
                ? `${this.inputFormat} - ${this.inputFormat}`
                : `${DatePickerUtil.DEFAULT_INPUT_FORMAT} - ${DatePickerUtil.DEFAULT_INPUT_FORMAT}`;
        }
        else {
            return this.inputFormat || DatePickerUtil.DEFAULT_INPUT_FORMAT;
        }
    }
    /** @hidden @internal */
    get hasProjectedInputs() {
        var _a;
        return ((_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
    get dropdownOverlaySettings() {
        return Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
    }
    get dialogOverlaySettings() {
        return Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
    }
    get required() {
        if (this._ngControl && this._ngControl.control && this._ngControl.control.validator) {
            const error = this._ngControl.control.validator({});
            return (error && error.required) ? true : false;
        }
        return false;
    }
    /**
     * Opens the date range picker's dropdown or dialog.
     *
     * @example
     * ```html
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.open()">Open Dialog</button
     * ```
     */
    open(overlaySettings) {
        if (!this.collapsed) {
            return;
        }
        this.updateCalendar();
        const settings = this.mode === InteractionMode.Dialog ? this.dialogOverlaySettings : this.dropdownOverlaySettings;
        this.toggleDirective.open(Object.assign(settings, overlaySettings));
    }
    /**
     * Closes the date range picker's dropdown or dialog.
     *
     * @example
     * html```
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.close()">Close Dialog</button>
     * ```
     */
    close() {
        if (!this.collapsed) {
            this.toggleDirective.close();
        }
    }
    /**
     * Toggles the date range picker's dropdown or dialog
     *
     * @example
     * html```
     * <igx-date-range-picker #dateRange></igx-date-range-picker>
     *
     * <button (click)="dateRange.toggle()">Toggle Dialog</button>
     * ```
     */
    toggle(overlaySettings) {
        if (!this.collapsed) {
            this.close();
        }
        else {
            this.open(overlaySettings);
        }
    }
    /**
     * Gets calendar state.
     *
     * ```typescript
     * let state = this.dateRange.collapsed;
     * ```
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * The currently selected value / range from the calendar
     *
     * @remarks
     * The current value is of type `DateRange`
     *
     * @example
     * ```typescript
     * const newValue: DateRange = { start: new Date("2/2/2012"), end: new Date("3/3/2013")};
     * this.dateRangePicker.value = newValue;
     * ```
     */
    get value() {
        return this._value;
    }
    set value(value) {
        this.updateValue(value);
        this.onChangeCallback(value);
    }
    updateValue(value) {
        this._value = value ? value : null;
        this.updateInputs();
    }
    /**
     * Selects a range of dates. If no `endDate` is passed, range is 1 day (only `startDate`)
     *
     * @example
     * ```typescript
     * public selectFiveDayRange() {
     *  const inFiveDays = new Date(new Date().setDate(today.getDate() + 5));
     *  const today = new Date();
     *  this.dateRange.selectRange(today, inFiveDays);
     * }
     * ```
     */
    selectRange(startDate, endDate) {
        endDate = endDate !== null && endDate !== void 0 ? endDate : startDate;
        const dateRange = [startDate, endDate];
        this.calendar.selectDate(dateRange);
        this.handleSelection(dateRange);
    }
    /** @hidden @internal */
    writeValue(value) {
        this.updateValue(value);
    }
    /** @hidden @internal */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /** @hidden @internal */
    registerOnTouched(fn) {
        this.onTouchCallback = fn;
    }
    /** @hidden @internal */
    validate(control) {
        const value = control.value;
        if (value) {
            const min = DatePickerUtil.parseDate(this.minValue);
            const max = DatePickerUtil.parseDate(this.maxValue);
            const start = DatePickerUtil.parseDate(value.start);
            const end = DatePickerUtil.parseDate(value.end);
            if (min && start && DatePickerUtil.lessThanMinValue(start, min, false)) {
                return { 'minValue': true };
            }
            if (min && end && DatePickerUtil.lessThanMinValue(end, min, false)) {
                return { 'minValue': true };
            }
            if (max && start && DatePickerUtil.greaterThanMaxValue(start, max, false)) {
                return { 'maxValue': true };
            }
            if (max && end && DatePickerUtil.greaterThanMaxValue(end, max, false)) {
                return { 'maxValue': true };
            }
        }
        // TODO: fix what happens on blur and ensure on blur the value is either null or with both start and end filled
        return null;
    }
    /** @hidden @internal */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /** @hidden @internal */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /** @hidden @internal */
    get separatorClass() {
        return this.getComponentDensityClass('igx-date-range-picker__label');
    }
    /** @hidden */
    ngOnInit() {
        this._ngControl = this._injector.get(NgControl, null);
    }
    /** @hidden */
    ngAfterViewInit() {
        if (this.mode === InteractionMode.DropDown) {
            this.attachOnKeydown();
        }
        this.subscribeToDateEditorEvents();
        this.configPositionStrategy();
        this.configOverlaySettings();
        this.attachOnTouched();
        const subsToClicked = () => {
            this.$toggleClickNotifier.next();
            this.toggleComponents.forEach(toggle => {
                toggle.clicked.pipe(takeUntil(this.$toggleClickNotifier)).subscribe(() => this.open());
            });
        };
        this.toggleComponents.changes.pipe(takeUntil(this.$destroy)).subscribe(() => subsToClicked());
        subsToClicked();
        this.setRequiredToInputs();
        if (this._ngControl) {
            this._statusChanges$ = this._ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this.initialSetValue();
        this.updateInputs();
    }
    /** @hidden @internal */
    ngOnChanges(changes) {
        if (changes['locale']) {
            this.inputFormat = DatePickerUtil.getDefaultInputFormat(this.locale || 'en') || DatePickerUtil.DEFAULT_INPUT_FORMAT;
        }
    }
    /** @hidden @internal */
    ngOnDestroy() {
        this.$destroy.next();
        this.$destroy.complete();
        this.$toggleClickNotifier.next();
        this.$toggleClickNotifier.complete();
    }
    /** @hidden @internal */
    handleOpening(event) {
        this.onOpening.emit(event);
        this._collapsed = false;
    }
    /** @hidden @internal */
    handleOpened() {
        this.calendar.daysView.focusActiveDate();
        this.onOpened.emit({ owner: this });
    }
    /** @hidden @internal */
    handleClosing(event) {
        this.onClosing.emit(event);
        if (this.value && this.value.start && !this.value.end) {
            this.value = { start: this.value.start, end: this.value.start };
        }
        if (this.value && !this.value.start && !this.value.end) {
            this.value = null;
        }
        if (this.mode === InteractionMode.DropDown && event.event && !this.element.nativeElement.contains(event.event.target)) {
            // outside click
            this.updateValidityOnBlur();
        }
        else {
            // input click
            this.focusInput();
        }
    }
    updateValidityOnBlur() {
        this.onTouchCallback();
        if (this._ngControl) {
            if (this.hasProjectedInputs) {
                this.projectedInputs.forEach(i => {
                    if (!this._ngControl.valid) {
                        i.updateInputValidity(IgxInputState.INVALID);
                    }
                    else {
                        i.updateInputValidity(IgxInputState.INITIAL);
                    }
                });
            }
            if (this.inputDirective) {
                if (!this._ngControl.valid) {
                    this.inputDirective.valid = IgxInputState.INVALID;
                }
                else {
                    this.inputDirective.valid = IgxInputState.INITIAL;
                }
            }
        }
    }
    focusInput() {
        var _a;
        // TODO: should we always focus start input?
        (_a = this.projectedInputs
            .find(i => i instanceof IgxDateRangeStartComponent)) === null || _a === void 0 ? void 0 : _a.setFocus();
        if (this.inputDirective) {
            this.inputDirective.focus();
        }
    }
    /** @hidden @internal */
    handleClosed() {
        this._collapsed = true;
        this.onClosed.emit({ owner: this });
    }
    /** @hidden @internal */
    onKeyDown(event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                if (event.altKey) {
                    this.close();
                }
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.open();
                }
                break;
            case "Escape" /* ESCAPE */:
            case "Esc" /* ESCAPE_IE */:
                this.close();
                break;
        }
    }
    /** @hidden @internal */
    handleSelection(selectionData) {
        this.value = this.extractRange(selectionData);
        this.rangeSelected.emit(this.value);
    }
    getInputState(focused) {
        if (focused) {
            return this._ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
        }
        else {
            return this._ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
        }
    }
    setRequiredToInputs() {
        // workaround for igxInput setting required
        Promise.resolve().then(() => {
            const isRequired = this.required;
            if (this.inputGroup && this.inputGroup.isRequired !== isRequired) {
                this.inputGroup.isRequired = isRequired;
            }
            else if (this.hasProjectedInputs && this._ngControl) {
                this.projectedInputs.forEach(i => i.isRequired = isRequired);
            }
        });
    }
    updateCalendar() {
        this.calendar.disabledDates = [];
        let minValue = DatePickerUtil.parseDate(this.minValue);
        if (!minValue && this.hasProjectedInputs) {
            const start = this.projectedInputs.filter(i => i instanceof IgxDateRangeStartComponent)[0];
            if (start) {
                minValue = DatePickerUtil.parseDate(start.dateTimeEditor.minValue);
            }
        }
        if (minValue) {
            this.calendar.disabledDates.push({ type: DateRangeType.Before, dateRange: [minValue] });
        }
        let maxValue = DatePickerUtil.parseDate(this.maxValue);
        if (!maxValue && this.hasProjectedInputs) {
            const end = this.projectedInputs.filter(i => i instanceof IgxDateRangeEndComponent)[0];
            if (end) {
                maxValue = DatePickerUtil.parseDate(end.dateTimeEditor.maxValue);
            }
        }
        if (maxValue) {
            this.calendar.disabledDates.push({ type: DateRangeType.After, dateRange: [maxValue] });
        }
        const range = [];
        if (this.value) {
            if (this.value.start) {
                range.push(this.value.start);
            }
            if (this.value.end) {
                range.push(this.value.end);
            }
        }
        if (range.length > 0) {
            this.calendar.selectDate(range);
            this.calendar.viewDate = range[0];
        }
        else {
            this.calendar.deselectDate();
        }
    }
    extractRange(selection) {
        return {
            start: selection[0],
            end: selection.length > 0 ? selection[selection.length - 1] : null
        };
    }
    attachOnKeydown() {
        fromEvent(this.element.nativeElement, 'keydown')
            .pipe(takeUntil(this.$destroy))
            .subscribe((evt) => this.onKeyDown(evt));
    }
    subscribeToDateEditorEvents() {
        if (this.hasProjectedInputs) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent);
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent);
            if (start && end) {
                start.dateTimeEditor.valueChange
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(value => {
                    if (this.value) {
                        this.value = { start: value, end: this.value.end };
                    }
                    else {
                        this.value = { start: value, end: null };
                    }
                    // TODO: should we check start and reset end value
                });
                end.dateTimeEditor.valueChange
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(value => {
                    if (this.value) {
                        this.value = { start: this.value.start, end: value };
                    }
                    else {
                        this.value = { start: null, end: value };
                    }
                });
            }
        }
    }
    attachOnTouched() {
        if (this.hasProjectedInputs) {
            this.projectedInputs.forEach(i => {
                fromEvent(i.dateTimeEditor.nativeElement, 'blur')
                    .pipe(takeUntil(this.$destroy))
                    .subscribe(() => {
                    if (this.collapsed) {
                        this.updateValidityOnBlur();
                    }
                    if (this.value && !this.value.start) {
                        this.value = null;
                    }
                    // TODO: if we have start and have no end should we fill end
                    // as we do on calendar close
                });
            });
        }
        else {
            fromEvent(this.inputDirective.nativeElement, 'blur')
                .pipe(takeUntil(this.$destroy))
                .subscribe(() => {
                if (this.collapsed) {
                    this.updateValidityOnBlur();
                }
            });
        }
    }
    configPositionStrategy() {
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut,
            target: this.element.nativeElement
        };
        this._dropDownOverlaySettings.positionStrategy = new AutoPositionStrategy(this._positionSettings);
    }
    configOverlaySettings() {
        if (this.overlaySettings !== null) {
            this._dropDownOverlaySettings = Object.assign({}, this._dropDownOverlaySettings, this.overlaySettings);
            this._dialogOverlaySettings = Object.assign({}, this._dialogOverlaySettings, this.overlaySettings);
        }
    }
    initialSetValue() {
        // if there is no value, no ngControl but we have inputs we may have value set trough
        // inputs' ngModels - we should generate our initial control value
        if (!this.value && this.hasProjectedInputs && !this._ngControl) {
            const start = this.projectedInputs.find(i => i instanceof IgxDateRangeStartComponent).dateTimeEditor.value;
            const end = this.projectedInputs.find(i => i instanceof IgxDateRangeEndComponent).dateTimeEditor.value;
            this.updateValue({ start, end });
        }
    }
    updateInputs() {
        var _a, _b;
        const start = (_a = this.projectedInputs) === null || _a === void 0 ? void 0 : _a.find(i => i instanceof IgxDateRangeStartComponent);
        const end = (_b = this.projectedInputs) === null || _b === void 0 ? void 0 : _b.find(i => i instanceof IgxDateRangeEndComponent);
        if (start && end && this.value) {
            start.updateInputValue(this.value.start);
            end.updateInputValue(this.value.end);
        }
    }
};
IgxDateRangePickerComponent.ɵfac = function IgxDateRangePickerComponent_Factory(t) { return new (t || IgxDateRangePickerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DisplayDensityToken, 8), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector)); };
IgxDateRangePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: IgxDateRangePickerComponent, selectors: [["igx-date-range-picker"]], contentQueries: function IgxDateRangePickerComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxLabelDirective, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDateRangeSeparatorDirective, true, TemplateRef);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxPickerToggleComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, IgxDateRangeInputsBaseComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.label = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.dateSeparatorTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleComponents = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.projectedInputs = _t);
    } }, viewQuery: function IgxDateRangePickerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(IgxCalendarComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxInputGroupComponent, true);
        ɵngcc0.ɵɵviewQuery(IgxInputDirective, true);
        ɵngcc0.ɵɵviewQuery(IgxToggleDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.calendar = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputGroup = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputDirective = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toggleDirective = _t.first);
    } }, hostVars: 2, hostBindings: function IgxDateRangePickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("igx-date-range-picker", ctx.cssClass);
    } }, inputs: { mode: "mode", monthsViewNumber: "monthsViewNumber", weekStart: "weekStart", doneButtonText: "doneButtonText", placeholder: "placeholder", locale: "locale", minValue: "minValue", maxValue: "maxValue", value: "value", disabled: "disabled", inputFormat: "inputFormat", hideOutsideDays: "hideOutsideDays", formatter: "formatter", overlaySettings: "overlaySettings", displayFormat: "displayFormat" }, outputs: { rangeSelected: "rangeSelected", onOpening: "onOpening", onOpened: "onOpened", onClosing: "onClosing", onClosed: "onClosed" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateRangePickerComponent_1, multi: true },
            { provide: NG_VALIDATORS, useExisting: IgxDateRangePickerComponent_1, multi: true }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c246, decls: 17, vars: 14, consts: [["igxToggle", "", 1, "igx-date-picker", 3, "onOpening", "onOpened", "onClosing", "onClosed"], ["toggle", "toggle"], ["selection", "range", 3, "weekStart", "hideOutsideDays", "monthsViewNumber", "locale", "keydown", "onSelection"], ["calendar", ""], [1, "igx-date-range-picker-buttons"], [4, "ngIf"], [4, "ngTemplateOutlet"], ["singleTemplate", ""], ["startEndTemplate", ""], ["defIcon", ""], ["defDateSeparatorTemplate", ""], ["defTemplate", ""], ["igxButton", "", "type", "button", 3, "click"], [1, "content-wrap", 3, "click"], [3, "className"], [3, "click"], ["igxInput", "", "type", "text", "readonly", "", "role", "combobox", "aria-haspopup", "grid", 3, "placeholder", "value"], ["singleInput", ""], ["ngProjectAs", "[igxLabel]", 5, ["", "igxLabel", ""]], ["ngProjectAs", "igx-prefix", 5, ["igx-prefix"]], ["ngProjectAs", "igx-suffix", 5, ["igx-suffix"]], ["ngProjectAs", "igx-hint", 5, ["igx-hint"]]], template: function IgxDateRangePickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c245);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("onOpening", function IgxDateRangePickerComponent_Template_div_onOpening_0_listener($event) { return ctx.handleOpening($event); })("onOpened", function IgxDateRangePickerComponent_Template_div_onOpened_0_listener() { return ctx.handleOpened(); })("onClosing", function IgxDateRangePickerComponent_Template_div_onClosing_0_listener($event) { return ctx.handleClosing($event); })("onClosed", function IgxDateRangePickerComponent_Template_div_onClosed_0_listener() { return ctx.handleClosed(); });
        ɵngcc0.ɵɵelementStart(2, "igx-calendar", 2, 3);
        ɵngcc0.ɵɵlistener("keydown", function IgxDateRangePickerComponent_Template_igx_calendar_keydown_2_listener($event) { return ctx.onKeyDown($event); })("onSelection", function IgxDateRangePickerComponent_Template_igx_calendar_onSelection_2_listener($event) { return ctx.handleSelection($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, IgxDateRangePickerComponent_ng_container_5_Template, 3, 1, "ng-container", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, IgxDateRangePickerComponent_ng_container_6_Template, 1, 0, "ng-container", 6);
        ɵngcc0.ɵɵtemplate(7, IgxDateRangePickerComponent_ng_template_7_Template, 2, 0, "ng-template", null, 7, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(9, IgxDateRangePickerComponent_ng_template_9_Template, 4, 2, "ng-template", null, 8, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(11, IgxDateRangePickerComponent_ng_template_11_Template, 2, 0, "ng-template", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(13, IgxDateRangePickerComponent_ng_template_13_Template, 1, 1, "ng-template", null, 10, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(15, IgxDateRangePickerComponent_ng_template_15_Template, 13, 9, "ng-template", null, 11, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r1706 = ɵngcc0.ɵɵreference(10);
        const _r1712 = ɵngcc0.ɵɵreference(16);
        ɵngcc0.ɵɵstyleProp("flex-basis", ctx.monthsViewNumber * 320 + "px")("width", ctx.monthsViewNumber * 320 + "px")("max-width", "90vw");
        ɵngcc0.ɵɵclassProp("igx-date-picker--dropdown", ctx.mode === "dropdown");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("weekStart", ctx.weekStart)("hideOutsideDays", ctx.hideOutsideDays)("monthsViewNumber", ctx.monthsViewNumber)("locale", ctx.locale);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.mode === "dialog");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.hasProjectedInputs ? _r1706 : _r1712);
    } }, directives: [IgxToggleDirective,
        IgxCalendarComponent, ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, IgxButtonDirective,
        IgxIconComponent,
        IgxInputGroupComponent,
        IgxInputDirective,
        IgxPrefixDirective], pipes: [DateRangePickerFormatPipe], encapsulation: 2 });
IgxDateRangePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [LOCALE_ID,] }] },
    { type: Injector }
];
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "mode", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "monthsViewNumber", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "hideOutsideDays", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "weekStart", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "locale", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "formatter", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "doneButtonText", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "overlaySettings", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "displayFormat", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "inputFormat", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "minValue", null);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "maxValue", null);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "disabled", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "placeholder", void 0);
__decorate([
    Output()
], IgxDateRangePickerComponent.prototype, "rangeSelected", void 0);
__decorate([
    Output()
], IgxDateRangePickerComponent.prototype, "onOpening", void 0);
__decorate([
    Output()
], IgxDateRangePickerComponent.prototype, "onOpened", void 0);
__decorate([
    Output()
], IgxDateRangePickerComponent.prototype, "onClosing", void 0);
__decorate([
    Output()
], IgxDateRangePickerComponent.prototype, "onClosed", void 0);
__decorate([
    HostBinding('class.igx-date-range-picker')
], IgxDateRangePickerComponent.prototype, "cssClass", void 0);
__decorate([
    ViewChild(IgxCalendarComponent)
], IgxDateRangePickerComponent.prototype, "calendar", void 0);
__decorate([
    ViewChild(IgxInputGroupComponent)
], IgxDateRangePickerComponent.prototype, "inputGroup", void 0);
__decorate([
    ViewChild(IgxInputDirective)
], IgxDateRangePickerComponent.prototype, "inputDirective", void 0);
__decorate([
    ViewChild(IgxToggleDirective)
], IgxDateRangePickerComponent.prototype, "toggleDirective", void 0);
__decorate([
    ContentChildren(IgxPickerToggleComponent, { descendants: true })
], IgxDateRangePickerComponent.prototype, "toggleComponents", void 0);
__decorate([
    ContentChildren(IgxDateRangeInputsBaseComponent)
], IgxDateRangePickerComponent.prototype, "projectedInputs", void 0);
__decorate([
    ContentChild(IgxLabelDirective)
], IgxDateRangePickerComponent.prototype, "label", void 0);
__decorate([
    ContentChild(IgxDateRangeSeparatorDirective, { read: TemplateRef })
], IgxDateRangePickerComponent.prototype, "dateSeparatorTemplate", void 0);
__decorate([
    Input()
], IgxDateRangePickerComponent.prototype, "value", null);
IgxDateRangePickerComponent = IgxDateRangePickerComponent_1 = __decorate([ __param(1, Optional()), __param(1, Inject(DisplayDensityToken)),
    __param(2, Inject(LOCALE_ID))
], IgxDateRangePickerComponent);

/**
 * @hidden
 */
let IgxDateRangePickerModule = class IgxDateRangePickerModule {
};
IgxDateRangePickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: IgxDateRangePickerModule });
IgxDateRangePickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function IgxDateRangePickerModule_Factory(t) { return new (t || IgxDateRangePickerModule)(); }, imports: [[
            CommonModule,
            IgxIconModule,
            IgxButtonModule,
            IgxToggleModule,
            IgxCalendarModule,
            IgxInputGroupModule,
            IgxDateTimeEditorModule
        ],
        IgxDateTimeEditorModule] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationToggleDirective, [{
        type: Directive,
        args: [{ selector: '[igxNavToggle]' }]
    }], function () { return [{ type: IgxNavigationService }]; }, { toggleNavigationDrawer: [{
            type: HostListener,
            args: ['click']
        }], target: [{
            type: Input,
            args: ['igxNavToggle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationCloseDirective, [{
        type: Directive,
        args: [{ selector: '[igxNavClose]' }]
    }], function () { return [{ type: IgxNavigationService }]; }, { closeNavigationDrawer: [{
            type: HostListener,
            args: ['click']
        }], target: [{
            type: Input,
            args: ['igxNavClose']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxNavigationModule, { declarations: [IgxNavigationCloseDirective,
        IgxNavigationToggleDirective], exports: [IgxNavigationCloseDirective,
        IgxNavigationToggleDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                providers: [IgxNavigationService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PlatformUtil, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GridBaseAPIService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridFilteringPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridFiltering',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
const ɵIgxCsvExporterService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxCsvExporterService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCsvExporterService, [{
        type: Injectable
    }], null, { onExportEnded: [{
            type: Output
        }] }); })();
const ɵIgxExcelExporterService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxExcelExporterService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelExporterService, [{
        type: Injectable
    }], null, { onExportEnded: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxOverlayService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }, { type: ɵngcc1.AnimationBuilder }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBaseTransactionService, [{
        type: Injectable
    }], function () { return []; }, null); })();
const ɵIgxTransactionService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxTransactionService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTransactionService, [{
        type: Injectable
    }], null, null); })();
const ɵIgxHierarchicalTransactionService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalTransactionService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalTransactionService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToggleDirective, [{
        type: Directive,
        args: [{
                exportAs: 'toggle',
                selector: '[igxToggle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { onOpened: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onAppended: [{
            type: Output
        }], hiddenClass: [{
            type: HostBinding,
            args: ['class.igx-toggle--hidden']
        }, {
            type: HostBinding,
            args: ['attr.aria-hidden']
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.igx-toggle']
        }], id: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToggleActionDirective, [{
        type: Directive,
        args: [{
                exportAs: 'toggle-action',
                selector: '[igxToggleAction]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { target: [{
            type: Input,
            args: ['igxToggleAction']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], overlaySettings: [{
            type: Input
        }], outlet: [{
            type: Input,
            args: ['igxToggleOutlet']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxOverlayOutletDirective, [{
        type: Directive,
        args: [{
                exportAs: 'overlay-outlet',
                selector: '[igxOverlayOutlet]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxToggleModule, { declarations: [IgxToggleDirective,
        IgxToggleActionDirective,
        IgxOverlayOutletDirective], exports: [IgxToggleDirective,
        IgxToggleActionDirective,
        IgxOverlayOutletDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToggleModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                providers: [IgxNavigationService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectionAPIService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-drop-down-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-drop-down-item"></ng-content>
    `
            }]
    }], function () { return []; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], groupClass: [{
            type: HostBinding,
            args: ['class.igx-drop-down__group']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: [`attr.aria-disabled`]
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__group--disabled']
        }], labelledBy: [{
            type: HostBinding,
            args: [`attr.aria-labelledby`]
        }], label: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownItemBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDropDownItemBase]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DROPDOWN_BASE]
            }] }, { type: ɵngcc0.ElementRef }, { type: IgxDropDownGroupComponent, decorators: [{
                type: Optional
            }] }, { type: IgxSelectionAPIService, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IgxSelectionAPIService]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], selectedChange: [{
            type: Output
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], index: [{
            type: Input
        }], itemStyle: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item']
        }], itemStyleCosy: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item--cosy']
        }], itemStyleCompact: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item--compact']
        }], selected: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__item--selected']
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-drop-down__item--focused']
        }], headerClassCosy: [{
            type: HostBinding,
            args: ['class.igx-drop-down__header--cosy']
        }], headerClassCompact: [{
            type: HostBinding,
            args: ['class.igx-drop-down__header--compact']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__item--disabled']
        }], clicked: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], value: [{
            type: Input
        }], isHeader: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-drop-down__header']
        }] }); })();
const ɵIgxDropDownItemComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxDropDownItemComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-drop-down-item',
                template: "<ng-content></ng-content>"
            }]
    }], null, { setTabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisplayDensityBase, [{
        type: Directive,
        args: [{
                selector: '[igxDisplayDensityBase]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { onDensityChanged: [{
            type: Output
        }], displayDensity: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDisplayDensityModule, { declarations: [DisplayDensityBase], exports: [DisplayDensityBase] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDisplayDensityModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    DisplayDensityBase
                ],
                exports: [
                    DisplayDensityBase
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDropDownBase]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { onSelection: [{
            type: Output
        }], maxHeight: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['style.maxHeight']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-drop-down']
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], id: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DisplayContainerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-display-container',
                template: `
        <ng-template
            #display_container
            igxScrollInertia
            [IgxScrollInertiaScrollContainer]="scrollContainer"
            [IgxScrollInertiaDirection]="scrollDirection">
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ViewContainerRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class']
        }], notVirtual: [{
            type: HostBinding,
            args: ['class.igx-display-container--inactive']
        }], _vcr: [{
            type: ViewChild,
            args: ['display_container', { read: ViewContainerRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualHelperBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxVirtualHelperBase]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { onScroll: [{
            type: HostListener,
            args: ['scroll', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HVirtualHelperComponent, [{
        type: Component,
        args: [{
                selector: 'igx-horizontal-virtual-helper',
                template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="size"></div>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], _vcr: [{
            type: ViewChild,
            args: ['horizontal_container', { read: ViewContainerRef, static: true }]
        }], width: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(VirtualHelperComponent, [{
        type: Component,
        args: [{
                selector: 'igx-virtual-helper',
                template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="size"></div>'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClasses: [{
            type: HostBinding,
            args: ['class']
        }], scrollWidth: [{
            type: HostBinding,
            args: ['style.width.px']
        }], scrollTop: [{
            type: HostBinding,
            args: ['scrollTop']
        }], _vcr: [{
            type: ViewChild,
            args: ['container', { read: ViewContainerRef, static: true }]
        }], itemsLength: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxScrollInertiaDirective, [{
        type: Directive,
        args: [{ selector: '[igxScrollInertia]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { wheelStep: [{
            type: Input
        }], inertiaStep: [{
            type: Input
        }], swipeToleranceX: [{
            type: Input
        }], inertiaDeltaY: [{
            type: Input
        }], inertiaDeltaX: [{
            type: Input
        }], inertiaDuration: [{
            type: Input
        }], IgxScrollInertiaDirection: [{
            type: Input
        }], IgxScrollInertiaScrollContainer: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxScrollInertiaModule, { declarations: function () { return [IgxScrollInertiaDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxScrollInertiaDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxScrollInertiaModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxScrollInertiaDirective],
                exports: [IgxScrollInertiaDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfSyncService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfScrollSyncService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfDirective, [{
        type: Directive,
        args: [{ selector: '[igxFor][igxForOf]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: IgxForOfScrollSyncService }]; }, { igxForScrollOrientation: [{
            type: Input
        }], onChunkLoad: [{
            type: Output
        }], onScrollbarVisibilityChanged: [{
            type: Output
        }], onContentSizeChange: [{
            type: Output
        }], onDataChanged: [{
            type: Output
        }], onBeforeViewDestroyed: [{
            type: Output
        }], onChunkPreload: [{
            type: Output
        }], igxForTotalItemCount: [{
            type: Input
        }], igxForSizePropName: [{
            type: Input
        }], igxForOf: [{
            type: Input
        }], igxForTrackBy: [{
            type: Input
        }], igxForScrollContainer: [{
            type: Input
        }], igxForContainerSize: [{
            type: Input
        }], igxForItemSize: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridForOfDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridFor][igxGridForOf]'
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: IgxForOfScrollSyncService }, { type: IgxForOfSyncService }]; }, { onDataChanging: [{
            type: Output
        }], igxGridForOf: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxForOfModule, { declarations: function () { return [IgxForOfDirective,
        IgxGridForOfDirective,
        DisplayContainerComponent,
        VirtualHelperComponent,
        HVirtualHelperComponent,
        VirtualHelperBaseDirective]; }, imports: function () { return [IgxScrollInertiaModule,
        CommonModule]; }, exports: function () { return [IgxForOfDirective,
        IgxGridForOfDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxForOfModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent,
                    HVirtualHelperComponent, VirtualHelperBaseDirective],
                entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                exports: [IgxForOfDirective, IgxGridForOfDirective],
                imports: [IgxScrollInertiaModule, CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownComponent, [{
        type: Component,
        args: [{
                selector: 'igx-drop-down',
                template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\" (onAppended)=\"onToggleContentAppended()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], allowItemsFocus: [{
            type: Input
        }], id: [{
            type: Input
        }], virtDir: [{
            type: ContentChild,
            args: [IgxForOfDirective, { read: IgxForOfDirective }]
        }], toggleDirective: [{
            type: ViewChild,
            args: [IgxToggleDirective, { static: true }]
        }], scrollContainerRef: [{
            type: ViewChild,
            args: ['scrollContainer', { static: true }]
        }], children: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxDropDownItemComponent), { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownItemNavigationDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDropDownItemNavigation]'
            }]
    }], function () { return [{ type: IgxDropDownBaseDirective, decorators: [{
                type: Self
            }, {
                type: Optional
            }, {
                type: Inject,
                args: [IGX_DROPDOWN_BASE]
            }] }]; }, { target: [{
            type: Input,
            args: ['igxDropDownItemNavigation']
        }], handleKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDropDownModule, { declarations: function () { return [IgxDropDownBaseDirective,
        IgxDropDownComponent,
        IgxDropDownItemBaseDirective,
        IgxDropDownItemComponent,
        IgxDropDownGroupComponent,
        IgxDropDownItemNavigationDirective]; }, imports: function () { return [CommonModule,
        IgxToggleModule]; }, exports: function () { return [IgxDropDownComponent,
        IgxDropDownItemComponent,
        IgxDropDownGroupComponent,
        IgxDropDownItemNavigationDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDownModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDropDownBaseDirective,
                    IgxDropDownComponent,
                    IgxDropDownItemBaseDirective,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                exports: [
                    IgxDropDownComponent,
                    IgxDropDownItemComponent,
                    IgxDropDownGroupComponent,
                    IgxDropDownItemNavigationDirective
                ],
                imports: [
                    CommonModule,
                    IgxToggleModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHintDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-hint,[igxHint]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { isPositionStart: [{
            type: HostBinding,
            args: ['class.igx-input-group__hint-item--start']
        }], isPositionEnd: [{
            type: HostBinding,
            args: ['class.igx-input-group__hint-item--end']
        }], position: [{
            type: Input,
            args: ['position']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxInputDirective, [{
        type: Directive,
        args: [{
                selector: '[igxInput]',
                exportAs: 'igxInput'
            }]
    }], function () { return [{ type: IgxInputGroupBase }, { type: ɵngcc3.NgModel, decorators: [{
                type: Optional
            }, {
                type: Self
            }, {
                type: Inject,
                args: [NgModel]
            }] }, { type: ɵngcc3.FormControlName, decorators: [{
                type: Optional
            }, {
                type: Self
            }, {
                type: Inject,
                args: [FormControlName]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isInput: [{
            type: HostBinding,
            args: ['class.igx-input-group__input']
        }], isTextArea: [{
            type: HostBinding,
            args: ['class.igx-input-group__textarea']
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], required: [{
            type: Input
        }], onFocus: [{
            type: HostListener,
            args: ['focus', ['$event']]
        }], onBlur: [{
            type: HostListener,
            args: ['blur', ['$event']]
        }], onInput: [{
            type: HostListener,
            args: ['input']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLabelDirective, [{
        type: Directive,
        args: [{
                selector: '[igxLabel]'
            }]
    }], function () { return []; }, { defaultClass: [{
            type: HostBinding,
            args: ['class.igx-input-group__label']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPrefixDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-prefix,[igxPrefix]'
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxPrefixModule, { declarations: [IgxPrefixDirective], exports: [IgxPrefixDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPrefixModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxPrefixDirective],
                exports: [IgxPrefixDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSuffixDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-suffix,[igxSuffix]'
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSuffixModule, { declarations: [IgxSuffixDirective], exports: [IgxSuffixDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSuffixModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxSuffixDirective],
                exports: [IgxSuffixDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxInputGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-input-group',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #inputBundle>\n    <ng-container *ngIf=\"!isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container *ngIf=\"isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n        <div *ngIf=\"!isTypeBootstrap; else inputBundle\" class=\"igx-input-group__bundle-main\">\n\n            <ng-container *ngIf=\"!isNotMaterial\">\n                <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            </ng-container>\n\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
                providers: [{ provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.igx-input-group']
        }], hasPlaceholder: [{
            type: HostBinding,
            args: ['class.igx-input-group--placeholder']
        }], isRequired: [{
            type: HostBinding,
            args: ['class.igx-input-group--required']
        }], isFocused: [{
            type: HostBinding,
            args: ['class.igx-input-group--focused']
        }], isBox: [{
            type: HostBinding,
            args: ['class.igx-input-group--box']
        }], isBorder: [{
            type: HostBinding,
            args: ['class.igx-input-group--border']
        }], isSearch: [{
            type: HostBinding,
            args: ['class.igx-input-group--search']
        }], isFluentSearch: [{
            type: HostBinding,
            args: ['class.igx-input-group--fluent-search']
        }], isFluent: [{
            type: HostBinding,
            args: ['class.igx-input-group--fluent']
        }], isBootstrap: [{
            type: HostBinding,
            args: ['class.igx-input-group--bootstrap']
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-input-group--disabled']
        }, {
            type: Input
        }], suppressInputAutofocus: [{
            type: Input
        }], hasWarning: [{
            type: HostBinding,
            args: ['class.igx-input-group--warning']
        }], validClass: [{
            type: HostBinding,
            args: ['class.igx-input-group--valid']
        }], invalidClass: [{
            type: HostBinding,
            args: ['class.igx-input-group--invalid']
        }], isFilled: [{
            type: HostBinding,
            args: ['class.igx-input-group--filled']
        }], isDisplayDensityCosy: [{
            type: HostBinding,
            args: ['class.igx-input-group--cosy']
        }], isDisplayDensityComfortable: [{
            type: HostBinding,
            args: ['class.igx-input-group--comfortable']
        }], isDisplayDensityCompact: [{
            type: HostBinding,
            args: ['class.igx-input-group--compact']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onPointerDown: [{
            type: HostListener,
            args: ['pointerdown', ['$event']]
        }], type: [{
            type: Input,
            args: ['type']
        }], supressInputAutofocus: [{
            type: Input
        }], hints: [{
            type: ContentChildren,
            args: [IgxHintDirective, { read: IgxHintDirective }]
        }], input: [{
            type: ContentChild,
            args: [IgxInputDirective, { read: IgxInputDirective, static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxInputGroupModule, { declarations: function () { return [IgxInputGroupComponent,
        IgxHintDirective,
        IgxInputDirective,
        IgxLabelDirective]; }, imports: function () { return [CommonModule,
        IgxPrefixModule,
        IgxSuffixModule]; }, exports: function () { return [IgxInputGroupComponent,
        IgxHintDirective,
        IgxInputDirective,
        IgxLabelDirective,
        IgxPrefixModule,
        IgxSuffixModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxInputGroupModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective
                ],
                exports: [
                    IgxInputGroupComponent,
                    IgxHintDirective,
                    IgxInputDirective,
                    IgxLabelDirective,
                    IgxPrefixModule,
                    IgxSuffixModule
                ],
                imports: [
                    CommonModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAutocompleteDirective, [{
        type: Directive,
        args: [{
                selector: '[igxAutocomplete]'
            }]
    }], function () { return [{ type: ɵngcc3.NgModel, decorators: [{
                type: Self
            }, {
                type: Optional
            }, {
                type: Inject,
                args: [NgModel]
            }] }, { type: ɵngcc3.FormControlName, decorators: [{
                type: Self
            }, {
                type: Optional
            }, {
                type: Inject,
                args: [FormControlName]
            }] }, { type: IgxInputGroupComponent, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { disabled: [{
            type: Input,
            args: ['igxAutocompleteDisabled']
        }], onItemSelected: [{
            type: Output
        }], autofill: [{
            type: HostBinding,
            args: ['attr.autocomplete']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], hasPopUp: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], ariaActiveDescendant: [{
            type: HostBinding,
            args: ['attr.aria-activedescendant']
        }], ariaAutocomplete: [{
            type: HostBinding,
            args: ['attr.aria-autocomplete']
        }], onInput: [{
            type: HostListener,
            args: ['input']
        }], onArrowDown: [{
            type: HostListener,
            args: ['keydown.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Alt.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.ArrowUp', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Alt.ArrowUp', ['$event']]
        }], onTab: [{
            type: HostListener,
            args: ['keydown.Tab']
        }, {
            type: HostListener,
            args: ['keydown.Shift.Tab']
        }], target: [{
            type: Input,
            args: ['igxAutocomplete']
        }], autocompleteSettings: [{
            type: Input,
            args: ['igxAutocompleteSettings']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxAutocompleteModule, { declarations: function () { return [IgxAutocompleteDirective]; }, imports: function () { return [IgxDropDownModule,
        CommonModule]; }, exports: function () { return [IgxAutocompleteDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAutocompleteModule, [{
        type: NgModule,
        args: [{
                imports: [IgxDropDownModule, CommonModule],
                declarations: [IgxAutocompleteDirective],
                exports: [IgxAutocompleteDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[igxButton]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { buttonClick: [{
            type: Output
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], selected: [{
            type: Input
        }], type: [{
            type: Input,
            args: ['igxButton']
        }], color: [{
            type: Input,
            args: ['igxButtonColor']
        }], background: [{
            type: Input,
            args: ['igxButtonBackground']
        }], label: [{
            type: Input,
            args: ['igxLabel']
        }], disabled: [{
            type: Input
        }], cssClassCosy: [{
            type: HostBinding,
            args: ['class.igx-button--cosy']
        }], cssClassCompact: [{
            type: HostBinding,
            args: ['class.igx-button--compact']
        }], cssClassCosyFab: [{
            type: HostBinding,
            args: ['class.igx-button--fab-cosy']
        }], cssClassCompactFab: [{
            type: HostBinding,
            args: ['class.igx-button--fab-compact']
        }], disabledAttribute: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxButtonModule, { declarations: [IgxButtonDirective], exports: [IgxButtonDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxButtonDirective],
                exports: [IgxButtonDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDividerDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-divider'
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], _inset: [{
            type: Input,
            args: ['inset']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], type: [{
            type: HostBinding,
            args: ['class.igx-divider']
        }, {
            type: Input
        }], middle: [{
            type: HostBinding,
            args: ['class.igx-divider--inset']
        }, {
            type: Input
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-divider--vertical']
        }, {
            type: Input
        }], isDashed: [{
            type: HostBinding,
            args: ['class.igx-divider--dashed']
        }], inset: [{
            type: HostBinding,
            args: ['style.margin']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDividerModule, { declarations: [IgxDividerDirective], exports: [IgxDividerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDividerModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDividerDirective],
                exports: [IgxDividerDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDragHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { baseClass: [{
            type: HostBinding,
            args: ['class.igx-drag__handle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragIgnoreDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDragIgnore]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { baseClass: [{
            type: HostBinding,
            args: ['class.igx-drag__ignore']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragDirective, [{
        type: Directive,
        args: [{
                exportAs: 'drag',
                selector: '[igxDrag]'
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }]; }, { dragTolerance: [{
            type: Input
        }], dragDirection: [{
            type: Input
        }], ghost: [{
            type: Input
        }], ghostClass: [{
            type: Input
        }], dragStart: [{
            type: Output
        }], dragMove: [{
            type: Output
        }], dragEnd: [{
            type: Output
        }], dragClick: [{
            type: Output
        }], ghostCreate: [{
            type: Output
        }], ghostDestroy: [{
            type: Output
        }], transitioned: [{
            type: Output
        }], baseClass: [{
            type: HostBinding,
            args: ['class.igx-drag']
        }], selectDisabled: [{
            type: HostBinding,
            args: ['class.igx-drag--select-disabled']
        }], ghostOffsetX: [{
            type: Input
        }], ghostOffsetY: [{
            type: Input
        }], data: [{
            type: Input,
            args: ['igxDrag']
        }], dragChannel: [{
            type: Input
        }], ghostTemplate: [{
            type: Input
        }], ghostHost: [{
            type: Input
        }], dragHandles: [{
            type: ContentChildren,
            args: [IgxDragHandleDirective]
        }], dragIgnoredElems: [{
            type: ContentChildren,
            args: [IgxDragIgnoreDirective]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDropDirective, [{
        type: Directive,
        args: [{
                exportAs: 'drop',
                selector: '[igxDrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { enter: [{
            type: Output
        }], over: [{
            type: Output
        }], leave: [{
            type: Output
        }], dropped: [{
            type: Output
        }], droppable: [{
            type: HostBinding,
            args: ['attr.droppable']
        }], dragover: [{
            type: HostBinding,
            args: ['class.dragOver']
        }], dropStrategy: [{
            type: Input
        }], onDragDrop: [{
            type: HostListener,
            args: ['igxDrop', ['$event']]
        }], data: [{
            type: Input,
            args: ['igxDrop']
        }], dropChannel: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDragDropModule, { declarations: [IgxDragDirective,
        IgxDropDirective,
        IgxDragHandleDirective,
        IgxDragIgnoreDirective], exports: [IgxDragDirective,
        IgxDropDirective,
        IgxDragHandleDirective,
        IgxDragIgnoreDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragDropModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective],
                exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective, IgxDragIgnoreDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFilter]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { filtering: [{
            type: Output
        }], filtered: [{
            type: Output
        }], filterOptions: [{
            type: Input,
            args: ['igxFilter']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterPipe, [{
        type: Pipe,
        args: [{
                name: 'igxFilter',
                pure: false
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxFilterModule, { declarations: function () { return [IgxFilterDirective,
        IgxFilterPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxFilterDirective,
        IgxFilterPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxFilterDirective, IgxFilterPipe],
                exports: [IgxFilterDirective, IgxFilterPipe],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFocusDirective, [{
        type: Directive,
        args: [{
                exportAs: 'igxFocus',
                selector: '[igxFocus]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: Array, decorators: [{
                type: Inject,
                args: [NG_VALUE_ACCESSOR]
            }, {
                type: Self
            }, {
                type: Optional
            }] }]; }, { focused: [{
            type: Input,
            args: ['igxFocus']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxFocusModule, { declarations: [IgxFocusDirective], exports: [IgxFocusDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFocusModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxFocusDirective],
                exports: [IgxFocusDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLayoutDirective, [{
        type: Directive,
        args: [{
                selector: '[igxLayout]'
            }]
    }], function () { return []; }, { dir: [{
            type: Input,
            args: ['igxLayoutDir']
        }], reverse: [{
            type: Input,
            args: ['igxLayoutReverse']
        }], wrap: [{
            type: Input,
            args: ['igxLayoutWrap']
        }], justify: [{
            type: Input,
            args: ['igxLayoutJustify']
        }], itemAlign: [{
            type: Input,
            args: ['igxLayoutItemAlign']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], flexwrap: [{
            type: HostBinding,
            args: ['style.flex-wrap']
        }], justifycontent: [{
            type: HostBinding,
            args: ['style.justify-content']
        }], align: [{
            type: HostBinding,
            args: ['style.align-items']
        }], direction: [{
            type: HostBinding,
            args: ['style.flex-direction']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFlexDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFlex]'
            }]
    }], function () { return []; }, { grow: [{
            type: Input,
            args: ['igxFlexGrow']
        }], shrink: [{
            type: Input,
            args: ['igxFlexShrink']
        }], flex: [{
            type: Input,
            args: ['igxFlex']
        }], order: [{
            type: Input,
            args: ['igxFlexOrder']
        }], basis: [{
            type: Input,
            args: ['igxFlexBasis']
        }], style: [{
            type: HostBinding,
            args: ['style.flex']
        }], itemorder: [{
            type: HostBinding,
            args: ['style.order']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxLayoutModule, { declarations: [IgxFlexDirective,
        IgxLayoutDirective], exports: [IgxFlexDirective,
        IgxLayoutDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLayoutModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxFlexDirective, IgxLayoutDirective],
                exports: [IgxFlexDirective, IgxLayoutDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MaskParsingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMaskDirective, [{
        type: Directive,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective_1, multi: true }],
                selector: '[igxMask]',
                exportAs: 'igxMask'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: MaskParsingService }, { type: ɵngcc0.Renderer2 }]; }, { promptChar: [{
            type: Input
        }], onValueChange: [{
            type: Output
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onInputChanged: [{
            type: HostListener,
            args: ['input']
        }], onPaste: [{
            type: HostListener,
            args: ['paste']
        }], onFocus: [{
            type: HostListener,
            args: ['focus']
        }], onBlur: [{
            type: HostListener,
            args: ['blur', ['$event.target.value']]
        }], onDragEnter: [{
            type: HostListener,
            args: ['dragenter']
        }], onDragLeave: [{
            type: HostListener,
            args: ['dragleave']
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }], mask: [{
            type: Input,
            args: ['igxMask']
        }], includeLiterals: [{
            type: Input
        }], displayValuePipe: [{
            type: Input
        }], focusedValuePipe: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxMaskModule, { declarations: function () { return [IgxMaskDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxMaskDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMaskModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxMaskDirective],
                exports: [IgxMaskDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRadioComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioComponent_1, multi: true }],
                selector: 'igx-radio',
                template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (click)=\"_onRadioClick($event)\"\n    (change)=\"_onRadioChange($event)\"\n    (focus)=\"onFocus()\"\n    (blur)=\"onBlur()\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel\n    [id]=\"labelId\"\n    [class]=\"labelClass\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], labelId: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }], required: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-radio']
        }], checked: [{
            type: HostBinding,
            args: ['class.igx-radio--checked']
        }, {
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-radio--disabled']
        }, {
            type: Input
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-radio--focused']
        }], nativeRadio: [{
            type: ViewChild,
            args: ['radio', { static: true }]
        }], nativeLabel: [{
            type: ViewChild,
            args: ['nativeLabel', { static: true }]
        }], placeholderLabel: [{
            type: ViewChild,
            args: ['placeholderLabel', { static: true }]
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRippleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRipple]'
            }]
    }], function () { return [{ type: ɵngcc1.AnimationBuilder }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { rippleTarget: [{
            type: Input,
            args: ['igxRippleTarget']
        }], rippleDuration: [{
            type: Input,
            args: ['igxRippleDuration']
        }], rippleDisabled: [{
            type: Input,
            args: ['igxRippleDisabled']
        }], centered: [{
            type: Input,
            args: ['igxRippleCentered']
        }], onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], rippleColor: [{
            type: Input,
            args: ['igxRipple']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxRippleModule, { declarations: [IgxRippleDirective], exports: [IgxRippleDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRippleModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxRippleDirective],
                exports: [IgxRippleDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRadioGroupDirective, [{
        type: Directive,
        args: [{
                exportAs: 'igxRadioGroup',
                selector: 'igx-radio-group, [igxRadioGroup]',
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective_1, multi: true }]
            }]
    }], function () { return []; }, { change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-radio-group']
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], required: [{
            type: Input
        }], disabled: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], selected: [{
            type: Input
        }], radioButtons: [{
            type: ContentChildren,
            args: [IgxRadioComponent, { descendants: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxRadioModule, { declarations: [IgxRadioGroupDirective,
        IgxRadioComponent], imports: [IgxRippleModule], exports: [IgxRadioGroupDirective,
        IgxRadioComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRadioModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                exports: [IgxRadioGroupDirective, IgxRadioComponent],
                imports: [IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextHighlightDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTextHighlight]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { groupName: [{
            type: Input,
            args: ['groupName']
        }], value: [{
            type: Input,
            args: ['value']
        }], cssClass: [{
            type: Input,
            args: ['cssClass']
        }], activeCssClass: [{
            type: Input,
            args: ['activeCssClass']
        }], containerClass: [{
            type: Input,
            args: ['containerClass']
        }], row: [{
            type: Input,
            args: ['row']
        }], column: [{
            type: Input,
            args: ['column']
        }], metadata: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTextHighlightModule, { declarations: [IgxTextHighlightDirective], exports: [IgxTextHighlightDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextHighlightModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTextHighlightDirective],
                exports: [IgxTextHighlightDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextSelectionDirective, [{
        type: Directive,
        args: [{
                exportAs: 'igxTextSelection',
                selector: '[igxTextSelection]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { selected: [{
            type: Input,
            args: ['igxTextSelection']
        }], onFocus: [{
            type: HostListener,
            args: ['focus']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTextSelectionModule, { declarations: [IgxTextSelectionDirective], exports: [IgxTextSelectionDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTextSelectionModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTextSelectionDirective],
                exports: [IgxTextSelectionDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTooltipTargetDirective, [{
        type: Directive,
        args: [{
                exportAs: 'tooltipTarget',
                selector: '[igxTooltipTarget]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { showDelay: [{
            type: Input,
            args: ['showDelay']
        }], hideDelay: [{
            type: Input,
            args: ['hideDelay']
        }], tooltipDisabled: [{
            type: Input,
            args: ['tooltipDisabled']
        }], onTooltipShow: [{
            type: Output
        }], onTooltipHide: [{
            type: Output
        }], target: [{
            type: Input,
            args: ['igxTooltipTarget']
        }], onKeydownEscape: [{
            type: HostListener,
            args: ['document:keydown.escape', ['$event']]
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], onTouchStart: [{
            type: HostListener,
            args: ['touchstart', ['$event']]
        }], onDocumentTouchStart: [{
            type: HostListener,
            args: ['document:touchstart', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTooltipDirective, [{
        type: Directive,
        args: [{
                exportAs: 'tooltip',
                selector: '[igxTooltip]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], hiddenClass: [{
            type: HostBinding,
            args: ['class.igx-tooltip--hidden']
        }], defaultClass: [{
            type: HostBinding,
            args: ['class.igx-tooltip--desktop']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], context: [{
            type: Input,
            args: ['context']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTooltipModule, { declarations: function () { return [IgxTooltipDirective,
        IgxTooltipTargetDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxTooltipDirective,
        IgxTooltipTargetDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTooltipModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                imports: [CommonModule],
                providers: [IgxOverlayService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateTimeEditorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDateTimeEditor]',
                exportAs: 'igxDateTimeEditor',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateTimeEditorDirective_1, multi: true },
                    { provide: NG_VALIDATORS, useExisting: IgxDateTimeEditorDirective_1, multi: true }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: MaskParsingService }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { isSpinLoop: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], validationFailed: [{
            type: Output
        }], locale: [{
            type: Input
        }], minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], inputFormat: [{
            type: Input,
            args: [`igxDateTimeEditor`]
        }], value: [{
            type: Input
        }], displayFormat: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDateTimeEditorModule, { declarations: [IgxDateTimeEditorDirective], exports: [IgxDateTimeEditorDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateTimeEditorModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDateTimeEditorDirective],
                exports: [IgxDateTimeEditorDirective]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionStripMenuItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxActionStripMenuItem]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionStripComponent, [{
        type: Component,
        args: [{
                selector: 'igx-action-strip',
                template: "<div class=\"igx-action-strip__actions\">\n    <ng-content #content></ng-content>\n    <ng-container *ngIf=\"menuItems.length > 0\">\n        <button igxButton=\"icon\" igxRipple [igxToggleAction]=\"dropdown\"\n            [overlaySettings]=\"menuOverlaySettings\" (click)=\"$event.stopPropagation()\"\n            [igxDropDownItemNavigation]=\"dropdown\">\n            <igx-icon>more_vert</igx-icon>\n        </button>\n        <igx-drop-down #dropdown>\n            <igx-drop-down-item *ngFor=\"let item of menuItems\">\n                <div class=\"igx-drop-down__item-template\">\n                    <ng-container *ngTemplateOutlet=\"item.templateRef; context: {$implicit: item}\"></ng-container>\n                </div>\n            </igx-drop-down-item>\n        </igx-drop-down>\n    </ng-container>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { display: [{
            type: HostBinding,
            args: ['style.display']
        }], hidden: [{
            type: Input
        }], hostClasses: [{
            type: HostBinding,
            args: ['attr.class']
        }], context: [{
            type: Input
        }], hostClass: [{
            type: Input,
            args: ['class']
        }], menuItems: [{
            type: ContentChildren,
            args: [IgxActionStripMenuItemDirective]
        }], menu: [{
            type: ViewChild,
            args: ['dropdown']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCRUDService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSelectionService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HammerGesturesManager, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: PlatformUtil }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\" [metadata]=\"searchMetadata\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"true\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"true\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"true\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: PlatformUtil }]; }, { lastPinned: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--pinned-last']
        }], firstPinned: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--pinned-first']
        }], editMode: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--editing']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], width: [{
            type: Input
        }], displayPinnedChip: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--row-pinned-first']
        }], onDoubleClick: [{
            type: HostListener,
            args: ['dblclick', ['$event']]
        }], rowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], visibleColumnIndex: [{
            type: HostBinding,
            args: ['attr.data-visibleIndex']
        }, {
            type: Input
        }], attrCellID: [{
            type: HostBinding,
            args: ['attr.id']
        }], cellSelectionMode: [{
            type: Input
        }], lastSearchInfo: [{
            type: Input
        }], readonly: [{
            type: HostBinding,
            args: ['attr.aria-readonly']
        }], describedby: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], selected: [{
            type: HostBinding,
            args: ['class.igx-grid__td--selected']
        }], columnSelected: [{
            type: HostBinding,
            args: ['class.igx-grid__td--column-selected']
        }], dirty: [{
            type: HostBinding,
            args: ['class.igx-grid__td--edited']
        }], highlight: [{
            type: ViewChild,
            args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective }]
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onContextMenu: [{
            type: HostListener,
            args: ['contextmenu', ['$event']]
        }], column: [{
            type: Input
        }], row: [{
            type: Input
        }], rowData: [{
            type: Input
        }], cellTemplate: [{
            type: Input
        }], pinnedIndicator: [{
            type: Input
        }], value: [{
            type: Input
        }], formatter: [{
            type: Input
        }], active: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid__td--active']
        }], defaultCellTemplate: [{
            type: ViewChild,
            args: ['defaultCell', { read: TemplateRef, static: true }]
        }], defaultPinnedIndicator: [{
            type: ViewChild,
            args: ['defaultPinnedIndicator', { read: TemplateRef, static: true }]
        }], inlineEditorTemplate: [{
            type: ViewChild,
            args: ['inlineEditor', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowIslandAPIService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCheckboxComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent_1, multi: true }],
                selector: 'igx-checkbox',
                preserveWhitespaces: false,
                template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<div\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    class=\"igx-checkbox__composite-wrapper\"\n>\n    <label #label class=\"igx-checkbox__composite\"\n        [attr.for]=\"inputId\">\n        <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n            <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n        </svg>\n    </label>\n\n    <div class=\"igx-checkbox__ripple\"></div>\n</div>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], labelId: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }], required: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-checkbox']
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-checkbox--focused']
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-checkbox--indeterminate']
        }, {
            type: Input
        }], checked: [{
            type: HostBinding,
            args: ['class.igx-checkbox--checked']
        }, {
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-checkbox--disabled']
        }, {
            type: Input
        }], readonly: [{
            type: Input
        }], disableTransitions: [{
            type: HostBinding,
            args: ['class.igx-checkbox--plain']
        }, {
            type: Input
        }], nativeCheckbox: [{
            type: ViewChild,
            args: ['checkbox', { static: true }]
        }], nativeLabel: [{
            type: ViewChild,
            args: ['label', { static: true }]
        }], placeholderLabel: [{
            type: ViewChild,
            args: ['placeholderLabel', { static: true }]
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();
const ɵIgxCheckboxRequiredDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxCheckboxRequiredDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCheckboxRequiredDirective, [{
        type: Directive,
        args: [{
                selector: `igx-checkbox[required][formControlName],
    igx-checkbox[required][formControl],
    igx-checkbox[required][ngModel]`,
                providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCheckboxModule, { declarations: [IgxCheckboxComponent,
        IgxCheckboxRequiredDirective], imports: [IgxRippleModule], exports: [IgxCheckboxComponent,
        IgxCheckboxRequiredDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCheckboxModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                imports: [IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowBaseComponent]'
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxGridCRUDService }, { type: IgxGridSelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.igx-grid__tr--disabled']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], rowData: [{
            type: Input
        }], dataRowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], selected: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-selected']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], index: [{
            type: Input
        }], gridID: [{
            type: Input
        }], virtDirRow: [{
            type: ViewChild,
            args: ['igxDirRef', { read: IgxGridForOfDirective }]
        }], checkboxElement: [{
            type: ViewChild,
            args: [forwardRef(() => IgxCheckboxComponent), { read: IgxCheckboxComponent }]
        }], _cells: [{
            type: ViewChildren,
            args: ['cell']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilterCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFilterCellTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCell]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeader]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellFooterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxFooter]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCellEditorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCellEditor]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCollapsibleIndicatorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCollapsibleIndicator]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-column',
                template: ``
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxRowIslandAPIService }, { type: ɵngcc0.ElementRef }]; }, { header: [{
            type: Input
        }], sortable: [{
            type: Input
        }], groupable: [{
            type: Input
        }], filterable: [{
            type: Input
        }], resizable: [{
            type: Input
        }], hiddenChange: [{
            type: Output
        }], expandedChange: [{
            type: Output
        }], collapsibleChange: [{
            type: Output
        }], visibleWhenCollapsedChange: [{
            type: Output
        }], disableHiding: [{
            type: Input
        }], disablePinning: [{
            type: Input
        }], movable: [{
            type: Input
        }], widthChange: [{
            type: Output
        }], headerClasses: [{
            type: Input
        }], headerGroupClasses: [{
            type: Input
        }], cellStyles: [{
            type: Input
        }], filteringIgnoreCase: [{
            type: Input
        }], sortingIgnoreCase: [{
            type: Input
        }], dataType: [{
            type: Input
        }], pinnedChange: [{
            type: Output
        }], searchable: [{
            type: Input
        }], selectable: [{
            type: Input
        }], editable: [{
            type: Input
        }], hasSummary: [{
            type: Input
        }], hidden: [{
            type: Input
        }], width: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], pinned: [{
            type: Input
        }], summaries: [{
            type: Input
        }], filters: [{
            type: Input
        }], sortStrategy: [{
            type: Input
        }], groupingComparer: [{
            type: Input
        }], bodyTemplate: [{
            type: Input,
            args: ['cellTemplate']
        }], headerTemplate: [{
            type: Input
        }], inlineEditorTemplate: [{
            type: Input,
            args: ['cellEditorTemplate']
        }], filterCellTemplate: [{
            type: Input,
            args: ['filterCellTemplate']
        }], visibleWhenCollapsed: [{
            type: Input
        }], field: [{
            type: Input
        }], maxWidth: [{
            type: Input
        }], cellClasses: [{
            type: Input
        }], formatter: [{
            type: Input
        }], collapsibleIndicatorTemplate: [{
            type: Input,
            args: ['collapsibleIndicatorTemplate']
        }], rowEnd: [{
            type: Input
        }], colEnd: [{
            type: Input
        }], rowStart: [{
            type: Input
        }], colStart: [{
            type: Input
        }], cellTemplate: [{
            type: ContentChild,
            args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective }]
        }], headTemplate: [{
            type: ContentChildren,
            args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective, descendants: false }]
        }], editorTemplate: [{
            type: ContentChild,
            args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective }]
        }], filterCellTemplateDirective: [{
            type: ContentChild,
            args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective }]
        }], collapseIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxCollapsibleIndicatorTemplateDirective, { read: IgxCollapsibleIndicatorTemplateDirective, static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridBodyDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridBody]',
                providers: [IgxForOfSyncService]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ItemPropertyValueChangedDirective, [{
        type: Directive
    }], function () { return [{ type: String }]; }, { valueChanged: [{
            type: Output
        }], value: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnChooserItemBaseDirective, [{
        type: Directive
    }], function () { return [{ type: String }]; }, { indentation: [{
            type: Input
        }], column: [{
            type: Input
        }], container: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnHidingItem]'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ColumnChooserBaseDirective, [{
        type: Directive
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { disableFilter: [{
            type: Input
        }], columnsAreaMaxHeight: [{
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], columns: [{
            type: Input
        }], title: [{
            type: Input
        }], filterColumnsPrompt: [{
            type: Input
        }], columnItems: [{
            type: Input
        }], filterCriteria: [{
            type: Input
        }], columnDisplayOrder: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-column-hiding',
                template: "<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let columnItem of hidableColumns\"\n        class=\"igx-column-hiding__columns-item\"\n        (onColumnVisibilityChanged)=\"onVisibilityChanged($event)\"\n        (change)=\"columnItem.value = !columnItem.value\"\n        [checked]=\"columnItem.value\"\n        [disabled]=\"columnItem.disabled\"\n        [style.margin-left.px]=\"columnItem.calcIndent\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-hiding__buttons\">\n    <button igxButton igxRipple (click)=\"showAllColumns()\" [disabled]=\"disableShowAll\">{{ showAllText }}</button>\n    <button igxButton igxRipple (click)=\"hideAllColumns()\" [disabled]=\"disableHideAll\">{{ hideAllText }}</button>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { showAllText: [{
            type: Input
        }], hideAllText: [{
            type: Input
        }], onColumnVisibilityChanged: [{
            type: Output
        }], disableHideAll: [{
            type: Input
        }], disableShowAll: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnPinningItem]'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningComponent, [{
        type: Component,
        args: [{
                preserveWhitespaces: false,
                selector: 'igx-column-pinning',
                template: "\n<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox igxColumnPinningItem\n        *ngFor=\"let columnItem of pinnableColumns\"\n        class=\"igx-column-hiding__columns-item\"\n        (change)=\"checkboxValueChange($event, columnItem)\"\n        [checked]=\"columnItem.value\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxIconService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridToolbarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-toolbar',
                template: "<span class=\"igx-grid-toolbar__title\" *ngIf=\"getTitle()\">\n    {{ getTitle() }}\n</span>\n\n<div class=\"igx-grid-toolbar__custom-content\" *ngIf=\"customContentTemplate != null\">\n    <ng-container *ngTemplateOutlet=\"customContentTemplate; context: context\">\n    </ng-container>\n</div>\n\n<div class=\"igx-grid-toolbar__actions\">\n    <div *ngIf=\"grid.allowAdvancedFiltering\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #advancedFilteringButton name=\"btnAdvancedFiltering\" igxRipple\n            (click)=\"showAdvancedFilteringUI()\"\n                [ngClass]=\"grid.advancedFilteringExpressionsTree ? 'igx-grid-toolbar__adv-filter--filtered' : 'igx-grid-toolbar__adv-filter'\">\n            <div class=\"igx-grid-toolbar__button-space\">\n                <igx-icon>\n                    filter_list\n                </igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_title}}</span>\n            </div>\n        </button>\n    </div>\n\n    <div *ngIf=\"grid.columnHiding\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnHidingButton name=\"btnColumnHiding\" igxRipple\n            (click)=\"toggleColumnHidingUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount > 0\">visibility_off</igx-icon>\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount === 0\">visibility</igx-icon>\n                <span>{{ grid.hiddenColumnsCount }}</span>\n                <span>{{ grid.hiddenColumnsText }}</span>\n            </div>\n        </button>\n        <igx-drop-down #columnHidingDropdown>\n            <igx-column-hiding\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnHidingTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"\n                (onColumnVisibilityChanged)=\"grid.toggleColumnVisibility($event)\">\n            </igx-column-hiding>\n        </igx-drop-down>\n    </div>\n    <div *ngIf=\"grid.columnPinning\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" #columnPinningButton name=\"btnColumnPinning\" igxRipple\n            (click)=\"toggleColumnPinningUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"pinnedColumnsCount > 0\" fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n                <igx-icon *ngIf=\"pinnedColumnsCount === 0\" fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n                <span>{{ pinnedColumnsCount }}</span>\n                <span>{{ grid.pinnedColumnsText }}</span>\n                <span></span>\n            </div>\n        </button>\n        <igx-drop-down #columnPinningDropdown>\n            <igx-column-pinning\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnPinningTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"></igx-column-pinning>\n        </igx-drop-down>\n    </div>\n\n    <div class=\"igx-grid-toolbar__dropdown\" *ngIf=\"shouldShowExportButton\" id=\"btnExport\">\n        <button igxButton=\"outlined\" [displayDensity]=\"grid.displayDensity\" igxRipple #btnExport\n                (click)=\"exportClicked()\">\n            <span class=\"igx-grid-toolbar__button-space\">\n                <igx-icon fontSet=\"material\">import_export</igx-icon>\n                <span>{{ getExportText() }}</span>\n                <igx-icon fontSet=\"material\">arrow_drop_down</igx-icon>\n            </span>\n        </button>\n\n        <igx-drop-down #exportDropdown>\n            <ul class=\"igx-grid-toolbar__dd-list\">\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportExcelButton\" id=\"btnExportExcel\"\n                (click)=\"exportToExcelClicked()\">{{ getExportExcelText() }}</li>\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportCsvButton\" id=\"btnExportCsv\"\n                (click)=\"exportToCsvClicked()\">{{ getExportCsvText() }}</li>\n            </ul>\n        </igx-drop-down>\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxExcelExporterService, decorators: [{
                type: Optional
            }] }, { type: IgxCsvExporterService, decorators: [{
                type: Optional
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: IgxIconService }]; }, { class: [{
            type: Input
        }], filterColumnsPrompt: [{
            type: Input
        }], defaultDropDownsMaxHeight: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], gridID: [{
            type: HostBinding,
            args: ['class.igx-grid-toolbar']
        }, {
            type: Input
        }], columnHidingDropdown: [{
            type: ViewChild,
            args: ['columnHidingDropdown', { read: IgxDropDownComponent }]
        }], columnHidingUI: [{
            type: ViewChild,
            args: [IgxColumnHidingComponent]
        }], columnHidingButton: [{
            type: ViewChild,
            args: ['columnHidingButton', { read: IgxButtonDirective }]
        }], exportDropdown: [{
            type: ViewChild,
            args: ['exportDropdown', { read: IgxDropDownComponent }]
        }], exportButton: [{
            type: ViewChild,
            args: ['btnExport', { read: IgxButtonDirective }]
        }], columnPinningDropdown: [{
            type: ViewChild,
            args: ['columnPinningDropdown', { read: IgxDropDownComponent }]
        }], columnPinningUI: [{
            type: ViewChild,
            args: [IgxColumnPinningComponent]
        }], columnPinningButton: [{
            type: ViewChild,
            args: ['columnPinningButton', { read: IgxButtonDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowEdit]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditTextDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowEditText]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditActionsDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowEditActions]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowEditTabStopDirective, [{
        type: Directive,
        args: [{
                selector: `[igxRowEditTabStop]`
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }]; }, { handleTab: [{
            type: HostListener,
            args: ['keydown.Tab', [`$event`]]
        }, {
            type: HostListener,
            args: ['keydown.Shift.Tab', [`$event`]]
        }], handleEscape: [{
            type: HostListener,
            args: ['keydown.Escape', [`$event`]]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxListBase]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxEmptyListTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxEmptyList]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDataLoadingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDataLoading]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListItemLeftPanningTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxListItemLeftPanning]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListItemRightPanningTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxListItemRightPanning]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListItemComponent, [{
        type: Component,
        args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-list-item',
                template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #itemThumbnails>\n    <div class=\"igx-list__item-thumbnail\">\n        <ng-content select=\"[igxListThumbnail], igx-list__item-thumbnail, igx-avatar\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemLines>\n    <div class=\"igx-list__item-lines\">\n        <ng-content select=\"[igxListLine], .igx-list__item-lines, [igxListLineTitle], [igxListLineSubTitle], .igx-list__item-line-title, .igx-list__item-line-subtitle\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #itemActions>\n    <div class=\"igx-list__item-actions\">\n        <ng-content select=\"[igxListAction], .igx-list__item-actions\"></ng-content>\n    </div>\n</ng-template>\n\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemThumbnails\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemLines\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemActions\"></ng-container>\n        <ng-container *ngTemplateOutlet=\"itemsContent\"></ng-container>\n    </div>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: IgxListBaseDirective }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { hidden: [{
            type: Input
        }], touchAction: [{
            type: HostBinding,
            args: ['style.touch-action']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], headerStyle: [{
            type: HostBinding,
            args: ['class.igx-list__header']
        }], innerStyle: [{
            type: HostBinding,
            args: ['class.igx-list__item-base']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], clicked: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], panStart: [{
            type: HostListener,
            args: ['panstart', ['$event']]
        }], panMove: [{
            type: HostListener,
            args: ['panmove', ['$event']]
        }], panEnd: [{
            type: HostListener,
            args: ['panend', ['$event']]
        }], index: [{
            type: Input
        }], leftPanningTemplateElement: [{
            type: ViewChild,
            args: ['leftPanningTmpl']
        }], rightPanningTemplateElement: [{
            type: ViewChild,
            args: ['rightPanningTmpl']
        }], isHeader: [{
            type: Input
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListThumbnailDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListThumbnail]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListActionDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListAction]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListLineDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLine]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListLineTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineTitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-list__item-line-title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListLineSubTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: '[igxListLineSubTitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-list__item-line-subtitle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListComponent, [{
        type: Component,
        args: [{
                selector: 'igx-list',
                template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"message\">\n        There are no items in the list.\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"message\">\n        Loading data from the server...\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                providers: [{ provide: IgxListBaseDirective, useExisting: IgxListComponent_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { panEndTriggeringThreshold: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], allowLeftPanning: [{
            type: Input
        }], allowRightPanning: [{
            type: Input
        }], isLoading: [{
            type: Input
        }], onLeftPan: [{
            type: Output
        }], onRightPan: [{
            type: Output
        }], onPanStateChange: [{
            type: Output
        }], onItemClicked: [{
            type: Output
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], isListEmpty: [{
            type: HostBinding,
            args: ['class.igx-list-empty']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-list']
        }], cssClassCompact: [{
            type: HostBinding,
            args: ['class.igx-list--compact']
        }], cssClassCosy: [{
            type: HostBinding,
            args: ['class.igx-list--cosy']
        }], children: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxListItemComponent), { descendants: true }]
        }], emptyListTemplate: [{
            type: ContentChild,
            args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective }]
        }], dataLoadingTemplate: [{
            type: ContentChild,
            args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective }]
        }], listItemLeftPanningTemplate: [{
            type: ContentChild,
            args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective }]
        }], listItemRightPanningTemplate: [{
            type: ContentChild,
            args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective }]
        }], defaultEmptyListTemplate: [{
            type: ViewChild,
            args: ['defaultEmptyList', { read: TemplateRef, static: true }]
        }], defaultDataLoadingTemplate: [{
            type: ViewChild,
            args: ['defaultDataLoading', { read: TemplateRef, static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxListModule, { declarations: function () { return [IgxListBaseDirective,
        IgxListComponent,
        IgxListItemComponent,
        IgxListThumbnailDirective,
        IgxListActionDirective,
        IgxListLineDirective,
        IgxListLineTitleDirective,
        IgxListLineSubTitleDirective,
        IgxDataLoadingTemplateDirective,
        IgxEmptyListTemplateDirective,
        IgxListItemLeftPanningTemplateDirective,
        IgxListItemRightPanningTemplateDirective]; }, imports: function () { return [CommonModule,
        IgxRippleModule]; }, exports: function () { return [IgxListComponent,
        IgxListItemComponent,
        IgxListThumbnailDirective,
        IgxListActionDirective,
        IgxListLineDirective,
        IgxListLineTitleDirective,
        IgxListLineSubTitleDirective,
        IgxDataLoadingTemplateDirective,
        IgxEmptyListTemplateDirective,
        IgxListItemLeftPanningTemplateDirective,
        IgxListItemRightPanningTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxListModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxListBaseDirective,
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                exports: [
                    IgxListComponent,
                    IgxListItemComponent,
                    IgxListThumbnailDirective,
                    IgxListActionDirective,
                    IgxListLineDirective,
                    IgxListLineTitleDirective,
                    IgxListLineSubTitleDirective,
                    IgxDataLoadingTemplateDirective,
                    IgxEmptyListTemplateDirective,
                    IgxListItemLeftPanningTemplateDirective,
                    IgxListItemRightPanningTemplateDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleLoadingValuesTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStyleLoading]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSearchComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-search',
                template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"displayDensity\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"column.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n<igx-list #list [displayDensity]=\"displayDensity\" [isLoading]=\"isLoading\">\n    <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n        <igx-list-item\n            *igxFor=\"let item of data | excelStyleSearchFilter: searchValue; scrollOrientation : 'vertical'; containerSize: containerSize; itemSize: itemSize\">\n            <igx-checkbox\n            [value]=\"item\"\n            tabindex=\"-1\"\n            [checked]=\"item.isSelected\"\n            [disableRipple]=\"true\"\n            [indeterminate]=\"item.indeterminate\"\n            [disableTransitions]=\"true\"\n            (change)=\"onCheckboxChange($event)\">\n                {{ item.label }}\n            </igx-checkbox>\n        </igx-list-item>\n    </div>\n\n    <ng-template igxDataLoading>\n        <div class=\"igx-excel-filter__loading\">\n            <ng-container *ngTemplateOutlet=\"valuesLoadingTemplate\">\n            </ng-container>\n        </div>\n    </ng-template>\n</igx-list>\n\n<ng-template #defaultExcelStyleLoadingValuesTemplate>\n    <igx-circular-bar [indeterminate]=\"true\">\n    </igx-circular-bar>\n</ng-template>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { grid: [{
            type: Input
        }], data: [{
            type: Input
        }], inline: [{
            type: Input
        }], column: [{
            type: Input
        }], searchInput: [{
            type: ViewChild,
            args: ['input', { read: IgxInputDirective, static: true }]
        }], list: [{
            type: ViewChild,
            args: ['list', { read: IgxListComponent, static: true }]
        }], displayDensity: [{
            type: Input
        }], virtDir: [{
            type: ViewChild,
            args: [IgxForOfDirective, { static: true }]
        }], defaultExcelStyleLoadingValuesTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStyleLoadingValuesTemplate', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCellStyleClassesPipe, [{
        type: Pipe,
        args: [{
                name: 'igxCellStyleClasses'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCellStylesPipe, [{
        type: Pipe,
        args: [{
                name: 'igxCellStyles'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridNotGroupedPipe, [{
        type: Pipe,
        args: [{
                name: 'igxNotGrouped'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridTopLevelColumns, [{
        type: Pipe,
        args: [{
                name: 'igxTopLevel'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilterConditionPipe, [{
        type: Pipe,
        args: [{
                name: 'filterCondition',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridTransactionPipe, [{
        type: Pipe,
        args: [{
                name: 'gridTransaction',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPaginatorOptionsPipe, [{
        type: Pipe,
        args: [{
                name: 'paginatorOptions',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHasVisibleColumnsPipe, [{
        type: Pipe,
        args: [{
                name: 'visibleColumns',
                pure: true
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePipeComponent, [{
        type: Pipe,
        args: [{
                name: 'igxdate'
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDecimalPipeComponent, [{
        type: Pipe,
        args: [{
                name: 'igxdecimal'
            }]
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridRowPinningPipe, [{
        type: Pipe,
        args: [{
                name: 'gridRowPinning',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxFilteringService, [{
        type: Injectable
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.NgModuleRef }, { type: IgxIconService }, { type: IgxOverlayService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxIconComponent, [{
        type: Component,
        args: [{
                selector: 'igx-icon',
                template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxIconService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-icon']
        }], ariaHidden: [{
            type: HostBinding,
            args: ['attr.aria-hidden']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], active: [{
            type: Input,
            args: ['isActive']
        }], font: [{
            type: Input,
            args: ['fontSet']
        }], getInactive: [{
            type: HostBinding,
            args: ['class.igx-icon--inactive']
        }], getIconColor: [{
            type: HostBinding,
            args: ['style.color']
        }], noLigature: [{
            type: ViewChild,
            args: ['noLigature', { read: TemplateRef, static: true }]
        }], explicitLigature: [{
            type: ViewChild,
            args: ['explicitLigature', { read: TemplateRef, static: true }]
        }], svgImage: [{
            type: ViewChild,
            args: ['svgImage', { read: TemplateRef, static: true }]
        }], iconColor: [{
            type: Input,
            args: ['color']
        }], iconName: [{
            type: Input,
            args: ['name']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxIconModule, { declarations: function () { return [IgxIconComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxIconComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxIconModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxIconComponent],
                exports: [IgxIconComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-buttongroup',
                template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <button *ngFor=\"let button of values; let i = 'index'\"\n        type=\"button\"\n        igxButton=\"flat\"\n        [displayDensity]=\"displayDensity\"\n        [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\"\n        [disabled]=\"disabled || button.disabled\"\n        [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\"\n        [igxLabel]=\"button.label\"\n        [igxRipple]=\"button.ripple\"\n    >\n        <span class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\" fontSet=\"material\">{{button.icon}}</igx-icon>\n            <span class=\"igx-button-group__button-text\" *ngIf=\"button.label\">{{button.label}}</span>\n        </span>\n    </button>\n    <ng-content></ng-content>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], zIndex: [{
            type: HostBinding,
            args: ['style.zIndex']
        }], multiSelection: [{
            type: Input
        }], onSelect: [{
            type: Output
        }], onUnselect: [{
            type: Output
        }], itemContentCssClass: [{
            type: Input
        }], disabled: [{
            type: Input
        }], alignment: [{
            type: Input
        }], viewButtons: [{
            type: ViewChildren,
            args: [IgxButtonDirective]
        }], templateButtons: [{
            type: ContentChildren,
            args: [IgxButtonDirective]
        }], values: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxButtonGroupModule, { declarations: function () { return [IgxButtonGroupComponent]; }, imports: function () { return [IgxButtonModule,
        CommonModule,
        IgxRippleModule,
        IgxIconModule]; }, exports: function () { return [IgxButtonGroupComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxButtonGroupModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxButtonGroupComponent],
                exports: [IgxButtonGroupComponent],
                imports: [IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleDefaultExpressionComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-default-expression',
                template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        tabindex=\"0\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { onExpressionRemoved: [{
            type: Output
        }], onLogicOperatorChanged: [{
            type: Output
        }], column: [{
            type: Input
        }], expressionUI: [{
            type: Input
        }], expressionsList: [{
            type: Input
        }], grid: [{
            type: Input
        }], displayDensity: [{
            type: Input
        }], inputGroupConditions: [{
            type: ViewChild,
            args: ['inputGroupConditions', { read: IgxInputGroupComponent, static: true }]
        }], inputValuesDirective: [{
            type: ViewChild,
            args: ['inputValues', { read: IgxInputDirective, static: true }]
        }], dropdownConditions: [{
            type: ViewChild,
            args: ['dropdownConditions', { read: IgxDropDownComponent, static: true }]
        }], logicOperatorButtonGroup: [{
            type: ViewChild,
            args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarYearDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarYear]'
            }]
    }], function () { return []; }, { onYearSelection: [{
            type: Output
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__year']
        }], currentCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__year--current']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], value: [{
            type: Input,
            args: ['igxCalendarYear']
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarMonthDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarMonth]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onMonthSelection: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__month']
        }], currentCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__month--current']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], value: [{
            type: Input,
            args: ['igxCalendarMonth']
        }], date: [{
            type: Input
        }], index: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarHeaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarHeader]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarSubheaderTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarSubheader]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarScrollMonthDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarScrollMonth]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { onMouseDown: [{
            type: HostListener,
            args: ['mousedown']
        }], onMouseUp: [{
            type: HostListener,
            args: ['mouseup', ['$event']]
        }], startScroll: [{
            type: Input
        }], stopScroll: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCalendarBase]'
            }]
    }], function () { return []; }, { hideOutsideDays: [{
            type: Input
        }], onSelection: [{
            type: Output
        }], viewDate: [{
            type: Input
        }], weekStart: [{
            type: Input
        }], locale: [{
            type: Input
        }], formatOptions: [{
            type: Input
        }], formatViews: [{
            type: Input
        }], selection: [{
            type: Input
        }], value: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], specialDates: [{
            type: Input
        }] }); })();
const ɵIgxMonthPickerBaseDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxMonthPickerBaseDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthPickerBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxMonthPickerBase]'
            }]
    }], null, { tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], yearsBtns: [{
            type: ViewChildren,
            args: ['yearsBtn']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthsViewComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent_1, multi: true }],
                selector: 'igx-months-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-row--wrap\">\n        <div [igxCalendarMonth]=\"month\" [date]=\"date\" (onMonthSelection)=\"selectMonth($event)\" [index]=\"i\" *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </div>\n    </div>\n</div>\n\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], date: [{
            type: Input
        }], formatView: [{
            type: Input
        }], onSelection: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], monthFormat: [{
            type: Input
        }], locale: [{
            type: Input
        }], onKeydownArrowUp: [{
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }], onKeydownArrowDown: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], onKeydownArrowRight: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }], onKeydownArrowLeft: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }], onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], onKeydownEnter: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], monthsRef: [{
            type: ViewChildren,
            args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective }]
        }] }); })();
const ɵCalendarHammerConfig_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(CalendarHammerConfig);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CalendarHammerConfig, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxYearsViewComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxYearsViewComponent_1,
                        multi: true
                    },
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: CalendarHammerConfig
                    }
                ],
                selector: 'igx-years-view',
                template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span [igxCalendarYear]=\"year\" [date]=\"date\" (onYearSelection)=\"selectYear($event)\" *ngFor=\"let year of decade; trackBy: yearTracker\">\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], date: [{
            type: Input
        }], onSelection: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], yearFormat: [{
            type: Input
        }], locale: [{
            type: Input
        }], onKeydownArrowDown: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], onKeydownArrowUp: [{
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }], onKeydownEnter: [{
            type: HostListener,
            args: ['keydown.enter']
        }], formatView: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDayItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-day-item',
                template: "<span class=\"igx-calendar__date-content\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { hideOutsideDays: [{
            type: Input
        }], isLastInRange: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-calendar__date--last']
        }], isFirstInRange: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-calendar__date--first']
        }], isWithinRange: [{
            type: Input
        }], onDateSelection: [{
            type: Output
        }], selected: [{
            type: Input
        }], isSelectedCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--selected']
        }], isInactive: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--inactive']
        }], isHidden: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--hidden']
        }], isToday: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--current']
        }], isWeekend: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--weekend']
        }], isWithinRangeCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--range']
        }], isSpecial: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--special']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date']
        }], isDisabledCSS: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--disabled']
        }], isSingleSelection: [{
            type: HostBinding,
            args: ['class.igx-calendar__date--single']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], onSelect: [{
            type: HostListener,
            args: ['click']
        }, {
            type: HostListener,
            args: ['keydown.enter']
        }], date: [{
            type: Input
        }], selection: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], outOfRangeDates: [{
            type: Input
        }], specialDates: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDaysViewNavigationService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDaysViewComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxDaysViewComponent_1
                    },
                    { provide: IgxDaysViewNavigationService, useClass: IgxDaysViewNavigationService }
                ],
                selector: 'igx-days-view',
                template: "<div class=\"igx-calendar__body-row\">\n    <span *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\"\n    class=\"igx-calendar__body-row\">\n    <igx-day-item\n        *ngFor=\"let day of week; trackBy: dateTracker\"\n        [date]=\"day\"\n        [selection]=\"selection\"\n        [selected]=\"isSelected(day)\"\n        [isLastInRange]=\"isLastInRange(day)\"\n        [isFirstInRange]=\"isFirstInRange(day)\"\n        [isWithinRange]=\"isWithinRange(day.date, true)\"\n        [disabledDates]=\"disabledDates\"\n        [specialDates]=\"specialDates\"\n        [outOfRangeDates]=\"outOfRangeDates\"\n        [hideOutsideDays]=\"hideOutsideDays\"\n        (onDateSelection)=\"selectDay($event)\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n"
            }]
    }], function () { return [{ type: IgxDaysViewNavigationService }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], changeDaysView: [{
            type: Input
        }], onDateSelection: [{
            type: Output
        }], onViewChanging: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], onKeydownArrow: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], dates: [{
            type: ViewChildren,
            args: [IgxDayItemComponent, { read: IgxDayItemComponent }]
        }] }); })();
const ɵIgxCalendarComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxCalendarComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxCalendarComponent_1
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-calendar',
                template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\" (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index, $event)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(getViewDate(obj.index)) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\" (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(getViewDate(obj.index)) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\"  [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [style.width.%]=\"100/monthsViewNumber\" [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\" [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <div style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                (onViewChanging)=\"viewChanging($event)\"\n                (onDateSelection)=\"childClicked($event)\">\n        </igx-days-view>\n    </div>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>\n"
            }]
    }], null, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], hasHeader: [{
            type: Input
        }], vertical: [{
            type: Input
        }], animationAction: [{
            type: Input
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaLabelledBy: [{
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], monthsViewNumber: [{
            type: Input
        }], styleVerticalClass: [{
            type: HostBinding,
            args: ['class.igx-calendar--vertical']
        }], headerTemplateDirective: [{
            type: ContentChild,
            args: [forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true }]
        }], subheaderTemplateDirective: [{
            type: ContentChild,
            args: [forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true }]
        }], onKeydownPageDown: [{
            type: HostListener,
            args: ['keydown.pagedown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.pageup', ['$event']]
        }], onKeydownShiftPageUp: [{
            type: HostListener,
            args: ['keydown.shift.pageup', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.shift.pagedown', ['$event']]
        }], onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], onMouseUp: [{
            type: HostListener,
            args: ['document:mouseup', ['$event']]
        }], monthsView: [{
            type: ViewChild,
            args: ['months', { read: IgxMonthsViewComponent }]
        }], monthsBtns: [{
            type: ViewChildren,
            args: ['monthsBtn']
        }], dacadeView: [{
            type: ViewChild,
            args: ['decade', { read: IgxYearsViewComponent }]
        }], daysView: [{
            type: ViewChild,
            args: ['days', { read: IgxDaysViewComponent }]
        }], monthViews: [{
            type: ViewChildren,
            args: ['days', { read: IgxDaysViewComponent }]
        }], prevMonthBtn: [{
            type: ViewChild,
            args: ['prevMonthBtn']
        }], nextMonthBtn: [{
            type: ViewChild,
            args: ['nextMonthBtn']
        }] }); })();
const ɵIgxMonthPickerComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxMonthPickerComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthPickerComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxMonthPickerComponent_1
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-month-picker',
                template: "<div *ngIf=\"isDefaultView\" [@animateView]=\"activeView\" class=\"igx-calendar__body\" (swiperight)=\"previousYear()\" (swipeleft)=\"nextYear()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" (click)=\"previousYear()\" (keydown)=\"previousYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'left': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div [style.width.%]=\"100\">\n            <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\" class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" (click)=\"nextYear()\" (keydown)=\"nextYearKB($event)\" [ngStyle]=\"{\n            'min-width.%': 25,\n            'right': 0\n        }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone()\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (onSelection)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"selectYear($event)\">\n</igx-years-view>\n"
            }]
    }], null, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-calendar']
        }], onKeydownPageUp: [{
            type: HostListener,
            args: ['keydown.pageup', ['$event']]
        }], onKeydownPageDown: [{
            type: HostListener,
            args: ['keydown.pagedown', ['$event']]
        }], onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], monthsView: [{
            type: ViewChild,
            args: ['months', { read: IgxMonthsViewComponent }]
        }], dacadeView: [{
            type: ViewChild,
            args: ['decade', { read: IgxYearsViewComponent }]
        }], daysView: [{
            type: ViewChild,
            args: ['days', { read: IgxDaysViewComponent }]
        }], yearsBtn: [{
            type: ViewChild,
            args: ['yearsBtn']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMonthViewSlotsCalendar, [{
        type: Pipe,
        args: [{
                name: 'IgxMonthViewSlots'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGetViewDateCalendar, [{
        type: Pipe,
        args: [{
                name: 'IgxGetViewDate'
            }]
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCalendarModule, { declarations: function () { return [IgxCalendarBaseDirective,
        IgxMonthPickerBaseDirective,
        IgxDayItemComponent,
        IgxDaysViewComponent,
        IgxCalendarComponent,
        IgxCalendarHeaderTemplateDirective,
        IgxCalendarMonthDirective,
        IgxCalendarYearDirective,
        IgxCalendarSubheaderTemplateDirective,
        IgxCalendarScrollMonthDirective,
        IgxMonthsViewComponent,
        IgxYearsViewComponent,
        IgxMonthPickerComponent,
        IgxMonthViewSlotsCalendar,
        IgxGetViewDateCalendar]; }, imports: function () { return [CommonModule, FormsModule,
        IgxIconModule]; }, exports: function () { return [IgxCalendarComponent,
        IgxDaysViewComponent,
        IgxMonthsViewComponent,
        IgxYearsViewComponent,
        IgxMonthPickerComponent,
        IgxCalendarHeaderTemplateDirective,
        IgxCalendarMonthDirective,
        IgxCalendarYearDirective,
        IgxCalendarSubheaderTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxCalendarBaseDirective,
                    IgxMonthPickerBaseDirective,
                    IgxDayItemComponent,
                    IgxDaysViewComponent,
                    IgxCalendarComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective,
                    IgxCalendarScrollMonthDirective,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxMonthViewSlotsCalendar,
                    IgxGetViewDateCalendar
                ],
                exports: [
                    IgxCalendarComponent,
                    IgxDaysViewComponent,
                    IgxMonthsViewComponent,
                    IgxYearsViewComponent,
                    IgxMonthPickerComponent,
                    IgxCalendarHeaderTemplateDirective,
                    IgxCalendarMonthDirective,
                    IgxCalendarYearDirective,
                    IgxCalendarSubheaderTemplateDirective
                ],
                imports: [CommonModule, FormsModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerDisplayValuePipe, [{
        type: Pipe,
        args: [{
                name: 'displayValue'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DATE_PICKER_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DatePickerInputValuePipe, [{
        type: Pipe,
        args: [{
                name: 'inputValue'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DATE_PICKER_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDatePickerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerActionsDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDatePickerActions]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCalendarContainerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-calendar-container',
                template: "<ng-template #defaultDatePickerActions>\n    <div *ngIf=\"cancelButtonLabel || todayButtonLabel\" class=\"igx-date-picker__buttons\">\n        <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n            {{ cancelButtonLabel }}\n        </button>\n        <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n            {{ todayButtonLabel }}\n        </button>\n    </div>\n</ng-template>\n<igx-calendar #calendar></igx-calendar>\n<ng-container *ngTemplateOutlet=\"datePickerActions ? datePickerActions.template : defaultDatePickerActions\"></ng-container>\n",
                styles: [':host {display: block;}']
            }]
    }], function () { return []; }, { mode: [{
            type: Input
        }], vertical: [{
            type: Input
        }], onClose: [{
            type: Output
        }], onTodaySelection: [{
            type: Output
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-date-picker']
        }], dropdownCSS: [{
            type: HostBinding,
            args: ['class.igx-date-picker--dropdown']
        }], verticalCSS: [{
            type: HostBinding,
            args: ['class.igx-date-picker--vertical']
        }], onEscape: [{
            type: HostListener,
            args: ['keydown.esc', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.alt.arrowup', ['$event']]
        }], calendar: [{
            type: ViewChild,
            args: ['calendar', { static: true }]
        }], cancelButtonLabel: [{
            type: Input
        }], todayButtonLabel: [{
            type: Input
        }], datePickerActions: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerComponent, [{
        type: Component,
        args: [{
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxDatePickerComponent_1,
                        multi: true
                    }],
                // tslint:disable-next-line:component-selector
                selector: 'igx-date-picker',
                template: "<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [value]=\"displayData || ''\"\n            [disabled]=\"disabled\"\n            (blur)=\"onBlur($event)\"\n            readonly\n        />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup>\n        <igx-prefix (click)=\"onOpenClick($event)\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input\n            class=\"igx-date-picker__input-date\"\n            igxInput\n            [igxTextSelection]=\"true\"\n            type=\"text\"\n            [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\"\n            [placeholder]=\"mask\"\n            [disabled]=\"disabled\"\n            [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\"\n            (blur)=\"onBlur($event)\"\n            (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\"\n            (focus)=\"onFocus()\"\n        />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgModuleRef }, { type: ɵngcc0.Injector }]; }, { label: [{
            type: Input
        }], labelVisibility: [{
            type: Input
        }], weekStart: [{
            type: Input
        }], monthsViewNumber: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], vertical: [{
            type: Input
        }], mode: [{
            type: Input
        }], isSpinLoop: [{
            type: Input
        }], onOpened: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], valueChange: [{
            type: Output
        }], onDisabledDate: [{
            type: Output
        }], onValidationFailed: [{
            type: Output
        }], formatOptions: [{
            type: Input
        }], format: [{
            type: Input
        }], formatViews: [{
            type: Input
        }], disabledDates: [{
            type: Input
        }], specialDates: [{
            type: Input
        }], modalOverlaySettings: [{
            type: Input
        }], dropDownOverlaySettings: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], onSpaceClick: [{
            type: HostListener,
            args: ['keydown.spacebar', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.space', ['$event']]
        }], mask: [{
            type: Input
        }], locale: [{
            type: Input
        }], hideOutsideDays: [{
            type: Input
        }], formatter: [{
            type: Input
        }], todayButtonLabel: [{
            type: Input
        }], cancelButtonLabel: [{
            type: Input
        }], outlet: [{
            type: Input
        }], readOnlyDatePickerTemplate: [{
            type: ViewChild,
            args: ['readOnlyDatePickerTemplate', { read: TemplateRef, static: true }]
        }], editableDatePickerTemplate: [{
            type: ViewChild,
            args: ['editableDatePickerTemplate', { read: TemplateRef, static: true }]
        }], inputGroup: [{
            type: ViewChild,
            args: [IgxInputGroupComponent]
        }], inputGroupUserTemplate: [{
            type: ContentChild,
            args: [IgxInputGroupComponent]
        }], _inputElementRef: [{
            type: ViewChild,
            args: [IgxInputDirective, { read: ElementRef }]
        }], _inputUserTemplateElementRef: [{
            type: ContentChild,
            args: [IgxInputDirective, { read: ElementRef }]
        }], _inputDirective: [{
            type: ViewChild,
            args: [IgxInputDirective]
        }], _inputDirectiveUserTemplate: [{
            type: ContentChild,
            args: [IgxInputDirective]
        }], datePickerTemplateDirective: [{
            type: ContentChild,
            args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective }]
        }], subheaderTemplate: [{
            type: ContentChild,
            args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective }]
        }], datePickerActionsDirective: [{
            type: ContentChild,
            args: [IgxDatePickerActionsDirective, { read: IgxDatePickerActionsDirective }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDatePickerModule, { declarations: function () { return [IgxDatePickerComponent,
        IgxCalendarContainerComponent,
        IgxDatePickerActionsDirective,
        IgxDatePickerTemplateDirective,
        DatePickerDisplayValuePipe,
        DatePickerInputValuePipe]; }, imports: function () { return [CommonModule,
        IgxIconModule,
        IgxInputGroupModule,
        IgxCalendarModule,
        IgxButtonModule,
        IgxRippleModule,
        IgxMaskModule,
        IgxTextSelectionModule]; }, exports: function () { return [IgxDatePickerComponent,
        IgxDatePickerTemplateDirective,
        IgxDatePickerActionsDirective,
        DatePickerDisplayValuePipe,
        DatePickerInputValuePipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDatePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDatePickerComponent,
                    IgxCalendarContainerComponent,
                    IgxDatePickerActionsDirective,
                    IgxDatePickerTemplateDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                entryComponents: [
                    IgxCalendarContainerComponent
                ],
                exports: [
                    IgxDatePickerComponent,
                    IgxDatePickerTemplateDirective,
                    IgxDatePickerActionsDirective,
                    DatePickerDisplayValuePipe,
                    DatePickerInputValuePipe
                ],
                imports: [
                    CommonModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxCalendarModule,
                    IgxButtonModule,
                    IgxRippleModule,
                    IgxMaskModule,
                    IgxTextSelectionModule
                ]
            }]
    }], null, null); })();
const ɵIgxExcelStyleDateExpressionComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxExcelStyleDateExpressionComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleDateExpressionComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-date-expression',
                template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    [displayDensity]=\"displayDensity\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        tabindex=\"0\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\" [outlet]=\"grid.outletDirective\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"value | igxdate: grid.locale\"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
            }]
    }], null, { datePicker: [{
            type: ViewChild,
            args: ['datePicker', { read: IgxDatePickerComponent, static: true }]
        }], displayDensity: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleCustomDialogComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-custom-dialog',
                template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    [ngClass]=\"{\n        'igx-excel-filter__secondary--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__secondary--compact': grid.displayDensity === 'compact'\n    }\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { expressionsList: [{
            type: Input
        }], column: [{
            type: Input
        }], selectedOperator: [{
            type: Input
        }], filteringService: [{
            type: Input
        }], overlayComponentId: [{
            type: Input
        }], overlayService: [{
            type: Input
        }], displayDensity: [{
            type: Input
        }], expressionComponents: [{
            type: ViewChildren,
            args: [IgxExcelStyleDefaultExpressionComponent]
        }], expressionDateComponents: [{
            type: ViewChildren,
            args: [IgxExcelStyleDateExpressionComponent]
        }], toggle: [{
            type: ViewChild,
            args: ['toggle', { read: IgxToggleDirective, static: true }]
        }], defaultExpressionTemplate: [{
            type: ViewChild,
            args: ['defaultExpressionTemplate', { read: TemplateRef }]
        }], dateExpressionTemplate: [{
            type: ViewChild,
            args: ['dateExpressionTemplate', { read: TemplateRef }]
        }], expressionsContainer: [{
            type: ViewChild,
            args: ['expressionsContainer', { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSortingComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-sorting',
                template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <button igxButton \n        [displayDensity]=\"displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(1)\"\n        >\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </button>\n\n    <button igxButton\n        [displayDensity]=\"displayDensity\"\n        [attr.data-togglable]=\"true\"\n        (click)=\"onSortButtonClicked(2)\"\n        >\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n         }}\n        </span>\n    </button>\n</igx-buttongroup>\n"
            }]
    }], function () { return []; }, { column: [{
            type: Input
        }], grid: [{
            type: Input
        }], displayDensity: [{
            type: Input
        }], sortButtonGroup: [{
            type: ViewChild,
            args: ['sortButtonGroup', { read: IgxButtonGroupComponent, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSortingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStyleSorting]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleMovingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStyleMoving]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleHidingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStyleHiding]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSelectingTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStyleSelecting]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStylePinningTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxExcelStylePinning]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridExcelStyleFilteringComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-excel-style-filtering',
                template: "<ng-template #defaultExcelStyleSortingTemplate>\n    <igx-excel-style-sorting #excelStyleSorting\n        class=\"igx-excel-filter__sort\"\n        [column]=\"column\"\n        [grid]=\"grid\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-sorting>\n</ng-template>\n\n<ng-template #defaultExcelStyleMovingTemplate>\n    <igx-excel-style-column-moving\n        class=\"igx-excel-filter__move\"\n        [column]=\"column\"\n        [grid]=\"grid\"\n        [isColumnPinnable]=\"isColumnPinnable\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-column-moving>\n</ng-template>\n\n<ng-template #defaultExcelStylePinningTemplate>\n    <div [ngClass]=\"pinClass()\"\n        (click)=\"onPin()\"\n        tabindex=\"0\"\n        *ngIf=\"!column.pinned\">\n        <span>{{ grid.resourceStrings.igx_grid_excel_pin }}</span>\n        <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n    </div>\n\n    <div class=\"igx-excel-filter__actions-unpin\"\n        (click)=\"onPin()\"\n        tabindex=\"0\"\n        *ngIf=\"column.pinned\">\n        <span>{{ grid.resourceStrings.igx_grid_excel_unpin }}</span>\n        <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n    </div>\n</ng-template>\n\n<ng-template #defaultExcelStyleHidingTemplate>\n    <div class=\"igx-excel-filter__actions-hide\"\n        tabindex=\"0\"\n        (click)=\"onHideToggle()\">\n        <span>{{ column.hidden ? grid.resourceStrings.igx_grid_excel_show : grid.resourceStrings.igx_grid_excel_hide }}</span>\n        <igx-icon>{{ column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n    </div>\n</ng-template>\n\n<ng-template #defaultExcelStyleSelectingTemplate>\n    <div [ngClass]=\"selectedClass()\"\n    tabindex=\"0\"\n    (click)=\"onSelect()\">\n        <span>{{grid.resourceStrings.igx_grid_excel_select }}</span>\n        <igx-icon fontSet=\"material\"  >done</igx-icon>\n    </div>\n</ng-template>\n\n<article #dropdown\n    *ngIf=\"column\"\n    class=\"igx-excel-filter__menu\"\n    [ngClass]=\"{\n        'igx-excel-filter__menu--cosy': grid.displayDensity === 'cosy',\n        'igx-excel-filter__menu--compact': grid.displayDensity === 'compact'\n    }\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\"\n    [style.min-height]=\"minHeight\"\n    [style.max-height]=\"maxHeight\">\n\n    <header class=\"igx-excel-filter__menu-header\">\n        <h4>{{ column.header || column.field }}</h4>\n        <div *ngIf=\"grid.displayDensity!=='comfortable'\" class=\"igx-excel-filter__menu-header-actions\">\n            <button *ngIf=\"columnSelectable()\" igxButton=\"icon\"\n            [displayDensity]=\"grid.displayDensity\" (click)=\"onSelect()\"\n            tabindex=\"0\" [ngClass]='selectedClass()'>\n             <igx-icon fontSet=\"material\">done</igx-icon>\n            </button>\n            <button *ngIf=\"!column.disablePinning && !column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                [disabled]=\"!isColumnPinnable\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disablePinning && column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disableHiding\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                tabindex=\"0\"\n                (click)=\"onHideToggle()\">\n                <igx-icon>{{ column.hidden ? 'visibility' : 'visibility_off' }}</igx-icon>\n            </button>\n        </div>\n    </header>\n\n    <div *ngIf=\"column.sortable\">\n        <ng-container *ngTemplateOutlet=\"sortingTemplate\"></ng-container>\n    </div>\n\n    <section class=\"igx-excel-filter__actions\">\n\n        <div *ngIf=\"column.movable\">\n            <ng-container *ngTemplateOutlet=\"movingTemplate\"></ng-container>\n        </div>\n\n        <div *ngIf=\"columnSelectable() && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"selectingTemplate\"></ng-container>\n        </div>\n\n        <div *ngIf=\"!column.disablePinning && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"pinningTemplate\"></ng-container>\n        </div>\n\n        <div *ngIf=\"!column.disableHiding && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"hidingTemplate\"></ng-container>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            [ngClass]=\"clearFilterClass()\"\n            (keydown)=\"onClearFilterKeyDown($event)\"\n            (click)=\"clearFilter()\">\n            <span>{{ grid.resourceStrings.igx_grid_excel_filter_clear }}</span>\n            <igx-icon>clear</igx-icon>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            class=\"igx-excel-filter__actions-filter\"\n            (keydown)=\"onTextFilterKeyDown($event)\"\n            (click)=\"onTextFilterClick($event)\"\n            [igxDropDownItemNavigation]=\"subMenu\" >\n            <span>{{ subMenuText }}</span>\n            <igx-icon>keyboard_arrow_right</igx-icon>\n    </div>\n    </section>\n\n    <igx-excel-style-search\n        class=\"igx-excel-filter__menu-main\"\n        #excelStyleSearch\n        [column]=\"column\"\n        [data]=\"listData\"\n        [grid]=\"grid\"\n        [inline]=\"inline\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-search>\n\n    <footer class=\"igx-excel-filter__menu-footer\">\n        <button igxButton [displayDensity]=\"grid.displayDensity\" (click)=\"cancel()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n        <button igxButton=\"raised\" [displayDensity]=\"grid.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ grid.resourceStrings.igx_grid_excel_apply }}</button>\n    </footer>\n</article>\n\n<igx-drop-down\n    *ngIf=\"column\"\n    #subMenu\n    [maxHeight]=\"'397px'\"\n    [displayDensity]=\"grid.displayDensity\"\n    (onSelection)=\"onSubMenuSelection($event)\"\n    (onClosed)=\"onSubMenuClosed()\">\n    <div>\n        <igx-drop-down-item\n        *ngFor=\"let condition of conditions\"\n        [value]=\"condition\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n        </igx-drop-down-item>\n        <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n            <igx-icon>filter_list</igx-icon>\n            <span style=\"margin-left: 16px\">{{ grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n        </igx-drop-down-item>\n    </div>\n</igx-drop-down>\n\n<igx-excel-style-custom-dialog\n    *ngIf=\"column\"\n    #customDialog\n    [column]=\"column\"\n    [filteringService]=\"filteringService\"\n    [overlayComponentId]=\"overlayComponentId\"\n    [overlayService]=\"overlayService\"\n    [displayDensity]=\"grid.displayDensity\">\n</igx-excel-style-custom-dialog>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { className: [{
            type: HostBinding,
            args: ['class.igx-excel-filter']
        }], inline: [{
            type: HostBinding,
            args: ['class.igx-excel-filter--inline']
        }], column: [{
            type: Input
        }], maxHeight: [{
            type: HostBinding,
            args: ['style.max-height']
        }], mainDropdown: [{
            type: ViewChild,
            args: ['dropdown', { read: ElementRef }]
        }], subMenu: [{
            type: ViewChild,
            args: ['subMenu', { read: IgxDropDownComponent }]
        }], customDialog: [{
            type: ViewChild,
            args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent }]
        }], excelStyleSearch: [{
            type: ViewChild,
            args: ['excelStyleSearch', { read: IgxExcelStyleSearchComponent }]
        }], excelStyleSorting: [{
            type: ViewChild,
            args: ['excelStyleSorting', { read: IgxExcelStyleSortingComponent }]
        }], defaultExcelStyleSortingTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStyleSortingTemplate', { read: TemplateRef, static: true }]
        }], defaultExcelStyleHidingTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStyleHidingTemplate', { read: TemplateRef, static: true }]
        }], defaultExcelStyleSelectingTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStyleSelectingTemplate', { read: TemplateRef, static: true }]
        }], defaultExcelStyleMovingTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStyleMovingTemplate', { read: TemplateRef, static: true }]
        }], defaultExcelStylePinningTemplate: [{
            type: ViewChild,
            args: ['defaultExcelStylePinningTemplate', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridNavigationService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnResizingService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHeaderComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header',
                template: "<ng-template #defaultColumn>\n    <span [attr.title]=\"columnTitle\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon [attr.draggable]=\"false\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <igx-icon [ngClass]=\"filterIconClassName\" [attr.draggable]=\"false\" (click)=\"onFilteringIconClick($event)\"\n        *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\">\n        filter_list\n    </igx-icon>\n</div>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxColumnResizingService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], height: [{
            type: HostBinding,
            args: ['style.height.rem']
        }], headerID: [{
            type: HostBinding,
            args: ['attr.id']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onPinterEnter: [{
            type: HostListener,
            args: ['pointerenter']
        }], onPointerLeave: [{
            type: HostListener,
            args: ['pointerleave']
        }], column: [{
            type: Input
        }], gridID: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChipComponent, [{
        type: Component,
        args: [{
                selector: 'igx-chip',
                template: "<div #chipArea class=\"igx-chip__item\"\n    [attr.tabIndex]=\"tabIndex\"\n    (keydown)=\"onChipKeyDown($event)\"\n    [igxDrag]=\"{chip: this}\"\n    [style.visibility]='hideBaseElement ? \"hidden\" : \"visible\"'\n    [ghostClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (ghostCreate)=\"onChipGhostCreate()\"\n    (ghostDestroy)=\"onChipGhostDestroy()\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (transitioned)=\"onChipMoveEnd($event)\"\n    (dragClick)=\"onChipDragClicked($event)\"\n    igxDrop\n    (enter)=\"onChipDragEnterHandler($event)\"\n    (dropped)=\"onChipDrop($event)\">\n\n    <div #selectContainer [ngClass]=\"selectClass(selected)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        [attr.tabIndex]=\"tabIndex\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], draggable: [{
            type: Input
        }], animateOnRelease: [{
            type: Input
        }], hideBaseOnDrag: [{
            type: Input
        }], removable: [{
            type: Input
        }], selectable: [{
            type: Input
        }], class: [{
            type: Input
        }], disabled: [{
            type: Input
        }], selectedChange: [{
            type: Output
        }], onMoveStart: [{
            type: Output
        }], onMoveEnd: [{
            type: Output
        }], onRemove: [{
            type: Output
        }], onClick: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], onSelectionDone: [{
            type: Output
        }], onKeyDown: [{
            type: Output
        }], onDragEnter: [{
            type: Output
        }], hostTabIndex: [{
            type: HostBinding,
            args: ['attr.tabIndex']
        }], tabIndex: [{
            type: Input
        }], selected: [{
            type: Input
        }], color: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], data: [{
            type: Input
        }], removeIcon: [{
            type: Input
        }], selectIcon: [{
            type: Input
        }], dragDirective: [{
            type: ViewChild,
            args: ['chipArea', { read: IgxDragDirective, static: true }]
        }], chipArea: [{
            type: ViewChild,
            args: ['chipArea', { read: ElementRef, static: true }]
        }], selectContainer: [{
            type: ViewChild,
            args: ['selectContainer', { read: ElementRef, static: true }]
        }], defaultRemoveIcon: [{
            type: ViewChild,
            args: ['defaultRemoveIcon', { read: TemplateRef, static: true }]
        }], defaultSelectIcon: [{
            type: ViewChild,
            args: ['defaultSelectIcon', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChipsAreaComponent, [{
        type: Component,
        args: [{
                selector: 'igx-chips-area',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.IterableDiffers }]; }, { class: [{
            type: Input
        }], onReorder: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], onMoveStart: [{
            type: Output
        }], onMoveEnd: [{
            type: Output
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], width: [{
            type: HostBinding,
            args: ['style.width.px']
        }, {
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height.px']
        }, {
            type: Input
        }], chipsList: [{
            type: ContentChildren,
            args: [IgxChipComponent, { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAvatarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-avatar',
                template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-avatar']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], roundShape: [{
            type: HostBinding,
            args: ['class.igx-avatar--rounded']
        }, {
            type: Input
        }], size: [{
            type: Input
        }], _isSmallSize: [{
            type: HostBinding,
            args: ['class.igx-avatar--small']
        }], _isMediumSize: [{
            type: HostBinding,
            args: ['class.igx-avatar--medium']
        }], _isLargeSize: [{
            type: HostBinding,
            args: ['class.igx-avatar--large']
        }], _isImageType: [{
            type: HostBinding,
            args: ['class.igx-avatar--image']
        }], _isIconType: [{
            type: HostBinding,
            args: ['class.igx-avatar--icon']
        }], _isInitialsType: [{
            type: HostBinding,
            args: ['class.igx-avatar--initials']
        }], roleDescription: [{
            type: HostBinding,
            args: ['attr.aria-roledescription']
        }], image: [{
            type: ViewChild,
            args: ['image']
        }], defaultTemplate: [{
            type: ViewChild,
            args: ['defaultTemplate', { read: TemplateRef, static: true }]
        }], imageTemplate: [{
            type: ViewChild,
            args: ['imageTemplate', { read: TemplateRef, static: true }]
        }], initialsTemplate: [{
            type: ViewChild,
            args: ['initialsTemplate', { read: TemplateRef, static: true }]
        }], iconTemplate: [{
            type: ViewChild,
            args: ['iconTemplate', { read: TemplateRef, static: true }]
        }], color: [{
            type: HostBinding,
            args: ['style.color']
        }, {
            type: Input
        }], bgColor: [{
            type: HostBinding,
            args: ['style.background']
        }, {
            type: Input
        }], initials: [{
            type: Input
        }], icon: [{
            type: Input
        }], src: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxAvatarModule, { declarations: function () { return [IgxAvatarComponent]; }, imports: function () { return [CommonModule,
        IgxIconModule]; }, exports: function () { return [IgxAvatarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAvatarModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxAvatarComponent],
                exports: [IgxAvatarComponent],
                imports: [CommonModule, IgxIconModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxChipsModule, { declarations: function () { return [IgxChipsAreaComponent,
        IgxChipComponent]; }, imports: function () { return [CommonModule,
        IgxRippleModule,
        IgxIconModule,
        IgxButtonModule,
        IgxAvatarModule,
        IgxDragDropModule,
        IgxPrefixModule,
        IgxSuffixModule]; }, exports: function () { return [IgxChipsAreaComponent,
        IgxChipComponent,
        IgxPrefixDirective,
        IgxSuffixDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChipsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxChipsAreaComponent,
                    IgxChipComponent
                ],
                exports: [
                    IgxChipsAreaComponent,
                    IgxChipComponent,
                    IgxPrefixDirective,
                    IgxSuffixDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule,
                    IgxDragDropModule,
                    IgxPrefixModule,
                    IgxSuffixModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-cell',
                template: "<ng-template #emptyFilter>\n    <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n        <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" [displayDensity]=\"'cosy'\" tabIndex=\"-1\">\n            <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n            <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n        </igx-chip>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                tabIndex=\"-1\"\n                [displayDensity]=\"'cosy'\"\n                (click)=\"onChipClicked(item.expression)\"\n                (onRemove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    fontSet=\"filtering-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"'cosy'\" (onRemove)=\"clearFiltering()\" tabIndex=\"-1\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: IgxFilteringService }]; }, { styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], column: [{
            type: Input
        }], emptyFilter: [{
            type: ViewChild,
            args: ['emptyFilter', { read: TemplateRef, static: true }]
        }], defaultFilter: [{
            type: ViewChild,
            args: ['defaultFilter', { read: TemplateRef, static: true }]
        }], complexFilter: [{
            type: ViewChild,
            args: ['complexFilter', { read: TemplateRef, static: true }]
        }], chipsArea: [{
            type: ViewChild,
            args: ['chipsArea', { read: IgxChipsAreaComponent }]
        }], moreIcon: [{
            type: ViewChild,
            args: ['moreIcon', { read: ElementRef }]
        }], ghostChip: [{
            type: ViewChild,
            args: ['ghostChip', { read: IgxChipComponent }]
        }], complexChip: [{
            type: ViewChild,
            args: ['complexChip', { read: IgxChipComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHeaderGroupComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-header-group',
                template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{\n         'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n         'igx-grid__th--pinned-first': hasFirstPinnedChildColumn\n        }\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.grid.id\"\n                [igxColumnMovingDrag]=\"child\"\n                [ghostHost]=\"grid.outletDirective.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n\n<ng-template #defaultColumn>\n    <span class=\"igx-grid__th-group-title\" [attr.title]=\"columnTitle\">{{column.header}}</span>\n</ng-template>\n\n<ng-template #defaultCollapseIndicator>\n    <igx-icon [attr.draggable]=\"false\" >\n            {{column.expanded ? 'expand_more' : 'chevron_right'}} </igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        role=\"columnheader\"\n        [attr.aria-label]=\"column.header || column.field\"\n        [attr.aria-expanded]=\"column.expanded\"\n        [attr.aria-selected]=\"column.selected\"\n        [ngClass]=\"{\n            'igx-grid__th--pinned-last': hasLastPinnedChildColumn,\n            'igx-grid__th--pinned-first': hasFirstPinnedChildColumn,\n            'igx-grid__th--collapsible': column.collapsible,\n            'igx-grid__th--selectable': selectable,\n            'igx-grid__th--selected': selected,\n            'igx-grid__th--active': activeGroup}\"\n        [igxColumnMovingDrag]=\"column\"\n        [ghostHost]=\"grid.outletDirective.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\"\n        (pointerdown)=\"activate()\"\n        (click)=\"groupClicked($event)\"\n        (pointerenter)=\"onPinterEnter()\"\n        (pointerleave)=\"onPointerLeave()\"\n        >\n        <ng-container *ngIf=\"column.collapsible\">\n            <div class=\"igx-grid__th-expander\" (click)=\"toggleExpandState($event)\">\n                <ng-container\n                    *ngTemplateOutlet=\"column.collapsibleIndicatorTemplate ? column.collapsibleIndicatorTemplate : defaultCollapseIndicator; context: {$implicit: column, column: column}\">\n                </ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n        </ng-container>\n    </div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [ghostHost]=\"grid.outletDirective.nativeElement\" [attr.droppable]=\"true\" (pointerdown)=\"activate()\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n        [igxResizeHandle]=\"column\"\n        [attr.draggable]=\"false\"\n        [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }, { type: IgxColumnResizingService }, { type: IgxFilteringService }]; }, { gridRowSpan: [{
            type: HostBinding,
            args: ['style.-ms-grid-row-span']
        }], gridColumnSpan: [{
            type: HostBinding,
            args: ['style.-ms-grid-column-span']
        }], rowEnd: [{
            type: HostBinding,
            args: ['style.grid-row-end']
        }], colEnd: [{
            type: HostBinding,
            args: ['style.grid-column-end']
        }], rowStart: [{
            type: HostBinding,
            args: ['style.-ms-grid-row']
        }, {
            type: HostBinding,
            args: ['style.grid-row-start']
        }], colStart: [{
            type: HostBinding,
            args: ['style.-ms-grid-column']
        }, {
            type: HostBinding,
            args: ['style.grid-column-start']
        }], active: [{
            type: HostBinding,
            args: ['class.igx-grid__th--active']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], zIndex: [{
            type: HostBinding,
            args: ['style.z-index']
        }], groupDisplayStyle: [{
            type: HostBinding,
            args: ['style.display']
        }], onMouseDown: [{
            type: HostListener,
            args: ['mousedown', ['$event']]
        }], pointerdown: [{
            type: HostListener,
            args: ['pointerdown', ['$event']]
        }], column: [{
            type: Input
        }], gridID: [{
            type: Input
        }], headerCell: [{
            type: ViewChild,
            args: [IgxGridHeaderComponent]
        }], filterCell: [{
            type: ViewChild,
            args: [IgxGridFilteringCellComponent]
        }], children: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxGridHeaderGroupComponent_1), { read: IgxGridHeaderGroupComponent_1 }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSummaryService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSummaryCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-cell',
                template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" title=\"{{ summary.label }}\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" title=\"{{ summary.summaryResult }}\">\n                    {{ columnDatatype === 'number' ? (summary.summaryResult | igxdecimal: grid.locale) : columnDatatype === 'date' ? (summary.summaryResult | igxdate: grid.locale) : (summary.summaryResult) }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { firstCellIndentation: [{
            type: Input
        }], hasSummary: [{
            type: Input
        }], visibleColumnIndex: [{
            type: HostBinding,
            args: ['attr.data-visibleIndex']
        }], describeby: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }], attrCellID: [{
            type: HostBinding,
            args: ['attr.id']
        }], activate: [{
            type: HostListener,
            args: ['pointerdown']
        }], summaryResults: [{
            type: Input
        }], column: [{
            type: Input
        }], density: [{
            type: Input
        }], active: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-grid-summary--active']
        }], rowIndex: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSummaryRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-summary-row',
                template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcPixelWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            role=\"cell\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\">\n        </igx-grid-summary-cell>\n    </ng-template>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"summaryCellTemplate; context: getContext(this)\"></ng-container>\n    </ng-container>\n</ng-container>\n\n<ng-template #summaryCellTemplate let-col>\n    <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            role=\"cell\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-first]=\"col.isFirstPinned\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\"\n            [style.min-width]=\"col.getCellWidth()\"\n            [style.max-width]=\"col.getCellWidth()\"\n            [style.flex-basis]=\"col.getCellWidth()\"\n            [style.left]=\"col.rightPinnedOffset\">\n        </igx-grid-summary-cell>\n</ng-template>",
                providers: [IgxForOfSyncService]
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { firstCellIndentation: [{
            type: Input
        }], dataRowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], summaries: [{
            type: Input
        }], gridID: [{
            type: Input
        }], index: [{
            type: Input
        }], _summaryCells: [{
            type: ViewChildren,
            args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent }]
        }], virtDirRow: [{
            type: ViewChild,
            args: ['igxDirRef', { read: IgxGridForOfDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDragSelectDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridDragSelect]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { onDragStop: [{
            type: Output
        }], onDragScroll: [{
            type: Output
        }], activeDrag: [{
            type: Input,
            args: ['igxGridDragSelect']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTemplateOutletDirective, [{
        type: Directive,
        args: [{ selector: '[igxTemplateOutlet]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }]; }, { onViewCreated: [{
            type: Output
        }], onViewMoved: [{
            type: Output
        }], onCachedViewLoaded: [{
            type: Output
        }], onBeforeViewDetach: [{
            type: Output
        }], igxTemplateOutletContext: [{
            type: Input
        }], igxTemplateOutlet: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTemplateOutletModule, { declarations: function () { return [IgxTemplateOutletDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxTemplateOutletDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTemplateOutletModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTemplateOutletDirective],
                entryComponents: [],
                exports: [IgxTemplateOutletDirective],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnResizerDirective, [{
        type: Directive,
        args: [{
                selector: '[igxResizer]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.NgZone }]; }, { restrictHResizeMin: [{
            type: Input
        }], restrictHResizeMax: [{
            type: Input
        }], resizeEnd: [{
            type: Output
        }], resizeStart: [{
            type: Output
        }], resize: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridColumnResizerComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-column-resizer',
                template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>\n"
            }]
    }], function () { return [{ type: IgxColumnResizingService }]; }, { resizer: [{
            type: ViewChild,
            args: [IgxColumnResizerDirective, { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-filtering-row',
                template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"inputGroupPrefixClick($event)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp($event)\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outletDirective\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClosed)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" (focusout)=\"onInputGroupFocusout()\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"inputGroupPrefixClick($event)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon fontSet=\"filtering-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"expression.condition.isUnary ? noop() : openDialog(inputGroup.element.nativeElement)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"value | igxdate: filteringService.grid.locale\"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\">\n                    <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                    <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (pointerdown)=\"onChipPointerdown($event, chip)\"\n                    (click)=\"onChipClick($event, item)\"\n                    (keydown)=\"onChipKeyDown($event, item)\"\n                    (onRemove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"false\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"'cosy'\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer class=\"igx-grid__filtering-row-editing-buttons\">\n    <button igxButton igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</button>\n    <button #closeButton igxButton igxRipple (click)=\"close()\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</button>\n</div>\n"
            }]
    }], function () { return [{ type: IgxFilteringService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-grid__filtering-row']
        }], column: [{
            type: Input
        }], value: [{
            type: Input
        }], onEscHandler: [{
            type: HostListener,
            args: ['keydown.esc', ['$event']]
        }], defaultFilterUI: [{
            type: ViewChild,
            args: ['defaultFilterUI', { read: TemplateRef, static: true }]
        }], defaultDateUI: [{
            type: ViewChild,
            args: ['defaultDateUI', { read: TemplateRef, static: true }]
        }], input: [{
            type: ViewChild,
            args: ['input', { read: ElementRef }]
        }], dropDownConditions: [{
            type: ViewChild,
            args: ['inputGroupConditions', { read: IgxDropDownComponent, static: true }]
        }], chipsArea: [{
            type: ViewChild,
            args: ['chipsArea', { read: IgxChipsAreaComponent, static: true }]
        }], dropDownOperators: [{
            type: ViewChildren,
            args: ['operators', { read: IgxDropDownComponent }]
        }], inputGroup: [{
            type: ViewChild,
            args: ['inputGroup', { read: ElementRef }]
        }], inputGroupPrefix: [{
            type: ViewChild,
            args: ['inputGroupPrefix', { read: ElementRef }]
        }], container: [{
            type: ViewChild,
            args: ['container', { static: true }]
        }], operand: [{
            type: ViewChild,
            args: ['operand']
        }], closeButton: [{
            type: ViewChild,
            args: ['closeButton', { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingDragDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnMovingDrag]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxColumnMovingService }]; }, { data: [{
            type: Input,
            args: ['igxColumnMovingDrag']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGroupByRowTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGroupByRow]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDetailTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridDetail]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowExpandedIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowExpandedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowCollapsedIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowCollapsedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHeaderExpandIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeaderExpandedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHeaderCollapseIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeaderCollapsedIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGroupAreaDropDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGroupAreaDrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }]; }, { hovered: [{
            type: HostBinding,
            args: ['class.igx-drop-area--hover']
        }] }); })();
const ɵIgxSelectItemComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxSelectItemComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-select-item',
                template: '<ng-content></ng-content>'
            }]
    }], null, { text: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectToggleIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectToggleIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectHeaderDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectHeader]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectFooterDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectFooter]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectComponent, [{
        type: Component,
        args: [{
                selector: 'igx-select',
                template: "<igx-input-group #inputGroup class=\"input-group\" (click)=\"toggle()\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n    <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n        [disabled]=\"disabled\"\n        readonly=\"true\"\n        [attr.placeholder]=\"this.placeholder\"\n        [value]=\"this.selectionValue\"\n        role=\"combobox\"\n        aria-haspopup=\"listbox\"\n        [attr.aria-labelledby]=\"this.label ? this.label.id : ''\"\n        [attr.aria-expanded]=\"!this.collapsed\"\n        [attr.aria-owns]=\"this.listId\"\n        [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n        (blur)=\"onBlur()\"\n        (focus)=\"onFocus()\"\n    />\n    <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </ng-container>\n    <igx-suffix>\n            <ng-container *ngIf=\"toggleIconTemplate\">\n                <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n                </ng-container>\n            <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<div igxToggle class=\"igx-drop-down__list\" (mousedown)=\"mousedownHandler($event);\" (onOpening)=\"onToggleOpening($event)\"\n    (onOpened)=\"onToggleOpened()\" (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n\n    <div *ngIf=\"headerTemplate\" class=\"igx-drop-down__select-header\">\n        <ng-content *ngTemplateOutlet=\"headerTemplate\"></ng-content>\n    </div>\n\n    <!-- #7436 LMB scrolling closes items container - unselectable attribute is IE specific  -->\n    <div #scrollContainer class=\"igx-drop-down__list-scroll\" unselectable=\"on\" [style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\"></ng-content>\n    </div>\n\n    <div *ngIf=\"footerTemplate\" class=\"igx-drop-down__select-footer\">\n        <ng-container *ngTemplateOutlet=\"footerTemplate\"></ng-container>\n    </div>\n</div>\n",
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent_1, multi: true },
                    { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent_1 }
                ],
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: ɵngcc0.Injector }]; }, { disabled: [{
            type: Input
        }], maxHeight: [{
            type: HostBinding,
            args: ['style.maxHeight']
        }], type: [{
            type: Input
        }], toggleIconTemplate: [{
            type: ContentChild,
            args: [IgxSelectToggleIconDirective, { read: TemplateRef }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [IgxSelectHeaderDirective, { read: TemplateRef, static: false }]
        }], footerTemplate: [{
            type: ContentChild,
            args: [IgxSelectFooterDirective, { read: TemplateRef, static: false }]
        }], value: [{
            type: Input
        }], inputGroup: [{
            type: ViewChild,
            args: ['inputGroup', { read: IgxInputGroupComponent, static: true }]
        }], input: [{
            type: ViewChild,
            args: ['input', { read: IgxInputDirective, static: true }]
        }], children: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxSelectItemComponent), { descendants: true }]
        }], label: [{
            type: ContentChild,
            args: [forwardRef(() => IgxLabelDirective), { static: true }]
        }], placeholder: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAdvancedFilteringDialogComponent, [{
        type: Component,
        args: [{
                selector: 'igx-advanced-filtering-dialog',
                template: "<article\n    *ngIf=\"grid\"\n    class=\"igx-advanced-filter\"\n    igxDrag\n    [ghost]=\"false\"\n    [dragTolerance]=\"0\"\n    (dragStart)=\"dragStart($event)\"\n    (dragEnd)=\"dragEnd($event)\"\n    (dragMove)=\"onDragMove($event)\"\n    (keydown)=\"onKeyDown($event)\"\n    [ngClass]=\"{\n        'igx-advanced-filter--cosy': grid.displayDensity === 'cosy',\n        'igx-advanced-filter--compact': grid.displayDensity === 'compact',\n        'igx-advanced-filter--inline': inline\n    }\"\n>\n    <header class=\"igx-advanced-filter__header\" igxDragHandle>\n        <h4 class=\"igx-typography__h6\" style=\"pointer-events: none;\">\n            {{ grid.resourceStrings.igx_grid_advanced_filter_title }}\n        </h4>\n        <div class=\"igx-filter-legend\">\n            <div class=\"igx-filter-legend__item--and\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_and_label }}</span>\n            </div>\n            <div class=\"igx-filter-legend__item--or\">\n                <span>{{ grid.resourceStrings.igx_grid_advanced_filter_or_label }}</span>\n            </div>\n        </div>\n    </header>\n\n    <article #expressionsContainer\n             class=\"igx-advanced-filter__main\"\n             (scroll)=\"onExpressionsScrolled()\">\n        <ng-container *ngIf=\"!rootGroup\">\n\n            <button #addRootAndGroupButton\n                igxButton=\"outlined\"\n                [displayDensity]=\"displayDensity\"\n                (click)=\"addAndGroup()\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\" [displayDensity]=\"displayDensity\" (click)=\"addOrGroup()\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n            <div class=\"igx-filter-empty\">\n                <h6 class=\"igx-filter-empty__title\">\n                    {{grid.resourceStrings.igx_grid_advanced_filter_initial_text}}\n                </h6>\n            </div>\n        </ng-container>\n\n        <ng-template #addExpressionsTemplate let-expressionItem let-afterExpression=\"afterExpression\">\n            <button #addConditionButton\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addCondition(expressionItem, afterExpression)\"\n            >\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_add_condition}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addAndGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_and_group}}</span>\n            </button>\n\n            <button igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"editedExpression\"\n                    (click)=\"addOrGroup(expressionItem, afterExpression)\">\n                <igx-icon fontSet=\"material\">add</igx-icon>\n                <span>{{grid.resourceStrings.igx_grid_advanced_filter_or_group}}</span>\n            </button>\n\n        </ng-template>\n\n        <ng-template #filterOperandTemplate let-expressionItem>\n            <div *ngIf=\"!expressionItem.inEditMode\"\n                class=\"igx-filter-tree__expression-item\"\n                (mouseenter)=\"expressionItem.hovered = true\"\n                (mouseleave)=\"expressionItem.hovered = false\"\n                >\n                <igx-chip [data]=\"expressionItem\"\n                          [displayDensity]=\"displayDensity === 'compact' ? 'cosy' : displayDensity\"\n                          [removable]=\"true\"\n                          [selected]=\"expressionItem.selected\"\n                          (keydown)=\"invokeClick($event)\"\n                          (click)=\"onChipClick(expressionItem)\"\n                          (dblclick)=\"onChipDblClick(expressionItem)\"\n                          (onRemove)=\"onChipRemove(expressionItem)\"\n                          (onSelectionDone)=\"onChipSelectionEnd()\"\n                    >\n                    <span igxPrefix class=\"igx-filter-tree__expression-column\">{{ expressionItem.columnHeader || expressionItem.expression.fieldName }}</span>\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"expressionItem.expression.condition.iconName\"\n                    >\n                    </igx-icon>\n                    <span class=\"igx-filter-tree__expression-condition\">\n                        {{ getConditionFriendlyName(expressionItem.expression.condition.name) }}\n                    </span>\n                    <span igxSuffix *ngIf=\"!expressionItem.expression.condition.isUnary\">\n                        {{ isDate(expressionItem.expression.searchVal) ? (expressionItem.expression.searchVal | igxdate:grid.locale) : expressionItem.expression.searchVal }}\n                    </span>\n                </igx-chip>\n                <div class=\"igx-filter-tree__expression-actions\"\n                *ngIf=\"(expressionItem.selected && selectedExpressions.length === 1) || expressionItem.hovered\">\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionEdit(expressionItem)\">\n                        edit\n                    </igx-icon>\n                    <igx-icon\n                        tabindex=\"0\"\n                        (keydown)=\"invokeClick($event)\"\n                        (click)=\"enterExpressionAdd(expressionItem)\"\n                        *ngIf=\"!expressionItem.inAddMode && (expressionItem.parent !== currentGroup || expressionItem !== currentGroup.children[currentGroup.children.length - 1])\"\n                    >\n                        add\n                    </igx-icon>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inEditMode\"\n                #editingInputsContainer\n                class=\"igx-filter-tree__inputs\"\n            >\n                <igx-select #columnSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"columnSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_column_placeholder\"\n                            [(ngModel)]=\"selectedColumn\">\n                    <igx-select-item *ngFor=\"let column of filterableColumns\" [value]=\"column\">\n                        {{column.header || column.field}}\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-select #conditionSelect\n                            type=\"box\"\n                            [displayDensity]=\"'compact'\"\n                            [overlaySettings]=\"conditionSelectOverlaySettings\"\n                            [placeholder]=\"grid.resourceStrings.igx_grid_filter_condition_placeholder\"\n                            [(ngModel)]=\"selectedCondition\"\n                            [disabled]=\"!selectedColumn\">\n                    <igx-icon *ngIf=\"selectedColumn && conditionSelect.value && selectedColumn.filters.condition(conditionSelect.value)\"\n                              igxPrefix\n                              fontSet=\"filtering-icons\"\n                              [name]=\"selectedColumn.filters.condition(conditionSelect.value).iconName\">\n                    </igx-icon>\n                    <igx-select-item *ngFor=\"let condition of getConditionList()\" [value]=\"condition\">\n                        <igx-icon fontSet=\"filtering-icons\"\n                                  [name]=\"selectedColumn.filters.condition(condition).iconName\">\n                        </igx-icon>\n                        <span>{{getConditionFriendlyName(condition)}}</span>\n                    </igx-select-item>\n                </igx-select>\n\n                <igx-input-group *ngIf=\"!selectedColumn || selectedColumn.dataType !== 'date'\"\n                                 type=\"box\"\n                                 [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"\n                                 [displayDensity]=\"'compact'\">\n                    <input #searchValueInput\n                           igxInput\n                           [type]=\"selectedColumn && selectedColumn.dataType === 'number' ? 'number' : 'text'\"\n                           [placeholder]=\"grid.resourceStrings.igx_grid_advanced_filter_value_placeholder\"\n                           [(ngModel)]=\"searchValue\"/>\n                </igx-input-group>\n\n                <igx-date-picker *ngIf=\"selectedColumn && selectedColumn.dataType === 'date'\"\n                                 mode=\"dropdown\"\n                                 [(ngModel)]=\"searchValue\"\n                                 [locale]=\"grid.locale\"\n                                 [outlet]=\"grid.outletDirective\">\n                    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n                        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\">\n                            <input #searchValueInput\n                                    igxInput\n                                    tabindex=\"0\"\n                                    (keydown)=\"invokeClick($event)\"\n                                    (click)=\"openDialog(dropDownTarget.element.nativeElement)\"\n                                    [placeholder]=\"grid.resourceStrings.igx_grid_filter_row_date_placeholder\"\n                                    autocomplete=\"off\"\n                                    [value]=\"value | igxdate: grid.locale\"\n                                    [readonly]=\"true\"\n                                    [disabled]=\"!selectedColumn || !selectedCondition || (selectedColumn && selectedColumn.filters.condition(selectedCondition).isUnary)\"/>\n                        </igx-input-group>\n                    </ng-template>\n                </igx-date-picker>\n\n                <div class=\"igx-filter-tree__inputs-actions\">\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            [disabled]=\"!operandCanBeCommitted()\"\n                            (click)=\"commitOperandEdit()\">\n                        <igx-icon fontSet=\"material\">check</igx-icon>\n                    </button>\n                    <button igxButton=\"icon\"\n                            [displayDensity]=\"displayDensity\"\n                            (click)=\"cancelOperandEdit()\">\n                        <igx-icon fontSet=\"material\">close</igx-icon>\n                    </button>\n                </div>\n            </div>\n\n            <div *ngIf=\"expressionItem.inAddMode\"\n                #addModeContainer\n                class=\"igx-filter-tree__buttons\"\n            >\n                <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem.parent, expressionItem)\"></ng-container>\n                <button igxButton=\"icon\"\n                        [displayDensity]=\"displayDensity\"\n                        (click)=\"cancelOperandAdd()\">\n                    <igx-icon fontSet=\"material\">close</igx-icon>\n                </button>\n            </div>\n\n        </ng-template>\n\n        <ng-template #expressionTreeTemplate let-expressionItem>\n            <div class=\"igx-filter-tree\">\n                <div tabindex=\"0\"\n                     class=\"igx-filter-tree__line\"\n                     [ngClass]=\"{\n                         'igx-filter-tree__line--and': expressionItem.operator === 0,\n                         'igx-filter-tree__line--or': expressionItem.operator === 1,\n                         'igx-filter-tree__line--selected': expressionItem.selected\n                     }\"\n                     (keydown)=\"invokeClick($event)\"\n                     (click)=\"onGroupClick(expressionItem)\"\n                ></div>\n\n                <div class=\"igx-filter-tree__expression\">\n                    <ng-container *ngFor=\"let expr of expressionItem.children\">\n                        <ng-container *ngTemplateOutlet=\"isExpressionGroup(expr) ? expressionTreeTemplate : filterOperandTemplate; context: context(expr)\"></ng-container>\n                    </ng-container>\n                    <div *ngIf=\"currentGroup === expressionItem\"\n                        #currentGroupButtonsContainer\n                        class=\"igx-filter-tree__buttons\">\n                        <ng-container *ngTemplateOutlet=\"addExpressionsTemplate; context: context(expressionItem)\"></ng-container>\n                        <button igxButton=\"outlined\"\n                                *ngIf=\"expressionItem !== rootGroup\"\n                                [displayDensity]=\"displayDensity\"\n                                [disabled]=\"editedExpression || expressionItem.children.length < 2\"\n                                (click)=\"endGroup(expressionItem)\">\n                            <span>{{grid.resourceStrings.igx_grid_advanced_filter_end_group}}</span>\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n        </ng-template>\n\n        <ng-container *ngIf=\"rootGroup\">\n            <ng-container *ngTemplateOutlet=\"expressionTreeTemplate; context: context(rootGroup)\"></ng-container>\n        </ng-container>\n\n        <div igxToggle\n            class=\"igx-filter-contextual-menu\"\n            (keydown)=\"onKeyDown($event)\"\n            (onClosed)=\"contextMenuClosed()\"\n            [ngClass]=\"{\n                'igx-filter-contextual-menu--cosy': displayDensity === 'cosy',\n                'igx-filter-contextual-menu--compact': displayDensity === 'compact'\n            }\"\n        >\n            <button igxButton=\"icon\"\n                    class=\"igx-filter-contextual-menu__close-btn\"\n                    (click)=\"clearSelection()\"\n            >\n                <igx-icon>close</igx-icon>\n            </button>\n\n            <ng-container *ngIf=\"contextualGroup\">\n                <igx-buttongroup [displayDensity]=\"displayDensity\"\n                                 [multiSelection]=\"false\"\n                                 [values]=\"filteringLogics\"\n                                 type=\"outline\"\n                                 (onSelect)=\"selectFilteringLogic($event)\">\n                </igx-buttongroup>\n\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    [disabled]=\"!contextualGroup.parent\"\n                    (click)=\"ungroup()\"\n                >\n                    <igx-icon fontSet=\"filtering-icons\" name=\"ungroup\"></igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_ungroup}}</span>\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteGroup()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    <igx-icon>delete</igx-icon>\n                    <span>{{grid.resourceStrings.igx_grid_advanced_filter_delete}}</span>\n                </button>\n            </ng-container>\n            <ng-container *ngIf=\"!contextualGroup\">\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createAndGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_and_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"createOrGroup()\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_create_or_group}}\n                </button>\n                <button\n                    igxButton=\"outlined\"\n                    [displayDensity]=\"displayDensity\"\n                    (click)=\"deleteFilters()\"\n                    class=\"igx-filter-contextual-menu__delete-btn\"\n                >\n                    {{grid.resourceStrings.igx_grid_advanced_filter_delete_filters}}\n                </button>\n            </ng-container>\n        </div>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"cancelChanges()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n<div #overlayOutlet\n     igxOverlayOutlet\n     class=\"igx-advanced-filter__outlet\"\n     (pointerdown)=\"onOutletPointerDown($event)\">\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { display: [{
            type: HostBinding,
            args: ['style.display']
        }], editingInputsContainer: [{
            type: ViewChild,
            args: ['editingInputsContainer', { read: ElementRef }]
        }], addModeContainer: [{
            type: ViewChild,
            args: ['addModeContainer', { read: ElementRef }]
        }], currentGroupButtonsContainer: [{
            type: ViewChild,
            args: ['currentGroupButtonsContainer', { read: ElementRef }]
        }], grid: [{
            type: Input
        }], columnSelect: [{
            type: ViewChild,
            args: ['columnSelect', { read: IgxSelectComponent }]
        }], conditionSelect: [{
            type: ViewChild,
            args: ['conditionSelect', { read: IgxSelectComponent }]
        }], searchValueInput: [{
            type: ViewChild,
            args: ['searchValueInput', { read: ElementRef }]
        }], addRootAndGroupButton: [{
            type: ViewChild,
            args: ['addRootAndGroupButton', { read: ElementRef }]
        }], addConditionButton: [{
            type: ViewChild,
            args: ['addConditionButton', { read: ElementRef }]
        }], contextMenuToggle: [{
            type: ViewChild,
            args: [IgxToggleDirective]
        }], chips: [{
            type: ViewChildren,
            args: [IgxChipComponent]
        }], expressionsContainer: [{
            type: ViewChild,
            args: ['expressionsContainer']
        }], overlayOutlet: [{
            type: ViewChild,
            args: ['overlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowSelectorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowSelector]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHeadSelectorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHeadSelector]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridToolbarCustomContentDirective, [{
        type: Directive,
        args: [{
                selector: '[igxToolbarCustomContent]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
const ɵIgxColumnGroupComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxColumnGroupComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnGroupComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnGroupComponent_1) }],
                selector: 'igx-column-group',
                template: ``
            }]
    }], null, { children: [{
            type: ContentChildren,
            args: [IgxColumnComponent, { read: IgxColumnComponent }]
        }], searchable: [{
            type: Input
        }], hiddenChange: [{
            type: Output
        }], collapsible: [{
            type: Input
        }], expanded: [{
            type: Input
        }], summaries: [{
            type: Input
        }], filters: [{
            type: Input
        }], collapsibleIndicatorTemplate: [{
            type: Input
        }], hidden: [{
            type: Input
        }] }); })();
const ɵIgxRowDragDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxRowDragDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDragDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowDrag]'
            }]
    }], null, { data: [{
            type: Input,
            args: ['igxRowDrag']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDragIndicatorIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDragIndicatorIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDragGhostDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowDragGhost]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxRowDragModule, { declarations: [IgxRowDragDirective,
        IgxDragIndicatorIconDirective,
        IgxRowDragGhostDirective], exports: [IgxRowDragDirective,
        IgxDragIndicatorIconDirective,
        IgxRowDragGhostDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowDragModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                entryComponents: [],
                exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective, IgxRowDragGhostDirective],
                imports: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridBaseComponent]'
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: IgxColumnResizingService }, { type: GridBaseAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IgxGridTransaction]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ViewContainerRef }, { type: IgxGridNavigationService }, { type: IgxFilteringService }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxGridSummaryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { autoGenerate: [{
            type: Input
        }], filteringExpressionsTreeChange: [{
            type: Output
        }], advancedFilteringExpressionsTreeChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], perPageChange: [{
            type: Output
        }], class: [{
            type: Input
        }], evenRowCSS: [{
            type: Input
        }], oddRowCSS: [{
            type: Input
        }], columnHidingTitle: [{
            type: Input
        }], columnPinningTitle: [{
            type: Input
        }], onCellClick: [{
            type: Output
        }], onSelection: [{
            type: Output
        }], onRowSelectionChange: [{
            type: Output
        }], onColumnSelectionChange: [{
            type: Output
        }], onColumnPinning: [{
            type: Output
        }], onCellEditCancel: [{
            type: Output
        }], onCellEditEnter: [{
            type: Output
        }], onCellEdit: [{
            type: Output
        }], onRowEditEnter: [{
            type: Output
        }], onRowEdit: [{
            type: Output
        }], onRowEditCancel: [{
            type: Output
        }], onColumnInit: [{
            type: Output
        }], onSortingDone: [{
            type: Output
        }], onFilteringDone: [{
            type: Output
        }], onPagingDone: [{
            type: Output
        }], onRowAdded: [{
            type: Output
        }], onRowDeleted: [{
            type: Output
        }], onDataPreLoad: [{
            type: Output
        }], onColumnResized: [{
            type: Output
        }], onContextMenu: [{
            type: Output
        }], onDoubleClick: [{
            type: Output
        }], onColumnVisibilityChanged: [{
            type: Output
        }], onColumnMovingStart: [{
            type: Output
        }], onColumnMoving: [{
            type: Output
        }], onColumnMovingEnd: [{
            type: Output
        }], onGridKeydown: [{
            type: Output
        }], onRowDragStart: [{
            type: Output
        }], onRowDragEnd: [{
            type: Output
        }], onGridCopy: [{
            type: Output
        }], expansionStatesChange: [{
            type: Output
        }], onRowToggle: [{
            type: Output
        }], onRowPinning: [{
            type: Output
        }], columnList: [{
            type: ContentChildren,
            args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true }]
        }], tmpOutlets: [{
            type: ViewChildren,
            args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective }]
        }], rowExpandedIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxRowExpandedIndicatorDirective, { read: TemplateRef }]
        }], rowCollapsedIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxRowCollapsedIndicatorDirective, { read: TemplateRef }]
        }], headerExpandIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxHeaderExpandIndicatorDirective, { read: TemplateRef }]
        }], headerCollapseIndicatorTemplate: [{
            type: ContentChild,
            args: [IgxHeaderCollapseIndicatorDirective, { read: TemplateRef }]
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], hostRole: [{
            type: HostBinding,
            args: ['attr.role']
        }], sortingExpressionsChange: [{
            type: Output
        }], toolbar: [{
            type: ViewChild,
            args: ['toolbar', { read: IgxGridToolbarComponent }]
        }], toolbarHtml: [{
            type: ViewChild,
            args: ['toolbar', { read: ElementRef }]
        }], clipboardOptions: [{
            type: Input
        }], onToolbarExporting: [{
            type: Output
        }], onRangeSelection: [{
            type: Output
        }], resourceStrings: [{
            type: Input
        }], filteringLogic: [{
            type: Input
        }], filteringExpressionsTree: [{
            type: Input
        }], advancedFilteringExpressionsTree: [{
            type: Input
        }], locale: [{
            type: Input
        }], paging: [{
            type: Input
        }], page: [{
            type: Input
        }], perPage: [{
            type: Input
        }], columnHiding: [{
            type: Input
        }], hideRowSelectors: [{
            type: Input
        }], rowDraggable: [{
            type: Input
        }], rowEditable: [{
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height']
        }, {
            type: Input
        }], hostWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], width: [{
            type: Input
        }], rowHeight: [{
            type: Input
        }], columnWidth: [{
            type: Input
        }], emptyGridMessage: [{
            type: Input
        }], isLoading: [{
            type: Input
        }], emptyFilteredGridMessage: [{
            type: Input
        }], pinning: [{
            type: Input
        }], columnPinning: [{
            type: Input
        }], allowFiltering: [{
            type: Input
        }], allowAdvancedFiltering: [{
            type: Input
        }], filterMode: [{
            type: Input
        }], summaryPosition: [{
            type: Input
        }], summaryCalculationMode: [{
            type: Input
        }], filterStrategy: [{
            type: Input
        }], sortStrategy: [{
            type: Input
        }], hostClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], sortingExpressions: [{
            type: Input
        }], hiddenColumnsText: [{
            type: Input
        }], pinnedColumnsText: [{
            type: Input
        }], showToolbar: [{
            type: Input
        }], toolbarTitle: [{
            type: Input
        }], exportExcel: [{
            type: Input
        }], exportCsv: [{
            type: Input
        }], exportText: [{
            type: Input
        }], exportExcelText: [{
            type: Input
        }], exportCsvText: [{
            type: Input
        }], cellSelection: [{
            type: Input
        }], rowSelection: [{
            type: Input
        }], columnSelection: [{
            type: Input
        }], expansionStates: [{
            type: Input
        }], defaultExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true }]
        }], emptyGridTemplate: [{
            type: Input
        }], loadingGridTemplate: [{
            type: Input
        }], paginationTemplate: [{
            type: Input
        }], primaryKey: [{
            type: Input
        }], uniqueColumnValuesStrategy: [{
            type: Input
        }], resizeLine: [{
            type: ViewChild,
            args: [IgxGridColumnResizerComponent]
        }], loadingOverlay: [{
            type: ViewChild,
            args: ['loadingOverlay', { static: true }]
        }], loadingOutlet: [{
            type: ViewChild,
            args: ['igxLoadingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], excelStyleSortingTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleSortingTemplateDirective, { read: IgxExcelStyleSortingTemplateDirective }]
        }], excelStyleMovingTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleMovingTemplateDirective, { read: IgxExcelStyleMovingTemplateDirective }]
        }], excelStyleHidingTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleHidingTemplateDirective, { read: IgxExcelStyleHidingTemplateDirective }]
        }], excelStyleSelectingTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleSelectingTemplateDirective, { read: IgxExcelStyleSelectingTemplateDirective }]
        }], excelStylePinningTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStylePinningTemplateDirective, { read: IgxExcelStylePinningTemplateDirective }]
        }], excelStyleLoadingValuesTemplateDirective: [{
            type: ContentChild,
            args: [IgxExcelStyleLoadingValuesTemplateDirective, { read: IgxExcelStyleLoadingValuesTemplateDirective, static: true }]
        }], headerGroups: [{
            type: ViewChildren,
            args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent }]
        }], _rowList: [{
            type: ViewChildren,
            args: ['row']
        }], _pinnedRowList: [{
            type: ViewChildren,
            args: ['pinnedRow']
        }], _summaryRowList: [{
            type: ViewChildren,
            args: ['summaryRow', { read: IgxSummaryRowComponent }]
        }], _dataRowList: [{
            type: ViewChildren,
            args: [IgxRowDirective, { read: IgxRowDirective }]
        }], emptyFilteredGridTemplate: [{
            type: ViewChild,
            args: ['emptyFilteredGrid', { read: TemplateRef, static: true }]
        }], emptyGridDefaultTemplate: [{
            type: ViewChild,
            args: ['defaultEmptyGrid', { read: TemplateRef, static: true }]
        }], loadingGridDefaultTemplate: [{
            type: ViewChild,
            args: ['defaultLoadingGrid', { read: TemplateRef, static: true }]
        }], parentVirtDir: [{
            type: ViewChild,
            args: ['scrollContainer', { read: IgxGridForOfDirective, static: true }]
        }], toolbarCustomContentTemplates: [{
            type: ContentChildren,
            args: [IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false }]
        }], headSelectorsTemplates: [{
            type: ContentChildren,
            args: [IgxHeadSelectorDirective, { read: IgxHeadSelectorDirective, descendants: false }]
        }], rowSelectorsTemplates: [{
            type: ContentChildren,
            args: [IgxRowSelectorDirective, { read: IgxRowSelectorDirective, descendants: false }]
        }], dragGhostCustomTemplates: [{
            type: ContentChildren,
            args: [IgxRowDragGhostDirective, { read: TemplateRef, descendants: false }]
        }], verticalScrollContainer: [{
            type: ViewChild,
            args: ['verticalScrollContainer', { read: IgxGridForOfDirective, static: true }]
        }], verticalScroll: [{
            type: ViewChild,
            args: ['verticalScrollHolder', { read: IgxGridForOfDirective, static: true }]
        }], scr: [{
            type: ViewChild,
            args: ['scr', { read: ElementRef, static: true }]
        }], footer: [{
            type: ViewChild,
            args: ['footer', { read: ElementRef }]
        }], headerContainer: [{
            type: ViewChild,
            args: ['hContainer', { read: IgxGridForOfDirective, static: true }]
        }], headerSelectorContainer: [{
            type: ViewChild,
            args: ['headerSelectorContainer']
        }], headerDragContainer: [{
            type: ViewChild,
            args: ['headerDragContainer']
        }], headerGroupContainer: [{
            type: ViewChild,
            args: ['headerGroupContainer']
        }], filteringRow: [{
            type: ViewChild,
            args: ['filteringRow', { read: IgxGridFilteringRowComponent }]
        }], theadRow: [{
            type: ViewChild,
            args: ['theadRow', { static: true }]
        }], tbody: [{
            type: ViewChild,
            args: ['tbody', { static: true }]
        }], pinContainer: [{
            type: ViewChild,
            args: ['pinContainer', { read: ElementRef }]
        }], tfoot: [{
            type: ViewChild,
            args: ['tfoot', { static: true }]
        }], _outletDirective: [{
            type: ViewChild,
            args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], rowEditingOutletDirective: [{
            type: ViewChild,
            args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective, static: true }]
        }], dragIndicatorIconBase: [{
            type: ViewChild,
            args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
        }], defaultRowEditTemplate: [{
            type: ViewChild,
            args: ['defaultRowEditTemplate', { read: TemplateRef, static: true }]
        }], rowEditCustom: [{
            type: ContentChild,
            args: [IgxRowEditTemplateDirective, { read: TemplateRef }]
        }], rowEditText: [{
            type: ContentChild,
            args: [IgxRowEditTextDirective, { read: TemplateRef }]
        }], rowEditActions: [{
            type: ContentChild,
            args: [IgxRowEditActionsDirective, { read: TemplateRef }]
        }], dragIndicatorIconTemplates: [{
            type: ContentChildren,
            args: [IgxDragIndicatorIconDirective, { read: TemplateRef, descendants: false }]
        }], rowEditTabsDEFAULT: [{
            type: ViewChildren,
            args: [IgxRowEditTabStopDirective]
        }], rowEditTabsCUSTOM: [{
            type: ContentChildren,
            args: [IgxRowEditTabStopDirective]
        }], rowEditingOverlay: [{
            type: ViewChild,
            args: [IgxToggleDirective]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFooterComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-footer',
                template: '<ng-content></ng-content>'
            }]
    }], null, null); })();
const ɵIgxSelectGroupComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxSelectGroupComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-select-item-group',
                template: `
        <label id="{{labelId}}">{{ label }}</label>
        <ng-content select="igx-select-item"></ng-content>
    `
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectItemNavigationDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSelectItemNavigation]'
            }]
    }], function () { return []; }, { captureKey: [{
            type: HostListener,
            args: ['keyup', ['$event']]
        }], target: [{
            type: Input,
            args: ['igxSelectItemNavigation']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSelectModule, { declarations: function () { return [IgxSelectComponent,
        IgxSelectFooterDirective,
        IgxSelectGroupComponent,
        IgxSelectHeaderDirective,
        IgxSelectItemComponent,
        IgxSelectItemNavigationDirective,
        IgxSelectToggleIconDirective]; }, imports: function () { return [CommonModule,
        FormsModule,
        IgxButtonModule,
        IgxDropDownModule,
        IgxIconModule,
        IgxInputGroupModule,
        IgxRippleModule,
        IgxToggleModule,
        ReactiveFormsModule]; }, exports: function () { return [IgxSelectComponent,
        IgxSelectFooterDirective,
        IgxSelectGroupComponent,
        IgxSelectHeaderDirective,
        IgxSelectItemComponent,
        IgxSelectItemNavigationDirective,
        IgxSelectToggleIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSelectModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxSelectComponent,
                    IgxSelectFooterDirective,
                    IgxSelectGroupComponent,
                    IgxSelectHeaderDirective,
                    IgxSelectItemComponent,
                    IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective
                ],
                exports: [
                    IgxSelectComponent,
                    IgxSelectFooterDirective,
                    IgxSelectGroupComponent,
                    IgxSelectHeaderDirective,
                    IgxSelectItemComponent,
                    IgxSelectItemNavigationDirective,
                    IgxSelectToggleIconDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDropDownModule,
                    IgxIconModule,
                    IgxInputGroupModule,
                    IgxRippleModule,
                    IgxToggleModule,
                    ReactiveFormsModule
                ],
                providers: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPaginatorComponent, [{
        type: Component,
        args: [{
                selector: 'igx-paginator',
                template: "<div class=\"igx-paginator__select\" [hidden]=\"dropdownHidden\">\n    <label class=\"igx-paginator__label\">{{ resourceStrings.igx_paginator_label }}</label>\n    <div class=\"igx-paginator__select-input\">\n        <igx-select [(ngModel)]=\"perPage\" [displayDensity]=\"paginatorSelectDisplayDensity()\" type=\"border\"\n            [disabled]=\"!dropdownEnabled\">\n            <label igxLabel [hidden]=\"true\">{{ resourceStrings.igx_paginator_label }}</label>\n            <igx-select-item [value]=\"val\" *ngFor=\"let val of selectOptions\">\n                {{val}}\n            </igx-select-item>\n        </igx-select>\n    </div>\n</div>\n<div class=\"igx-paginator__pager\" [hidden]=\"pagerHidden\" role=\"navigation\">\n    <button [title]=\"resourceStrings.igx_paginator_first_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_previous_page_button_text\" [disabled]=\"isFirstPageDisabled\" [attr.aria-disabled]=\"isFirstPageDisabled\" (click)=\"previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <div class='igx-paginator__pager-text' aria-current=\"page\">\n        <span>{{ page + 1 }}</span>\n        <span>&nbsp;{{ resourceStrings.igx_paginator_pager_text }}&nbsp;</span>\n        <span>{{ totalPages }}</span>\n    </div>\n    <button [title]=\"resourceStrings.igx_paginator_next_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n    <button [title]=\"resourceStrings.igx_paginator_last_page_button_text\" [disabled]=\"isLastPageDisabled\" [attr.aria-disabled]=\"isLastPageDisabled\" (click)=\"paginate(totalPages - 1)\" igxButton=\"icon\" igxRipple\n        igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n</div>\n"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { pagerEnabled: [{
            type: Input
        }], pagerHidden: [{
            type: Input
        }], dropdownEnabled: [{
            type: Input
        }], dropdownHidden: [{
            type: Input
        }], selectLabel: [{
            type: Input
        }], prepositionPage: [{
            type: Input
        }], perPageChange: [{
            type: Output
        }], pageChange: [{
            type: Output
        }], classCosy: [{
            type: HostBinding,
            args: ['class.igx-paginator--cosy']
        }], classCompact: [{
            type: HostBinding,
            args: ['class.igx-paginator--compact']
        }], classComfortable: [{
            type: HostBinding,
            args: ['class.igx-paginator']
        }], page: [{
            type: Input
        }], perPage: [{
            type: Input
        }], totalRecords: [{
            type: Input
        }], selectOptions: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxPaginatorModule, { declarations: function () { return [IgxPaginatorComponent]; }, imports: function () { return [CommonModule,
        IgxSelectModule,
        FormsModule,
        IgxIconModule,
        IgxButtonModule,
        IgxRippleModule,
        IgxInputGroupModule]; }, exports: function () { return [IgxPaginatorComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPaginatorModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxPaginatorComponent],
                exports: [IgxPaginatorComponent],
                imports: [CommonModule, IgxSelectModule, FormsModule, IgxIconModule, IgxButtonModule, IgxRippleModule, IgxInputGroupModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridPipesModule, { declarations: function () { return [IgxDatePipeComponent,
        IgxDecimalPipeComponent,
        IgxGridFilterConditionPipe,
        IgxGridTransactionPipe,
        IgxGridNotGroupedPipe,
        IgxGridTopLevelColumns,
        IgxGridCellStylesPipe,
        IgxGridCellStyleClassesPipe,
        IgxGridPaginatorOptionsPipe,
        IgxHasVisibleColumnsPipe,
        IgxGridRowPinningPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxDatePipeComponent,
        IgxDecimalPipeComponent,
        IgxGridFilterConditionPipe,
        IgxGridTransactionPipe,
        IgxGridNotGroupedPipe,
        IgxGridTopLevelColumns,
        IgxGridCellStylesPipe,
        IgxGridCellStyleClassesPipe,
        IgxGridPaginatorOptionsPipe,
        IgxHasVisibleColumnsPipe,
        IgxGridRowPinningPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPipesModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDatePipeComponent,
                    IgxDecimalPipeComponent,
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe,
                    IgxGridRowPinningPipe
                ],
                exports: [
                    IgxDatePipeComponent,
                    IgxDecimalPipeComponent,
                    IgxGridFilterConditionPipe,
                    IgxGridTransactionPipe,
                    IgxGridNotGroupedPipe,
                    IgxGridTopLevelColumns,
                    IgxGridCellStylesPipe,
                    IgxGridCellStyleClassesPipe,
                    IgxGridPaginatorOptionsPipe,
                    IgxHasVisibleColumnsPipe,
                    IgxGridRowPinningPipe
                ],
                imports: [
                    CommonModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleColumnMovingComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-excel-style-column-moving',
                template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n"
            }]
    }], function () { return []; }, { column: [{
            type: Input
        }], grid: [{
            type: Input
        }], displayDensity: [{
            type: Input
        }], isColumnPinnable: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExcelStyleSearchFilterPipe, [{
        type: Pipe,
        args: [{
                name: 'excelStyleSearchFilter'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProcessBarTextTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxProcessBarText]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProgressBarGradientDirective, [{
        type: Directive,
        args: [{
                selector: '[igxProgressBarGradient]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDirectionality, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DIR_DOCUMENT]
            }] }]; }, null); })();

/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLinearProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\" [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            }]
    }], function () { return []; }, { valueMin: [{
            type: HostBinding,
            args: ['attr.aria-valuemin']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-linear-bar']
        }], striped: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--striped']
        }, {
            type: Input
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--indeterminate']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], textAlign: [{
            type: Input
        }], textVisibility: [{
            type: Input
        }], textTop: [{
            type: Input
        }], type: [{
            type: Input
        }], value: [{
            type: HostBinding,
            args: ['attr.aria-valuenow']
        }, {
            type: Input
        }], error: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--danger']
        }], info: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--info']
        }], warning: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--warning']
        }], success: [{
            type: HostBinding,
            args: ['class.igx-linear-bar--success']
        }], text: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCircularProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <svg:circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <svg:text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate;\n            context: context\">\n        </ng-container>\n    </svg:text>\n\n    <svg:defs>\n        <ng-container\n            *ngTemplateOutlet=\"gradientTemplate ? gradientTemplate.template : defaultGradientTemplate;\n            context: { $implicit: gradientId }\">\n        </ng-container>\n    </svg:defs>\n\n    <ng-template #defaultTextTemplate>\n        <svg:tspan class=\"igx-circular-bar__text\">\n            {{textContent ? textContent: valueInPercent + '%'}}\n        </svg:tspan>\n    </ng-template>\n\n    <ng-template #defaultGradientTemplate>\n        <svg:linearGradient [id]=\"gradientId\" gradientTransform=\"rotate(90)\">\n          <stop offset=\"0%\"   class=\"igx-circular-bar__gradient-start\" />\n          <stop offset=\"100%\" class=\"igx-circular-bar__gradient-end\" />\n        </svg:linearGradient>\n    </ng-template>\n</svg>\n\n"
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: IgxDirectionality }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-circular-bar']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], indeterminate: [{
            type: HostBinding,
            args: ['class.igx-circular-bar--indeterminate']
        }, {
            type: Input
        }], textVisibility: [{
            type: Input
        }], value: [{
            type: Input
        }], text: [{
            type: Input
        }], textTemplate: [{
            type: ContentChild,
            args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective }]
        }], gradientTemplate: [{
            type: ContentChild,
            args: [IgxProgressBarGradientDirective, { read: IgxProgressBarGradientDirective }]
        }], _svgCircle: [{
            type: ViewChild,
            args: ['circle', { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxProgressBarModule, { declarations: function () { return [IgxLinearProgressBarComponent,
        IgxCircularProgressBarComponent,
        IgxProcessBarTextTemplateDirective,
        IgxProgressBarGradientDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxLinearProgressBarComponent,
        IgxCircularProgressBarComponent,
        IgxProcessBarTextTemplateDirective,
        IgxProgressBarGradientDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxProgressBarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                exports: [
                    IgxLinearProgressBarComponent,
                    IgxCircularProgressBarComponent,
                    IgxProcessBarTextTemplateDirective,
                    IgxProgressBarGradientDirective,
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridExcelStyleFilteringModule, { declarations: function () { return [IgxGridExcelStyleFilteringComponent,
        IgxExcelStyleSortingComponent,
        IgxExcelStyleColumnMovingComponent,
        IgxExcelStyleSearchComponent,
        IgxExcelStyleCustomDialogComponent,
        IgxExcelStyleDefaultExpressionComponent,
        IgxExcelStyleDateExpressionComponent,
        IgxExcelStyleSortingTemplateDirective,
        IgxExcelStyleHidingTemplateDirective,
        IgxExcelStyleMovingTemplateDirective,
        IgxExcelStylePinningTemplateDirective,
        IgxExcelStyleSelectingTemplateDirective,
        IgxExcelStyleLoadingValuesTemplateDirective,
        IgxExcelStyleSearchFilterPipe]; }, imports: function () { return [CommonModule,
        FormsModule,
        IgxGridPipesModule,
        IgxButtonModule,
        IgxButtonGroupModule,
        IgxDatePickerModule,
        IgxIconModule,
        IgxRippleModule,
        IgxInputGroupModule,
        IgxDropDownModule,
        IgxForOfModule,
        IgxCheckboxModule,
        IgxFilterModule,
        IgxToggleModule,
        IgxListModule,
        IgxProgressBarModule]; }, exports: function () { return [IgxGridExcelStyleFilteringComponent,
        IgxExcelStyleSortingTemplateDirective,
        IgxExcelStyleHidingTemplateDirective,
        IgxExcelStyleMovingTemplateDirective,
        IgxExcelStylePinningTemplateDirective,
        IgxExcelStyleSelectingTemplateDirective,
        IgxExcelStyleLoadingValuesTemplateDirective,
        IgxExcelStyleDateExpressionComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridExcelStyleFilteringModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleSortingComponent,
                    IgxExcelStyleColumnMovingComponent,
                    IgxExcelStyleSearchComponent,
                    IgxExcelStyleCustomDialogComponent,
                    IgxExcelStyleDefaultExpressionComponent,
                    IgxExcelStyleDateExpressionComponent,
                    IgxExcelStyleSortingTemplateDirective,
                    IgxExcelStyleHidingTemplateDirective,
                    IgxExcelStyleMovingTemplateDirective,
                    IgxExcelStylePinningTemplateDirective,
                    IgxExcelStyleSelectingTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleSearchFilterPipe
                ],
                exports: [
                    IgxGridExcelStyleFilteringComponent,
                    IgxExcelStyleSortingTemplateDirective,
                    IgxExcelStyleHidingTemplateDirective,
                    IgxExcelStyleMovingTemplateDirective,
                    IgxExcelStylePinningTemplateDirective,
                    IgxExcelStyleSelectingTemplateDirective,
                    IgxExcelStyleLoadingValuesTemplateDirective,
                    IgxExcelStyleDateExpressionComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxGridPipesModule,
                    IgxButtonModule,
                    IgxButtonGroupModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxDropDownModule,
                    IgxForOfModule,
                    IgxCheckboxModule,
                    IgxFilterModule,
                    IgxToggleModule,
                    IgxListModule,
                    IgxProgressBarModule
                ],
                entryComponents: [
                    IgxGridExcelStyleFilteringComponent
                ],
                providers: [
                    IgxSelectionAPIService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridSelectionModule, { declarations: [IgxRowSelectorDirective,
        IgxHeadSelectorDirective,
        IgxGridDragSelectDirective], exports: [IgxRowSelectorDirective,
        IgxHeadSelectorDirective,
        IgxGridDragSelectDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSelectionModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ],
                exports: [
                    IgxRowSelectorDirective,
                    IgxHeadSelectorDirective,
                    IgxGridDragSelectDirective
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxResizeHandleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxResizeHandle]'
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: ɵngcc0.ElementRef }, { type: IgxColumnResizingService }]; }, { onMouseOver: [{
            type: HostListener,
            args: ['mouseover']
        }], onDoubleClick: [{
            type: HostListener,
            args: ['dblclick']
        }], column: [{
            type: Input,
            args: ['igxResizeHandle']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridResizingModule, { declarations: function () { return [IgxGridColumnResizerComponent,
        IgxResizeHandleDirective,
        IgxColumnResizerDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxGridColumnResizerComponent,
        IgxResizeHandleDirective,
        IgxColumnResizerDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridResizingModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                imports: [
                    CommonModule
                ],
                exports: [
                    IgxGridColumnResizerComponent,
                    IgxResizeHandleDirective,
                    IgxColumnResizerDirective
                ],
                providers: [
                    IgxColumnResizingService
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingDropDirective, [{
        type: Directive,
        args: [{
                selector: '[igxColumnMovingDrop]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.NgZone }, { type: IgxColumnMovingService }]; }, { data: [{
            type: Input,
            args: ['igxColumnMovingDrop']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnMovingModule, { declarations: [IgxColumnMovingDropDirective,
        IgxColumnMovingDragDirective], exports: [IgxColumnMovingDropDirective,
        IgxColumnMovingDragDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnMovingModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ],
                exports: [
                    IgxColumnMovingDropDirective,
                    IgxColumnMovingDragDirective
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBadgeComponent, [{
        type: Component,
        args: [{
                selector: 'igx-badge',
                template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], type: [{
            type: Input
        }], value: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-badge']
        }], label: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], icon: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxBadgeModule, { declarations: function () { return [IgxBadgeComponent]; }, imports: function () { return [CommonModule,
        IgxIconModule]; }, exports: function () { return [IgxBadgeComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBadgeModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxBadgeComponent],
                exports: [IgxBadgeComponent],
                imports: [CommonModule, IgxIconModule]
            }]
    }], null, null); })();
const ɵIgxGridAPIService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxGridAPIService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridAPIService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridGroupByRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-groupby-row',
                template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n            <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n            </ng-container>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n    <ng-template #defaultGroupByCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </ng-template>\n\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxGridSelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isFocused: [{
            type: Input
        }], expanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], describedBy: [{
            type: HostBinding,
            args: ['attr.aria-describedby']
        }], dataRowIndex: [{
            type: HostBinding,
            args: ['attr.data-rowIndex']
        }], attrCellID: [{
            type: HostBinding,
            args: ['attr.id']
        }], styleClasses: [{
            type: HostBinding,
            args: ['class']
        }], activate: [{
            type: HostListener,
            args: ['pointerdown']
        }], defaultGroupByExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultGroupByExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultGroupByCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultGroupByCollapsedTemplate', { read: TemplateRef, static: true }]
        }], index: [{
            type: Input
        }], gridID: [{
            type: Input
        }], groupRow: [{
            type: Input
        }], groupContent: [{
            type: ViewChild,
            args: ['groupContent', { static: true }]
        }] }); })();
const ɵIgxGridMRLNavigationService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxGridMRLNavigationService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridMRLNavigationService, [{
        type: Injectable
    }], null, null); })();
const ɵIgxGridComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    IgxGridNavigationService,
                    IgxGridSummaryService,
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxGridComponent_1) },
                    IgxFilteringService,
                    IgxColumnResizingService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ],
                selector: 'igx-grid',
                template: "<igx-grid-toolbar [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" role=\"toolbar\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\" (focus)=\"navigation.focusFirstCell()\"\n    [style.width.px]='calcWidth' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.headerNavigation($event)\" (scroll)=\"preventHeaderScroll($event)\" #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"pinnedWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.handleNavigation($event)\" (focus)=\"navigation.focusTbody($event)\"\n        role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (scroll)='preventContainerScroll($event)'\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n    <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n    </ng-container>\n    <ng-template #pinnedRecordsTemplate>\n        <ng-container *ngIf='data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridRowPinning:id:true:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData'>\n            <div #pinContainer *ngIf='pinnedData.length > 0'\n                [ngClass]=\"{\n                    'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                    'igx-grid__tr--pinned-top': isRowPinningToTop\n                }\"\n                class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                    <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                    </ng-container>\n                </ng-container>\n            </div>\n        </ng-container>\n    </ng-template>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\n        | gridDetails:hasDetails:expansionStates:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='getRowTemplate(rowData)'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-rowData let-disabledRow=\"disabled\">\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [disabled]=\"disabledRow\" #row>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row #pinnedRow>\n            </igx-grid-row>\n        </ng-template>\n        <ng-template #group_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n            </igx-grid-groupby-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-template #detail_template_container let-rowIndex=\"index\" let-rowData>\n            <div detail='true' style=\"overflow:auto;width: 100%;\" id=\"{{id}}_{{rowIndex}}\" (pointerdown)='detailsViewFocused(detailsContainer, rowIndex)' #detailsContainer [attr.data-rowindex]='rowIndex'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr-container--active': isDetailActive(rowIndex)\n            }\">\n                <div class=\"igx-grid__hierarchical-indent\" style='display:flex;'>\n                        <ng-container *ngIf=\"this.groupingExpressions.length > 0\">\n                                <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"></div>\n                        </ng-container>\n                        <ng-template\n                    [ngTemplateOutlet]='detailTemplate'\n                    [ngTemplateOutletContext]='getDetailsContext(rowData, rowIndex)'>\n                    </ng-template>\n                </div>\n            </div>\n        </ng-template>\n\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\"\n(focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth'  [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n"
            }]
    }], null, { groupingExpressionsChange: [{
            type: Output
        }], groupingExpansionStateChange: [{
            type: Output
        }], groupsExpanded: [{
            type: Input
        }], onGroupingDone: [{
            type: Output
        }], detailTemplate: [{
            type: ContentChild,
            args: [IgxGridDetailTemplateDirective, { read: TemplateRef, static: false }]
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], data: [{
            type: Input
        }], groupingExpressions: [{
            type: Input
        }], groupingExpansionState: [{
            type: Input
        }], hideGroupedColumns: [{
            type: Input
        }], dropAreaMessage: [{
            type: Input
        }], dropAreaTemplate: [{
            type: Input
        }], groupTemplate: [{
            type: ContentChild,
            args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective }]
        }], gridDetailsTemplate: [{
            type: ContentChild,
            args: [IgxGridDetailTemplateDirective, { read: IgxGridDetailTemplateDirective, static: false }]
        }], _groupsRowList: [{
            type: ViewChildren,
            args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent }]
        }], defaultDropAreaTemplate: [{
            type: ViewChild,
            args: ['defaultDropArea', { read: TemplateRef, static: true }]
        }], groupArea: [{
            type: ViewChild,
            args: ['groupArea']
        }], recordTemplate: [{
            type: ViewChild,
            args: ['record_template', { read: TemplateRef, static: true }]
        }], detailTemplateContainer: [{
            type: ViewChild,
            args: ['detail_template_container', { read: TemplateRef, static: true }]
        }], defaultGroupTemplate: [{
            type: ViewChild,
            args: ['group_template', { read: TemplateRef, static: true }]
        }], summaryTemplate: [{
            type: ViewChild,
            args: ['summary_template', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridStateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridState]'
            }]
    }], function () { return [{ type: IgxGridComponent, decorators: [{
                type: Host
            }, {
                type: Optional
            }] }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }]; }, { options: [{
            type: Input,
            args: ['igxGridState']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridStateModule, { declarations: [IgxGridStateDirective], exports: [IgxGridStateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridStateModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxGridStateDirective],
                exports: [IgxGridStateDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridSharedModules, { imports: function () { return [CommonModule,
        FormsModule,
        IgxButtonModule,
        IgxDatePickerModule,
        IgxIconModule,
        IgxRippleModule,
        IgxInputGroupModule,
        IgxFocusModule,
        IgxToggleModule,
        IgxForOfModule,
        IgxTemplateOutletModule,
        IgxTextHighlightModule,
        IgxTextSelectionModule,
        IgxCheckboxModule,
        IgxBadgeModule,
        IgxChipsModule,
        IgxDragDropModule,
        IgxDropDownModule,
        IgxButtonGroupModule,
        IgxProgressBarModule,
        IgxSelectModule,
        IgxGridStateModule]; }, exports: function () { return [CommonModule,
        FormsModule,
        IgxButtonModule,
        IgxDatePickerModule,
        IgxIconModule,
        IgxRippleModule,
        IgxInputGroupModule,
        IgxFocusModule,
        IgxToggleModule,
        IgxForOfModule,
        IgxTemplateOutletModule,
        IgxTextHighlightModule,
        IgxGridStateModule,
        IgxTextSelectionModule,
        IgxCheckboxModule,
        IgxBadgeModule,
        IgxChipsModule,
        IgxDragDropModule,
        IgxDropDownModule,
        IgxButtonGroupModule,
        IgxProgressBarModule,
        IgxSelectModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSharedModules, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule,
                    IgxGridStateModule
                ],
                exports: [
                    CommonModule,
                    FormsModule,
                    IgxButtonModule,
                    IgxDatePickerModule,
                    IgxIconModule,
                    IgxRippleModule,
                    IgxInputGroupModule,
                    IgxFocusModule,
                    IgxToggleModule,
                    IgxForOfModule,
                    IgxTemplateOutletModule,
                    IgxTextHighlightModule,
                    IgxGridStateModule,
                    IgxTextSelectionModule,
                    IgxCheckboxModule,
                    IgxBadgeModule,
                    IgxChipsModule,
                    IgxDragDropModule,
                    IgxDropDownModule,
                    IgxButtonGroupModule,
                    IgxProgressBarModule,
                    IgxSelectModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSummaryDataPipe, [{
        type: Pipe,
        args: [{
                name: 'igxGridSummaryDataPipe',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridSummaryModule, { declarations: [IgxSummaryCellComponent,
        IgxSummaryRowComponent,
        IgxSummaryDataPipe], imports: [IgxGridPipesModule,
        IgxGridSharedModules], exports: [IgxSummaryCellComponent,
        IgxSummaryRowComponent,
        IgxSummaryDataPipe] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSummaryModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ],
                imports: [
                    IgxGridPipesModule,
                    IgxGridSharedModules
                ],
                exports: [
                    IgxSummaryCellComponent,
                    IgxSummaryRowComponent,
                    IgxSummaryDataPipe
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnHidingModule, { declarations: [IgxColumnHidingComponent,
        IgxColumnHidingItemDirective], imports: [IgxGridSharedModules], exports: [IgxColumnHidingComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnHidingModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnHidingComponent,
                    IgxColumnHidingItemDirective
                ],
                imports: [
                    IgxGridSharedModules
                ],
                exports: [
                    IgxColumnHidingComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxColumnPinningModule, { declarations: [IgxColumnPinningItemDirective,
        IgxColumnPinningComponent], imports: [IgxGridSharedModules], exports: [IgxColumnPinningComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnPinningModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxColumnPinningItemDirective,
                    IgxColumnPinningComponent
                ],
                imports: [
                    IgxGridSharedModules
                ],
                exports: [
                    IgxColumnPinningComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridToolbarModule, { declarations: [IgxGridToolbarComponent,
        IgxGridToolbarCustomContentDirective], imports: [IgxGridSharedModules,
        IgxColumnHidingModule,
        IgxColumnPinningModule], exports: [IgxGridToolbarComponent,
        IgxGridToolbarCustomContentDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridToolbarModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxColumnHidingModule,
                    IgxColumnPinningModule
                ],
                exports: [
                    IgxGridToolbarComponent,
                    IgxGridToolbarCustomContentDirective
                ]
            }]
    }], null, null); })();
const ɵIgxColumnLayoutComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxColumnLayoutComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxColumnLayoutComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(() => IgxColumnLayoutComponent_1) }],
                selector: 'igx-column-layout',
                template: ``
            }]
    }], null, { hidden: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridColumnModule, { declarations: [IgxFilterCellTemplateDirective,
        IgxCellTemplateDirective,
        IgxCellHeaderTemplateDirective,
        IgxCellFooterTemplateDirective,
        IgxCellEditorTemplateDirective,
        IgxCollapsibleIndicatorTemplateDirective,
        IgxColumnComponent,
        IgxColumnGroupComponent,
        IgxColumnLayoutComponent], exports: [IgxFilterCellTemplateDirective,
        IgxCellTemplateDirective,
        IgxCellHeaderTemplateDirective,
        IgxCellFooterTemplateDirective,
        IgxCellEditorTemplateDirective,
        IgxCollapsibleIndicatorTemplateDirective,
        IgxColumnComponent,
        IgxColumnGroupComponent,
        IgxColumnLayoutComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridColumnModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                entryComponents: [
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ],
                exports: [
                    IgxFilterCellTemplateDirective,
                    IgxCellTemplateDirective,
                    IgxCellHeaderTemplateDirective,
                    IgxCellFooterTemplateDirective,
                    IgxCellEditorTemplateDirective,
                    IgxCollapsibleIndicatorTemplateDirective,
                    IgxColumnComponent,
                    IgxColumnGroupComponent,
                    IgxColumnLayoutComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridFilteringModule, { declarations: [IgxGridFilteringCellComponent,
        IgxGridFilteringRowComponent], imports: [IgxGridSharedModules,
        IgxGridPipesModule], exports: [IgxGridFilteringCellComponent,
        IgxGridFilteringRowComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridPipesModule
                ],
                exports: [
                    IgxGridFilteringCellComponent,
                    IgxGridFilteringRowComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridHeadersModule, { declarations: [IgxGridHeaderComponent,
        IgxGridHeaderGroupComponent], imports: [IgxGridSharedModules,
        IgxGridFilteringModule,
        IgxColumnMovingModule,
        IgxGridResizingModule], exports: [IgxGridHeaderComponent,
        IgxGridHeaderGroupComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHeadersModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent
                ],
                imports: [
                    IgxGridSharedModules,
                    IgxGridFilteringModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule
                ],
                exports: [
                    IgxGridHeaderComponent,
                    IgxGridHeaderGroupComponent
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridCommonModule, { declarations: [IgxGridBaseDirective,
        IgxRowDirective,
        IgxGridCellComponent,
        IgxRowEditTemplateDirective,
        IgxRowEditActionsDirective,
        IgxRowEditTextDirective,
        IgxRowEditTabStopDirective,
        IgxGridBodyDirective,
        IgxGridFooterComponent,
        IgxAdvancedFilteringDialogComponent], imports: [IgxGridColumnModule,
        IgxGridHeadersModule,
        IgxColumnMovingModule,
        IgxGridResizingModule,
        IgxColumnPinningModule,
        IgxGridSelectionModule,
        IgxGridSummaryModule,
        IgxGridToolbarModule,
        IgxColumnHidingModule,
        IgxGridPipesModule,
        IgxGridFilteringModule,
        IgxGridExcelStyleFilteringModule,
        IgxRowDragModule,
        IgxPaginatorModule,
        IgxGridSharedModules], exports: [IgxGridCellComponent,
        IgxRowEditTemplateDirective,
        IgxRowEditActionsDirective,
        IgxRowEditTextDirective,
        IgxRowEditTabStopDirective,
        IgxGridBodyDirective,
        IgxColumnHidingModule,
        IgxColumnPinningModule,
        IgxGridColumnModule,
        IgxGridHeadersModule,
        IgxGridPipesModule,
        IgxGridFilteringModule,
        IgxGridExcelStyleFilteringModule,
        IgxRowDragModule,
        IgxPaginatorModule,
        IgxGridFooterComponent,
        IgxGridResizingModule,
        IgxColumnMovingModule,
        IgxGridSelectionModule,
        IgxGridSummaryModule,
        IgxGridToolbarModule,
        IgxAdvancedFilteringDialogComponent,
        IgxGridSharedModules] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridCommonModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridBaseDirective,
                    IgxRowDirective,
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxGridFooterComponent,
                    IgxAdvancedFilteringDialogComponent
                ],
                entryComponents: [
                    IgxAdvancedFilteringDialogComponent
                ],
                exports: [
                    IgxGridCellComponent,
                    IgxRowEditTemplateDirective,
                    IgxRowEditActionsDirective,
                    IgxRowEditTextDirective,
                    IgxRowEditTabStopDirective,
                    IgxGridBodyDirective,
                    IgxColumnHidingModule,
                    IgxColumnPinningModule,
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridFooterComponent,
                    IgxGridResizingModule,
                    IgxColumnMovingModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxAdvancedFilteringDialogComponent,
                    IgxGridSharedModules
                ],
                imports: [
                    IgxGridColumnModule,
                    IgxGridHeadersModule,
                    IgxColumnMovingModule,
                    IgxGridResizingModule,
                    IgxColumnPinningModule,
                    IgxGridSelectionModule,
                    IgxGridSummaryModule,
                    IgxGridToolbarModule,
                    IgxColumnHidingModule,
                    IgxGridPipesModule,
                    IgxGridFilteringModule,
                    IgxGridExcelStyleFilteringModule,
                    IgxRowDragModule,
                    IgxPaginatorModule,
                    IgxGridSharedModules
                ],
                providers: [
                    { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridActionsBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxGridActionsBase]'
            }]
    }], function () { return [{ type: IgxActionStripComponent, decorators: [{
                type: Inject,
                args: [IgxActionStripComponent]
            }] }]; }, null); })();
const ɵIgxGridEditingActionsComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxGridEditingActionsComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridEditingActionsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-editing-actions',
                template: "<ng-container *ngIf=\"isRowContext\">\n    <button igxButton=\"icon\" [disabled]=\"disabled\" igxRipple (click)=\"startEdit($event)\">\n        <igx-icon>edit</igx-icon>\n    </button>\n    <button igxButton=\"icon\" [disabled]=\"disabled\" class=\"igx-action-strip__delete\" igxRipple (click)=\"deleteRow($event)\">\n        <igx-icon >delete</igx-icon>\n    </button>\n</ng-container>\n",
                providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridEditingActionsComponent_1 }]
            }]
    }], null, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-action-strip__editing-actions']
        }] }); })();
const ɵIgxGridPinningActionsComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxGridPinningActionsComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPinningActionsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-grid-pinning-actions',
                template: "<ng-container *ngIf=\"isRowContext\">\n    <button *ngIf=\"inPinnedArea && pinnedTop\" igxRipple igxButton=\"icon\" (click)=\"scrollToRow($event)\">\n        <igx-icon fontSet=\"filtering-icons\" name=\"jump_down\"></igx-icon>\n    </button>\n    <button *ngIf=\"inPinnedArea && !pinnedTop\" igxRipple igxButton=\"icon\" (click)=\"scrollToRow($event)\">\n        <igx-icon fontSet=\"filtering-icons\" name=\"jump_up\"></igx-icon>\n    </button>\n    <button *ngIf=\"!pinned\" igxRipple igxButton=\"icon\" (click)=\"pin($event)\">\n        <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n    </button>\n    <button *ngIf=\"pinned\" igxRipple igxButton=\"icon\" (click)=\"unpin($event)\">\n        <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n    </button>\n</ng-container>",
                providers: [{ provide: IgxGridActionsBaseDirective, useExisting: IgxGridPinningActionsComponent_1 }]
            }]
    }], null, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-action-strip__pining-actions']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxActionStripModule, { declarations: function () { return [IgxActionStripComponent,
        IgxActionStripMenuItemDirective,
        IgxGridPinningActionsComponent,
        IgxGridEditingActionsComponent,
        IgxGridActionsBaseDirective]; }, imports: function () { return [CommonModule,
        IgxDropDownModule,
        IgxToggleModule,
        IgxButtonModule,
        IgxIconModule,
        IgxRippleModule]; }, exports: function () { return [IgxActionStripComponent,
        IgxActionStripMenuItemDirective,
        IgxGridPinningActionsComponent,
        IgxGridEditingActionsComponent,
        IgxGridActionsBaseDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionStripModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxActionStripComponent,
                    IgxActionStripMenuItemDirective,
                    IgxGridPinningActionsComponent,
                    IgxGridEditingActionsComponent,
                    IgxGridActionsBaseDirective
                ],
                entryComponents: [],
                exports: [
                    IgxActionStripComponent,
                    IgxActionStripMenuItemDirective,
                    IgxGridPinningActionsComponent,
                    IgxGridEditingActionsComponent,
                    IgxGridActionsBaseDirective
                ],
                imports: [CommonModule, IgxDropDownModule, IgxToggleModule, IgxButtonModule, IgxIconModule, IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelBodyComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-body',
                template: `<ng-content></ng-content>`
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_EXPANSION_PANEL_COMPONENT]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__body']
        }], role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }], label: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-label']
        }], labelledBy: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelTitleDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-title'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header-title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelDescriptionDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-description'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header-description']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelIconDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-expansion-panel-icon'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'igx-expansion-panel-header',
                template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\" fontSet=\"material\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Host
            }, {
                type: Inject,
                args: [IGX_EXPANSION_PANEL_COMPONENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }]; }, { lv: [{
            type: HostBinding,
            args: ['attr.aria-level']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], iconPosition: [{
            type: Input
        }], onInteraction: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.igx-expansion-panel--disabled']
        }], iconTemplate: [{
            type: ContentChild,
            args: [IgxExpansionPanelIconDirective]
        }], isExpanded: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel__header--expanded']
        }], onAction: [{
            type: HostListener,
            args: ['keydown.Enter', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Space', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Spacebar', ['$event']]
        }, {
            type: HostListener,
            args: ['click', ['$event']]
        }], openPanel: [{
            type: HostListener,
            args: ['keydown.Alt.ArrowDown', ['$event']]
        }], closePanel: [{
            type: HostListener,
            args: ['keydown.Alt.ArrowUp', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelComponent, [{
        type: Component,
        args: [{
                selector: 'igx-expansion-panel',
                template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.AnimationBuilder }]; }, { animationSettings: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-expansion-panel']
        }], collapsedChange: [{
            type: Output
        }], onCollapsed: [{
            type: Output
        }], onExpanded: [{
            type: Output
        }], collapsed: [{
            type: Input
        }], body: [{
            type: ContentChild,
            args: [IgxExpansionPanelBodyComponent, { read: IgxExpansionPanelBodyComponent }]
        }], header: [{
            type: ContentChild,
            args: [IgxExpansionPanelHeaderComponent, { read: IgxExpansionPanelHeaderComponent }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxExpansionPanelModule, { declarations: function () { return [IgxExpansionPanelComponent,
        IgxExpansionPanelHeaderComponent,
        IgxExpansionPanelBodyComponent,
        IgxExpansionPanelDescriptionDirective,
        IgxExpansionPanelTitleDirective,
        IgxExpansionPanelIconDirective]; }, imports: function () { return [CommonModule,
        IgxRippleModule,
        IgxIconModule,
        IgxButtonModule,
        IgxAvatarModule]; }, exports: function () { return [IgxExpansionPanelComponent,
        IgxExpansionPanelHeaderComponent,
        IgxExpansionPanelBodyComponent,
        IgxExpansionPanelDescriptionDirective,
        IgxExpansionPanelTitleDirective,
        IgxExpansionPanelIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxExpansionPanelModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                entryComponents: [],
                exports: [
                    IgxExpansionPanelComponent,
                    IgxExpansionPanelHeaderComponent,
                    IgxExpansionPanelBodyComponent,
                    IgxExpansionPanelDescriptionDirective,
                    IgxExpansionPanelTitleDirective,
                    IgxExpansionPanelIconDirective
                ],
                imports: [
                    CommonModule,
                    IgxRippleModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxAvatarModule
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBannerActionsDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-banner-actions'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBannerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-banner',
                template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { onOpened: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], animationSettings: [{
            type: Input
        }], displayStyle: [{
            type: HostBinding,
            args: ['style.display']
        }], _expansionPanel: [{
            type: ViewChild,
            args: ['expansionPanel', { static: true }]
        }], _bannerActionTemplate: [{
            type: ContentChild,
            args: [IgxBannerActionsDirective]
        }], bannerIcon: [{
            type: ContentChild,
            args: [IgxIconComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxBannerModule, { declarations: function () { return [IgxBannerComponent,
        IgxBannerActionsDirective]; }, imports: function () { return [CommonModule,
        IgxExpansionPanelModule,
        IgxIconModule,
        IgxButtonModule,
        IgxRippleModule]; }, exports: function () { return [IgxBannerComponent,
        IgxBannerActionsDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBannerModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                exports: [IgxBannerComponent, IgxBannerActionsDirective],
                imports: [CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardMediaDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-media'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card__media']
        }], width: [{
            type: HostBinding,
            args: ['style.width']
        }, {
            type: HostBinding,
            args: ['style.min-width']
        }, {
            type: Input
        }], height: [{
            type: HostBinding,
            args: ['style.height']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'igx-card-header',
                template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-header']
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-card-header--vertical']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardThumbnailDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCardThumbnail]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardHeaderTitleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCardHeaderTitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-header__title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardHeaderSubtitleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCardHeaderSubtitle]'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-header__subtitle']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardContentDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-content'
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-card-content']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardFooterDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-footer'
            }]
    }], function () { return []; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardComponent, [{
        type: Component,
        args: [{
                selector: 'igx-card',
                template: "<ng-container select='igx-card-media'></ng-container>\n\n<ng-container select='igx-card-header'></ng-container>\n<ng-container select='igx-card-content'>\n    <ng-content></ng-content>\n</ng-container>\n\n<ng-container select='igx-card-actions'></ng-container>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }, {
            type: Input
        }], type: [{
            type: HostBinding,
            args: ['class.igx-card']
        }, {
            type: Input
        }], horizontal: [{
            type: HostBinding,
            args: ['class.igx-card--horizontal']
        }, {
            type: Input
        }], isOutlinedCard: [{
            type: HostBinding,
            args: ['class.igx-card--outlined']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardActionsComponent, [{
        type: Component,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-card-actions',
                template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: IgxCardComponent, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [IgxCardComponent]
            }] }]; }, { layout: [{
            type: HostBinding,
            args: ['class.igx-card-actions']
        }, {
            type: Input
        }], reverse: [{
            type: HostBinding,
            args: ['class.igx-card-actions--reverse']
        }, {
            type: Input
        }], isJustifyLayout: [{
            type: HostBinding,
            args: ['class.igx-card-actions--justify']
        }], vertical: [{
            type: HostBinding,
            args: ['class.igx-card-actions--vertical']
        }, {
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCardModule, { declarations: function () { return [IgxCardComponent,
        IgxCardHeaderComponent,
        IgxCardMediaDirective,
        IgxCardContentDirective,
        IgxCardActionsComponent,
        IgxCardFooterDirective,
        IgxCardHeaderTitleDirective,
        IgxCardHeaderSubtitleDirective,
        IgxCardThumbnailDirective]; }, imports: function () { return [CommonModule,
        IgxButtonModule]; }, exports: function () { return [IgxCardComponent,
        IgxCardHeaderComponent,
        IgxCardMediaDirective,
        IgxCardContentDirective,
        IgxCardActionsComponent,
        IgxCardFooterDirective,
        IgxCardHeaderTitleDirective,
        IgxCardHeaderSubtitleDirective,
        IgxCardThumbnailDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCardModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                exports: [
                    IgxCardComponent,
                    IgxCardHeaderComponent,
                    IgxCardMediaDirective,
                    IgxCardContentDirective,
                    IgxCardActionsComponent,
                    IgxCardFooterDirective,
                    IgxCardHeaderTitleDirective,
                    IgxCardHeaderSubtitleDirective,
                    IgxCardThumbnailDirective,
                ],
                imports: [CommonModule, IgxButtonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselIndicatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCarouselIndicator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselNextButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCarouselNextButton]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselPrevButtonDirective, [{
        type: Directive,
        args: [{
                selector: '[igxCarouselPrevButton]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSlideComponent, [{
        type: Component,
        args: [{
                selector: 'igx-slide',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-slide']
        }], previous: [{
            type: HostBinding,
            args: ['class.igx-slide--previous']
        }, {
            type: Input
        }], activeChange: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], ariaLive: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], active: [{
            type: HostBinding,
            args: ['class.igx-slide--current']
        }, {
            type: Input
        }], index: [{
            type: Input
        }], direction: [{
            type: Input
        }] }); })();
const ɵCarouselHammerConfig_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(CarouselHammerConfig);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CarouselHammerConfig, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: CarouselHammerConfig
                    }
                ],
                selector: 'igx-carousel',
                template: "<ng-template #defaultIndicator let-slide>\n    <div class=\"igx-nav-dot\"\n        [class.igx-nav-dot--active]=\"slide.active\"\n    >\n    </div>\n</ng-template>\n\n<ng-template #defaultNextButton let-disabled>\n    <a class=\"igx-nav-arrow\"\n        [class.igx-nav-arrow--disabled]=\"disabled\"\n    >\n        <igx-icon fontSet=\"material\">arrow_forward</igx-icon>\n    </a>\n</ng-template>\n\n<ng-template #defaultPrevButton let-disabled>\n    <a class=\"igx-nav-arrow\"\n        [class.igx-nav-arrow--disabled]=\"disabled\"\n    >\n        <igx-icon fontSet=\"material\">arrow_back</igx-icon>\n    </a>\n</ng-template>\n\n\n<div *ngIf=\"showIndicators\" [ngClass]=\"indicatorsOrientationClass\">\n    <div *ngFor=\"let slide of slides\"\n        class=\"igx-carousel-indicators__indicator\"\n        (click)=\"select(slide)\"\n        [attr.aria-label]=\"setAriaLabel(slide)\"\n        [attr.aria-selected]=\"slide.active\">\n        <ng-container *ngTemplateOutlet=\"getIndicatorTemplate; context: {$implicit: slide};\"></ng-container>\n    </div>\n</div>\n\n<div *ngIf=\"showIndicatorsLabel\" [ngClass]=\"indicatorsOrientationClass\">\n    <span class=\"igx-carousel__label\">{{getCarouselLabel}}</span>\n</div>\n\n<div class=\"igx-carousel__inner\" role=\"list\">\n    <ng-content></ng-content>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" (click)=\"prev()\">\n    <ng-container *ngTemplateOutlet=\"getPrevButtonTemplate; context: {$implicit: prevButtonDisabled};\"></ng-container>\n</div>\n\n<div *ngIf=\"navigation && slides.length\" role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" (click)=\"next()\">\n    <ng-container *ngTemplateOutlet=\"getNextButtonTemplate; context: {$implicit: nextButtonDisabled};\"></ng-container>\n</div>\n\n\n\n",
                styles: [`
    :host {
        display: block;
        outline-style: none;
    }`]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc1.AnimationBuilder }, { type: PlatformUtil }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-carousel']
        }], loop: [{
            type: Input
        }], pause: [{
            type: Input
        }], navigation: [{
            type: Input
        }], keyboardSupport: [{
            type: Input
        }], gesturesSupport: [{
            type: Input
        }], maximumIndicatorsCount: [{
            type: Input
        }], indicatorsOrientation: [{
            type: Input
        }], animationType: [{
            type: Input
        }], indicatorTemplate: [{
            type: ContentChild,
            args: [IgxCarouselIndicatorDirective, { read: TemplateRef, static: false }]
        }], nextButtonTemplate: [{
            type: ContentChild,
            args: [IgxCarouselNextButtonDirective, { read: TemplateRef, static: false }]
        }], prevButtonTemplate: [{
            type: ContentChild,
            args: [IgxCarouselPrevButtonDirective, { read: TemplateRef, static: false }]
        }], onSlideChanged: [{
            type: Output
        }], onSlideAdded: [{
            type: Output
        }], onSlideRemoved: [{
            type: Output
        }], onCarouselPaused: [{
            type: Output
        }], onCarouselPlaying: [{
            type: Output
        }], tabIndex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], touchAction: [{
            type: HostBinding,
            args: ['style.touch-action']
        }], interval: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }], onKeydownArrowRight: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }], onKeydownArrowLeft: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }], onTap: [{
            type: HostListener,
            args: ['tap', ['$event']]
        }], onKeydownHome: [{
            type: HostListener,
            args: ['keydown.home', ['$event']]
        }], onKeydownEnd: [{
            type: HostListener,
            args: ['keydown.end', ['$event']]
        }], onMouseEnter: [{
            type: HostListener,
            args: ['mouseenter']
        }], onMouseLeave: [{
            type: HostListener,
            args: ['mouseleave']
        }], onPanLeft: [{
            type: HostListener,
            args: ['panleft', ['$event']]
        }], onPanRight: [{
            type: HostListener,
            args: ['panright', ['$event']]
        }], onPanEnd: [{
            type: HostListener,
            args: ['panend', ['$event']]
        }], defaultIndicator: [{
            type: ViewChild,
            args: ['defaultIndicator', { read: TemplateRef, static: true }]
        }], defaultNextButton: [{
            type: ViewChild,
            args: ['defaultNextButton', { read: TemplateRef, static: true }]
        }], defaultPrevButton: [{
            type: ViewChild,
            args: ['defaultPrevButton', { read: TemplateRef, static: true }]
        }], slides: [{
            type: ContentChildren,
            args: [IgxSlideComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxCarouselModule, { declarations: function () { return [IgxCarouselComponent,
        IgxSlideComponent,
        IgxCarouselIndicatorDirective,
        IgxCarouselNextButtonDirective,
        IgxCarouselPrevButtonDirective]; }, imports: function () { return [CommonModule,
        IgxIconModule]; }, exports: function () { return [IgxCarouselComponent,
        IgxSlideComponent,
        IgxCarouselIndicatorDirective,
        IgxCarouselNextButtonDirective,
        IgxCarouselPrevButtonDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxCarouselModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                exports: [
                    IgxCarouselComponent,
                    IgxSlideComponent,
                    IgxCarouselIndicatorDirective,
                    IgxCarouselNextButtonDirective,
                    IgxCarouselPrevButtonDirective
                ],
                imports: [CommonModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboHeaderDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboHeader]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboFooterDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboFooter]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboItem]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboEmptyDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboEmpty]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboHeaderItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboHeaderItem]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboAddItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboAddItem]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboToggleIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboToggleIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboClearIconDirective, [{
        type: Directive,
        args: [{
                selector: '[igxComboClearIcon]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboAPIService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo-item',
                template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" [tabindex]=\"-1\" (click)=\"disableCheck($event)\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: IgxComboAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IGX_DROPDOWN_BASE]
            }] }, { type: ɵngcc0.ElementRef }, { type: IgxSelectionAPIService, decorators: [{
                type: Inject,
                args: [IgxSelectionAPIService]
            }] }]; }, { itemHeight: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['style.height.px']
        }] }); })();
const ɵIgxComboAddItemComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxComboAddItemComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboAddItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo-add-item',
                template: '<ng-content></ng-content>',
                providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent_1 }]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboDropDownComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo-drop-down',
                template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\"\n(onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\" (onAppended)=\"onToggleContentAppended()\"\n(onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <div class=\"igx-drop-down__list-scroll\" #scrollContainer [attr.id]=\"this.listId\" role=\"listbox\"\n    [style.height]=\"height\"\n    [style.maxHeight]=\"maxHeight\">\n        <ng-container *ngIf=\"!collapsed\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</div>\n",
                providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IGX_COMBO_COMPONENT]
            }] }, { type: IgxComboAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { children: [{
            type: ContentChildren,
            args: [IgxComboItemComponent, { descendants: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboFilteringPipe, [{
        type: Pipe,
        args: [{
                name: 'comboFiltering'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboGroupingPipe, [{
        type: Pipe,
        args: [{
                name: 'comboGrouping'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_COMBO_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboComponent, [{
        type: Component,
        args: [{
                selector: 'igx-combo',
                template: "<igx-input-group #inputGroup [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n        <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n    </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [attr.placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" (focus)=\"onFocus()\"/>\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\"\n        (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\" fontSet=\"material\">\n            clear\n        </igx-icon>\n    </igx-suffix>\n    <igx-suffix igxButton=\"icon\" class=\"igx-combo__toggle-button\" igxRipple>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">\n            {{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}\n        </igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [displayDensity]=\"displayDensity\"\n    [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\" (onClosing)=\"handleClosing($event)\"\n    (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [attr.placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\"\n        [style.maxHeight.px]=\"itemsMaxHeight\" [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\"\n        [tabindex]=\"dropdown.collapsed ? -1 : 0\" role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <igx-combo-item role=\"option\" [itemHeight]='itemHeight'\n            *igxFor=\"let item of data\n            | comboFiltering:searchValue:displayKey:filterable\n            | comboGrouping:groupKey:valueKey;\n            index as rowIndex; containerSize: itemsMaxHeight; scrollOrientation: 'vertical'; itemSize: itemHeight\"\n            [value]=\"item\" [isHeader]=\"item.isHeader\" [index]=\"rowIndex\">\n            <ng-container *ngIf=\"item.isHeader\">\n                <ng-container\n                    *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase;\n                    context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"!item.isHeader\">\n                <ng-container #listItem\n                    *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\">\n                </ng-container>\n            </ng-container>\n        </igx-combo-item>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\"\n            [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\" class=\"igx-combo__add-item\" role=\"button\"\n            aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>\n<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>",
                providers: [
                    IgxComboAPIService,
                    { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent_1 },
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxComboComponent_1, multi: true }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: IgxSelectionAPIService }, { type: IgxComboAPIService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: ɵngcc0.Injector, decorators: [{
                type: Optional
            }] }]; }, { overlaySettings: [{
            type: Input
        }], searchInput: [{
            type: ViewChild,
            args: ['searchInput']
        }], itemTemplate: [{
            type: ContentChild,
            args: [IgxComboItemDirective, { read: TemplateRef }]
        }], headerTemplate: [{
            type: ContentChild,
            args: [IgxComboHeaderDirective, { read: TemplateRef }]
        }], footerTemplate: [{
            type: ContentChild,
            args: [IgxComboFooterDirective, { read: TemplateRef }]
        }], headerItemTemplate: [{
            type: ContentChild,
            args: [IgxComboHeaderItemDirective, { read: TemplateRef }]
        }], addItemTemplate: [{
            type: ContentChild,
            args: [IgxComboAddItemDirective, { read: TemplateRef }]
        }], emptyTemplate: [{
            type: ContentChild,
            args: [IgxComboEmptyDirective, { read: TemplateRef }]
        }], toggleIconTemplate: [{
            type: ContentChild,
            args: [IgxComboToggleIconDirective, { read: TemplateRef }]
        }], clearIconTemplate: [{
            type: ContentChild,
            args: [IgxComboClearIconDirective, { read: TemplateRef }]
        }], dropdownContainer: [{
            type: ViewChild,
            args: ['dropdownItemContainer', { static: true }]
        }], onSelectionChange: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onAddition: [{
            type: Output
        }], onSearchInput: [{
            type: Output
        }], onDataPreLoad: [{
            type: Output
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-combo']
        }], role: [{
            type: HostBinding,
            args: [`attr.role`]
        }], allowCustomValues: [{
            type: Input
        }], searchPlaceholder: [{
            type: Input
        }], valueKey: [{
            type: Input
        }], filterable: [{
            type: Input
        }], disabled: [{
            type: Input
        }], type: [{
            type: Input
        }], autoFocusSearch: [{
            type: Input
        }], ariaExpanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], hasPopUp: [{
            type: HostBinding,
            args: ['attr.aria-haspopup']
        }], ariaOwns: [{
            type: HostBinding,
            args: ['attr.aria-owns']
        }], itemsMaxHeight: [{
            type: Input
        }], itemHeight: [{
            type: Input
        }], data: [{
            type: Input
        }], displayKey: [{
            type: Input
        }], groupKey: [{
            type: Input
        }], onArrowDown: [{
            type: HostListener,
            args: ['keydown.ArrowDown', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.Alt.ArrowDown', ['$event']]
        }], virtDir: [{
            type: ViewChild,
            args: [IgxForOfDirective, { read: IgxForOfDirective, static: true }]
        }], inputGroup: [{
            type: ViewChild,
            args: ['inputGroup', { read: IgxInputGroupComponent, static: true }]
        }], comboInput: [{
            type: ViewChild,
            args: ['comboInput', { read: IgxInputDirective, static: true }]
        }], dropdown: [{
            type: ViewChild,
            args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent, static: true }]
        }], primitiveTemplate: [{
            type: ViewChild,
            args: ['primitive', { read: TemplateRef, static: true }]
        }], complexTemplate: [{
            type: ViewChild,
            args: ['complex', { read: TemplateRef, static: true }]
        }], virtualScrollContainer: [{
            type: ViewChild,
            args: [IgxForOfDirective, { static: true }]
        }], width: [{
            type: HostBinding,
            args: ['style.width']
        }, {
            type: Input
        }], itemsWidth: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-labelledby']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxComboModule, { declarations: function () { return [IgxComboComponent,
        IgxComboItemComponent,
        IgxComboGroupingPipe,
        IgxComboFilteringPipe,
        IgxComboDropDownComponent,
        IgxComboAddItemComponent,
        IgxComboItemDirective,
        IgxComboEmptyDirective,
        IgxComboHeaderItemDirective,
        IgxComboHeaderDirective,
        IgxComboFooterDirective,
        IgxComboAddItemDirective,
        IgxComboToggleIconDirective,
        IgxComboClearIconDirective]; }, imports: function () { return [IgxRippleModule,
        CommonModule,
        IgxInputGroupModule,
        FormsModule, ReactiveFormsModule,
        IgxForOfModule,
        IgxToggleModule,
        IgxCheckboxModule,
        IgxDropDownModule,
        IgxButtonModule,
        IgxIconModule]; }, exports: function () { return [IgxComboComponent,
        IgxComboItemComponent,
        IgxComboDropDownComponent,
        IgxComboAddItemComponent,
        IgxComboItemDirective,
        IgxComboEmptyDirective,
        IgxComboHeaderItemDirective,
        IgxComboHeaderDirective,
        IgxComboFooterDirective,
        IgxComboAddItemDirective,
        IgxComboToggleIconDirective,
        IgxComboClearIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxComboModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboGroupingPipe,
                    IgxComboFilteringPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                    IgxComboItemDirective,
                    IgxComboEmptyDirective,
                    IgxComboHeaderItemDirective,
                    IgxComboHeaderDirective,
                    IgxComboFooterDirective,
                    IgxComboAddItemDirective,
                    IgxComboToggleIconDirective,
                    IgxComboClearIconDirective],
                imports: [IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
                    IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogTitleDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-dialog-title,[igxDialogTitle]'
            }]
    }], function () { return []; }, { defaultStyle: [{
            type: HostBinding,
            args: ['class.igx-dialog__window-title']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogActionsDirective, [{
        type: Directive,
        args: [{
                selector: 'igx-dialog-actions,[igxDialogActions]'
            }]
    }], function () { return []; }, { defaultClass: [{
            type: HostBinding,
            args: ['class.igx-dialog__window-actions']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogComponent, [{
        type: Component,
        args: [{
                selector: 'igx-dialog',
                template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\" *ngIf=\"message\">{{ message }}</div>\n        <ng-content *ngIf=\"!message\"></ng-content>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], title: [{
            type: Input
        }], message: [{
            type: Input
        }], leftButtonLabel: [{
            type: Input
        }], leftButtonType: [{
            type: Input
        }], leftButtonColor: [{
            type: Input
        }], leftButtonBackgroundColor: [{
            type: Input
        }], leftButtonRipple: [{
            type: Input
        }], rightButtonLabel: [{
            type: Input
        }], rightButtonType: [{
            type: Input
        }], rightButtonColor: [{
            type: Input
        }], rightButtonBackgroundColor: [{
            type: Input
        }], rightButtonRipple: [{
            type: Input
        }], onOpen: [{
            type: Output
        }], onClose: [{
            type: Output
        }], onLeftButtonSelect: [{
            type: Output
        }], onRightButtonSelect: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], isModal: [{
            type: Input
        }], closeOnOutsideSelect: [{
            type: Input
        }], positionSettings: [{
            type: Input
        }], isOpen: [{
            type: Input
        }], isCollapsed: [{
            type: HostBinding,
            args: ['class.igx-dialog--hidden']
        }], role: [{
            type: Input
        }], titleId: [{
            type: Input
        }], toggleRef: [{
            type: ViewChild,
            args: [IgxToggleDirective, { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDialogModule, { declarations: function () { return [IgxDialogComponent,
        IgxDialogTitleDirective,
        IgxDialogActionsDirective]; }, imports: function () { return [CommonModule,
        IgxToggleModule,
        IgxButtonModule,
        IgxRippleModule,
        IgxFocusModule]; }, exports: function () { return [IgxDialogComponent,
        IgxDialogTitleDirective,
        IgxDialogActionsDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDialogModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                imports: [CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSortingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridSort',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridGroupingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridGroupBy',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridPagingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridPaging',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridFilteringPipe, [{
        type: Pipe,
        args: [{
                name: 'gridFiltering',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-grid-row',
                template: "<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"this.showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n         <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n    </ng-template>\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? expandableCellTemplate : cellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcPixelWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\" [ngStyle]=\"{\n            'grid-template-rows':col.getGridTemplate(true, false),\n            'grid-template-columns':col.getGridTemplate(false, false),\n            '-ms-grid-rows':col.getGridTemplate(true, true),\n            '-ms-grid-columns':col.getGridTemplate(false, true)\n        }\">\n            <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails ? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n            </ng-template>\n        </div>\n    </ng-template>\n\n    <ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n        <ng-container *ngTemplateOutlet=\"mrlPinnedTemplate; context: getContextMRL(pinnedColumns, this)\"></ng-container>\n    </ng-container>\n</ng-container>\n\n<ng-template #mrlPinnedTemplate let-pinnedColumns>\n    <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n    [class.igx-grid__td--pinned-last]=\"col.hasLastPinnedChildColumn\"\n    [class.igx-grid__td--pinned-first]=\"col.hasFirstPinnedChildColumn\"\n    [style.left]=\"mrlRightPinnedOffset\"\n    [ngStyle]=\"{\n        'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)\n    }\">\n        <ng-template ngFor let-col [ngForOf]=\"col.children\">\n                <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 && grid.hasDetails? mrlExpandableCellTemplate : mrlCellTemplate; context: getContext(col, this)\"></ng-container>\n        </ng-template>\n    </div>\n</ng-template>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"selected\"\n            [readonly]=\"true\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #cellTemplate let-col>\n        <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [style.left]=\"col.rightPinnedOffset\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #expandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n\n<ng-template #mrlCellTemplate let-col>\n    <igx-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [firstPinned]=\"col.columnLayoutChild ? null : col.isFirstPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-grid-cell>\n</ng-template>\n\n<ng-template #mrlExpandableCellTemplate let-col>\n    <igx-expandable-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n        [class.igx-grid__td--pinned]=\"col.pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [expanded]=\"expanded\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [style.-ms-grid-row-span]=\"col.gridRowSpan\"\n        [style.-ms-grid-column-span]=\"col.gridColumnSpan\"\n        [style.grid-row-end]=\"col.rowEnd\"\n        [style.grid-column-end]=\"col.colEnd\"\n        [style.-ms-grid-row]=\"col.rowStart\"\n        [style.grid-row-start]=\"col.rowStart\"\n        [style.-ms-grid-column]=\"col.colStart\"\n        [style.grid-column-start]=\"col.colStart\"\n        [lastPinned]=\"col.columnLayoutChild ? null : col.isLastPinned\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n        #cell>\n    </igx-expandable-grid-cell>\n</ng-template>\n",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxGridRowComponent_1) }]
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: IgxGridCRUDService }, { type: IgxGridSelectionService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { hasColumnLayouts: [{
            type: HostBinding,
            args: ['class.igx-grid__tr--mrl']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridSummaryPipe, [{
        type: Pipe,
        args: [{
                name: 'gridSummary',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridDetailsPipe, [{
        type: Pipe,
        args: [{
                name: 'gridDetails',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridExpandableCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-expandable-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\" [metadata]=\"searchMetadata\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"true\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"showExpanderIndicator\">\n    <div #indicator\n         class=\"igx-grid__tree-grouping-indicator\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: PlatformUtil }]; }, { expanded: [{
            type: Input
        }], indicator: [{
            type: ViewChild,
            args: ['indicator', { read: ElementRef }]
        }], indentationDiv: [{
            type: ViewChild,
            args: ['indentationDiv', { read: ElementRef }]
        }], defaultExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxGridModule, { declarations: [IgxGridComponent,
        IgxGridRowComponent,
        IgxGridGroupByRowComponent,
        IgxGroupByRowTemplateDirective,
        IgxGridDetailTemplateDirective,
        IgxRowExpandedIndicatorDirective,
        IgxRowCollapsedIndicatorDirective,
        IgxHeaderExpandIndicatorDirective,
        IgxHeaderCollapseIndicatorDirective,
        IgxGroupAreaDropDirective,
        IgxGridGroupingPipe,
        IgxGridPagingPipe,
        IgxGridSortingPipe,
        IgxGridFilteringPipe,
        IgxGridSummaryPipe,
        IgxGridDetailsPipe,
        IgxGridExpandableCellComponent], imports: [IgxGridCommonModule], exports: [IgxGridComponent,
        IgxGridExpandableCellComponent,
        IgxGridGroupByRowComponent,
        IgxGridRowComponent,
        IgxGroupByRowTemplateDirective,
        IgxGridDetailTemplateDirective,
        IgxRowExpandedIndicatorDirective,
        IgxRowCollapsedIndicatorDirective,
        IgxHeaderExpandIndicatorDirective,
        IgxHeaderCollapseIndicatorDirective,
        IgxGroupAreaDropDirective,
        IgxGridGroupingPipe,
        IgxGridPagingPipe,
        IgxGridSortingPipe,
        IgxGridFilteringPipe,
        IgxGridSummaryPipe,
        IgxGridDetailsPipe,
        IgxGridCommonModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxGridComponent,
                    IgxGridRowComponent,
                    IgxGridGroupByRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridExpandableCellComponent
                ],
                exports: [
                    IgxGridComponent,
                    IgxGridExpandableCellComponent,
                    IgxGridGroupByRowComponent,
                    IgxGridRowComponent,
                    IgxGroupByRowTemplateDirective,
                    IgxGridDetailTemplateDirective,
                    IgxRowExpandedIndicatorDirective,
                    IgxRowCollapsedIndicatorDirective,
                    IgxHeaderExpandIndicatorDirective,
                    IgxHeaderCollapseIndicatorDirective,
                    IgxGroupAreaDropDirective,
                    IgxGridGroupingPipe,
                    IgxGridPagingPipe,
                    IgxGridSortingPipe,
                    IgxGridFilteringPipe,
                    IgxGridSummaryPipe,
                    IgxGridDetailsPipe,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
const ɵIgxTreeGridAPIService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridAPIService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridAPIService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowLoadingIndicatorTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRowLoadingIndicator]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
const ɵIgxTreeGridComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-tree-grid',
                template: "<igx-grid-toolbar role=\"toolbar\" [style.max-width.px]='outerWidth' [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (focus)=\"navigation.focusFirstCell()\" (keydown)=\"navigation.headerNavigation($event)\" #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\" [style.left]=\"col.rightPinnedOffset\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollWidth\"></div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" [attr.aria-activedescendant]=\"activeDescendant\" (keydown)=\"navigation.handleNavigation($event)\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf='data\n            | treeGridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | treeGridNormalizeRecord:pipeTrigger\n            | gridRowPinning:id:true:pipeTrigger\n            | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData'>\n                <div #pinContainer *ngIf='pinnedData.length > 0'\n                    [ngClass]=\"{\n                        'igx-grid__tr--pinned-bottom':  !isRowPinningToTop,\n                        'igx-grid__tr--pinned-top': isRowPinningToTop\n                    }\"\n                    class='igx-grid__tr--pinned' [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData;let rowIndex = index;\">\n                        <ng-container *ngTemplateOutlet=\"pinned_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:sortStrategy:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\"></ng-container>\n        <ng-template #record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" [disabled]=\"disabledRow\" #row>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #pinned_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row #pinnedRow>\n            </igx-tree-grid-row>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n            [style.height.px]='calcHeight'>\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' tabindex=\"0\" [attr.aria-activedescendant]=\"activeDescendant\" (focus)=\"navigation.focusFirstCell(false)\" (keydown)=\"navigation.summaryNav($event)\" #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"processedExpandedFlatData.length\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    IgxGridSummaryService,
                    IgxGridNavigationService,
                    { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxTreeGridComponent_1) },
                    IgxFilteringService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            }]
    }], null, { cascadeOnDelete: [{
            type: Input
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], data: [{
            type: Input
        }], expansionDepth: [{
            type: Input
        }], rowLoadingIndicatorTemplate: [{
            type: Input
        }], childDataKey: [{
            type: Input
        }], foreignKey: [{
            type: Input
        }], hasChildrenKey: [{
            type: Input
        }], rowLoadingTemplate: [{
            type: ContentChild,
            args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective }]
        }], loadChildrenOnDemand: [{
            type: Input
        }], dragIndicatorIconBase: [{
            type: ViewChild,
            args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
        }], recordTemplate: [{
            type: ViewChild,
            args: ['record_template', { read: TemplateRef, static: true }]
        }], summaryTemplate: [{
            type: ViewChild,
            args: ['summary_template', { read: TemplateRef, static: true }]
        }] }); })();
const ɵIgxTreeGridRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxTreeGridRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-row',
                template: "<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: { index: viewIndex, rowID: rowID, selected: selected }}\">\n        </ng-template>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcPixelWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n            [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width]=\"col.width\"\n            [style.max-width]=\"col.width\"\n            [style.flex-basis]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\"\n            [lastSearchInfo]=\"grid.lastSearchInfo\"\n            [active]=\"isCellActive(col.visibleIndex)\"\n            [cellSelectionMode]=\"grid.cellSelection\"\n            [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n            #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n<ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n    <ng-container *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-container>\n</ng-container>\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            [disabled]=\"deleted\"\n            disableRipple=\"true\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #pinnedCellsTemplate let-col>\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [firstPinned]=\"col.isFirstPinned\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n                [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width]=\"col.width\"\n                [style.max-width]=\"col.width\"\n                [style.flex-basis]=\"col.width\"\n                [style.left]=\"col.rightPinnedOffset\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\"\n                [lastSearchInfo]=\"grid.lastSearchInfo\"\n                [active]=\"isCellActive(col.visibleIndex)\"\n                [cellSelectionMode]=\"grid.cellSelection\"\n                [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\"\n                #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-template>",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxTreeGridRowComponent_1) }]
            }]
    }], null, { treeRow: [{
            type: Input
        }], expanded: [{
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], _cells: [{
            type: ViewChildren,
            args: ['treeCell']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridHierarchizingPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridHierarchizing',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridFlatteningPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridFlattening',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridSortingPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridSorting',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridPagingPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridPaging',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridTransactionPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridTransaction',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridNormalizeRecordsPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridNormalizeRecord',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-tree-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\" [metadata]=\"searchMetadata\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{level}}\"></div>\n    </ng-container>\n    <div #indicator\n         *ngIf=\"!isLoading\"\n         class=\"igx-grid__tree-grouping-indicator\"\n         [ngStyle]=\"{'visibility': showIndicator ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n        </ng-container>\n    </div>\n    <div *ngIf=\"isLoading\"\n         (dblclick)=\"onLoadingDblClick($event)\"\n         class=\"igx-grid__tree-loading-indicator\">\n        <ng-container *ngTemplateOutlet=\"grid.rowLoadingIndicatorTemplate ? grid.rowLoadingIndicatorTemplate : defaultLoadingIndicatorTemplate\">\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: PlatformUtil }]; }, { level: [{
            type: Input
        }], showIndicator: [{
            type: Input
        }], isLoading: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridSummaryPipe, [{
        type: Pipe,
        args: [{
                name: 'treeGridSummary',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTreeGridModule, { declarations: [IgxTreeGridComponent,
        IgxTreeGridRowComponent,
        IgxTreeGridCellComponent,
        IgxTreeGridHierarchizingPipe,
        IgxTreeGridFlatteningPipe,
        IgxTreeGridSortingPipe,
        IgxTreeGridFilteringPipe,
        IgxTreeGridPagingPipe,
        IgxTreeGridTransactionPipe,
        IgxTreeGridSummaryPipe,
        IgxRowLoadingIndicatorTemplateDirective,
        IgxTreeGridNormalizeRecordsPipe], imports: [IgxGridCommonModule], exports: [IgxTreeGridComponent,
        IgxTreeGridRowComponent,
        IgxTreeGridCellComponent,
        IgxRowLoadingIndicatorTemplateDirective,
        IgxGridCommonModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTreeGridModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxTreeGridHierarchizingPipe,
                    IgxTreeGridFlatteningPipe,
                    IgxTreeGridSortingPipe,
                    IgxTreeGridFilteringPipe,
                    IgxTreeGridPagingPipe,
                    IgxTreeGridTransactionPipe,
                    IgxTreeGridSummaryPipe,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxTreeGridNormalizeRecordsPipe
                ],
                exports: [
                    IgxTreeGridComponent,
                    IgxTreeGridRowComponent,
                    IgxTreeGridCellComponent,
                    IgxRowLoadingIndicatorTemplateDirective,
                    IgxGridCommonModule
                ],
                imports: [
                    IgxGridCommonModule,
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxChildGridRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-child-grid-row',
                template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
            }]
    }], function () { return [{ type: GridBaseAPIService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ChangeDetectorRef }]; }, { rowData: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], level: [{
            type: HostBinding,
            args: ['attr.data-level']
        }], layout: [{
            type: Input
        }], parentGridID: [{
            type: Input
        }], index: [{
            type: Input
        }], hGrid: [{
            type: ViewChild,
            args: ['hgrid', { static: true }]
        }] }); })();
const ɵIgxHierarchicalGridNavigationService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalGridNavigationService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridNavigationService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridBaseDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHierarchicalGridBase]'
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: IgxColumnResizingService }, { type: GridBaseAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IgxGridTransaction]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ViewContainerRef }, { type: IgxHierarchicalGridNavigationService }, { type: IgxFilteringService }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxGridSummaryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }]; }, { showExpandAll: [{
            type: Input
        }], expandChildren: [{
            type: Input
        }], hasChildrenKey: [{
            type: Input
        }], dragIndicatorIconBase: [{
            type: ViewChild,
            args: ['dragIndicatorIconBase', { read: TemplateRef, static: true }]
        }] }); })();
const ɵIgxHierarchicalGridAPIService_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalGridAPIService);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridAPIService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRowIslandComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'igx-row-island',
                template: ``,
                providers: [IgxRowIslandAPIService]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: IgxColumnResizingService }, { type: GridBaseAPIService }, { type: undefined, decorators: [{
                type: Inject,
                args: [IgxGridTransaction]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ViewContainerRef }, { type: IgxHierarchicalGridNavigationService }, { type: IgxFilteringService }, { type: IgxOverlayService, decorators: [{
                type: Inject,
                args: [IgxOverlayService]
            }] }, { type: IgxGridSummaryService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: IgxRowIslandAPIService }]; }, { children: [{
            type: ContentChildren,
            args: [IgxRowIslandComponent_1, { read: IgxRowIslandComponent_1, descendants: false }]
        }], childColumns: [{
            type: ContentChildren,
            args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false }]
        }], onLayoutChange: [{
            type: Output
        }], onGridCreated: [{
            type: Output
        }], onGridInitialized: [{
            type: Output
        }], expandChildren: [{
            type: Input
        }], key: [{
            type: Input
        }] }); })();
const ɵIgxHierarchicalGridComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalGridComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid',
                template: "<igx-grid-toolbar role=\"toolbar\" [style.max-width.px]='outerWidth' [style.flex-basis.px]=\"outerWidth\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\"  tabindex=\"0\" (focus)=\"navigation.focusFirstCell()\" [attr.aria-activedescendant]=\"activeDescendant\"\n     (keydown)=\"navigation.headerNavigation($event)\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <div #headerHierarchyExpander (click)=\"toggleAll()\" (mousedown)='$event.preventDefault()' [hidden]='!hasExpandableChildren || !hasVisibleColumns' [ngClass]=\"{\n                'igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header': hasExpandableChildren,\n                'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                'igx-grid__hierarchical-expander--no-border': isRowSelectable || rowDraggable\n            }\">\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n            </div>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !isRowSelectable\n                    }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter,\n                                        selectAll: selectAllRows.bind(this),\n                                        deselectAll: deselectAllRows.bind(this) }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            <ng-container *ngIf=\"pinnedColumns.length > 0 && !isPinningToStart\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group\n                        [column]=\"col\"\n                        [gridID]=\"id\"\n                        [style.min-width]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis]=\"getHeaderGroupWidth(col)\"\n                        [style.left]=\"col.rightPinnedOffset\">\n                    </igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\" *ngIf='shouldOverlayLoading'>\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalScroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\"  tabindex=\"0\" (focus)=\"navigation.focusTbody($event)\" [attr.aria-activedescendant]=\"activeDescendant\"\n     (keydown)=\"navigation.handleNavigation($event)\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" role=\"rowgroup\"\n        [style.height.px]='totalHeight' [style.width.px]='calcWidth' #tbody (scroll)='preventContainerScroll($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template #pinnedRecordsTemplate>\n            <ng-container *ngIf=\"data\n            | gridTransaction:id:pipeTrigger\n            | visibleColumns:hasVisibleColumns\n            | gridRowPinning:id:true:pipeTrigger\n            | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger:true\n            | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger:true as pinnedData\">\n                <div #pinContainer *ngIf='pinnedData.length > 0' class='igx-grid__tr--pinned'\n                    [ngClass]=\"{ 'igx-grid__tr--pinned-bottom':  !isRowPinningToTop, 'igx-grid__tr--pinned-top': isRowPinningToTop }\"\n                    [style.width.px]='calcWidth'>\n                    <ng-container *ngFor=\"let rowData of pinnedData; let rowIndex = index\">\n                        <ng-container *ngTemplateOutlet=\"pinned_hierarchical_record_template; context: getContext(rowData, rowIndex, true)\">\n                        </ng-container>\n                    </ng-container>\n                </div>\n            </ng-container>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-template igxGridFor let-rowData let-rowIndex=\"index\" [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:sortStrategy:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:expansionStates:id:primaryKey:childLayoutKeys:pipeTrigger\n        | gridRowPinning:id:false:pipeTrigger\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" [igxForTrackBy]='trackChanges'\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex, false)' (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)' (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-disabledRow=\"disabled\" let-rowData>\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [disabled]=\"disabledRow\" [rowData]=\"rowData\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n\n        <ng-template #pinned_hierarchical_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row #pinnedRow>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow:auto;width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()'\n                [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\"\n                    [rowData]=\"rowData\" [layout]='layout' #row>\n                </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"hasPinnedRecords && !isRowPinningToTop ? pinnedRecordsTemplate : null\">\n        </ng-container>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n            id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n        <igc-trial-watermark *ngIf=\"!this.parent\"></igc-trial-watermark>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalScroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\">\n        <div class=\"igx-grid__tbody-scrollbar-start\" [style.height.px]=' isRowPinningToTop ? pinnedRowHeight : 0'></div>\n        <div class=\"igx-grid__tbody-scrollbar-main\" [style.height.px]='calcHeight'>\n            <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n        </div>\n        <div class=\"igx-grid__tbody-scrollbar-end\" [style.height.px]='!isRowPinningToTop ? pinnedRowHeight : 0'></div>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" tabindex=\"0\" (focus)=\"navigation.focusFirstCell(false)\" [attr.aria-activedescendant]=\"activeDescendant\"\n (keydown)=\"navigation.summaryNav($event)\"  role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" role=\"row\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"dataView.length\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalScroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth' [style.min-width.px]='isPinningToStart ? pinnedWidth : headerFeaturesWidth'></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n    <div class=\"igx-grid__scroll-end\" [style.float]='\"right\"' [style.width.px]='pinnedWidth' [style.min-width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0 || isPinningToStart\"></div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" fontSet=\"material\">unfold_more</igx-icon>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" [isActive]='hasExpandedRecords() && hasExpandableChildren' fontSet=\"material\">unfold_less</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                    { provide: IgxGridBaseDirective, useExisting: forwardRef(() => IgxHierarchicalGridComponent_1) },
                    IgxGridSummaryService,
                    IgxFilteringService,
                    IgxHierarchicalGridNavigationService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            }]
    }], null, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], data: [{
            type: Input
        }], expandChildren: [{
            type: Input
        }], childLayoutList: [{
            type: ContentChildren,
            args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false }]
        }], allLayoutList: [{
            type: ContentChildren,
            args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true }]
        }], hierarchicalRecordTemplate: [{
            type: ViewChild,
            args: ['hierarchical_record_template', { read: TemplateRef, static: true }]
        }], childTemplate: [{
            type: ViewChild,
            args: ['child_record_template', { read: TemplateRef, static: true }]
        }], headerHierarchyExpander: [{
            type: ViewChild,
            args: ['headerHierarchyExpander', { read: ElementRef, static: true }]
        }], templateOutlets: [{
            type: ViewChildren,
            args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective }]
        }], hierarchicalRows: [{
            type: ViewChildren,
            args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridCellComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid-cell',
                template: "<ng-template #defaultPinnedIndicator>\n    <igx-chip *ngIf=\"displayPinnedChip\" class=\"igx-grid__td--pinned-chip\" [disabled]=\"true\" [displayDensity]=\"'compact'\">{{ grid.resourceStrings.igx_grid_pinned_row_indicator }}</igx-chip>\n</ng-template>\n<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\" [metadata]=\"searchMetadata\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"true\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"true\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"true\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n            [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"true\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"pinnedIndicatorTemplate; context: context\">\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n",
                providers: [HammerGesturesManager]
            }]
    }], function () { return [{ type: IgxGridSelectionService }, { type: IgxGridCRUDService }, { type: GridBaseAPIService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: HammerGesturesManager }, { type: PlatformUtil }]; }, null); })();
const ɵIgxHierarchicalRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxHierarchicalRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalRowComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-hierarchical-grid-row',
                template: "<div (click)=\"expanderClick($event)\" (mousedown)='$event.preventDefault()' [ngClass]=\"expanderClassResolved\" *ngIf=\"hasChildren\" #expander>\n        <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\">\n        </ng-container>\n</div>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">expand_more</igx-icon>\n    </ng-template>\n\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon [isActive]='!added' fontSet=\"material\">chevron_right</igx-icon>\n </ng-template>\n\n <ng-template #defaultEmptyTemplate>\n    <igx-icon fontSet=\"material\"></igx-icon>\n</ng-template>\n\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\" (click)=\"$event.stopPropagation()\" [ghostTemplate]=\"this.grid.getDragGhostCustomTemplate()\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowSelectors\">\n    <div class=\"igx-grid__cbx-selection\" (click)=\"onRowSelectorClick($event)\">\n        <ng-template *ngTemplateOutlet=\"\n            this.grid.rowSelectorTemplate ? this.grid.rowSelectorTemplate : rowSelectorBaseTemplate;\n            context: { $implicit: {\n                            index: viewIndex,\n                            rowID: rowID,\n                            selected: selected,\n                            select: select,\n                            deselect: deselect }}\">\n        </ng-template>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"pinnedColumns.length > 0 && grid.isPinningToStart\">\n    <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n</ng-container>\n\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcPixelWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-hierarchical-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n    </igx-hierarchical-grid-cell>\n</ng-template>\n\n<ng-container *ngIf=\"pinnedColumns.length > 0 && !grid.isPinningToStart\">\n    <ng-template *ngTemplateOutlet=\"pinnedCellsTemplate; context: this\"></ng-template>\n</ng-container>\n\n<ng-template #rowSelectorBaseTemplate>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [tabindex]=\"-1\"\n            [readonly]=\"true\"\n            [checked]=\"selected\"\n            disableRipple=\"true\"\n            [disabled]=\"deleted\"\n            [disableTransitions]=\"grid.disableTransitions\"\n            [aria-label]=\"rowCheckboxAriaLabel\">\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<ng-template #pinnedCellsTemplate let-col>\n    <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyleClasses:rowData[col.field]:rowData:col.field:viewIndex\"\n        [ngStyle]=\"col.cellStyles | igxCellStyles:rowData[col.field]:rowData:col.field:viewIndex\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [active]=\"isCellActive(col.visibleIndex)\"\n        [firstPinned]=\"col.isFirstPinned\"\n        [lastPinned]=\"col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width]=\"col.width\"\n        [style.max-width]=\"col.width\"\n        [style.flex-basis]=\"col.width\"\n        [style.left]=\"col.rightPinnedOffset\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\"\n        [lastSearchInfo]=\"grid.lastSearchInfo\"\n        [cellSelectionMode]=\"grid.cellSelection\"\n        [displayPinnedChip]=\"shouldDisplayPinnedChip(col.visibleIndex)\">\n    </igx-hierarchical-grid-cell>\n</ng-template>",
                providers: [{ provide: IgxRowDirective, useExisting: forwardRef(() => IgxHierarchicalRowComponent_1) }]
            }]
    }], null, { expandedClass: [{
            type: HostBinding,
            args: ['class.igx-grid__tr--expanded']
        }], highlighted: [{
            type: HostBinding,
            args: ['class.igx-grid__tr--highlighted']
        }], _cells: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxHierarchicalGridCellComponent), { read: IgxHierarchicalGridCellComponent }]
        }], expander: [{
            type: ViewChild,
            args: ['expander', { read: ElementRef }]
        }], defaultExpandedTemplate: [{
            type: ViewChild,
            args: ['defaultExpandedTemplate', { read: TemplateRef, static: true }]
        }], defaultEmptyTemplate: [{
            type: ViewChild,
            args: ['defaultEmptyTemplate', { read: TemplateRef, static: true }]
        }], defaultCollapsedTemplate: [{
            type: ViewChild,
            args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHierarchicalPipe, [{
        type: Pipe,
        args: [{
                name: 'gridHierarchical',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxGridHierarchicalPagingPipe, [{
        type: Pipe,
        args: [{
                name: 'gridHierarchicalPaging',
                pure: true
            }]
    }], function () { return [{ type: GridBaseAPIService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxHierarchicalGridModule, { declarations: [IgxHierarchicalGridBaseDirective,
        IgxHierarchicalGridComponent,
        IgxHierarchicalRowComponent,
        IgxRowIslandComponent,
        IgxChildGridRowComponent,
        IgxHierarchicalGridCellComponent,
        IgxGridHierarchicalPipe,
        IgxGridHierarchicalPagingPipe], imports: [IgxGridModule], exports: [IgxGridModule,
        IgxHierarchicalGridComponent,
        IgxHierarchicalRowComponent,
        IgxHierarchicalGridCellComponent,
        IgxRowIslandComponent,
        IgxChildGridRowComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHierarchicalGridModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxHierarchicalGridBaseDirective,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxGridHierarchicalPipe,
                    IgxGridHierarchicalPagingPipe
                ],
                exports: [
                    IgxGridModule,
                    IgxHierarchicalGridComponent,
                    IgxHierarchicalRowComponent,
                    IgxHierarchicalGridCellComponent,
                    IgxRowIslandComponent,
                    IgxChildGridRowComponent
                ],
                imports: [
                    IgxGridModule,
                ],
                entryComponents: [
                    IgxGridComponent
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxActionIconDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: 'igx-action-icon'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavbarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-navbar',
                template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon (click)=\"_triggerAction()\" fontSet=\"material\" *ngIf=\"isActionButtonVisible\">{{actionButtonIcon}}</igx-icon>\n        <ng-content select=\"igx-action-icon\"></ng-content>\n        <h1 class=\"igx-navbar__title\" [attr.id]=\"titleId\">{{ title }}</h1>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], onAction: [{
            type: Output
        }], titleId: [{
            type: Input
        }], isActionButtonVisible: [{
            type: Input
        }], actionButtonIcon: [{
            type: Input
        }], title: [{
            type: Input
        }], actionIconTemplate: [{
            type: ContentChild,
            args: [IgxActionIconDirective, { read: IgxActionIconDirective }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxNavbarModule, { declarations: function () { return [IgxNavbarComponent,
        IgxActionIconDirective]; }, imports: function () { return [IgxButtonModule,
        IgxIconModule,
        CommonModule]; }, exports: function () { return [IgxNavbarComponent,
        IgxActionIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavbarModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxNavbarComponent, IgxActionIconDirective],
                exports: [IgxNavbarComponent, IgxActionIconDirective],
                imports: [IgxButtonModule, IgxIconModule, CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavDrawerItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDrawerItem]',
                exportAs: 'igxDrawerItem'
            }]
    }], function () { return []; }, { active: [{
            type: Input,
            args: ['active']
        }], isHeader: [{
            type: Input,
            args: ['isHeader']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer__item']
        }], currentCSS: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer__item--active']
        }], headerCSS: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer__item--header']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavDrawerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDrawer]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavDrawerMiniTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDrawerMini]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationDrawerComponent, [{
        type: Component,
        args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef, decorators: [{
                type: Inject,
                args: [ElementRef]
            }] }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }, { type: ɵngcc0.Renderer2 }, { type: HammerGesturesManager }, { type: PlatformUtil }]; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-nav-drawer']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], position: [{
            type: Input
        }], enableGestures: [{
            type: Input
        }], isOpenChange: [{
            type: Output
        }], pin: [{
            type: Input
        }], pinThreshold: [{
            type: Input
        }], width: [{
            type: Input
        }], miniWidth: [{
            type: Input
        }], pinChange: [{
            type: Output
        }], opening: [{
            type: Output
        }], opened: [{
            type: Output
        }], closing: [{
            type: Output
        }], closed: [{
            type: Output
        }], isOpen: [{
            type: Input
        }], miniTemplate: [{
            type: ContentChild,
            args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective }]
        }], flexWidth: [{
            type: HostBinding,
            args: ['style.flexBasis']
        }], isPinnedRight: [{
            type: HostBinding,
            args: ['style.order']
        }], contentTemplate: [{
            type: ContentChild,
            args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective }]
        }], _drawer: [{
            type: ViewChild,
            args: ['aside', { static: true }]
        }], _overlay: [{
            type: ViewChild,
            args: ['overlay', { static: true }]
        }], _styleDummy: [{
            type: ViewChild,
            args: ['dummy', { static: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxNavigationDrawerModule, { declarations: function () { return [IgxNavigationDrawerComponent,
        IgxNavDrawerItemDirective,
        IgxNavDrawerMiniTemplateDirective,
        IgxNavDrawerTemplateDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxNavigationDrawerComponent,
        IgxNavDrawerItemDirective,
        IgxNavDrawerMiniTemplateDirective,
        IgxNavDrawerTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxNavigationDrawerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                exports: [
                    IgxNavigationDrawerComponent,
                    IgxNavDrawerItemDirective,
                    IgxNavDrawerMiniTemplateDirective,
                    IgxNavDrawerTemplateDirective
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxThumbFromTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSliderThumbFrom]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxThumbToTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSliderThumbTo]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTickLabelTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSliderTickLabel]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSliderThumbComponent, [{
        type: Component,
        args: [{
                selector: 'igx-thumb',
                template: "<div class=\"dot\"></div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxDirectionality }]; }, { onThumbValueChange: [{
            type: Output
        }], onChange: [{
            type: Output
        }], onHoverChange: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], zIndex: [{
            type: HostBinding,
            args: ['attr.z-index']
        }], thumbFromClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-from']
        }], thumbToClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-to']
        }], thumbFromActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-from--active']
        }], thumbToActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb-to--active']
        }], thumbPressedClass: [{
            type: HostBinding,
            args: ['class.igx-slider__thumb--pressed']
        }], onPinterEnter: [{
            type: HostListener,
            args: ['pointerenter']
        }], onPointerLeave: [{
            type: HostListener,
            args: ['pointerleave']
        }], onKeyDown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onFocusListener: [{
            type: HostListener,
            args: ['focus']
        }], value: [{
            type: Input
        }], continuous: [{
            type: Input
        }], thumbLabelVisibilityDuration: [{
            type: Input
        }], disabled: [{
            type: Input
        }], onPan: [{
            type: Input
        }], stepDistance: [{
            type: Input
        }], step: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], context: [{
            type: Input
        }], type: [{
            type: Input
        }], deactiveState: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxThumbLabelComponent, [{
        type: Component,
        args: [{
                selector: 'igx-thumb-label',
                template: "<div class=\"label\">\n    <ng-container *ngTemplateOutlet=\"templateRef ? templateRef : thumbFromDefaultTemplate; context: context\"></ng-container>\n</div>\n\n<ng-template #thumbFromDefaultTemplate>\n    {{ value }}\n</ng-template>\n"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { thumbFromClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-from']
        }], thumbToClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-to']
        }], thumbFromActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-from--active']
        }], thumbToActiveClass: [{
            type: HostBinding,
            args: ['class.igx-slider__label-to--active']
        }], value: [{
            type: Input
        }], templateRef: [{
            type: Input
        }], context: [{
            type: Input
        }], type: [{
            type: Input
        }], continuous: [{
            type: Input
        }], deactiveState: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTicksComponent, [{
        type: Component,
        args: [{
                selector: 'igx-ticks',
                template: "<div class=\"igx-slider__ticks-group\" *ngFor=\"let n of [].constructor(ticksLength); let idx=index\" [ngClass]=\"{ 'igx-slider__ticks-group--tall': isPrimary(idx)}\">\n    <div class=\"igx-slider__ticks-tick\">\n        <span class=\"igx-slider__ticks-label\" [ngClass]=\"{ 'igx-slider__tick-label--hidden': !hiddenTickLabels(idx)}\">\n            <ng-container *ngTemplateOutlet=\"tickLabelTemplateRef ? tickLabelTemplateRef : tickLabelDefaultTemplate; context: context(idx)\"></ng-container>\n        </span>\n    </div>\n</div>\n\n<ng-template #tickLabelDefaultTemplate let-value>\n    {{ value }}\n</ng-template>\n"
            }]
    }], function () { return []; }, { ticksClass: [{
            type: HostBinding,
            args: ['class.igx-slider__ticks']
        }], ticksTopClass: [{
            type: HostBinding,
            args: ['class.igx-slider__ticks--top']
        }], hasPrimaryClass: [{
            type: HostBinding,
            args: ['class.igx-slider__ticks--tall']
        }], labelsTopToBottomClass: [{
            type: HostBinding,
            args: ['class.igx-slider__tick-labels--top-bottom']
        }], labelsBottomToTopClass: [{
            type: HostBinding,
            args: ['class.igx-slider__tick-labels--bottom-top']
        }], primaryTicks: [{
            type: Input
        }], secondaryTicks: [{
            type: Input
        }], primaryTickLabels: [{
            type: Input
        }], secondaryTickLabels: [{
            type: Input
        }], ticksOrientation: [{
            type: Input
        }], tickLabelsOrientation: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], minValue: [{
            type: Input
        }], labelsViewEnabled: [{
            type: Input
        }], labels: [{
            type: Input
        }], tickLabelTemplateRef: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTickLabelsPipe, [{
        type: Pipe,
        args: [{
                name: 'spreadTickLabels'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSliderComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent_1, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider__track\">\n    <igx-ticks\n        *ngIf=\"showTicks && showTopTicks\"\n        [ticksOrientation]=\"0\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-steps\"></div>\n\n    <igx-ticks\n        *ngIf=\"showTicks && showBottomTicks\"\n        [ticksOrientation]=\"1\"\n        [primaryTicks]=\"primaryTicks\"\n        [secondaryTicks]=\"secondaryTicks\"\n        [primaryTickLabels]=\"primaryTickLabels\"\n        [secondaryTickLabels]=\"secondaryTickLabels\"\n        [tickLabelsOrientation]=\"tickLabelsOrientation\"\n        [labelsViewEnabled]=\"labelsViewEnabled\"\n        [labels]=\"labels | spreadTickLabels:secondaryTicks\"\n        [tickLabelTemplateRef]=\"tickLabelTemplateRef\"\n        [minValue]=\"minValue\"\n        [maxValue]=\"maxValue\"></igx-ticks>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"></igx-thumb-label>\n\n    <igx-thumb\n        *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        [type]=\"1\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"\n        [deactiveState]=\"deactivateThumbLabel\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [deactiveState]=\"deactivateThumbLabel\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }, { type: IgxDirectionality }]; }, { thumbs: [{
            type: ViewChildren,
            args: [IgxSliderThumbComponent]
        }], labelRefs: [{
            type: ViewChildren,
            args: [IgxThumbLabelComponent]
        }], role: [{
            type: HostBinding,
            args: [`attr.role`]
        }], slierClass: [{
            type: HostBinding,
            args: ['class.igx-slider']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], thumbLabelVisibilityDuration: [{
            type: Input
        }], showTicks: [{
            type: Input
        }], primaryTickLabels: [{
            type: Input
        }], secondaryTickLabels: [{
            type: Input
        }], ticksOrientation: [{
            type: Input
        }], tickLabelsOrientation: [{
            type: Input
        }], onValueChange: [{
            type: Output
        }], onValueChanged: [{
            type: Output
        }], valuemin: [{
            type: HostBinding,
            args: [`attr.aria-valuemin`]
        }], valuemax: [{
            type: HostBinding,
            args: [`attr.aria-valuemax`]
        }], readonly: [{
            type: HostBinding,
            args: [`attr.aria-readonly`]
        }], disabledClass: [{
            type: HostBinding,
            args: ['class.igx-slider--disabled']
        }], type: [{
            type: Input
        }], labels: [{
            type: Input
        }], step: [{
            type: Input
        }], disabled: [{
            type: Input
        }], continuous: [{
            type: Input
        }], minValue: [{
            type: Input
        }], lowerBound: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], upperBound: [{
            type: Input
        }], value: [{
            type: Input
        }], primaryTicks: [{
            type: Input
        }], secondaryTicks: [{
            type: Input
        }], onPointerDown: [{
            type: HostListener,
            args: ['pointerdown', ['$event']]
        }], onPointerUp: [{
            type: HostListener,
            args: ['pointerup', ['$event']]
        }], onFocus: [{
            type: HostListener,
            args: ['focus']
        }], onPanListener: [{
            type: HostListener,
            args: ['pan', ['$event']]
        }], ticks: [{
            type: ViewChild,
            args: ['ticks', { static: true }]
        }], trackRef: [{
            type: ViewChild,
            args: ['track', { static: true }]
        }], thumbFromTemplateRef: [{
            type: ContentChild,
            args: [IgxThumbFromTemplateDirective, { read: TemplateRef }]
        }], thumbToTemplateRef: [{
            type: ContentChild,
            args: [IgxThumbToTemplateDirective, { read: TemplateRef }]
        }], tickLabelTemplateRef: [{
            type: ContentChild,
            args: [IgxTickLabelTemplateDirective, { read: TemplateRef, static: false }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSliderModule, { declarations: function () { return [IgxSliderComponent,
        IgxThumbFromTemplateDirective,
        IgxThumbToTemplateDirective,
        IgxTickLabelTemplateDirective,
        IgxSliderThumbComponent,
        IgxThumbLabelComponent,
        IgxTicksComponent,
        IgxTickLabelsPipe]; }, imports: function () { return [CommonModule, FormsModule]; }, exports: function () { return [IgxSliderComponent,
        IgxThumbFromTemplateDirective,
        IgxThumbToTemplateDirective,
        IgxTickLabelTemplateDirective,
        IgxSliderThumbComponent,
        IgxThumbLabelComponent,
        IgxTicksComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSliderModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent,
                    IgxTickLabelsPipe
                ],
                exports: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxTickLabelTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent,
                    IgxTicksComponent
                ],
                imports: [CommonModule, FormsModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSnackbarComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('slideInOut', [
                        transition('void => *', [
                            useAnimation(slideInBottom, {
                                params: {
                                    duration: '.35s',
                                    easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                    fromPosition: 'translateY(100%)',
                                    toPosition: 'translateY(0)'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(slideOutBottom, {
                                params: {
                                    duration: '.2s',
                                    easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                    fromPosition: 'translateY(0)',
                                    toOpacity: 1,
                                    toPosition: 'translateY(100%)'
                                }
                            })
                        ])
                    ]),
                    trigger('fadeInOut', [
                        transition('void => *', [
                            useAnimation(fadeIn, {
                                params: {
                                    duration: '.35s',
                                    easing: 'ease-out'
                                }
                            })
                        ]),
                        transition('* => void', [
                            useAnimation(fadeOut, {
                                params: {
                                    duration: '.2s',
                                    easing: 'ease-out'
                                }
                            })
                        ])
                    ])
                ],
                selector: 'igx-snackbar',
                template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ message }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], isVisible: [{
            type: Input
        }], autoHide: [{
            type: Input
        }], displayTime: [{
            type: Input
        }], onAction: [{
            type: Output
        }], animationStarted: [{
            type: Output
        }], animationDone: [{
            type: Output
        }], message: [{
            type: Input
        }], actionText: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSnackbarModule, { declarations: function () { return [IgxSnackbarComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxSnackbarComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSnackbarModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxSnackbarComponent],
                exports: [IgxSnackbarComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSwitchComponent, [{
        type: Component,
        args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent_1, multi: true }],
                selector: 'igx-switch',
                template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
            }]
    }], function () { return []; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], labelId: [{
            type: Input
        }], tabindex: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], disableRipple: [{
            type: Input
        }], required: [{
            type: Input
        }], ariaLabelledBy: [{
            type: Input,
            args: ['aria-labelledby']
        }], ariaLabel: [{
            type: Input,
            args: ['aria-label']
        }], change: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-switch']
        }], checked: [{
            type: HostBinding,
            args: ['class.igx-switch--checked']
        }, {
            type: Input
        }], disabled: [{
            type: HostBinding,
            args: ['class.igx-switch--disabled']
        }, {
            type: Input
        }], focused: [{
            type: HostBinding,
            args: ['class.igx-switch--focused']
        }], nativeCheckbox: [{
            type: ViewChild,
            args: ['checkbox', { static: true }]
        }], nativeLabel: [{
            type: ViewChild,
            args: ['label', { static: true }]
        }], placeholderLabel: [{
            type: ViewChild,
            args: ['placeholderLabel', { static: true }]
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }] }); })();
const ɵIgxSwitchRequiredDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxSwitchRequiredDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSwitchRequiredDirective, [{
        type: Directive,
        args: [{
                selector: `igx-switch[required][formControlName],
    igx-switch[required][formControl],
    igx-switch[required][ngModel]`,
                providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSwitchModule, { declarations: [IgxSwitchComponent,
        IgxSwitchRequiredDirective], imports: [IgxRippleModule], exports: [IgxSwitchComponent,
        IgxSwitchRequiredDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSwitchModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                imports: [IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTab]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBottomNavComponent, [{
        type: Component,
        args: [{
                selector: 'igx-bottom-nav',
                template: "<div *ngIf=\"!hasContentTabs\">\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <ng-container *ngIf=\"!hasContentTabs\">\n        <igx-tab *ngFor=\"let panel of panels; let i = index\"\n            [relatedPanel]=\"panel\"\n            [autoGenerated]=\"true\"\n            [id]=\"getTabId(i)\"\n            [attr.aria-controls]=\"getTabPanelId(i)\">>\n        </igx-tab>\n    </ng-container>\n    <ng-content select=\"igx-tab\"></ng-content>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], onTabSelected: [{
            type: Output
        }], onTabDeselected: [{
            type: Output
        }], _selectedPanelHandler: [{
            type: HostListener,
            args: ['onTabSelected', ['$event']]
        }], viewTabs: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxTabComponent)]
        }], contentTabs: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabComponent)]
        }], panels: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabPanelComponent)]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabPanelComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tab-panel',
                template: "<ng-content></ng-content>\n"
            }]
    }], function () { return [{ type: IgxBottomNavComponent }, { type: ɵngcc0.ElementRef }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__panel']
        }], isSelected: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__panel--selected']
        }], label: [{
            type: Input
        }], icon: [{
            type: Input
        }], disabled: [{
            type: Input
        }], tabTemplate: [{
            type: ContentChild,
            args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tab',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"tab-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"context.changesCount\" [hidden]=\"context.changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"tab-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            }]
    }], function () { return [{ type: IgxBottomNavComponent }, { type: ɵngcc0.ElementRef }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], label: [{
            type: Input
        }], icon: [{
            type: Input
        }], disabled: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], cssClassSelected: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__menu-item--selected']
        }], cssClassDisabled: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__menu-item--disabled']
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-bottom-nav__menu-item']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], relatedPanel: [{
            type: Input
        }], autoGenerated: [{
            type: Input
        }], defaultTabTemplate: [{
            type: ViewChild,
            args: ['defaultTabTemplate', { read: TemplateRef, static: true }]
        }], customTabTemplateDir: [{
            type: ContentChild,
            args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxBottomNavModule, { declarations: function () { return [IgxBottomNavComponent,
        IgxTabPanelComponent,
        IgxTabComponent,
        IgxTabTemplateDirective]; }, imports: function () { return [CommonModule,
        IgxBadgeModule,
        IgxIconModule]; }, exports: function () { return [IgxBottomNavComponent,
        IgxTabPanelComponent,
        IgxTabComponent,
        IgxTabTemplateDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxBottomNavModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxRightButtonStyleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxRightButtonStyle]'
            }]
    }], function () { return [{ type: IgxTabsBase }]; }, { visibleCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button']
        }], hiddenCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--hidden']
        }], notDisplayedCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--none']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxLeftButtonStyleDirective, [{
        type: Directive,
        args: [{
                selector: '[igxLeftButtonStyle]'
            }]
    }], function () { return [{ type: IgxTabsBase }]; }, { visibleCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button']
        }], hiddenCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--hidden']
        }], notDisplayedCSS: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-button--none']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabItemTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTab]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabItemComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tab-item',
                template: "<ng-template #defaultTabTemplate let-context>\n    <div *ngIf=\"context.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon fontSet=\"material\">{{context.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"context.label\" ngClass=\"igx-tabs__item-label\">{{context.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this.context }\">\n</ng-container>"
            }]
    }], function () { return [{ type: IgxTabsBase }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { role: [{
            type: HostBinding,
            args: ['attr.role']
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], ariaLabel: [{
            type: HostBinding,
            args: ['attr.aria-label']
        }], ariaDisabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], ariaSelected: [{
            type: HostBinding,
            args: ['attr.aria-selected']
        }], icon: [{
            type: Input
        }], label: [{
            type: Input
        }], provideCssClassSelected: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-menu-item--selected']
        }], provideCssClassDisabled: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-menu-item--disabled']
        }], provideCssClass: [{
            type: HostBinding,
            args: ['class.igx-tabs__header-menu-item']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }], onKeydown: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], disabled: [{
            type: Input
        }], isSelected: [{
            type: Input
        }], relatedGroup: [{
            type: Input
        }], autoGenerated: [{
            type: Input
        }], defaultTabTemplate: [{
            type: ViewChild,
            args: ['defaultTabTemplate', { read: TemplateRef, static: true }]
        }], customTabTemplateDir: [{
            type: ContentChild,
            args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabsGroupComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tabs-group',
                template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
            }]
    }], function () { return [{ type: IgxTabsBase }, { type: ɵngcc0.ElementRef }]; }, { disabled: [{
            type: Input
        }], role: [{
            type: HostBinding,
            args: ['attr.role']
        }], styleClass: [{
            type: HostBinding,
            args: ['class.igx-tabs__group']
        }], icon: [{
            type: Input
        }], label: [{
            type: Input
        }], tabTemplate: [{
            type: ContentChild,
            args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabsComponent, [{
        type: Component,
        args: [{
                selector: 'igx-tabs',
                template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple\n                        *ngFor=\"let group of groups; let i = index\"\n                        [relatedGroup]=\"group\"\n                        [autoGenerated]=\"true\"\n                        [id]=\"getTabItemId(i)\"\n                        [attr.aria-controls]=\"getTabsGroupId(i)\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>\n",
                providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: PlatformUtil }]; }, { selectedIndexChange: [{
            type: Output
        }], type: [{
            type: Input,
            args: ['type']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], class: [{
            type: Input
        }], onTabItemDeselected: [{
            type: Output
        }], onTabItemSelected: [{
            type: Output
        }], selectedIndex: [{
            type: Input
        }], cssClass: [{
            type: HostBinding,
            args: ['attr.class']
        }], groups: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabsGroupComponent)]
        }], contentTabs: [{
            type: ContentChildren,
            args: [forwardRef(() => IgxTabItemComponent)]
        }], contentsContainer: [{
            type: ViewChild,
            args: ['contentsContainer', { static: true }]
        }], headerContainer: [{
            type: ViewChild,
            args: ['headerContainer', { static: true }]
        }], itemsContainer: [{
            type: ViewChild,
            args: ['itemsContainer', { static: true }]
        }], selectedIndicator: [{
            type: ViewChild,
            args: ['selectedIndicator']
        }], tabsContainer: [{
            type: ViewChild,
            args: ['tabsContainer', { static: true }]
        }], viewPort: [{
            type: ViewChild,
            args: ['viewPort', { static: true }]
        }], viewTabs: [{
            type: ViewChildren,
            args: [forwardRef(() => IgxTabItemComponent)]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTabsModule, { declarations: function () { return [IgxTabsComponent,
        IgxTabsGroupComponent,
        IgxTabItemComponent,
        IgxTabItemTemplateDirective,
        IgxRightButtonStyleDirective,
        IgxLeftButtonStyleDirective]; }, imports: function () { return [CommonModule,
        IgxBadgeModule,
        IgxIconModule,
        IgxRippleModule]; }, exports: function () { return [IgxTabsComponent,
        IgxTabsGroupComponent,
        IgxTabItemComponent,
        IgxTabItemTemplateDirective,
        IgxRightButtonStyleDirective,
        IgxLeftButtonStyleDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTabsModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                exports: [IgxTabsComponent,
                    IgxTabsGroupComponent,
                    IgxTabItemComponent,
                    IgxTabItemTemplateDirective,
                    IgxRightButtonStyleDirective,
                    IgxLeftButtonStyleDirective],
                imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxItemListDirective, [{
        type: Directive,
        args: [{
                selector: '[igxItemList]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: ɵngcc0.ElementRef }]; }, { tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__column']
        }], hourCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__hourList']
        }], minuteCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__minuteList']
        }], secondsCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__secondsList']
        }], ampmCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__ampmList']
        }], onFocus: [{
            type: HostListener,
            args: ['focus']
        }], onBlur: [{
            type: HostListener,
            args: ['blur']
        }], onKeydownArrowDown: [{
            type: HostListener,
            args: ['keydown.arrowdown', ['$event']]
        }], onKeydownArrowUp: [{
            type: HostListener,
            args: ['keydown.arrowup', ['$event']]
        }], onKeydownArrowRight: [{
            type: HostListener,
            args: ['keydown.arrowright', ['$event']]
        }], onKeydownArrowLeft: [{
            type: HostListener,
            args: ['keydown.arrowleft', ['$event']]
        }], onKeydownEnter: [{
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], onKeydownEscape: [{
            type: HostListener,
            args: ['keydown.escape', ['$event']]
        }], onHover: [{
            type: HostListener,
            args: ['mouseover']
        }], onScroll: [{
            type: HostListener,
            args: ['wheel', ['$event']]
        }], onPanMove: [{
            type: HostListener,
            args: ['panmove', ['$event']]
        }], type: [{
            type: Input,
            args: ['igxItemList']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxHourItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxHourItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxHourItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxMinuteItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxMinuteItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxMinuteItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSecondsItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxSecondsItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxSecondsItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxAmPmItemDirective, [{
        type: Directive,
        args: [{
                selector: '[igxAmPmItem]'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }, { type: IgxItemListDirective }]; }, { defaultCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item']
        }], selectedCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--selected']
        }], activeCSS: [{
            type: HostBinding,
            args: ['class.igx-time-picker__item--active']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['value']]
        }], value: [{
            type: Input,
            args: ['igxAmPmItem']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTimePickerTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerActionsDirective, [{
        type: Directive,
        args: [{
                selector: '[igxTimePickerActions]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeDisplayFormatPipe, [{
        type: Pipe,
        args: [{ name: 'displayFormat' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimeInputFormatPipe, [{
        type: Pipe,
        args: [{ name: 'inputFormat' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [IGX_TIME_PICKER_COMPONENT]
            }] }]; }, null); })();
const ɵTimePickerHammerConfig_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TimePickerHammerConfig);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimePickerHammerConfig, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerComponent, [{
        type: Component,
        args: [{
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxTimePickerComponent_1,
                        multi: true
                    },
                    {
                        provide: HAMMER_GESTURE_CONFIG,
                        useClass: TimePickerHammerConfig
                    },
                    {
                        provide: IGX_TIME_PICKER_COMPONENT,
                        useExisting: IgxTimePickerComponent_1
                    }
                ],
                selector: 'igx-time-picker',
                template: "<ng-template #dropdownInputTemplate>\n    <igx-input-group #group (mousedown)=\"mouseDown($event)\">\n        <label igxLabel>Time</label>\n        <igx-prefix (click)=\"openDialog(group.element.nativeElement)\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input \n            type=\"text\"\n            [igxMask]=\"mask\"\n            igxInput\n            [includeLiterals]=\"true\"\n            [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\"\n            [focusedValuePipe]=\"inputFormat\"\n            [promptChar]=\"promptChar\"\n            [value]=\"displayValue\"\n            (input)=\"onInput($event)\"\n            (blur)=\"onBlur($event)\"\n            (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\"\n            [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon fontSet=\"material\">clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\" (mousedown)=\"mouseDown($event)\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel>Time</label>\n        <input\n            igxInput\n            [value]=\"displayTime || ''\"\n            [disabled]=\"disabled\"\n            tabindex=\"0\" readonly\n            (blur)=\"onBlur($event)\" />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<ng-template #defaultTimePickerActions>\n    <div *ngIf=\"cancelButtonLabel || okButtonLabel\" class=\"igx-time-picker__buttons\">\n        <button *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n            {{cancelButtonLabel}}\n        </button>\n        <button *ngIf=\"okButtonLabel\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n            {{okButtonLabel}}\n        </button>\n    </div>\n</ng-template>\n<div igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>:<span>{{ selectedSeconds }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div *ngIf=\"showHoursList\" #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\" *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div *ngIf=\"showMinutesList\" #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\" *ngFor=\"let minute of minuteView\">{{ minute }}</span>\n            </div>\n            <div *ngIf=\"showSecondsList\" #secondsList [igxItemList]=\"'secondsList'\">\n                <span [igxSecondsItem]=\"seconds\" *ngFor=\"let seconds of secondsView\">{{ seconds }}</span>\n            </div>\n            <div *ngIf=\"showAmPmList\" #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\" *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <ng-container\n            *ngTemplateOutlet=\"timePickerActionsDirective ? timePickerActionsDirective.template : defaultTimePickerActions\">\n        </ng-container>\n    </div>\n</div>\n",
                styles: [`:host {
            display: block;
        }`]
            }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }]; }, { id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], disabled: [{
            type: Input
        }], isSpinLoop: [{
            type: Input
        }], vertical: [{
            type: Input
        }], promptChar: [{
            type: Input
        }], mode: [{
            type: Input
        }], onValueChanged: [{
            type: Output
        }], onValidationFailed: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], value: [{
            type: Input
        }], resourceStrings: [{
            type: Input
        }], okButtonLabel: [{
            type: Input
        }], cancelButtonLabel: [{
            type: Input
        }], itemsDelta: [{
            type: Input
        }], format: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }], onKeydownSpace: [{
            type: HostListener,
            args: ['keydown.spacebar', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.space', ['$event']]
        }], onAltArrowDown: [{
            type: HostListener,
            args: ['keydown.Alt.ArrowDown']
        }], minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], outlet: [{
            type: Input
        }], hourList: [{
            type: ViewChild,
            args: ['hourList']
        }], minuteList: [{
            type: ViewChild,
            args: ['minuteList']
        }], secondsList: [{
            type: ViewChild,
            args: ['secondsList']
        }], ampmList: [{
            type: ViewChild,
            args: ['ampmList']
        }], defaultTimePickerTemplate: [{
            type: ViewChild,
            args: ['defaultTimePickerTemplate', { read: TemplateRef, static: true }]
        }], dropdownInputTemplate: [{
            type: ViewChild,
            args: ['dropdownInputTemplate', { read: TemplateRef, static: true }]
        }], timePickerTemplateDirective: [{
            type: ContentChild,
            args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective }]
        }], timePickerActionsDirective: [{
            type: ContentChild,
            args: [IgxTimePickerActionsDirective, { read: IgxTimePickerActionsDirective }]
        }], toggleRef: [{
            type: ViewChild,
            args: [IgxToggleDirective, { static: true }]
        }], _inputElementRef: [{
            type: ViewChild,
            args: [IgxInputDirective, { read: ElementRef }]
        }], _inputDirective: [{
            type: ViewChild,
            args: [IgxInputDirective, { read: IgxInputDirective }]
        }], _inputDirectiveUserTemplate: [{
            type: ContentChild,
            args: [IgxInputDirective, { read: IgxInputDirective }]
        }], _inputGroup: [{
            type: ViewChild,
            args: [IgxInputGroupComponent, { read: IgxInputGroupComponent }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxTimePickerModule, { declarations: function () { return [IgxTimePickerComponent,
        IgxHourItemDirective,
        IgxMinuteItemDirective,
        IgxSecondsItemDirective,
        IgxItemListDirective,
        IgxAmPmItemDirective,
        IgxTimePickerTemplateDirective,
        IgxTimePickerActionsDirective,
        TimeDisplayFormatPipe,
        TimeInputFormatPipe]; }, imports: function () { return [CommonModule,
        IgxInputGroupModule,
        IgxIconModule,
        IgxButtonModule,
        IgxMaskModule,
        IgxToggleModule]; }, exports: function () { return [IgxTimePickerComponent,
        IgxTimePickerTemplateDirective,
        IgxTimePickerActionsDirective,
        TimeDisplayFormatPipe,
        TimeInputFormatPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxTimePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxTimePickerComponent,
                    IgxHourItemDirective,
                    IgxMinuteItemDirective,
                    IgxSecondsItemDirective,
                    IgxItemListDirective,
                    IgxAmPmItemDirective,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                exports: [
                    IgxTimePickerComponent,
                    IgxTimePickerTemplateDirective,
                    IgxTimePickerActionsDirective,
                    TimeDisplayFormatPipe,
                    TimeInputFormatPipe
                ],
                imports: [
                    CommonModule,
                    IgxInputGroupModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxMaskModule,
                    IgxToggleModule
                ],
                providers: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToastComponent, [{
        type: Component,
        args: [{
                animations: [
                    trigger('animate', [
                        state('visible', style({
                            opacity: 1
                        })),
                        transition('invisible => visible', animate('.20s ease')),
                        transition('visible => invisible', animate('.40s ease-out'))
                    ])
                ],
                selector: 'igx-toast',
                template: "<ng-content></ng-content>\n<span>{{ message }}</span>\n\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: IgxNavigationService, decorators: [{
                type: Optional
            }] }]; }, { animationState: [{
            type: HostBinding,
            args: ['@animate']
        }], id: [{
            type: HostBinding,
            args: ['attr.id']
        }, {
            type: Input
        }], onShowing: [{
            type: Output
        }], onShown: [{
            type: Output
        }], onHiding: [{
            type: Output
        }], onHidden: [{
            type: Output
        }], role: [{
            type: Input
        }], autoHide: [{
            type: Input
        }], displayTime: [{
            type: Input
        }], isVisibleChange: [{
            type: Output
        }], message: [{
            type: Input
        }], position: [{
            type: Input
        }], isVisible: [{
            type: Input
        }], cssClassTop: [{
            type: HostBinding,
            args: ['class.igx-toast--top']
        }], cssClassMiddle: [{
            type: HostBinding,
            args: ['class.igx-toast--middle']
        }], cssClassBottom: [{
            type: HostBinding,
            args: ['class.igx-toast--bottom']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxToastModule, { declarations: function () { return [IgxToastComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [IgxToastComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxToastModule, [{
        type: NgModule,
        args: [{
                declarations: [IgxToastComponent],
                exports: [IgxToastComponent],
                imports: [CommonModule]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterPaneComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter-pane',
                template: "<ng-content></ng-content>"
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, { resizable: [{
            type: Input
        }], onToggle: [{
            type: Output
        }], overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], minHeight: [{
            type: HostBinding,
            args: ['style.min-height']
        }, {
            type: HostBinding,
            args: ['style.min-width']
        }], maxHeight: [{
            type: HostBinding,
            args: ['style.max-height']
        }, {
            type: HostBinding,
            args: ['style.max-width']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], size: [{
            type: Input
        }], flex: [{
            type: HostBinding,
            args: ['style.flex']
        }], collapsed: [{
            type: Input
        }], minSize: [{
            type: Input
        }], maxSize: [{
            type: Input
        }], order: [{
            type: HostBinding,
            args: ['style.order']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter',
                template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\n                    [type]=\"type\"\n                    [pane]=\"pane\"\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\n                    (moveStart)=\"onMoveStart($event)\"\n                    (moving)=\"onMoving($event)\">\n    </igx-splitter-bar>\n</ng-container>\n"
            }]
    }], function () { return []; }, { overflow: [{
            type: HostBinding,
            args: ['style.overflow']
        }], display: [{
            type: HostBinding,
            args: ['style.display']
        }], type: [{
            type: Input
        }], direction: [{
            type: HostBinding,
            args: ['style.flex-direction']
        }], panes: [{
            type: ContentChildren,
            args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitBarComponent, [{
        type: Component,
        args: [{
                selector: 'igx-splitter-bar',
                template: "<div class=\"igx-splitter-bar\"\n    [class.igx-splitter-bar--vertical]='type === 0'\n    [style.cursor]='cursor'\n    igxDrag\n    [ghost]=\"false\"\n    [dragDirection]='dragDir'\n    (dragStart)='onDragStart($event)'\n    (dragMove)=\"onDragMove($event)\"\n>\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\n    <div class=\"igx-splitter-bar__handle\" ></div>\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\n</div>\n"
            }]
    }], function () { return []; }, { cssClass: [{
            type: HostBinding,
            args: ['class.igx-splitter-bar-host']
        }], type: [{
            type: Input
        }], moveStart: [{
            type: Output
        }], moving: [{
            type: Output
        }], tabindex: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], orientation: [{
            type: HostBinding,
            args: ['attr.aria-orientation']
        }], keyEvent: [{
            type: HostListener,
            args: ['keydown', ['$event']]
        }], order: [{
            type: HostBinding,
            args: ['style.order']
        }, {
            type: Input
        }], pane: [{
            type: Input
        }], siblings: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxSplitterModule, { declarations: function () { return [IgxSplitterComponent,
        IgxSplitterPaneComponent,
        IgxSplitBarComponent]; }, imports: function () { return [CommonModule,
        IgxIconModule,
        IgxDragDropModule]; }, exports: function () { return [IgxSplitterComponent,
        IgxSplitterPaneComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxSplitterModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule, IgxIconModule, IgxDragDropModule
                ],
                declarations: [
                    IgxSplitterComponent,
                    IgxSplitterPaneComponent,
                    IgxSplitBarComponent
                ],
                exports: [
                    IgxSplitterComponent,
                    IgxSplitterPaneComponent
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateRangePickerFormatPipe, [{
        type: Pipe,
        args: [{ name: 'dateRange' }]
    }], null, null); })();
const ɵIgxDateRangeInputsBaseComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxDateRangeInputsBaseComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeInputsBaseComponent, [{
        type: Component,
        args: [{
                template: ``,
                selector: `igx-date-range-base`,
                providers: [{ provide: IgxInputGroupBase, useExisting: IgxDateRangeInputsBaseComponent_1 }]
            }]
    }], null, { ngControl: [{
            type: ContentChild,
            args: [NgControl]
        }], dateTimeEditor: [{
            type: ContentChild,
            args: [IgxDateTimeEditorDirective]
        }], inputDirective: [{
            type: ContentChild,
            args: [IgxInputDirective]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxPickerToggleComponent, [{
        type: Component,
        args: [{
                template: `<ng-content></ng-content>`,
                selector: 'igx-picker-toggle'
            }]
    }], function () { return []; }, { clicked: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
const ɵIgxDateRangeStartComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxDateRangeStartComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeStartComponent, [{
        type: Component,
        args: [{
                selector: 'igx-date-range-start',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #inputBundle>\n    <ng-container *ngIf=\"!isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container *ngIf=\"isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n        <div *ngIf=\"!isTypeBootstrap; else inputBundle\" class=\"igx-input-group__bundle-main\">\n\n            <ng-container *ngIf=\"!isNotMaterial\">\n                <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            </ng-container>\n\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxDateRangeStartComponent_1 },
                    { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeStartComponent_1 }
                ]
            }]
    }], null, null); })();
const ɵIgxDateRangeEndComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(IgxDateRangeEndComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeEndComponent, [{
        type: Component,
        args: [{
                selector: 'igx-date-range-end',
                template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n\n<ng-template #label>\n    <ng-content select=\"[igxLabel]\"></ng-content>\n</ng-template>\n\n<ng-template #input>\n    <ng-content select=\"[igxInput]\"></ng-content>\n</ng-template>\n\n<ng-template #inputBundle>\n    <ng-container *ngIf=\"!isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n</ng-template>\n\n<ng-template #bundle>\n    <ng-container *ngIf=\"isNotMaterial\">\n        <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n    </ng-container>\n\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n        <div *ngIf=\"!isTypeBootstrap; else inputBundle\" class=\"igx-input-group__bundle-main\">\n\n            <ng-container *ngIf=\"!isNotMaterial\">\n                <ng-container *ngTemplateOutlet=\"label\"></ng-container>\n            </ng-container>\n\n            <ng-container *ngTemplateOutlet=\"input\"></ng-container>\n        </div>\n\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
                providers: [
                    { provide: IgxInputGroupBase, useExisting: IgxDateRangeEndComponent_1 },
                    { provide: IgxDateRangeInputsBaseComponent, useExisting: IgxDateRangeEndComponent_1 }
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangeSeparatorDirective, [{
        type: Directive,
        args: [{
                selector: '[igxDateRangeSeparator]'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangePickerComponent, [{
        type: Component,
        args: [{
                selector: 'igx-date-range-picker',
                template: "<div #toggle=\"toggle\" igxToggle class=\"igx-date-picker\" [class.igx-date-picker--dropdown]=\"mode === 'dropdown'\"\n    (onOpening)=\"handleOpening($event)\" (onOpened)=\"handleOpened()\"\n    (onClosing)=\"handleClosing($event)\" (onClosed)=\"handleClosed()\"\n    [style.flex-basis]=\"monthsViewNumber * 320 + 'px'\"\n    [style.width]=\"monthsViewNumber * 320 + 'px'\"\n    [style.max-width]=\"'90vw'\"\n>\n    <!-- TODO: use IgxCalendarContainerComponent instead -->\n    <igx-calendar #calendar (keydown)=\"onKeyDown($event)\" selection=\"range\" [weekStart]=\"weekStart\"\n        [hideOutsideDays]=\"hideOutsideDays\" [monthsViewNumber]=\"monthsViewNumber\" [locale]=\"locale\"\n        (onSelection)=\"handleSelection($event)\"></igx-calendar>\n    <div class=\"igx-date-range-picker-buttons\">\n        <ng-container *ngIf=\"mode === 'dialog'\">\n            <button igxButton type=\"button\" (click)=\"close()\">{{ doneButtonText }}</button>\n        </ng-container>\n    </div>\n</div>\n\n<ng-container *ngTemplateOutlet=\"this.hasProjectedInputs ? startEndTemplate : defTemplate\"></ng-container>\n\n<ng-template #singleTemplate>\n    <div (click)=\"open()\" class=\"content-wrap\">\n        <ng-content select=\"igx-date-single\"></ng-content>\n    </div>\n</ng-template>\n\n<ng-template #startEndTemplate>\n    <ng-content select=\"igx-date-range-start\"></ng-content>\n    <div [className]=\"separatorClass\">\n        <ng-container *ngTemplateOutlet=\"dateSeparatorTemplate ? dateSeparatorTemplate : defDateSeparatorTemplate;\"></ng-container>\n    </div>\n    <ng-content select=\"igx-date-range-end\"></ng-content>\n</ng-template>\n\n<ng-template #defIcon>\n    <igx-icon>\n        calendar_today\n    </igx-icon>\n</ng-template>\n\n<ng-template #defDateSeparatorTemplate>{{ dateSeparator }}</ng-template>\n\n<ng-template #defTemplate>\n    <igx-input-group (click)=\"open()\">\n        <input #singleInput igxInput type=\"text\" readonly\n            [placeholder]=\"this.value ? '' : appliedFormat\"\n            role=\"combobox\"\n            aria-haspopup=\"grid\"\n            [attr.aria-expanded]=\"!toggle.collapsed\"\n            [attr.aria-labelledby]=\"this.label?.id\"\n            [value]=\"this.value | dateRange: this.inputFormat : this.locale\"\n        />\n\n        <igx-prefix *ngIf=\"!this.toggleComponents.length\">\n            <ng-container *ngTemplateOutlet=\"defIcon\"></ng-container>\n        </igx-prefix>\n\n        <ng-container ngProjectAs=\"[igxLabel]\">\n            <ng-content select=\"[igxLabel]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-prefix\">\n            <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-suffix\">\n            <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n        </ng-container>\n        <ng-container ngProjectAs=\"igx-hint\">\n            <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n        </ng-container>\n    </igx-input-group>\n</ng-template>\n",
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: IgxDateRangePickerComponent_1, multi: true },
                    { provide: NG_VALIDATORS, useExisting: IgxDateRangePickerComponent_1, multi: true }
                ]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [DisplayDensityToken]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }, { type: ɵngcc0.Injector }]; }, { mode: [{
            type: Input
        }], monthsViewNumber: [{
            type: Input
        }], weekStart: [{
            type: Input
        }], doneButtonText: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], rangeSelected: [{
            type: Output
        }], onOpening: [{
            type: Output
        }], onOpened: [{
            type: Output
        }], onClosing: [{
            type: Output
        }], onClosed: [{
            type: Output
        }], cssClass: [{
            type: HostBinding,
            args: ['class.igx-date-range-picker']
        }], locale: [{
            type: Input
        }], minValue: [{
            type: Input
        }], maxValue: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], inputFormat: [{
            type: Input
        }], hideOutsideDays: [{
            type: Input
        }], formatter: [{
            type: Input
        }], overlaySettings: [{
            type: Input
        }], displayFormat: [{
            type: Input
        }], calendar: [{
            type: ViewChild,
            args: [IgxCalendarComponent]
        }], inputGroup: [{
            type: ViewChild,
            args: [IgxInputGroupComponent]
        }], inputDirective: [{
            type: ViewChild,
            args: [IgxInputDirective]
        }], toggleDirective: [{
            type: ViewChild,
            args: [IgxToggleDirective]
        }], toggleComponents: [{
            type: ContentChildren,
            args: [IgxPickerToggleComponent, { descendants: true }]
        }], projectedInputs: [{
            type: ContentChildren,
            args: [IgxDateRangeInputsBaseComponent]
        }], label: [{
            type: ContentChild,
            args: [IgxLabelDirective]
        }], dateSeparatorTemplate: [{
            type: ContentChild,
            args: [IgxDateRangeSeparatorDirective, { read: TemplateRef }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IgxDateRangePickerModule, { declarations: function () { return [IgxDateRangePickerComponent,
        IgxDateRangeStartComponent,
        IgxDateRangeEndComponent,
        IgxDateRangeInputsBaseComponent,
        DateRangePickerFormatPipe,
        IgxPickerToggleComponent,
        IgxDateRangeSeparatorDirective]; }, imports: function () { return [CommonModule,
        IgxIconModule,
        IgxButtonModule,
        IgxToggleModule,
        IgxCalendarModule,
        IgxInputGroupModule,
        IgxDateTimeEditorModule]; }, exports: function () { return [IgxDateRangePickerComponent,
        IgxDateRangeStartComponent,
        IgxDateRangeEndComponent,
        IgxDateRangeSeparatorDirective,
        IgxDateTimeEditorModule,
        IgxPickerToggleComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(IgxDateRangePickerModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    IgxDateRangePickerComponent,
                    IgxDateRangeStartComponent,
                    IgxDateRangeEndComponent,
                    IgxDateRangeInputsBaseComponent,
                    DateRangePickerFormatPipe,
                    IgxPickerToggleComponent,
                    IgxDateRangeSeparatorDirective
                ],
                imports: [
                    CommonModule,
                    IgxIconModule,
                    IgxButtonModule,
                    IgxToggleModule,
                    IgxCalendarModule,
                    IgxInputGroupModule,
                    IgxDateTimeEditorModule
                ],
                exports: [
                    IgxDateRangePickerComponent,
                    IgxDateRangeStartComponent,
                    IgxDateRangeEndComponent,
                    IgxDateRangeSeparatorDirective,
                    IgxDateTimeEditorModule,
                    IgxPickerToggleComponent
                ]
            }]
    }], null, null); })();

/*
 * Public API Surface of igniteui-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AbsoluteScrollStrategy, AutoPositionStrategy, BaseFilteringStrategy, BaseProgress, BlockScrollStrategy, ButtonGroupAlignment, Calendar, CalendarHammerConfig, CalendarView, CarouselAnimationType, CarouselHammerConfig, CarouselIndicatorsOrientation, CloseScrollStrategy, ColumnDisplayOrder, ColumnPinningPosition, ConnectedPositioningStrategy, ContainerPositionStrategy, CsvFileTypes, DataType, DataUtil, DatePart, DateRangePickerFormatPipe, DateRangeType, DefaultSortingStrategy, DisplayDensity, DisplayDensityBase, DisplayDensityToken, DragDirection, ElasticPositionStrategy, FilterMode, FilteringExpressionsTree, FilteringExpressionsTreeType, FilteringLogic, FilteringStrategy, GlobalPositionStrategy, GridBaseAPIService, GridKeydownTargetType, GridSelectionMode, GridSummaryCalculationMode, GridSummaryPosition, GroupedRecords, HorizontalAlignment, IGX_CHECKBOX_REQUIRED_VALIDATOR, IGX_SWITCH_REQUIRED_VALIDATOR, IgxActionIconDirective, IgxActionStripComponent, IgxActionStripModule, IgxAppendDropStrategy, IgxAutocompleteDirective, IgxAutocompleteModule, IgxAvatarComponent, IgxAvatarModule, IgxAvatarSize, IgxAvatarType, IgxBadgeComponent, IgxBadgeModule, IgxBadgeType, IgxBannerComponent, IgxBannerModule, IgxBaseExporter, IgxBaseTransactionService, IgxBooleanFilteringOperand, IgxBottomNavComponent, IgxBottomNavModule, IgxButtonDirective, IgxButtonGroupComponent, IgxButtonGroupModule, IgxButtonModule, IgxCalendarComponent, IgxCalendarHeaderTemplateDirective, IgxCalendarModule, IgxCalendarMonthDirective, IgxCalendarScrollMonthDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarYearDirective, IgxCardActionsComponent, IgxCardActionsLayout, IgxCardComponent, IgxCardContentDirective, IgxCardFooterDirective, IgxCardHeaderComponent, IgxCardHeaderSubtitleDirective, IgxCardHeaderTitleDirective, IgxCardMediaDirective, IgxCardModule, IgxCardThumbnailDirective, IgxCardType, IgxCarouselComponent, IgxCarouselModule, IgxCellEditorTemplateDirective, IgxCellFooterTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellTemplateDirective, IgxCheckboxComponent, IgxCheckboxModule, IgxCheckboxRequiredDirective, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxCircularProgressBarComponent, IgxCollapsibleIndicatorTemplateDirective, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnHidingComponent, IgxColumnHidingModule, IgxColumnLayoutComponent, IgxColumnPinningComponent, IgxComboComponent, IgxComboModule, IgxComboState, IgxCsvExporterOptions, IgxCsvExporterService, IgxDataLoadingTemplateDirective, IgxDataRecordSorting, IgxDateFilteringOperand, IgxDatePickerComponent, IgxDatePickerModule, IgxDateRangeEndComponent, IgxDateRangeInputsBaseComponent, IgxDateRangePickerComponent, IgxDateRangePickerModule, IgxDateRangeSeparatorDirective, IgxDateRangeStartComponent, IgxDateSummaryOperand, IgxDateTimeEditorDirective, IgxDateTimeEditorModule, IgxDaysViewComponent, IgxDefaultDropStrategy, IgxDialogComponent, IgxDialogModule, IgxDisplayDensityModule, IgxDividerDirective, IgxDividerModule, IgxDividerType, IgxDragDirective, IgxDragDropModule, IgxDragHandleDirective, IgxDragIgnoreDirective, IgxDragLocation, IgxDropDirective, IgxDropDownBaseDirective, IgxDropDownComponent, IgxDropDownGroupComponent, IgxDropDownItemBaseDirective, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownModule, IgxEmptyListTemplateDirective, IgxExcelExporterOptions, IgxExcelExporterService, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelModule, IgxExporterOptionsBase, IgxFilterCellTemplateDirective, IgxFilterDirective, IgxFilterModule, IgxFilterOptions, IgxFilterPipe, IgxFilteringOperand, IgxFlexDirective, IgxFocusDirective, IgxFocusModule, IgxForOfContext, IgxForOfDirective, IgxForOfModule, IgxGridAPIService, IgxGridActionsBaseDirective, IgxGridBaseDirective, IgxGridBodyDirective, IgxGridCellComponent, IgxGridCommonModule, IgxGridComponent, IgxGridDetailTemplateDirective, IgxGridEditingActionsComponent, IgxGridForOfDirective, IgxGridGroupByRowComponent, IgxGridModule, IgxGridPinningActionsComponent, IgxGridRowComponent, IgxGridStateDirective, IgxGridStateModule, IgxGridTransaction, IgxGroupAreaDropDirective, IgxGroupByRowTemplateDirective, IgxGrouping, IgxHeaderCollapseIndicatorDirective, IgxHeaderExpandIndicatorDirective, IgxHierarchicalGridAPIService, IgxHierarchicalGridBaseDirective, IgxHierarchicalGridCellComponent, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalRowComponent, IgxHierarchicalTransactionService, IgxHierarchicalTransactionServiceFactory, IgxHintDirective, IgxIconComponent, IgxIconModule, IgxIconService, IgxInputDirective, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInsertDropStrategy, IgxLabelDirective, IgxLayoutDirective, IgxLayoutModule, IgxLeftButtonStyleDirective, IgxLinearProgressBarComponent, IgxListActionDirective, IgxListBaseDirective, IgxListComponent, IgxListItemComponent, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListLineDirective, IgxListLineSubTitleDirective, IgxListLineTitleDirective, IgxListModule, IgxListPanState, IgxListThumbnailDirective, IgxMaskDirective, IgxMaskModule, IgxMonthPickerBaseDirective, IgxMonthPickerComponent, IgxMonthsViewComponent, IgxNavDrawerItemDirective, IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavigationCloseDirective, IgxNavigationDrawerComponent, IgxNavigationDrawerModule, IgxNavigationModule, IgxNavigationService, IgxNavigationToggleDirective, IgxNumberFilteringOperand, IgxNumberSummaryOperand, IgxOverlayOutletDirective, IgxOverlayService, IgxPaginatorComponent, IgxPaginatorModule, IgxPickerToggleComponent, IgxPrefixDirective, IgxPrefixModule, IgxPrependDropStrategy, IgxProgressBarModule, IgxProgressType, IgxRadioComponent, IgxRadioGroupDirective, IgxRadioModule, IgxRightButtonStyleDirective, IgxRippleDirective, IgxRippleModule, IgxRowCollapsedIndicatorDirective, IgxRowDirective, IgxRowExpandedIndicatorDirective, IgxRowIslandAPIService, IgxRowIslandComponent, IgxSelectComponent, IgxSelectFooterDirective, IgxSelectGroupComponent, IgxSelectHeaderDirective, IgxSelectItemComponent, IgxSelectModule, IgxSelectToggleIconDirective, IgxSliderComponent, IgxSliderModule, IgxSliderType, IgxSnackbarComponent, IgxSnackbarModule, IgxSorting, IgxSplitterComponent, IgxSplitterModule, IgxSplitterPaneComponent, IgxStringFilteringOperand, IgxSuffixDirective, IgxSuffixModule, IgxSummaryOperand, IgxSwitchComponent, IgxSwitchModule, IgxSwitchRequiredDirective, IgxTabComponent, IgxTabItemComponent, IgxTabItemTemplateDirective, IgxTabPanelComponent, IgxTabTemplateDirective, IgxTabsComponent, IgxTabsGroupComponent, IgxTabsModule, IgxTabsType, IgxTextAlign, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, IgxTickLabelTemplateDirective, IgxTimePickerComponent, IgxTimePickerModule, IgxToastComponent, IgxToastModule, IgxToastPosition, IgxToggleActionDirective, IgxToggleDirective, IgxToggleModule, IgxTooltipDirective, IgxTooltipModule, IgxTooltipTargetDirective, IgxTransactionService, IgxTreeGridAPIService, IgxTreeGridCellComponent, IgxTreeGridComponent, IgxTreeGridModule, IgxTreeGridRowComponent, IgxYearsViewComponent, InteractionMode, LabelPosition, NoOpScrollStrategy, NoopFilteringStrategy, NoopSortingStrategy, PagingError, Point, PredefinedFormatOptions, RadioLabelPosition, RowEditPositionStrategy, RowPinningPosition, ScrollStrategy, SliderHandle, SortingDirection, SplitterType, SwitchLabelPosition, TickLabelsOrientation, TicksOrientation, TimePickerHammerConfig, TransactionType, VerticalAlignment, WEEKDAYS, blink, changei18n, fadeIn, fadeOut, filteringStateDefaults, flipBottom, flipHorBck, flipHorFwd, flipLeft, flipRight, flipTop, flipVerBck, flipVerFwd, getCurrentResourceStrings, getTypeNameForDebugging, growVerIn, growVerOut, heartbeat, hierarchicalTransactionServiceFactory, isDateInRanges, isLeap, monthRange, pulsateBck, pulsateFwd, range, rotateInBl, rotateInBottom, rotateInBr, rotateInCenter, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInLeft, rotateInRight, rotateInTl, rotateInTop, rotateInTr, rotateInVer, rotateOutBl, rotateOutBottom, rotateOutBr, rotateOutCenter, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutLeft, rotateOutRight, rotateOutTl, rotateOutTop, rotateOutTr, rotateOutVer, scaleInBl, scaleInBottom, scaleInBr, scaleInCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleInLeft, scaleInRight, scaleInTl, scaleInTop, scaleInTr, scaleInVerBottom, scaleInVerCenter, scaleInVerTop, scaleOutBl, scaleOutBottom, scaleOutBr, scaleOutCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, scaleOutLeft, scaleOutRight, scaleOutTl, scaleOutTop, scaleOutTr, scaleOutVerBottom, scaleOutVerCenter, scaleOutVerTop, shakeBl, shakeBottom, shakeBr, shakeCenter, shakeHor, shakeLeft, shakeRight, shakeTl, shakeTop, shakeTr, shakeVer, slideInBl, slideInBottom, slideInBr, slideInLeft, slideInRight, slideInTl, slideInTop, slideInTr, slideOutBl, slideOutBottom, slideOutBr, slideOutLeft, slideOutRight, slideOutTl, slideOutTop, slideOutTr, swingInBottomBck, swingInBottomFwd, swingInLeftBck, swingInLeftFwd, swingInRightBck, swingInRightFwd, swingInTopBck, swingInTopFwd, swingOutBottomBck, swingOutBottomFwd, swingOutLeftBck, swingOutLefttFwd, swingOutRightBck, swingOutRightFwd, swingOutTopBck, swingOutTopFwd, toPercent, valueInRange, weekDay, ɵ0, ɵ1, ɵ2, IgxActionStripMenuItemDirective as ɵa, IGX_DROPDOWN_BASE as ɵb, IgxBannerActionsDirective as ɵba, IgxExpansionPanelTitleDirective as ɵbb, IgxExpansionPanelDescriptionDirective as ɵbc, IgxExpansionPanelIconDirective as ɵbd, IgxCalendarBaseDirective as ɵbe, IgxDaysViewNavigationService as ɵbf, IgxDayItemComponent as ɵbg, IgxMonthViewSlotsCalendar as ɵbh, IgxGetViewDateCalendar as ɵbi, IgxCarouselIndicatorDirective as ɵbj, IgxCarouselNextButtonDirective as ɵbk, IgxCarouselPrevButtonDirective as ɵbl, IgxSlideComponent as ɵbm, IgxComboAPIService as ɵbn, IGX_COMBO_COMPONENT as ɵbo, IgxComboDropDownComponent as ɵbq, IgxComboItemComponent as ɵbr, IgxComboHeaderDirective as ɵbs, IgxComboFooterDirective as ɵbt, IgxComboItemDirective as ɵbu, IgxComboEmptyDirective as ɵbv, IgxComboHeaderItemDirective as ɵbw, IgxComboAddItemDirective as ɵbx, IgxComboToggleIconDirective as ɵby, IgxComboClearIconDirective as ɵbz, IgxComboFilteringPipe as ɵca, IgxComboGroupingPipe as ɵcb, IgxComboAddItemComponent as ɵcc, IgxDatePickerTemplateDirective as ɵcd, IgxDatePickerActionsDirective as ɵce, IgxCalendarContainerComponent as ɵcf, DatePickerDisplayValuePipe as ɵcg, DatePickerInputValuePipe as ɵch, IGX_DATE_PICKER_COMPONENT as ɵci, IgxDialogTitleDirective as ɵck, IgxDialogActionsDirective as ɵcl, ColumnChooserBaseDirective as ɵcm, ItemPropertyValueChangedDirective as ɵcn, ColumnChooserItemBaseDirective as ɵco, IgxGridSharedModules as ɵcp, IgxTemplateOutletDirective as ɵcq, IgxTemplateOutletModule as ɵcr, IgxProcessBarTextTemplateDirective as ɵcs, IgxProgressBarGradientDirective as ɵct, DIR_DOCUMENT as ɵcu, DIR_DOCUMENT_FACTORY as ɵcv, IgxDirectionality as ɵcw, IgxSelectItemNavigationDirective as ɵcx, WatchChanges as ɵcy, WatchColumnChanges as ɵcz, IgxGridCRUDService as ɵd, notifyChanges as ɵda, IgxGridColumnResizerComponent as ɵdb, IgxColumnResizingService as ɵdc, IgxColumnResizerDirective as ɵdd, IgxExcelStyleSortingTemplateDirective as ɵde, IgxExcelStyleMovingTemplateDirective as ɵdf, IgxExcelStyleHidingTemplateDirective as ɵdg, IgxExcelStyleSelectingTemplateDirective as ɵdh, IgxExcelStylePinningTemplateDirective as ɵdi, IgxGridExcelStyleFilteringComponent as ɵdj, IgxExcelStyleLoadingValuesTemplateDirective as ɵdk, IgxExcelStyleSearchComponent as ɵdl, IgxGridHeaderGroupComponent as ɵdm, IgxGridHeaderComponent as ɵdn, IgxGridFilteringCellComponent as ɵdo, IgxFilteringService as ɵdp, IgxSummaryRowComponent as ɵdq, IgxSummaryCellComponent as ɵdr, IgxGridToolbarCustomContentDirective as ɵds, IgxRowSelectorDirective as ɵdt, IgxHeadSelectorDirective as ɵdu, IgxRowDragDirective as ɵdv, IgxDragIndicatorIconDirective as ɵdw, IgxRowDragGhostDirective as ɵdx, IgxRowDragModule as ɵdy, IgxGridFilteringRowComponent as ɵdz, IgxGridSelectionService as ɵe, IgxRowEditTemplateDirective as ɵea, IgxRowEditTextDirective as ɵeb, IgxRowEditActionsDirective as ɵec, IgxRowEditTabStopDirective as ɵed, IgxGridToolbarComponent as ɵee, IgxGridNavigationService as ɵef, IgxGridSummaryService as ɵeg, HammerGesturesManager as ɵeh, ConnectedPositioningStrategy as ɵei, IgxGridFooterComponent as ɵej, IgxAdvancedFilteringDialogComponent as ɵek, IgxColumnPinningModule as ɵel, IgxColumnPinningItemDirective as ɵem, IgxGridColumnModule as ɵen, IgxGridHeadersModule as ɵeo, IgxGridFilteringModule as ɵep, IgxGridPipesModule as ɵeq, IgxGridCellStyleClassesPipe as ɵer, IgxGridCellStylesPipe as ɵes, IgxGridNotGroupedPipe as ɵet, IgxGridTopLevelColumns as ɵeu, IgxGridFilterConditionPipe as ɵev, IgxGridTransactionPipe as ɵew, IgxGridPaginatorOptionsPipe as ɵex, IgxHasVisibleColumnsPipe as ɵey, IgxDatePipeComponent as ɵez, IgxColumnHidingItemDirective as ɵf, IgxDecimalPipeComponent as ɵfa, IgxGridRowPinningPipe as ɵfb, IgxColumnMovingModule as ɵfc, IgxColumnMovingDropDirective as ɵfd, IgxColumnMovingService as ɵfe, IgxColumnMovingDragDirective as ɵff, IgxGridResizingModule as ɵfg, IgxResizeHandleDirective as ɵfh, IgxGridExcelStyleFilteringModule as ɵfi, IgxExcelStyleCustomDialogComponent as ɵfj, IgxExcelStyleDefaultExpressionComponent as ɵfk, IgxExcelStyleDateExpressionComponent as ɵfl, IgxExcelStyleSortingComponent as ɵfm, IgxExcelStyleColumnMovingComponent as ɵfn, IgxExcelStyleSearchFilterPipe as ɵfo, IgxGridSelectionModule as ɵfp, IgxGridDragSelectDirective as ɵfq, IgxGridSummaryModule as ɵfr, IgxSummaryDataPipe as ɵfs, IgxGridToolbarModule as ɵft, IgxGridSortingPipe as ɵfu, IgxGridGroupingPipe as ɵfv, IgxGridPagingPipe as ɵfw, IgxGridFilteringPipe as ɵfx, IgxGridSummaryPipe as ɵfy, IgxGridDetailsPipe as ɵfz, IgxGridExpandableCellComponent as ɵga, IgxRowLoadingIndicatorTemplateDirective as ɵgb, IgxTreeGridHierarchizingPipe as ɵgc, IgxTreeGridFlatteningPipe as ɵgd, IgxTreeGridSortingPipe as ɵge, IgxTreeGridPagingPipe as ɵgf, IgxTreeGridTransactionPipe as ɵgg, IgxTreeGridNormalizeRecordsPipe as ɵgh, IgxTreeGridFilteringPipe as ɵgi, IgxTreeGridSummaryPipe as ɵgj, IgxHierarchicalGridNavigationService as ɵgk, IgxChildGridRowComponent as ɵgl, IgxGridHierarchicalPipe as ɵgm, IgxGridHierarchicalPagingPipe as ɵgn, IgxSliderThumbComponent as ɵgo, IgxThumbLabelComponent as ɵgp, IgxTicksComponent as ɵgq, IgxTickLabelsPipe as ɵgr, IgxTabsBase as ɵgs, IgxTabItemBase as ɵgt, IgxTabsGroupBase as ɵgu, IGX_TIME_PICKER_COMPONENT as ɵgv, IgxItemListDirective as ɵgx, IgxHourItemDirective as ɵgy, IgxMinuteItemDirective as ɵgz, IGX_EXPANSION_PANEL_COMPONENT as ɵh, IgxSecondsItemDirective as ɵha, IgxAmPmItemDirective as ɵhb, IgxTimePickerTemplateDirective as ɵhc, IgxTimePickerActionsDirective as ɵhd, TimeDisplayFormatPipe as ɵhe, TimeInputFormatPipe as ɵhf, IgxSplitBarComponent as ɵhg, PlatformUtil as ɵi, EaseIn as ɵj, EaseOut as ɵk, IgxInputGroupBase as ɵl, DeprecateMethod as ɵm, DeprecateProperty as ɵn, IgxForOfSyncService as ɵo, IgxForOfScrollSyncService as ɵp, IgxSelectionAPIService as ɵq, DisplayContainerComponent as ɵr, VirtualHelperComponent as ɵs, VirtualHelperBaseDirective as ɵt, HVirtualHelperComponent as ɵu, IgxScrollInertiaDirective as ɵv, IgxScrollInertiaModule as ɵw, MaskParsingService as ɵx, isHierarchyMatch as ɵy, getHierarchy as ɵz };

//# sourceMappingURL=igniteui-angular.js.map